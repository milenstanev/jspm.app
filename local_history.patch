Index: node_modules/jspm/lib/ui.js
===================================================================
--- node_modules/jspm/lib/ui.js	(revision )
+++ node_modules/jspm/lib/ui.js	(revision )
@@ -1,238 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-
-var Promise = require('rsvp').Promise;
-var chalk = require('chalk');
-
-var apiResolver;
-var logging = true;
-
-var logBuffer = '';
-var errBuffer = '';
-
-var logged = false;
-var cli = module.exports;
-
-var ui = exports;
-
-ui.logLevel = 3; // corresponds to 'info'
-var logTypes = ['err', 'warn', 'ok', 'info', 'debug'];
-
-// if storing any logs, dump them on exit
-process.on('exit', function() {
-  if (!apiResolver) {
-    if (logBuffer)
-      process.stdout.write(logBuffer);
-    if (errBuffer)
-      process.stderr.write(errBuffer);
-  }
-});
-
-exports.setResolver = function(resolver) {
-  apiResolver = resolver;
-};
-
-// use the default option in all prompts
-// throws an error for prompts that don't take a default
-var useDefaults;
-exports.useDefaults = function(_useDefaults) {
-  if (_useDefaults === undefined)
-    _useDefaults = true;
-  useDefaults = _useDefaults;
-};
-
-exports.setLogLevel = function(level) {
-  if (!level)
-    return;
-
-  var levelIndex = logTypes.indexOf(level);
-
-  if (levelIndex == -1)
-    ui.log('warn', 'Unknown log level: ' + level);
-  else
-    ui.logLevel = levelIndex;
-};
-
-var format = exports.format = {
-  q: function(msg, opt) {
-    return moduleMsg(msg) + '' + (opt ? ' [' + opt + ']' : '') + ':';
-  },
-  err: function(msg) {
-    return '\n' + chalk.red.bold('err  ') + moduleMsg(msg);
-  },
-  info: function(msg) {
-    return '     ' + moduleMsg(msg);
-  },
-  warn: function(msg) {
-    return '\n' + chalk.yellow.bold('warn ') + moduleMsg(msg);
-  },
-  ok: function(msg) {
-    return chalk.green.bold('ok   ') + moduleMsg(msg);
-  }
-};
-
-exports.log = function(type, msg) {
-  if (apiResolver)
-    return apiResolver.emit('log', type, msg);
-
-  logged = true;
-  
-  if (arguments.length === 1) {
-    msg = type;
-    type = null;
-  }
-  
-  msg = msg || '';
-
-  if (type)
-    msg = format[type](msg.toString());
-
-  var logLevel = logTypes.indexOf(type);
-  if (logLevel == -1)
-    logLevel = 3;
-  if (logLevel <= ui.logLevel) {
-    if (logging) {
-      if (type != 'err')
-        console.log(msg);
-      else
-        console.error(msg);
-    }
-    else {
-      if (type != 'err')
-        logBuffer += msg + '\n';
-      else
-        errBuffer += msg + '\n';
-    }
-  }
-};
-
-function moduleMsg(msg) {
-  return msg
-    .replace(/(\s|\`|^)%([^%\n]+)%/g, '$1' + chalk.bold('$2'))
-    .replace(/(\s|^)\`([^\`\n]+)\`/g, '$1' + chalk.cyan('$2'))
-    .replace(/\n\r?( {0,4}\w)/g, '\n     $1');
-}
-
-var inputQueue = [];
-var confirm = exports.confirm = function(msg, def) {
-  if (useDefaults) {
-    if (def !== true && def !== false)
-      def = true;
-    process.stdout.write(format.q(msg) + (def ? 'Yes' : 'No') + '\n');
-    return Promise.resolve(def);
-  }
-
-  if (apiResolver)
-    return new Promise(function(resolve) {
-      apiResolver.emit('prompt', {
-        type: 'confirm',
-        message: msg,
-        default: def
-      }, function(answer) {
-        resolve(answer);
-      });
-    });
-
-  var defText = 'y/n';
-  if (def === true)
-    defText = 'yes';
-  else if (def === false)
-    defText = 'no';
-  else
-    def = undefined;
-
-  var p = cli.input(msg, defText);
-  return p.then(function(reply) {
-    if (reply.match(/\b(no|n)\b/i))
-      return false;
-    else if (reply.match(/\b(yes|y\b)/i))
-      return true;
-    else if (def !== undefined)
-      return def;
-    else
-      return confirm(msg, def);
-  });
-};
-
-exports.input = function(msg, def, disableOutput, queue) {
-  if (useDefaults) {
-    process.stdout.write(format.q(msg) + def + '\n');
-    return Promise.resolve(def);
-  }
-
-  if (apiResolver)
-    return new Promise(function(resolve) {
-      apiResolver.emit('prompt', {
-        type: 'input',
-        message: msg,
-        default: def
-      }, function(answer) {
-        resolve(answer.input);
-      });
-    });
-
-  if (arguments.length === 2)
-    disableOutput = false;
-
-  return new Promise(function(resolve, reject) {
-    if (!logging && !queue)
-      return inputQueue.push({
-        args: [msg, def, disableOutput, true],
-        resolve: resolve,
-        reject: reject
-      });
-
-    if (logging && logged)
-      process.stdout.write('\n');
-    logging = false;
-    process.stdout.write(format.q(msg, def));
-    process.stdin.resume();
-    process.stdin.setEncoding('utf8');
-    if (disableOutput && process.stdin.isTTY)
-      process.stdin.setRawMode(disableOutput);
-    var inputVal = '';
-    process.stdin.on('data', function(chunk) {
-      var lastChar = chunk.substr(chunk.length - 1, 1);
-      if (lastChar === '\n' || lastChar === '\r' || lastChar === '\u0004') {
-        if (disableOutput && process.stdin.isTTY)
-          process.stdin.setRawMode(false);
-        process.stdin.pause();
-        process.stdin.removeAllListeners('data');
-        inputVal += chunk.substr(0, chunk.length - 1);
-
-        if (disableOutput)
-          process.stdout.write('\n');
-
-        // bump the input queue
-        var next = inputQueue.shift();
-        if (next)
-          cli.input.apply(null, next.args).then(next.resolve, next.reject);
-        else {
-          process.stdout.write(logBuffer);
-          process.stderr.write(errBuffer);
-          logBuffer = '';
-          errBuffer = '';
-          logging = true;
-          logged = false;
-        }
-
-        resolve(inputVal.trim() || def);
-      }
-      inputVal += chunk;
-    });
-
-  });
-};
Index: node_modules/jspm/lib/config/utils.js
===================================================================
--- node_modules/jspm/lib/config/utils.js	(revision )
+++ node_modules/jspm/lib/config/utils.js	(revision )
@@ -1,33 +0,0 @@
-// convert structured configuration into a plain object
-// by calling the .write() methods of structured classes
-// properties ending in _ are considered private
-// NB may be less convoluted just to make these explicit
-require('core-js/es6/string');
-
-module.exports.extractObj = function extractObj(obj, host) {
-  var out = {};
-  for (var p in obj) {
-    if (!obj.hasOwnProperty(p))
-      continue;
-    if (p.startsWith('__'))
-      continue;
-
-    var val = obj[p];
-    if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean')
-      out[p] = val;
-    else if (typeof val === 'object') {
-      if (typeof val.write === 'function')
-        out[p] = val.write();
-      else if (val instanceof Array)
-        out[p] = val;
-      else
-        out[p] = extractObj(val, {});
-    }
-  }
-
-  for (var h in host)
-    if (host.hasOwnProperty(h) && !(h in out))
-      out[h] = host[h];
-
-  return out;
-};
Index: node_modules/jspm/lib/config/loader.js
===================================================================
--- node_modules/jspm/lib/config/loader.js	(revision )
+++ node_modules/jspm/lib/config/loader.js	(revision )
@@ -1,412 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-
-var registry = require('../registry');
-var config = require('../config');
-var extend = require('../common').extend;
-var hasProperties = require('../common').hasProperties;
-var fs = require('graceful-fs');
-var asp = require('rsvp').denodeify;
-var path = require('path');
-var PackageName = require('./package-name');
-var alphabetize = require('../common').alphabetize;
-var stringify = require('../common').stringify;
-var ui = require('../ui');
-var extractObj = require('./utils').extractObj;
-var globalConfig = require('../global-config');
-
-/*
- * Loader Configuration Class
- *
- * baseURL
- * defaultJSExtensions
- * registries
- * transpiler
- * babelOptions
- * traceurOptions
- * typescriptOptions
- *
- * paths
- * bundles
- * depCache
- *
- * baseMap
- * depMap
- * versions
- *
- */
-// and registry is a path rule ending in ':*'
-var registryRegEx = /\:\*$/;
-function Config(fileName) {
-  this.__fileName = fileName;
-}
-Config.prototype.read = function(prompts, sync) {
-  if (this.__read)
-    throw 'Config already read';
-  this.__read = true;
-
-  var self = this;
-  var source;
-  try {
-    source = fs.readFileSync(this.__fileName);
-  }
-  catch(e) {
-    source = '';
-  }
-
-  var cfg = {};
-  var System = {
-    config: function(_cfg) {
-      for (var c in _cfg) {
-        if (!_cfg.hasOwnProperty(c))
-          continue;
-
-        var v = _cfg[c];
-        if (typeof v === 'object') {
-          cfg[c] = cfg[c] || {};
-          for (var p in v) {
-            if (!v.hasOwnProperty(p))
-              continue;
-            cfg[c][p] = v[p];
-          }
-        }
-        else
-          cfg[c] = v;
-      }
-    },
-    paths: {},
-    map: {},
-    versions: {}
-  };
-  eval(source.toString());
-
-  // allow declarative form too
-  var config = System.config;
-  delete System.config;
-  config(System);
-
-  self.__originalConfig = cfg;
-
-  self.baseURL = cfg.baseURL;
-
-  self.defaultJSExtensions = true;
-
-  if (cfg.transpiler === false)
-    cfg.transpiler = 'none';
-
-  // NB deprecate cfg.parser with 0.11.0
-  self.transpiler = cfg.transpiler || cfg.parser || globalConfig.config.defaultTranspiler;
-
-  // NB deprecate babel rename with 0.13
-  if (self.transpiler === '6to5')
-    self.transpiler = 'babel';
-
-  self.babelOptions = cfg.babelOptions || {};
-  self.traceurOptions = cfg.traceurOptions || {};
-  self.typescriptOptions = cfg.typescriptOptions || {};
-
-  // separate paths into registries and paths
-  self.registries = {};
-  self.paths = {};
-  for (var p in cfg.paths) {
-    if (p.match(registryRegEx)) {
-      var registryName = p.substr(0, p.length - 2);
-      var registryPath = new RegistryPath(registryName, cfg.paths[p]);
-      self.registries[registryName] = registryPath;
-      if (self.__local === undefined) {
-        if (registryPath.mode === 'local')
-          self.__local = true;
-        else
-          self.__local = false;
-      }
-    }
-    // deprecate *: *.js
-    else if (p === '*' && cfg.paths[p] === '*.js') {
-      delete cfg.paths[p];
-      continue;
-    }
-  }
-  self.paths = cfg.paths;
-
-  self.shim = cfg.shim;
-  self.bundles = cfg.bundles;
-  self.depCache = cfg.depCache;
-
-  // separate map into baseMap and depMap
-  self.baseMap = {};
-  self.depMap = {};
-  for (var d in cfg.map) {
-    if (typeof cfg.map[d] === 'string')
-      self.baseMap[d] = new PackageName(cfg.map[d]);
-    else {
-      var depMap = cfg.map[d];
-      self.depMap[d] = {};
-      for (var m in depMap)
-        if (depMap.hasOwnProperty(m)) {
-          self.depMap[d][m] = new PackageName(depMap[m]);
-        }
-    }
-  }
-
-  // ensure that everything in baseMap has a depMap, even if empty
-  var baseMap = self.baseMap, exactName;
-  for (var n in baseMap) {
-    if (baseMap.hasOwnProperty(n)) {
-      exactName = baseMap[n].exactName;
-      self.depMap[exactName] = self.depMap[exactName] || {};
-    }
-  }
-
-  self.versions = self.versions || {};
-  for (var v in cfg.versions) {
-    if (typeof cfg.versions[v] === 'string')
-      self.versions[v] = [cfg.versions[v]];
-    else
-      self.versions[v] = cfg.versions[v];
-  }
-
-  if (hasProperties(self.versions))
-    upgradeToExactVersionResolution(self);
-
-
-  if (!prompts)
-    return;
-
-  if (sync)
-    throw 'Configuration file has not been initialized. Run jspm init first.';
-
-  return ui.input('Enter client baseURL (public folder URL)', self.baseURL || '/')
-  .then(function(baseURL) {
-    self.baseURL = baseURL;
-
-    return ui.confirm('Do you wish to use a transpiler?', true);
-  })
-  .then(function(useTranspiler) {
-    if (!useTranspiler) {
-      self.transpiler = 'none';
-      return 'none';
-    }
-
-    return ui.input('Which ES6 transpiler would you like to use, %Babel%, %TypeScript% or %Traceur%?', self.transpiler);
-  })
-  .then(function(transpiler) {
-    transpiler = transpiler.toLowerCase();
-
-    if (transpiler !== 'babel' && transpiler !== 'traceur' && transpiler !== 'typescript' && transpiler !== 'none')
-      transpiler = globalConfig.config.defaultTranspiler;
-
-    self.transpiler = transpiler;
-    globalConfig.config.defaultTranspiler = transpiler;
-  });
-};
-
-Config.prototype.ensureRegistry = function(registryName, remote) {
-  var registries = this.registries;
-
-  if (typeof remote === 'undefined') {
-    // detect the registry mode from the first registry
-    var registryKeys = Object.keys(registries);
-    if (registryKeys.length > 0) {
-      remote = registries[registryKeys[0]].mode === 'remote';
-    } else {
-      remote = false;
-    }
-  }
-
-  if (registries[registryName]) {
-    if (remote)
-      registries[registryName].setRemote();
-    else
-      registries[registryName].setLocal();
-    return;
-  }
-
-  var ep = registries[registryName] = new RegistryPath(registryName);
-  if (remote)
-    ep.setRemote();
-  else
-    ep.setLocal();
-};
-
-// return the loader configuration for a server loading use
-Config.prototype.getConfig = function() {
-  var cfg = extend({}, this.__originalConfig);
-
-  // set all registry paths to be local paths
-  cfg.paths = extend({}, cfg.paths);
-  var registries = this.registries;
-  for (var e in registries) {
-    if (registries.hasOwnProperty(e))
-      cfg.paths[e + ':*'] = registries[e].local;
-  }
-  return cfg;
-};
-
-/*
- * RegistryPath object
- */
-var jspmPackages;
-function RegistryPath(name, registryPath) {
-  jspmPackages = jspmPackages || path.relative(config.pjson.baseURL, config.pjson.packages).replace(/\\/g, '/');
-  var registryRemote = registry.load(name).remote;
-  this.remote = registryRemote + '/*';
-  this.local = jspmPackages + '/' + name + '/*';
-
-  this.mode = 'local';
-  if (registryPath === this.remote)
-    this.mode = 'remote';
-  this.path = registryPath;
-}
-RegistryPath.prototype.setLocal = function() {
-  this.path = this.local;
-  this.mode = 'local';
-};
-RegistryPath.prototype.setRemote = function() {
-  this.path = this.remote;
-  this.mode = 'remote';
-};
-RegistryPath.prototype.write = function() {
-  return this.path;
-};
-
-Config.prototype.write = function() {
-  // extract over original config to keep initial values
-  var cfg = extractObj(this, this.__originalConfig),
-      cfgRegistries, cfgMap, cfgVersions;
-
-  cfgRegistries = cfg.registries;
-  for (var e in cfgRegistries) {
-    if (!cfgRegistries.hasOwnProperty(e))
-      continue;
-    var val = cfgRegistries[e];
-    delete cfgRegistries[e];
-    cfgRegistries[e + ':*'] = val;
-  }
-
-  extend(cfg.paths, alphabetize(cfg.registries));
-  delete cfg.registries;
-
-  cfg.baseMap = alphabetize(cfg.baseMap);
-  cfg.map = extend(cfg.baseMap, alphabetize(cfg.depMap));
-  delete cfg.baseMap;
-  delete cfg.depMap;
-
-  cfgMap = cfg.map;
-  for (var p in cfgMap) {
-    if (!cfgMap.hasOwnProperty(p))
-      continue;
-    var subMap = cfgMap[p];
-    if (typeof subMap === 'object') {
-      if (!hasProperties(subMap))
-        delete cfgMap[p];
-      else
-        cfgMap[p] = alphabetize(cfgMap[p]);
-    }
-  }
-
-  cfgVersions = cfg.versions;
-  for (var v in cfgVersions) {
-    if (!cfgVersions.hasOwnProperty(v))
-      continue;
-    var version = cfgVersions[v];
-    if (version.length === 1)
-      cfgVersions[v] = version[0];
-    if (version.length === 0)
-      delete cfgVersions[v];
-  }
-
-  var outConfig = {};
-
-  var meta = cfg.meta;
-  var depCache = cfg.depCache;
-  var map = cfg.map;
-  var versions = alphabetize(cfg.versions);
-
-  delete cfg.meta;
-  delete cfg.depCache;
-  delete cfg.map;
-  delete cfg.versions;
-
-  if (!hasProperties(cfg.babelOptions))
-    delete cfg.babelOptions;
-  if (!hasProperties(cfg.traceurOptions))
-    delete cfg.traceurOptions;
-  if (!hasProperties(cfg.typescriptOptions))
-    delete cfg.typescriptOptions;
-
-  if (cfg.bundles && !hasProperties(cfg.bundles))
-    delete cfg.bundles;
-
-  if (hasProperties(cfg))
-    extend(outConfig, cfg);
-
-  cfg.meta = meta;
-  cfg.depCache = depCache;
-  cfg.map = map;
-  cfg.versions = versions;
-
-  if (hasProperties(meta))
-    extend(outConfig, { meta: meta });
-
-  if (hasProperties(depCache))
-    extend(outConfig, { depCache: depCache });
-
-  if (hasProperties(map))
-    extend(outConfig, { map: map });
-
-  if (outConfig.transpiler === 'none')
-    outConfig.transpiler = false;
-
-  var configContent = stringify(outConfig)
-      // add a newline before "meta", "depCache", "map" blocks, removing quotes
-      .replace(new RegExp('^' + config.tab + '"(meta|depCache|map|packages)"', 'mg'), config.newLine + config.tab + '$1')
-      // remove quotes on first-level letter-based properties
-      .replace(new RegExp('^' + config.tab + '"(\\w+)"', 'mg'), config.tab + '$1');
-
-  return asp(fs.writeFile)(this.__fileName, 'System.config(' + configContent + ');' + config.newLine);
-};
-module.exports = Config;
-
-
-
-
-// --- can be removed after jspm@0.8 is fully deprecated --
-var semver = require('../semver');
-function upgradeToExactVersionResolution(config) {
-  // run through depMap and baseMap, and assign exact version matches
-  Object.keys(config.baseMap).forEach(function(p) {
-    upgradeToExactVersionResolveRange(config.baseMap[p], config);
-  });
-
-  Object.keys(config.depMap).forEach(function(p) {
-    var curMap = config.depMap[p];
-    Object.keys(curMap).forEach(function(p) {
-      upgradeToExactVersionResolveRange(curMap[p], config);
-    });
-  });
-
-  config.versions = {};
-}
-function upgradeToExactVersionResolveRange(range, config) {
-  var versions = config.versions[range.name];
-  if (versions)
-  versions.sort(semver.compare).reverse().some(function(version) {
-    if (semver.match(range.version, version)) {
-      range.setVersion(version);
-      return true;
-    }
-  });
-}
Index: node_modules/jspm/lib/config/package.js
===================================================================
--- node_modules/jspm/lib/config/package.js	(revision )
+++ node_modules/jspm/lib/config/package.js	(revision )
@@ -1,299 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-
-var config = require('../config');
-var path = require('path');
-var extend = require('../common').extend;
-var hasProperties = require('../common').hasProperties;
-var Promise = require('rsvp').Promise;
-var ui = require('../ui');
-var fs = require('graceful-fs');
-var asp = require('rsvp').denodeify;
-var readJSONSync = require('../common').readJSONSync;
-var alphabetize = require('../common').alphabetize;
-var processDeps = require('../package').processDeps;
-var stringify = require('../common').stringify;
-
-var isWindows = process.platform.match(/^win/);
-var winRegEx = /\\/g;
-function winPath(path) {
-  if (!isWindows)
-    return path;
-  return path.replace(winRegEx, '/');
-}
-
-/*
- * Package.json Configuration Class
- *
- * main
- * registry
- * dependencies
- * devDependencies
- * configFile
- * baseURL
- * packages
- * format
- * map
- * buildConfig
- * overrides
- *
- */
-function PackageJSON(fileName) {
-  this.fileName = fileName;
-}
-
-PackageJSON.prototype.read = function(prompts, sync) {
-  if (this.__read)
-    throw 'Package.json file already read';
-
-  this.__read = true;
-  var self = this;
-  var pjson;
-
-  var _pjson = readJSONSync(this.fileName);
-  self.originalPjson = _pjson;
-
-  self.jspmPrefix = true;
-  if ((_pjson.registry || _pjson.jspm === true) && typeof _pjson.jspm != 'object')
-    self.jspmPrefix = false;
-
-  // if we have dependencies in `jspm` prefix, assume devDependencies are too
-  if (_pjson.jspm && _pjson.jspm.dependencies) {
-    if (_pjson.devDependencies)
-      _pjson.jspm.devDependencies = _pjson.jspm.devDependencies || {};
-  }
-  // and vice versa
-  if (_pjson.jspm && _pjson.jspm.devDependencies) {
-    if (_pjson.dependencies)
-      _pjson.jspm.dependencies = _pjson.jspm.dependencies || {};
-  }
-
-  // derive the jspm config from the 'jspm' property in the package.json
-  // also sets the registry property if dependencies are jspm-prefixed
-  pjson = config.derivePackageConfig(_pjson);
-
-  self.pjson = pjson;
-
-  // not already jspm-configured
-  if (!_pjson.jspm && !_pjson.registry) {
-    prompts = true;
-    // dont read dependencies or devDependencies in this case
-    delete pjson.dependencies;
-    delete pjson.devDependencies;
-    // if dependencies already existing, override with empty dependencies
-    if (self.originalPjson.dependencies)
-      pjson.dependencies = {};
-    if (self.originalPjson.devDependencies)
-      pjson.devDependencies = {};
-  }
-
-  prompts = prompts || (!_pjson.jspm && !_pjson.registry);
-
-  if (prompts) {
-    if (sync)
-      throw 'Package.json file has not been initialized by jspm before. Run jspm init first.';
-    return doInitPrompts(pjson, self.fileName, self.jspmPrefix)
-    .then(function(prefixed) {
-      self.jspmPrefix = prefixed;
-      setDefaults();
-      return true;
-    });
-  }
-
-  setDefaults();
-
-  function setDefaults() {
-    self.dir = path.dirname(self.fileName);
-
-    // populate defaults as we go
-    var defaults = self.defaults = {};
-
-    self.registry = pjson.registry;
-    self.dependencies = {};
-    self.devDependencies = {};
-    // only read dependencies when combined with a registry property
-    self.dependencies = processDeps(pjson.dependencies, self.registry);
-    self.devDependencies = processDeps(pjson.devDependencies, self.registry);
-
-    defaults.baseURL = self.dir;
-    self.baseURL = pjson.directories && pjson.directories.baseURL && path.resolve(self.dir, pjson.directories.baseURL) || defaults.baseURL;
-    if (self.baseURL === path.resolve('/')) {
-      ui.log('warn', 'Server baseURL should be a relative file path, reverting to `.`');
-      self.baseURL = self.dir;
-    }
-
-    defaults.packages = path.resolve(self.baseURL, 'jspm_packages');
-
-    defaults.main = path.join(self.baseURL, 'index');
-    self.main = pjson.main || defaults.main;
-
-    // NB can remove jspmPackages suport in time
-    self.packages = pjson.directories && pjson.directories.packages && path.resolve(self.dir, pjson.directories.packages) ||
-      pjson.directories && pjson.directories.jspmPackages && path.resolve(self.dir, pjson.directories.jspmPackages) || defaults.packages;
-
-    defaults.configFile = path.resolve(self.baseURL, 'config.js');
-    self.configFile = pjson.configFile && path.resolve(self.dir, pjson.configFile) || defaults.configFile;
-
-    self.format = pjson.format;
-    self.map = extend({}, pjson.map || {});
-
-    self.buildConfig = extend({}, pjson.buildConfig || {});
-    self.overrides = extend({}, pjson.overrides || {});
-  }
-
-  // warn on invalid configs
-  if (path.relative(self.baseURL, self.packages)[0] == '.')
-    ui.log('warn', 'jspm_packages must be specified in the package.json within the baseURL for paths to resolve correctly.');
-};
-
-PackageJSON.prototype.write = function() {
-  var pjson = this.jspmPrefix ? {} : this.originalPjson;
-
-  if (!this.jspmPrefix && this.registry !== 'jspm')
-    pjson.jspm = true;
-
-  // set the registry property
-  if (this.jspmPrefix && this.registry !== 'jspm' || this.originalPjson.jspm && this.originalPjson.jspm.registry === 'jspm')
-    pjson.registry = this.registry;
-
-  var defaults = this.defaults;
-
-  function set(property, value, setValue) {
-    if (property in defaults && defaults[property] === value)
-      delete pjson[property];
-    else if (setValue !== undefined)
-      pjson[property] = setValue;
-    else if (value !== undefined)
-      pjson[property] = value;
-  }
-
-  // only set properties that differ from the defaults
-  // we set what we want the "derived" pjson to be first
-  set('main', this.main);
-  set('format', this.format);
-
-  var directories = extend({}, this.pjson.directories);
-  if (this.baseURL !== defaults.baseURL)
-    directories.baseURL = winPath(path.relative(this.dir, this.baseURL)) || '.';
-  else
-    delete directories.baseURL;
-  if (this.packages !== defaults.packages)
-    directories.packages = winPath(path.relative(this.dir, this.packages)) || '.';
-  else
-    delete directories.packages;
-
-  pjson.directories = alphabetize(directories);
-
-  set('configFile', this.configFile, winPath(path.relative(this.dir, this.configFile)));
-
-  pjson.map = alphabetize(this.map);
-
-  pjson.dependencies = writeDependencies(this.dependencies, this.registry);
-
-  pjson.devDependencies = writeDependencies(this.devDependencies, this.registry);
-
-  pjson.buildConfig = this.buildConfig;
-  pjson.overrides = this.overrides;
-
-  var self = this;
-  // remove any empty object properties that aren't nulling a base property
-  Object.keys(pjson).forEach(function(key) {
-    var val = pjson[key];
-    if (typeof val !== 'object' || hasProperties(val))
-      return;
-    if (!self.jspmPrefix || !(key in self.originalPjson))
-      delete pjson[key];
-  });
-
-  // for jspm prefixing, work out what we need to get desired package.json
-  if (this.jspmPrefix) {
-    for (var p in pjson) {
-      if (this.originalPjson[p] === pjson[p])
-        delete pjson[p];
-    }
-    this.originalPjson.jspm = pjson;
-  }
-
-  return asp(fs.readFile)(this.fileName).then(function(content) {
-    if (content.toString() === stringify(self.originalPjson) + config.newLine) {
-      return Promise.resolve();
-    } else {
-      return asp(fs.writeFile)(self.fileName, stringify(self.originalPjson) + config.newLine);
-    }
-  }).catch(function() {
-    return asp(fs.writeFile)(self.fileName, stringify(self.originalPjson) + config.newLine);
-  });
-};
-
-function writeDependencies(dependencies, registry) {
-  var outDependencies = {};
-  var depValue;
-  for (var dkey in dependencies) {
-    if (!dependencies.hasOwnProperty(dkey))
-      continue;
-    var dep = dependencies[dkey];
-    if (!dep)
-      continue;
-    if (dep.registry === registry) {
-      if (dkey === dep.package)
-        depValue = dep.version || '*';
-      else
-        depValue = dep.exactPackage;
-    }
-    else
-      depValue = dep.exactName;
-
-    outDependencies[dkey] = depValue;
-  }
-  return alphabetize(outDependencies);
-}
-
-// can take an existing non-jspm package.json
-function doInitPrompts(pjson, pjsonPath, prefixed) {
-  var baseDir = path.dirname(pjsonPath);
-  var base;
-
-  pjson.directories = pjson.directories || {};
-
-  return Promise.resolve()
-  .then(function() {
-    return ui.confirm('Would you like jspm to prefix the jspm package.json properties under %jspm%?', prefixed);
-  })
-  .then(function(prefix) {
-    prefixed = prefix;
-    return ui.input('Enter server baseURL (public folder path)', pjson.directories.baseURL || './');
-  })
-  .then(function(baseURL) {
-    base = path.relative(process.cwd(), path.resolve(baseURL));
-    baseURL = path.relative(baseDir, path.resolve(baseURL));
-    if (!base)
-      base = '.';
-    base += path.sep;
-    if (baseURL)
-      pjson.directories.baseURL = baseURL;
-    return ui.input('Enter jspm packages folder', pjson.directories.packages || base + 'jspm_packages');
-  })
-  .then(function(packages) {
-    pjson.directories.packages = path.relative(baseDir, path.resolve(packages));
-    return ui.input('Enter config file path', pjson.configFile || base + 'config.js');
-  })
-  .then(function(configFile) {
-    pjson.configFile = path.relative(baseDir, path.resolve(configFile));
-    return prefixed;
-  });
-}
-
-module.exports = PackageJSON;
Index: node_modules/jspm/lib/config/package-name.js
===================================================================
--- node_modules/jspm/lib/config/package-name.js	(revision )
+++ node_modules/jspm/lib/config/package-name.js	(revision )
@@ -1,89 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-
-/*
-  Parse a package name into registry:package@version
-
-  name: 'github:jquery/jquery',
-  exactName: 'github:jquery/jquery@2.0.3',
-  exactPackage: 'jquery/jquery@2.0.3',
-
-  registry: 'github',
-  package: 'jquery/jquery',
-  version: '2.0.3'
-*/
-function Package(name, escape) {
-  this.exactName = name;
-
-  if (name.indexOf(':') !== -1)
-    this.registry = name.split(':')[0];
-
-  var pkg = this.registry ? name.substr(this.registry.length + 1) : name;
-
-  var versionIndex = pkg.lastIndexOf('@');
-  var version = '';
-
-  if (versionIndex !== -1 && versionIndex !== 0) {
-    version = pkg.substr(versionIndex + 1);
-    pkg = pkg.substr(0, versionIndex);
-  }
-
-  if (escape && version)
-    version = version.replace(/[\/%]/g, function(symbol) {
-      return encodeURIComponent(symbol);
-    });
-
-  this.package = pkg;
-
-  this.name = (this.registry ? this.registry + ':' : '') + this.package;
-
-  this.setVersion(version);
-}
-
-Package.prototype.setVersion = function(version) {
-  if (version === '*')
-    version = '';
-  this.version = version;
-  var v = this.version ? '@' + this.version : '';
-  this.exactPackage = this.package + v;
-  this.exactName = this.name + v;
-  return this;
-};
-
-Package.prototype.setRegistry = function(registry) {
-  if (this.registry)
-    throw 'Endpoint already set.';
-  this.registry = registry;
-  this.exactName = registry + ':' + this.exactName;
-  this.name = registry + ':' + this.name;
-  return this;
-};
-
-Package.prototype.copy = function() {
-  return new Package(this.exactName);
-};
-
-var path = require('path');
-var config = require('../config');
-Package.prototype.getPath = function() {
-  return path.resolve(config.pjson.packages, this.registry, this.exactPackage);
-};
-
-Package.prototype.write = function() {
-  return this.exactName;
-};
-
-module.exports = Package;
Index: node_modules/jspm/lib/core.js
===================================================================
--- node_modules/jspm/lib/core.js	(revision )
+++ node_modules/jspm/lib/core.js	(revision )
@@ -1,418 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-require('core-js/es6/string');
-
-var Promise = require('rsvp').Promise;
-var path = require('path');
-var nodeSemver = require('semver');
-var ui = require('./ui');
-var config = require('./config');
-var registry = require('./registry');
-var build = require('./build');
-var PackageName = require('./config/package-name');
-var fs = require('graceful-fs');
-var mkdirp = require('mkdirp');
-var rimraf = require('rimraf');
-var ncp = require('ncp');
-var asp = require('rsvp').denodeify;
-var System = require('systemjs');
-var install = require('./install');
-var globalConfig = require('./global-config');
-var toFileURL = require('./common').toFileURL;
-
-
-var core = module.exports;
-
-// we always download the latest semver compatible version
-var systemVersion = require('../package.json').dependencies.systemjs;
-
-var tPackages = {
-  'babel':           'npm:babel-core@^5.8.24',
-  'babel-runtime':   'npm:babel-runtime@^5.8.24',
-  'core-js':         'npm:core-js@^1.1.4',
-  'traceur':         'github:jmcriffey/bower-traceur@0.0.93',
-  'traceur-runtime': 'github:jmcriffey/bower-traceur-runtime@0.0.93',
-  'typescript':      'npm:typescript@^2.0.7'
-};
-
-exports.run = function(moduleName) {
-  return config.load()
-  .then(function() {
-    var cfg = config.loader.getConfig();
-    delete cfg.bundles;
-    cfg.baseURL = toFileURL(config.pjson.baseURL);
-    System.config(cfg);
-
-    return System.import(moduleName);
-  })
-  .catch(function(e) {
-    ui.log('err', e.stack || e);
-  });
-};
-
-exports.build = function() {
-  var saveConfig = false;
-
-  return config.load()
-  .then(function() {
-    if (config.pjson.buildConfig.transpileES6 === undefined) {
-      saveConfig = true;
-      return ui.confirm('Transpile ES6?', true);
-    }
-  })
-  .then(function(doTranspile) {
-    if (doTranspile)
-      config.pjson.buildConfig.transpileES6 = true;
-
-    if (!config.pjson.buildConfig || config.pjson.buildConfig.minify === undefined) {
-      saveConfig = true;
-      return ui.confirm('Minify?', true);
-    }
-  })
-  .then(function(doMinify) {
-    if (doMinify)
-      config.pjson.buildConfig.minify = true;
-
-    if (saveConfig)
-      return config.save();
-  })
-  .then(function() {
-    return asp(rimraf)(config.pjson.dist);
-  })
-  .then(function() {
-    return asp(ncp)(config.pjson.lib, config.pjson.dist);
-  })
-  .then(function() {
-    return build.compileDir(config.pjson.dist, {
-      format: config.pjson.format,
-      map: config.pjson.map,
-      transpile: config.pjson.buildConfig.transpileES6,
-      minify: config.pjson.buildConfig.minify,
-      removeJSExtensions: config.pjson.useJSExtensions
-    });
-  })
-  .then(function(compileErrors) {
-    if (compileErrors)
-      ui.log('warn', 'Compile Errors:\n' + compileErrors);
-    else
-      ui.log('ok', 'Build Completed');
-  }, function(err) {
-    ui.log('err', err.stack || err);
-  });
-};
-
-exports.setMode = function(modes) {
-  if (!(modes instanceof Array))
-    modes = [modes];
-
-  var msg = '';
-
-  return config.load()
-  .then(function() {
-    if (modes.indexOf('local') === -1)
-      return true;
-
-    // set local
-    Object.keys(config.loader.registries).forEach(function(e) {
-      config.loader.registries[e].setLocal();
-    });
-
-    msg += 'Loader set to local library sources\n';
-  })
-  .then(function(unmatched) {
-    if (modes.indexOf('remote') === -1)
-      return unmatched;
-
-    // set remote
-    Object.keys(config.loader.registries).forEach(function(e) {
-      config.loader.registries[e].setRemote();
-    });
-
-    msg += 'Loader set to CDN library sources\n';
-  })
-  .then(function(unmatched) {
-    if (unmatched)
-      return ui.log('warn', 'Invalid mode');
-
-    return config.save()
-    .then(function() {
-      return msg;
-    });
-  });
-};
-
-exports.dlTranspiler = function(transpilerName, update) {
-  return config.load()
-  .then(function() {
-    var installObj = {};
-
-    transpilerName = transpilerName || config.loader.transpiler || globalConfig.config.defaultTranspiler;
-    
-    // skip download if not using a transpiler
-    if (transpilerName === 'none')
-      return;
-    
-    // read existing transpiler from package.json install
-    var target = !update && (config.pjson.devDependencies[transpilerName] || config.pjson.dependencies[transpilerName]);
-    if (target)
-      installObj[transpilerName] = target.exactName;
-    else
-      installObj[transpilerName] = transpilerName === 'traceur' ? tPackages.traceur : transpilerName === 'typescript' || transpilerName == 'ts' ? tPackages.typescript : tPackages.babel;
-    
-    // typescript does not have runtime library
-    if (transpilerName !== 'typescript') {
-      target = !update && (config.pjson.devDependencies[transpilerName + '-runtime'] || config.pjson.dependencies[transpilerName + '-runtime']);
-      if (target)
-        installObj[transpilerName + '-runtime'] = target.exactName;
-      else
-        installObj[transpilerName + '-runtime'] = transpilerName === 'traceur' ? tPackages['traceur-runtime'] : tPackages['babel-runtime'];
-    }
-    
-    if (transpilerName === 'babel') {
-      target = !update && (config.pjson.devDependencies['core-js'] || config.pjson.dependencies['core-js']);
-      if (target)
-        installObj['core-js'] = target.exactName;
-      else
-        installObj['core-js'] = tPackages['core-js'];
-    }
-    
-    // just do a quick install which checks basic existence
-    return install.install(installObj, { quick: !update, dev: true, summary: false });
-  })
-  .then(function() {
-    if (config.loader.transpiler !== transpilerName) {
-      config.loader.transpiler = transpilerName;
-      
-      if (transpilerName !== 'none')
-        ui.log('ok', 'ES6 transpiler set to %' + transpilerName + '%.');
-    }
-    if (transpilerName === 'babel')
-      if (!config.loader.babelOptions.optional)
-        config.loader.babelOptions.optional = ['runtime', 'optimisation.modules.system'];
-    return config.save();
-  });
-};
-
-// check and download module loader files
-exports.checkDlLoader = function(transpilerName) {
-  return config.load()
-  .then(function() {
-    transpilerName = transpilerName || config.loader.transpiler || globalConfig.config.defaultTranspiler;
-    var tPkgs = [];
-    if (transpilerName === 'traceur')
-      tPkgs = ['traceur', 'traceur-runtime'];
-    else if (transpilerName === 'babel')
-      tPkgs = ['babel', 'babel-runtime', 'core-js'];
-    else if (transpilerName === 'typescript')
-      tPkgs = ['typescript'];
-      
-    tPkgs.forEach(function(p) {
-      if (config.loader.baseMap[p])
-        if (config.loader.baseMap[p].version !== tPackages[p].split('@').pop() && !nodeSemver.satisfies(config.loader.baseMap[p].version, tPackages[p].split('@').pop()))
-          ui.log('warn', '`' + p + '@' + config.loader.baseMap[p].version + '` is unsupported for this version of jspm. Use %jspm dl-loader --latest% to update.');
-    });
-  })
-  .then(function() {
-    return asp(fs.readFile)(path.resolve(config.pjson.packages, '.loaderversions'));
-  })
-  .catch(function(err) {
-    if (err.code === 'ENOENT')
-      return '';
-    throw err;
-  })
-  .then(function(cacheVersions) {
-    if (cacheVersions.toString() !== systemVersion)
-      return exports.dlLoader(transpilerName);
-
-    // even if version file is fresh, still check files exist
-    return asp(fs.readdir)(config.pjson.packages)
-    .catch(function(err) {
-      if (err.code === 'ENOENT')
-        return [];
-      throw err;
-    })
-    .then(function(files) {
-      if (files.indexOf('system.js') === -1)
-        return exports.dlLoader(transpilerName);
-      return exports.dlTranspiler(transpilerName);
-    });
-  });
-};
-
-// mini registry API usage implementation
-var loaderFilesCacheDir = path.join(config.HOME, '.jspm', 'loader-files');
-
-function dl(name, repo, version) {
-  var pkg = new PackageName(repo);
-  var endpoint = registry.load(pkg.registry);
-  var vMatch, vMatchLookup;
-  var dlDir = path.resolve(loaderFilesCacheDir, name);
-
-  return endpoint.lookup(pkg.package)
-  .then(function(lookup) {
-    if (!(nodeSemver.validRange(version)))
-      vMatch = version;
-    else
-      vMatch = Object.keys(lookup.versions)
-      .filter(nodeSemver.valid)
-      .sort(nodeSemver.compare).reverse()
-      .filter(function(v) {
-        return nodeSemver.satisfies(v, version);
-      })[0];
-
-    vMatchLookup = lookup.versions[vMatch];
-
-    return asp(fs.readFile)(path.resolve(dlDir, '.hash'))
-    .then(function(_hash) {
-      return _hash.toString() === vMatchLookup.hash;
-    }, function (e) {
-      if (e.code === 'ENOENT')
-        return;
-      throw e;
-    });
-  })
-  .then(function(cached) {
-    if (cached)
-      return;
-
-    return endpoint.download(pkg.package, vMatch, vMatchLookup.hash, vMatchLookup.meta, dlDir)
-    .then(function() {
-      return fs.writeFile(path.resolve(dlDir, '.hash'), vMatchLookup.hash);
-    });
-  })
-  .then(function() {
-    return vMatch;
-  });
-}
-
-// file copy implementation
-function cp(file, name, transform) {
-  return asp(fs.readFile)(path.resolve(loaderFilesCacheDir, file)).then(function(source) {
-    if (transform)
-      source = transform(source.toString());
-    ui.log('info', '  `' + name + '`');
-    return asp(fs.writeFile)(path.resolve(config.pjson.packages, name), source);
-  });
-}
-
-exports.dlLoader = function(transpilerName, unminified, edge, latest) {
-  ui.log('info', 'Looking up loader files...');
-  var min = unminified ? '.src' : '';
-
-  var using = {};
-
-  return config.load()
-  .then(function() {
-    return asp(mkdirp)(config.pjson.packages);
-  })
-  .then(function() {
-    // delete old versions
-    return asp(fs.readdir)(config.pjson.packages);
-  })
-  .then(function(files) {
-    return Promise.all(files.filter(function(file) {
-      return file.match(/^(system-csp|system-csp-production|system|es6-module-loader|traceur|babel|system-polyfills|typescript)/);
-    }).map(function(file) {
-      return asp(fs.unlink)(path.resolve(config.pjson.packages, file));
-    }));
-  })
-  .then(function() {
-    return dl('systemjs', 'github:systemjs/systemjs', !edge ? (!latest ? systemVersion : '^' + systemVersion) : 'master')
-    .then(function(version) {
-      using.system = version;
-      return Promise.all([
-        cp('systemjs/dist/system' + min + '.js', 'system.js'),
-        unminified || cp('systemjs/dist/system.src.js', 'system.src.js'),
-        unminified || cp('systemjs/dist/system.js.map', 'system.js.map'),
-        cp('systemjs/dist/system-csp-production' + min + '.js', 'system-csp-production.js'),
-        unminified || cp('systemjs/dist/system-csp-production.src.js', 'system-csp-production.src.js'),
-        unminified || cp('systemjs/dist/system-csp-production.js.map', 'system-csp-production.js.map'),
-        cp('systemjs/dist/system-polyfills' + min + '.js', 'system-polyfills.js'),
-        unminified || cp('systemjs/dist/system-polyfills.src.js', 'system-polyfills.src.js'),
-        unminified || cp('systemjs/dist/system-polyfills.js.map', 'system-polyfills.js.map')
-      ]);
-    });
-  })
-  .then(function() {
-    ui.log('info', '\nUsing loader versions:');
-    ui.log('info', '  `systemjs@' + using.system + '`');
-
-    return asp(fs.writeFile)(path.resolve(config.pjson.packages, '.loaderversions'), systemVersion);
-  })
-  .then(function() {
-    return exports.dlTranspiler(transpilerName, latest);
-  })
-  .then(function() {
-    ui.log('ok', 'Loader files downloaded successfully');
-  }, function(err) {
-    ui.log('err', err);
-    ui.log('err', 'Error downloading loader files.');
-    throw err;
-  });
-};
-
-exports.init = function init(basePath, ask) {
-  if (basePath)
-    process.env.jspmConfigPath = path.resolve(basePath, 'package.json');
-  var relBase = path.relative(process.cwd(), path.dirname(process.env.jspmConfigPath));
-  if (relBase !== '')
-    ui.log('info', 'Initializing package at `' + relBase + '/`\nUse %jspm init .% to intialize into the current folder.');
-  return config.load(ask)
-  .then(function() {
-    return config.save();
-  })
-  .then(function() {
-    ui.log('ok', 'Verified package.json at %' + path.relative(process.cwd(), config.pjsonPath) + '%\nVerified config file at %' + path.relative(process.cwd(), config.pjson.configFile) + '%');
-  })
-  .then(function() {
-    return core.checkDlLoader();
-  })
-  .catch(function(err) {
-    ui.log('err', err && err.stack || err);
-  });
-};
-
-exports.cacheClear = function() {
-  var jspmDir = path.resolve(config.HOME, '.jspm'),
-      packagesCacheDir = path.join(jspmDir, 'packages'),
-      loaderCacheDir = path.join(jspmDir, 'loader-files'),
-      files, filesLength, fileName, i;
-
-  // Clear loader files
-  if (fs.existsSync(loaderCacheDir))
-    rimraf.sync(loaderCacheDir);
-  ui.log('ok', 'Loader file cache cleared.');
-
-  // Clear packages cache folder
-  if (fs.existsSync(packagesCacheDir))
-    rimraf.sync(packagesCacheDir);
-  ui.log('ok', 'Package cache cleared.');
-
-  // Clear registry cache folders
-  files = fs.readdirSync(jspmDir);
-  filesLength = files.length;
-  for (i = 0; i < filesLength; i++) {
-    fileName = files[i];
-    if (fileName.endsWith('-cache')) {
-      rimraf.sync(path.join(jspmDir, fileName));
-      ui.log('ok', '%' + fileName.substr(0, fileName.length - '-cache'.length) + '% cache cleared.');
-    }
-  }
-
-  ui.log('warn', 'All caches cleared.');
-  ui.log('info', 'Please post an issue if you suspect the cache isn\'t invalidating properly.');
-  ui.log('info', '%jspm install -f% is equivalent to running a cache clear for that specific package tree.');
-};
Index: node_modules/jspm/lib/link.js
===================================================================
--- node_modules/jspm/lib/link.js	(revision )
+++ node_modules/jspm/lib/link.js	(revision )
@@ -1,201 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-var readJSON = require('./common').readJSON;
-var package = require('./package');
-var PackageName = require('./config/package-name');
-var Promise = require('rsvp').Promise;
-var asp = require('rsvp').denodeify;
-var config = require('./config');
-var ncp = require('ncp');
-var path = require('path');
-var ui = require('./ui');
-var rimraf = require('rimraf');
-var mkdirp = require('mkdirp');
-var fs = require('graceful-fs');
-
-exports.link = function(name, dir, force) {
-  var pjson, linkDir, pkg;
-
-  return Promise.resolve()
-  .then(function() {
-    // try to get registry, package
-    return readJSON(path.resolve(dir, 'package.json'));
-  })
-  .then(function(_pjson) {
-    try {
-      pkg = new PackageName(name);
-    }
-    catch(e) {
-      pkg = {};
-    }
-
-    var packageName = pkg.package || _pjson.jspm && _pjson.jspm.name || _pjson.name;
-    var registry = pkg.registry || _pjson.jspm && _pjson.jspm.registry || _pjson.registry;
-    var version = pkg.version || _pjson.jspm && _pjson.jspm.version || _pjson.version;
-
-    if (!packageName)
-      throw 'Package name not specified.';
-    if (!registry)
-      throw 'Package registry not specified.';
-    if (!version)
-      throw 'Package version not specified.';
-
-    pkg = new PackageName(registry + ':' + packageName + '@' + version);
-
-    return package.derivePackageConfig(pkg, _pjson);
-  })
-  .then(function(_pjson) {
-    pjson = _pjson;
-
-    linkDir = path.resolve(config.HOME, '.jspm', 'linked', pkg.registry, pkg.exactPackage);
-    try {
-      if (fs.existsSync(linkDir)) {
-        return (force ? Promise.resolve(true) : ui.confirm('`' + pkg.exactName + '` is already linked, are you sure you want to override it (use -y to skip this prompt in future)?', true))
-        .then(function(override) {
-          return !override;
-        });
-      }
-    }
-    catch(e) {}
-  })
-  // clear the directory
-  .then(function(abort) {
-    if (abort)
-      return true;
-
-    return asp(rimraf)(linkDir)
-    // create it
-    .then(function() {
-      if (pjson.directories) {
-        if (pjson.directories.lib) {
-          dir = path.resolve(dir, pjson.directories.lib);
-          delete pjson.directories.lib;
-        }
-        if (pjson.directories.dist) {
-          dir = path.resolve(dir, pjson.directories.dist);
-          delete pjson.directories.dist;
-        }
-      }
-
-      return asp(mkdirp)(linkDir);
-    })
-    // copy the files to the local cache folder
-    .then(function() {
-      return asp(ncp)(dir, linkDir);
-    })
-    // run the jspm operations on the folder to process it
-    .then(function() {
-      return package.processPackage(pkg, linkDir, pjson, function() {});
-    })
-    .then(function() {
-      return asp(fs.writeFile)(path.resolve(linkDir, '.jspm.json'), JSON.stringify(pjson, null, 2));
-    });
-  })
-  .then(function(aborted) {
-    if (!aborted)
-      ui.log('ok', 'Package linked as `' + pkg.exactName + '`');
-    else
-      ui.log('info', 'Link operation aborted.');
-  }, function(err) {
-    ui.log('err', err.stack || err);
-  });
-};
-
-exports.lookup = function(pkg, edge) {
-  var packageParts = pkg.package.split('/');
-  var packagePart = packageParts.pop();
-  var linkFolder = path.resolve(config.HOME, '.jspm', 'linked', pkg.registry, packageParts.join('/'));
-
-  return asp(fs.readdir)(linkFolder)
-  .then(function(files) {
-    var versions = {};
-    var hasVersions;
-    files
-    .filter(function(file) {
-      return file.substr(0, file.lastIndexOf('@')) === packagePart;
-    })
-    .forEach(function(file) {
-      hasVersions = true;
-      versions[file.substr(file.lastIndexOf('@') + 1)] = { hash: 'hash' };
-    });
-
-    if (!hasVersions)
-      throw 'No version match found for `' + pkg.exactName + '`';
-
-    return function(version) {
-      var lookupObj = package.getVersionMatch(version, versions, {edge: edge});
-      if (!lookupObj)
-        return;
-
-      return pkg.copy().setVersion(lookupObj.version);
-    };
-  }, function(err) {
-    if (err.code === 'ENOENT')
-      throw 'No linked versions found for `' + pkg.name + '`';
-    throw err;
-  });
-};
-
-exports.symlink = function(pkg, downloadDeps) {
-  var linkDir = path.resolve(config.HOME, '.jspm', 'linked', pkg.registry, pkg.exactPackage);
-  var dir = path.resolve(config.pjson.packages, pkg.registry, pkg.exactPackage);
-  var pjson;
-
-  var fresh = false;
-
-  return asp(fs.readlink)(dir)
-  .then(function(linkString) {
-    if (linkString === linkDir)
-      return asp(fs.unlink)(dir);
-
-    return Promise.resolve(ui.confirm('`' + pkg.exactName + '` already linked, are you sure you want to link over it?', true))
-    .then(function(remove) {
-      if (!remove)
-        throw 'Aborted.';
-      return asp(fs.unlink)(dir);
-    });
-
-  }, function(err) {
-    if (err.code === 'ENOENT')
-      return;
-    if (err.code !== 'EINVAL' && err.code !== 'UNKNOWN')
-      throw err;
-
-    return Promise.resolve(ui.confirm('`' + pkg.exactName + '` already installed, are you sure you want to link over it?', true))
-    .then(function(remove) {
-      if (!remove)
-        throw 'Aborted.';
-      return asp(rimraf)(dir);
-    });
-  })
-  .then(function() {
-    return asp(mkdirp)(path.resolve(dir, '..'))
-    .then(function() {
-      return asp(fs.symlink)(linkDir, dir, 'junction');
-    })
-    .then(function() {
-      return readJSON(path.resolve(dir, '.jspm.json'));
-    })
-    .then(function(_pjson) {
-      pjson = config.derivePackageConfig(_pjson);
-      return package.createMain(pkg, pjson, dir);
-    });
-  })
-  .then(function() {
-    downloadDeps(package.processDeps(pjson.dependencies, pjson.registry));
-    return fresh;
-  });
-};
Index: node_modules/jspm/lib/build.js
===================================================================
--- node_modules/jspm/lib/build.js	(revision )
+++ node_modules/jspm/lib/build.js	(revision )
@@ -1,669 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-require('core-js/es6/string');
-
-var Promise = require('rsvp').Promise;
-var asp = require('rsvp').denodeify;
-var fs = require('graceful-fs');
-var glob = require('glob');
-var rimraf = require('rimraf');
-var path = require('path');
-var minimatch = require('minimatch');
-
-var build = module.exports;
-
-exports.buildPackage = function(dir, pjson, isCDN) {
-  return build.filterIgnoreAndFiles(dir, pjson.ignore, pjson.files)
-
-  // check if directories.dist exists
-  // if so collapse and do nothing further
-  .then(function() {
-    if (!pjson.directories || !pjson.directories.dist)
-      return;
-
-    return asp(fs.stat)(path.resolve(dir, pjson.directories.dist))
-    .then(function(stats) {
-      return stats && stats.isDirectory();
-    }, function() {
-      return false;
-    })
-    .then(function(dist) {
-      if (dist)
-        return build.collapseLibDir(dir, pjson.directories.dist).then(function() { return true; });
-    });
-  })
-
-  // check if directories.lib exists, if so collapse
-  .then(function(dist) {
-    if (dist)
-      return true;
-
-    if (!pjson.directories || !pjson.directories.lib)
-      return;
-
-    return asp(fs.stat)(path.resolve(dir, pjson.directories.lib))
-    .then(function(stats) {
-      return stats && stats.isDirectory();
-    }, function() {
-      return false;
-    })
-    .then(function(dist) {
-      if (dist)
-        return build.collapseLibDir(dir, pjson.directories.lib);
-    });
-  })
-
-  // finally, build
-  .then(function(hasDist) {
-    if (pjson.format || pjson.shim || pjson.buildConfig || (pjson.registry && pjson.dependencies) || pjson.map)
-      return build.compileDir(dir, {
-        format: pjson.format,
-        shim: pjson.shim,
-        dependencies: pjson.dependencies, // dependencies already parsed into jspm-compatible
-        removeJSExtensions: pjson.useJSExtensions,
-        map: pjson.map,
-        transpile: !hasDist && pjson.buildConfig && pjson.buildConfig.transpile,
-        minify: isCDN, // && !hasDist && pjson.buildConfig && (pjson.buildConfig.uglify || pjson.buildConfig.minify)
-        alwaysIncludeFormat: isCDN
-      });
-  });
-};
-
-exports.filterIgnoreAndFiles = function(dir, ignore, files) {
-  if (!ignore && !files)
-    return Promise.resolve();
-
-  return asp(glob)(dir + path.sep + '**' + path.sep + '*', {dot: true})
-  .then(function(allFiles) {
-    var removeFiles = [];
-
-    allFiles.forEach(function(file) {
-      var fileName = path.relative(dir, file).replace(/\\/g, '/');
-
-      // if files, remove all files except those in the files list
-      if (files && !files.some(function(keepFile) {
-        if (keepFile.startsWith('./'))
-          keepFile = keepFile.substr(2);
-        else if (keepFile.startsWith('/'))
-          keepFile = keepFile.substr(1);
-
-        // this file is in a keep dir, or a keep file, don't exclude
-        if (inDir(fileName, keepFile, false) || minimatch(fileName, keepFile))
-          return true;
-      }))
-        return removeFiles.push(fileName);
-
-      // if ignore, ensure removed
-      if (ignore && ignore.some(function(ignoreFile) {
-        if (ignoreFile.startsWith('./'))
-          ignoreFile = ignoreFile.substr(2);
-        else if (ignoreFile.startsWith('/'))
-          ignoreFile = ignoreFile.substr(1);
-        // this file is in an ignore dir or an ignore file, ignore
-        if (inDir(fileName, ignoreFile, false) || minimatch(fileName, ignoreFile))
-          return true;
-      }))
-        removeFiles.push(fileName);
-    });
-
-    return removeFiles.map(function(removeFile) {
-      return path.resolve(dir, removeFile);
-    })
-    // do removal of files in reverse order so that directories get removed properly
-    .reverse()
-    .reduce(function(removePromise, resolvedFile) {
-      return removePromise.then(function() {
-        return asp(fs.unlink)(resolvedFile)
-        .catch(function(e) {
-          if (e.code === 'ENOENT')
-            return;
-          if (e.code === 'EISDIR' || e.code === 'EPERM')
-            return asp(fs.rmdir)(resolvedFile)
-            .catch(function(e) {
-              if (e.code === 'ENOTEMPTY')
-                return;
-              throw e;
-            });
-          throw e;
-        });
-      });
-    }, Promise.resolve());
-  });
-};
-
-exports.collapseLibDir = function(dir, subDir) {
-  if (subDir.endsWith('/'))
-    subDir = subDir.substr(0, subDir.length - 1);
-
-  var tmpDir = path.resolve(dir, '..', '.tmp-' + dir.split(path.sep).pop());
-
-  // move subDir to tmpDir
-  return asp(fs.rename)(path.normalize(dir + path.sep + subDir), tmpDir)
-
-  // remove everything in dir
-  .then(function() {
-    return asp(rimraf)(dir);
-  })
-
-  // move subDir to dir
-  .then(function() {
-    return asp(fs.rename)(tmpDir, dir);
-  });
-};
-
-function inDir(fileName, dir, sep) {
-  return fileName.substr(0, dir.length) === dir && (sep === false || fileName.substr(dir.length - 1, 1) === path.sep);
-}
-
-function matchWithWildcard(matches, name) {
-  var curMatch;
-  var curMatchLength;
-
-  main:
-  for (var p in matches) {
-    if (!matches.hasOwnProperty(p))
-      continue;
-
-    var matchParts = p.split('/');
-    var nameParts = name.split('/');
-    if (matchParts.length !== nameParts.length)
-      continue;
-
-    var match;
-
-    for (var i = 0; i < matchParts.length; i++) {
-      // do wildcard matching on individual parts if necessary
-      if (matchParts[i].includes('*')) {
-        if (!(match = nameParts[i].match(new RegExp(matchParts[i].replace(/([^*\w])/g, '\\$1').replace(/(\*)/g, '(.*)')))))
-          continue main;
-      }
-      else if (nameParts[i] !== matchParts[i])
-        continue main;
-    }
-
-    // least wildcards in match wins
-    if (p.length >= curMatchLength)
-      continue;
-
-    curMatch = p;
-    curMatchLength = matchParts.length;
-  }
-  return curMatch;
-}
-
-// return the number of prefix parts (separated by '/') matching the name
-// eg prefixMatchLength('jquery/some/thing', 'jquery') -> 1
-function prefixMatchLength(name, prefix) {
-  var prefixParts = prefix.split('/');
-  var nameParts = name.split('/');
-  if (prefixParts.length > nameParts.length)
-    return 0;
-  for (var i = 0; i < prefixParts.length; i++)
-    if (nameParts[i] !== prefixParts[i])
-      return 0;
-  return prefixParts.length;
-}
-
-// while doing map, we also remove ".js" extensions where necessary
-function applyMap(_name, map, baseFile, removeJSExtensions) {
-  var name = _name, pluginName;
-
-  if (name.includes('!')) {
-    pluginName = name.substr(name.indexOf('!') + 1);
-    name = name.substr(0, name.length - pluginName.length - 1);
-    pluginName = pluginName || name.substr(name.lastIndexOf('.') + 1);
-    pluginName = applyMap(pluginName, map, baseFile, false) || pluginName;
-  }
-
-
-  if (removeJSExtensions) {
-    if (name.startsWith('./') || name.split('/').length > 1) {
-      if (name.endsWith('.js'))
-        name = name.substr(0, name.length - 3);
-    }
-  }
-
-  for (var m in map) {
-    if (!map.hasOwnProperty(m))
-      continue;
-
-    var matchLength = prefixMatchLength(name, m);
-    if (!matchLength)
-      continue;
-
-    var subPath = name.split('/').splice(matchLength).join('/');
-
-    var toMap = map[m];
-
-    if (typeof toMap != 'string')
-      continue;
-
-    if (toMap.startsWith('./')) {
-      // add .js in case of matching directory name
-      toMap = path.relative(path.dirname(baseFile), toMap.substr(2) + '.js').replace(/\\/g, '/');
-      if (!toMap.startsWith('.'))
-        toMap = './' + toMap;
-      // remove .js
-      toMap = toMap.substr(0, toMap.length - 3);
-    }
-
-    return toMap + (subPath ? '/' + subPath : '') + (pluginName ? '!' + pluginName : '');
-  }
-
-  if (pluginName)
-    name += '!' + pluginName;
-
-  if (name !== _name)
-    return name;
-}
-
-// NB keep these up to date with SystemJS
-var esmRegEx = /(^\s*|[}\);\n]\s*)(import\s+(['"]|(\*\s+as\s+)?[^"'\(\)\n;]+\s+from\s+['"]|\{)|export\s+\*\s+from\s+["']|export\s+(\{|default|function|class|var|const|let|async\s+function))/;
-var esmDepRegEx = /(^|\}|\s)(from|import)\s*("([^"]+)"|'([^']+)')/g;
-var amdRegEx = /(?:^|[^$_a-zA-Z\xA0-\uFFFF.])define\s*\(\s*("[^"]+"\s*,\s*|'[^']+'\s*,\s*)?\s*(\[(\s*(("[^"]+"|'[^']+')\s*,|\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*(\s*("[^"]+"|'[^']+')\s*,?)?(\s*(\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*\s*\]|function\s*|{|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*\))/;
-var amdDefineRegEx = /(?:^|[^$_a-zA-Z\xA0-\uFFFF.])define\s*\(\s*("[^"]+"\s*,|'[^']+'\s*,\s*)?(\[(\s*("[^"]+"|'[^']+')\s*,)*(\s*("[^"]+"|'[^']+')\s*)?\])?/g;
-var cjsRequireRegEx = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF."'])require\s*\(\s*("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*')\s*\)/g;
-var cjsExportsRegEx = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.]|module\.)(exports\s*\[['"]|\exports\s*\.)|(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])module\.exports\s*\=/;
-
-var registerRegEx = /System\.register/;
-
-var metaRegEx = /^(\s*\/\*.*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)+/;
-var metaPartRegEx = /\/\*.*\*\/|\/\/[^\n]*|"[^"]+"\s*;?|'[^']+'\s*;?/g;
-
-  // var commentRegEx = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;
-var initialCommentRegEx = /^\s*(\/\*|\/\/)/;
-
-function detectFormat(source) {
-  // first checkout if we have format meta
-  var meta = source.match(metaRegEx);
-  var metadata = {};
-  if (meta) {
-    var metaParts = meta[0].match(metaPartRegEx);
-    for (var i = 0; i < metaParts.length; i++) {
-      var len = metaParts[i].length;
-
-      var firstChar = metaParts[i].substr(0, 1);
-      if (metaParts[i].endsWith(';'))
-        len--;
-
-      if (firstChar !== '"' && firstChar !== '\'')
-        continue;
-
-      var metaString = metaParts[i].substr(1, metaParts[i].length - 3);
-
-      var metaName = metaString.substr(0, metaString.indexOf(' '));
-      if (metaName) {
-        var metaValue = metaString.substr(metaName.length + 1, metaString.length - metaName.length - 1);
-
-        if (metadata[metaName] instanceof Array)
-          metadata[metaName].push(metaValue);
-        else
-          metadata[metaName] = metaValue;
-      }
-    }
-  }
-
-  if (metadata.format)
-    return { format: metadata.format, meta: true };
-
-  cjsExportsRegEx.lastIndex = 0;
-  cjsRequireRegEx.lastIndex = 0;
-  if (source.match(esmRegEx))
-    return { format: 'esm' };
-
-  if (source.match(registerRegEx))
-    return { format: 'register' };
-
-  if (source.match(amdRegEx))
-    return { format: 'amd' };
-
-  if (cjsRequireRegEx.exec(source) || cjsExportsRegEx.exec(source))
-    return { format: 'cjs' };
-
-  return { format: 'global' };
-}
-exports.detectFormat = detectFormat;
-
-/*
-  options.format
-  options.shim
-  options.dependencies
-  options.map
-  options.removeJSExtensions
-  options.transpile
-  options.minify
-  options.sourceURLBase
-  options.alwaysIncludeFormat
-*/
-exports.compileDir = function(dir, options) {
-  dir = path.resolve(dir);
-
-  options.sourceURLBase = options.sourceURLBase || '';
-
-  // store a list of compile errors
-  var compileErrors = '';
-
-  // create the map config
-  // convert jspm options.dependencies into a requirable form
-  // and combine them into a new map object
-  var map = {}, optionsMap, optionsDependencies;
-  if (options.map)
-    optionsMap = options.map;
-    for (var m in optionsMap)
-      if (optionsMap.hasOwnProperty(m))
-        map[m] = optionsMap[m];
-
-  if (options.dependencies) {
-    optionsDependencies = options.dependencies;
-    for (var d in optionsDependencies) {
-      if (!optionsDependencies.hasOwnProperty(d))
-        continue;
-      // custom map overrides dependency map
-      if (map[d])
-        continue;
-
-      var curDep = optionsDependencies[d];
-      if (curDep.includes(':') || curDep.includes('@'))
-        map[d] = curDep;
-
-      else if (curDep && curDep !== '*')
-        map[d] = d + '@' + curDep;
-      else
-        map[d] = d;
-    }
-  }
-
-  var nl = '\n';
-
-  // glob each ".js" file
-  return asp(glob)(dir + path.sep + '**' + path.sep + '*.js')
-
-  .then(function(files) {
-
-    return Promise.all(files.map(function(file) {
-
-      var changed = false;
-
-      var sourceMap;
-
-      var format;
-      if (options.format && typeof options.format === 'string')
-        format = options.format.toLowerCase();
-
-      var relFile = path.relative(dir, file);
-      var relModule = relFile.substr(0, relFile.length - 3).replace(/\\/g, '/');
-
-      // first check if a symlink
-      return asp(fs.lstat)(file)
-      .then(function(stats) {
-        if (stats.isSymbolicLink())
-          return;
-
-        return asp(fs.readFile)(file)
-        .then(function(source) {
-          source += '';
-
-          return Promise.resolve()
-          // add shim config if necessary
-          .then(function() {
-            if (!options.shim)
-              return;
-
-            var match;
-
-            if (!(match = matchWithWildcard(options.shim, relModule)))
-              return;
-
-            var curShim = options.shim[match];
-            if (curShim instanceof Array)
-              curShim = { deps: curShim };
-
-            // NB backwards-compatible with shim.imports
-            curShim.deps = curShim.deps || curShim.imports;
-
-            if (typeof curShim.deps === 'string')
-              curShim.deps = [curShim.deps];
-
-            var depStr = '"format global";' + nl;
-            if (curShim.deps)
-              for (var i = 0; i < curShim.deps.length; i++)
-                depStr += '"deps ' + curShim.deps[i] + '";' + nl;
-
-            if (curShim.exports)
-              depStr += '"exports ' + curShim.exports + '";' + nl;
-
-            changed = true;
-            source = depStr + source;
-
-            return true;
-          })
-
-          // add any format hint if provided
-          // only add format hint if detection would fail
-          // also set the format here if not set
-          // NB all regexs should apply after removing comments
-          // also ideally format injection should be post-minification
-          // in case of minification quirks
-          .then(function(shimmed) {
-            // don't add format if already shimmed!
-            if (shimmed)
-              return;
-
-            var detected = detectFormat(source);
-
-            // don't rewrite meta
-            if (detected.meta) {
-              format = detected.format;
-              return;
-            }
-
-            if (format == 'es6')
-              format = 'esm';
-
-            if (options.alwaysIncludeFormat || !format || detected.format !== format) {
-              changed = true;
-              source = '"format ' + (format || detected.format) + '";' + nl + source;
-            }
-
-            if (!format)
-              format = detected.format;
-          })
-
-          // apply map config
-          .then(function() {
-            // ES Module
-            if (format === 'esm') {
-              source = source.replace(esmDepRegEx, function(statement, start, type, str, singleString, doubleString) {
-                var name = singleString || doubleString;
-                var mapped = applyMap(name, map, relFile, options.removeJSExtensions);
-
-                if (!mapped)
-                  return statement;
-
-                changed = true;
-                return statement.replace(new RegExp('"' + name + '"|\'' + name + '\'', 'g'), '\'' + mapped + '\'');
-              });
-            }
-
-            // AMD
-            else if (format === 'amd') {
-              amdDefineRegEx.lastIndex = 0;
-              var defineStatement = amdDefineRegEx.exec(source);
-              if (defineStatement) {
-                if (!defineStatement[2])
-                  return;
-
-                var depArray = eval(defineStatement[2]);
-                depArray = depArray.map(function(name) {
-                  var mapped = applyMap(name, map, relFile, options.removeJSExtensions);
-
-                  if (!mapped)
-                    return name;
-
-                  changed = true;
-                  return mapped;
-                });
-
-                if (changed)
-                  source = source.replace(defineStatement[2], JSON.stringify(depArray));
-              }
-            }
-
-            // CommonJS
-            else if (format === 'cjs') {
-              source = source.replace(cjsRequireRegEx, function(statement, singleString, doubleString) {
-                var name = singleString || doubleString;
-                name = name.substr(1, name.length - 2);
-                var mapped = applyMap(name, map, relFile, options.removeJSExtensions);
-
-                if (!mapped)
-                  return statement;
-
-                changed = true;
-                return statement.replace(new RegExp('"' + name + '"|\'' + name + '\'', 'g'), '\'' + mapped + '\'');
-              });
-            }
-
-            // Global? (including shim?)
-            // else {
-            // }
-          })
-
-          // if changed, save these meta-updates into the original file
-          .then(function() {
-
-            // ensure there is a comment at the beginning of the file
-            // this is necessary to protect the source map when wrapping
-            if (!source.match(initialCommentRegEx)) {
-              source = '\/* *\/ \n' + source;
-              changed = true;
-            }
-
-            if (changed)
-              return asp(fs.writeFile)(file, source);
-          })
-
-          // transpile
-          .then(function() {
-            if (!options.transpile)
-              return;
-
-            var traceur = require('traceur');
-
-            traceur.options.sourceMaps = true;
-            traceur.options.modules = 'instantiate';
-
-            try {
-              var compiler = new traceur.Compiler({
-                moduleName: '',
-                modules: 'instantiate'
-              });
-
-              source = compiler.compile(source, relFile, path.basename(relFile.replace(/\.js$/, '.src.js')));
-              sourceMap = compiler.getSourceMap();
-            }
-            catch(e) {
-              // an error in one compiled file doesn't stop all compilation
-
-              if (!e.stack)
-                compileErrors +=  + '\n';
-              else
-                compileErrors += e.stack + '\n' + relFile + ': Unable to transpile ES Module\n';
-            }
-          })
-
-          // minify
-          .then(function() {
-            if (!options.minify)
-              return;
-
-            var uglify = require('uglify-js');
-
-            try {
-              var ast = uglify.parse(source, { filename: path.basename(relFile.replace(/\.js$/, '.src.js')) });
-
-              ast.figure_out_scope();
-
-              ast = ast.transform(uglify.Compressor({
-                warnings: false,
-                evaluate: false
-              }));
-
-              ast.figure_out_scope();
-              ast.compute_char_frequency();
-              ast.mangle_names({
-                except: ['require']
-              });
-
-              var source_map = uglify.SourceMap({
-                file: path.basename(relFile),
-                orig: sourceMap
-              });
-
-              source = ast.print_to_string({
-                ascii_only: true, // for some reason non-ascii broke esprima
-                comments: function(node, comment) {
-                  return comment.line === 1 && comment.col === 0;
-                },
-                source_map: source_map
-              });
-              sourceMap = source_map.toString();
-            }
-            catch(e) {
-              // an error in one compiled file doesn't stop all compilation
-              compileErrors += relFile + ': Unable to minify file\n';
-            }
-          })
-
-          // finally, if compiled, rename to the new file with source maps
-          .then(function() {
-            if (!options.minify && !options.transpile)
-              return;
-
-            // rename the original with meta changes to .src.js
-            return asp(fs.rename)(file, file.replace(/\.js$/, '.src.js'))
-
-            // write .js as the current source, with a source map comment
-            .then(function() {
-              return asp(fs.writeFile)(file, source + '\n//# sourceMappingURL=' + relFile.split('/').pop() + '.map');
-            })
-
-            // write the source map to .js.map
-            .then(function() {
-              return asp(fs.writeFile)(file + '.map', sourceMap);
-            });
-          });
-        }, function(e) {
-          if (e.code === 'EISDIR')
-            return;
-          else
-            throw e;
-        });
-      }, function(e) {
-        // rethrow an error that wasn't a file read error
-        if (e.code === 'EISDIR')
-          return;
-        else
-          throw e;
-      });
-    }));
-  })
-
-  // output of compile promise is any compile errors
-  .then(function() {
-    return compileErrors;
-  });
-};
Index: node_modules/jspm/lib/bundle.js
===================================================================
--- node_modules/jspm/lib/bundle.js	(revision )
+++ node_modules/jspm/lib/bundle.js	(revision )
@@ -1,248 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-var ui = require('./ui');
-var path = require('path');
-var config = require('./config');
-var SystemJSBuilder = require('systemjs-builder');
-var fs = require('fs');
-var asp = require('rsvp').denodeify;
-var extend = require('./common').extend;
-var alphabetize = require('./common').alphabetize;
-var toFileURL = require('./common').toFileURL;
-
-// jspm version of builder ignores config, baseURL arguments
-// just allows cfg object
-function Builder(_config) {
-  config.loadSync();
-  SystemJSBuilder.call(this, toFileURL(config.pjson.baseURL));
-
-  var cfg = config.loader.getConfig();
-
-  if (cfg.depCache)
-    delete cfg.depCache;
-  if (cfg.bundles)
-    delete cfg.bundles;
-  if (cfg.baseURL)
-    delete cfg.baseURL;
-
-  this.config(cfg, true);
-
-  if (typeof _config == 'object')
-    this.config(_config, true);
-}
-Builder.prototype = Object.create(SystemJSBuilder.prototype);
-
-// extend build functions with jspm 0.16 compatibility options
-Builder.prototype.bundle = function(expressionOrTree, outFile, opts) {
-  if (outFile && typeof outFile === 'object') {
-    opts = outFile;
-    outFile = undefined;
-  }
-
-  opts = opts || {};
-
-  if (outFile)
-    opts.outFile = outFile;
-
-  if (!('normalize' in opts))
-    opts.normalize = true;
-
-  if (!('lowResSourceMaps' in opts))
-    opts.lowResSourceMaps = true;
-
-  var self = this;
-
-  return SystemJSBuilder.prototype.bundle.call(this, expressionOrTree, opts)
-  .then(function(output) {
-
-    // Add the bundle to config if the inject flag was given
-    if (opts.injectConfig && opts.outFile) {
-      // NB deprecate
-      output.bundleName = output.bundleName || self.getCanonicalName(toFileURL(path.resolve(opts.outFile)));
-      var bundleName = output.bundleName;
-
-      if (!config.loader.bundles)
-        config.loader.bundles = {};
-      
-      config.loader.bundles[bundleName] = output.modules;
-      return config.save()
-      .then(function() {
-        return output;
-      });
-    }
-
-    return output;
-  });
-};
-
-Builder.prototype.buildStatic = function(expressionOrTree, outFile, opts) {
-  if (outFile && typeof outFile === 'object') {
-    opts = outFile;
-    outFile = undefined;
-  }
-
-  opts = opts || {};
-
-  if (outFile)
-    opts.outFile = outFile;
-
-  if (!('format' in opts))
-    opts.format = 'global';
-
-  if (!('lowResSourceMaps' in opts))
-    opts.lowResSourceMaps = true;
-
-  return SystemJSBuilder.prototype.buildStatic.call(this, expressionOrTree, opts);
-};
-
-
-exports.Builder = Builder;
-
-exports.depCache = function(expression) {
-  var systemBuilder = new Builder();
-
-  expression = expression || config.loader.main;
-  
-  ui.log('info', 'Injecting the traced dependency tree for `' + expression + '`...');
-
-  return systemBuilder.trace(expression)
-  .then(function(tree) {
-    logTree(tree);
-    var depCache = config.loader.depCache || {};
-    extend(depCache, systemBuilder.getDepCache(tree));
-    config.loader.depCache = depCache;
-  })
-  .then(config.save)
-  .then(function() {
-    ui.log('ok', 'Dependency tree injected');
-  })
-  .catch(function(e) {
-    ui.log('err', e.stack || e);
-  });
-};
-
-// options.inject, options.sourceMaps, options.minify
-exports.bundle = function(moduleExpression, fileName, opts) {
-
-  var systemBuilder = new Builder();
-  
-  opts = opts || {};
-
-  opts.normalize = true;
-
-  fileName = fileName || path.resolve(config.pjson.baseURL, 'build.js');
-
-  return Promise.resolve()
-  .then(function() {
-
-    if (!opts.sourceMaps)
-      return removeExistingSourceMap(fileName);
-  })
-  .then(function() {
-    ui.log('info', 'Building the bundle tree for `' + moduleExpression + '`...');
-
-    return systemBuilder.trace(moduleExpression);
-  })
-  .then(function(buildTree) {
-    logTree(buildTree);
-    return systemBuilder.bundle(buildTree, fileName, opts);
-  })
-  .then(function(output) {
-    if (opts.injectConfig)
-      ui.log('ok', '`' + output.bundleName + '` added to config bundles.');
-
-    logBuild(path.relative(process.cwd(), fileName), opts);
-  })
-  .catch(function(e) {
-    ui.log('err', e.stack || e);
-    throw e;
-  });
-};
-
-exports.unbundle = function() {
-  return config.load()
-  .then(function() {
-    config.loader.bundles = {};
-    config.loader.depCache = {};
-    return config.save();
-  })
-  .then(function() {
-    ui.log('ok', 'Bundle configuration removed.');
-  });
-};
-
-function logBuild(outFile, opts) {
-  var resolution = opts.lowResSourceMaps ? '' : 'high-res ';
-  ui.log('ok', 'Built into `' + outFile + '`' +
-    (opts.sourceMaps ? ' with ' + resolution + 'source maps' : '') + ', ' +
-    (opts.minify ? '' : 'un') + 'minified' +
-    (opts.minify ? (opts.mangle ? ', ' : ', un') + 'mangled.' : '.'));
-}
-
-// options.minify, options.sourceMaps
-exports.bundleSFX = function(expression, fileName, opts) {
-  var systemBuilder = new Builder();
-  
-  opts = opts || {};
-
-  fileName = fileName || path.resolve(config.pjson.baseURL, 'build.js');
-
-  return Promise.resolve()
-  .then(function() {
-    if (!opts.sourceMaps)
-      return removeExistingSourceMap(fileName);
-  })
-  .then(function() {
-    ui.log('info', 'Building the single-file sfx bundle for `' + expression + '`...');
-
-    opts.format = opts.format || 'global';
-
-    return systemBuilder.buildStatic(expression, fileName, opts);
-  })
-  .then(function() {
-    logBuild(path.relative(process.cwd(), fileName), opts);
-  })
-  .catch(function(e) {
-    // catch sfx globals error to give a better error message
-    if (e.toString().indexOf('globalDeps option') != -1) {
-      var module = e.toString().match(/dependency "([^"]+)"/);
-      ui.log('err', 'SFX exclusion "' + module[1] + '" needs a reference.\nEither output an SFX module format like %--format amd% or map the module to an environment global via %--globals "{\'test.js\': \'test\'}"%.');
-      throw 'SFX Bundle input error';
-    }
-
-    ui.log('err', e.stack || e);
-    throw e;
-  });
-};
-
-function logTree(tree) {
-  ui.log('info', '');
-  tree = alphabetize(tree);
-  for (var name in tree) {
-    if (tree[name] && tree[name].metadata && tree[name].metadata.build !== false)
-      ui.log('info', '  `' + name + '`');
-  }
-  ui.log('info', '');
-}
-
-function removeExistingSourceMap(fileName) {
-  return asp(fs.unlink)(fileName + '.map')
-  .catch(function(e) {
-    if (e.code === 'ENOENT')
-      return;
-    throw e;
-  });
-}
Index: node_modules/jspm/lib/common.js
===================================================================
--- node_modules/jspm/lib/common.js	(revision )
+++ node_modules/jspm/lib/common.js	(revision )
@@ -1,173 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-require('core-js/es6/string');
-
-var asp = require('rsvp').denodeify;
-var fs = require('graceful-fs');
-var path = require('path');
-var newLine = require('./config').newLine;
-var tab = require('./config').tab;
-
-exports.toFileURL = function toFileURL(path) {
-  return 'file://' + (process.platform.match(/^win/) ? '/' : '') + path.replace(/\\/g, '/');
-};
-
-exports.fromFileURL = function fromFileURL(path) {
-  return path.substr(process.platform.match(/^win/) ? 8 : 7).replace(path.sep, '/');
-};
-
-// the opposite of extend
-// useful for setting default config
-exports.dprepend = function dprepend(a, b) {
-  for (var p in b) {
-    if (!b.hasOwnProperty(p))
-      continue;
-
-    var val = b[p];
-    if (typeof val === 'object')
-      dprepend(a[p] = typeof a[p] === 'object' ? a[p] : {}, val);
-    else if (!(p in a))
-      a[p] = val;
-  }
-  return a;
-};
-
-exports.extend = function(a, b) {
-  for (var p in b) {
-    if (b.hasOwnProperty(p)) {
-      a[p] = b[p];
-    }
-  }
-  return a;
-};
-
-function dextend(a, b) {
-  for (var p in b) {
-    if (!b.hasOwnProperty(p))
-      continue;
-    var val = b[p];
-    if (typeof val === 'object')
-      dextend(a[p] = typeof a[p] === 'object' ? a[p] : {}, val);
-    else
-      a[p] = val;
-  }
-  return a;
-}
-exports.dextend = dextend;
-
-exports.hasProperties = function(obj) {
-  for (var p in obj) {
-    if (obj.hasOwnProperty(p))
-      return true;
-  }
-  return false;
-};
-
-exports.readJSON = function(file) {
-  return asp(fs.readFile)(file)
-  .then(function(pjson) {
-    pjson = pjson.toString();
-    // remove any byte order mark
-    if (pjson.startsWith('\uFEFF'))
-      pjson = pjson.substr(1);
-    try {
-      return JSON.parse(pjson);
-    }
-    catch(e) {
-      throw 'Error parsing package.json file ' + file;
-    }
-  }, function(err) {
-    if (err.code === 'ENOENT')
-      return {};
-    throw err;
-  });
-};
-
-exports.readJSONSync = function(file) {
-  var pjson;
-  try {
-    pjson = fs.readFileSync(file).toString();
-  }
-  catch(e) {
-    if (e.code === 'ENOENT')
-      pjson = '{}';
-    else
-      throw e;
-  }
-  if (pjson.startsWith('\uFEFF'))
-    pjson = pjson.substr(1);
-  try {
-    return JSON.parse(pjson);
-  }
-  catch(e) {
-    throw 'Error parsing package.json file ' + file;
-  }
-  return pjson;
-};
-
-// given an object, create a new object with the properties ordered alphabetically
-exports.alphabetize = function(obj) {
-  var newObj = {};
-  Object.keys(obj).sort().forEach(function(p) {
-    newObj[p] = obj[p];
-  });
-  return newObj;
-};
-
-exports.getRedirectContents = function(format, main) {
-  if (format === 'es6' || format === 'esm')
-    return 'export * from "' + main + '";\nexport {default} from "' + main + '";';
-
-  else if (format === 'cjs' || format === 'global')
-    return 'module.exports = require("' + main + '");';
-
-  else if (format === 'amd')
-    return 'define(["' + main + '"], function(main) {\n  return main;\n});';
-
-  else if (format === 'register')
-    return 'System.register(["' + main + '"], ' +
-      'function($__export) {\n  return {  setters: [function(m) { for (var p in m) $__export(p, m[p]); }],  execute: function() {}  };\n});';
-
-  else
-    throw 'Unknown module format ' + format + '.';
-};
-
-exports.stringify = function (subject) {
-  return JSON.stringify(subject, null, tab).replace(/\n/g, newLine);
-};
-
-/* Recursively remove directory, all those above it, if they are empty.
- * Takes optional `stopDir` to terminate at. */
-function cascadeDelete(dir, stopDir) {
-  if (dir && dir !== stopDir) {
-    return asp(fs.rmdir)(dir)
-    .catch(function(err) {
-      // just continue if directory does not exist
-      if (err.code !== 'ENOENT')
-        throw err;
-    })
-    .then(function() {
-      return cascadeDelete(path.dirname(dir), stopDir);
-    })
-    .catch(function(err) {
-      // gracefully stop at first non-empty directory
-      if (err.code !== 'ENOTEMPTY')
-        throw err;
-    });
-  }
-}
-
-exports.cascadeDelete = cascadeDelete;
Index: node_modules/jspm/lib/config.js
===================================================================
--- node_modules/jspm/lib/config.js	(revision )
+++ node_modules/jspm/lib/config.js	(revision )
@@ -1,266 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-exports.HOME = process.env.LOCALAPPDATA || process.env.HOME || process.env.HOMEPATH;
-
-// default newline to the appropriate value for the system
-exports.newLine = require('os').EOL;
-exports.tab = '  ';
-
-var ui = require('./ui');
-var fs = require('graceful-fs');
-var path = require('path');
-var PackageConfig = require('./config/package');
-var LoaderConfig = require('./config/loader');
-var mkdirp = require('mkdirp');
-var extend = require('./common').extend;
-var config = module.exports;
-var asp = require('rsvp').denodeify;
-var readJSON = require('./common').readJSON;
-var PackageName = require('./config/package-name');
-
-// given a package.json file and an override
-// calculate the package.json file jspm will see
-exports.derivePackageConfig = function(pjson, override) {
-  var dpjson = extend({}, pjson);
-
-  // first derive the override
-  if (override || pjson.jspm)
-    dpjson.jspm = extend({}, pjson.jspm || {});
-
-  if (override)
-    extend(dpjson.jspm, override);
-
-  // then apply the override
-  if (override || pjson.jspm)
-    extend(dpjson, dpjson.jspm);
-
-  return dpjson;
-};
-
-// package and loader configuration objects that are created
-exports.pjson = null;
-exports.loader = null;
-
-var loadPromise;
-exports.loaded = false;
-exports.load = function(prompts) {
-  if (loadPromise)
-    return loadPromise;
-
-  return (loadPromise = Promise.resolve()
-  .then(function() {
-
-    if (process.env.globalJspm === 'true')
-      ui.log('warn', 'Running jspm globally, it is advisable to locally install jspm via %npm install jspm --save-dev%.');
-
-    if (!process.env.jspmConfigPath)
-      return ui.confirm('Package.json file does not exist, create it?', true)
-      .then(function(create) {
-        if (!create)
-          throw 'Operation aborted.';
-      });
-  })
-  .then(function() {
-    config.pjsonPath = process.env.jspmConfigPath || path.resolve(process.cwd(), 'package.json');
-
-    config.pjson = new PackageConfig(config.pjsonPath);
-    return config.pjson.read(prompts);
-  })
-  .then(function(_prompts) {
-    // package.json can indicate if we need to run config prompts for a new package
-    prompts = prompts || _prompts;
-
-    if (fs.existsSync(config.pjson.configFile))
-      return;
-
-    return ui.confirm('Configuration file %' + path.relative(process.cwd(), config.pjson.configFile) + '% doesn\'t exist, create it?', true)
-    .then(function(create) {
-      if (!create)
-        throw 'Operation aborted.';
-
-      // ensure config folder exists
-      return asp(mkdirp)(path.dirname(config.pjson.configFile));
-    });
-  })
-  .then(function() {
-    config.loader = new LoaderConfig(config.pjson.configFile);
-    return config.loader.read(prompts);
-  })
-  .then(function() {
-    return readJSON(path.resolve(config.pjson.packages, '.dependencies.json'));
-  })
-  .then(function(depsJSON) {
-    config.deps = setSerializedDeps(depsJSON);
-    config.loaded = true;
-  }));
-};
-
-exports.loadSync = function() {
-  if (config.loaded)
-    return;
-  if (loadPromise)
-    throw 'Configuration file is already loading.';
-  config.pjsonPath = process.env.jspmConfigPath || path.resolve(process.cwd(), 'package.json');
-  config.pjson = new PackageConfig(config.pjsonPath);
-  config.pjson.read(false, true);
-
-  if (!fs.existsSync(config.pjson.configFile))
-    throw 'No project configuration file not found. Looking for: ' + config.pjson.configFile;
-
-  config.loader = new LoaderConfig(config.pjson.configFile);
-  config.loader.read(false, true);
-
-  var depsJSON;
-  try {
-    depsJSON = JSON.parse(fs.readFileSync(path.resolve(config.pjson.packages, '.dependencies.json')));
-  }
-  catch(e) {
-    if (e.code == 'ENOENT')
-      depsJSON = {};
-    else
-      throw e;
-  }
-
-  config.deps = setSerializedDeps(depsJSON);
-
-  config.loaded = true;
-  loadPromise = Promise.resolve();
-};
-
-function getSerializedDeps(deps) {
-  var serializedDeps = {};
-  Object.keys(deps).forEach(function(dep) {
-    var depMap = deps[dep];
-    var serializedDepMap = serializedDeps[dep] = {};
-    Object.keys(depMap).forEach(function(dep) {
-      serializedDepMap[dep] = depMap[dep].exactName;
-    });
-  });
-  return serializedDeps;
-}
-function setSerializedDeps(serializedDeps) {
-  var deps = {};
-  Object.keys(serializedDeps).forEach(function(dep) {
-    var depMap = deps[dep] = {};
-    var serializedDepMap = serializedDeps[dep];
-    Object.keys(serializedDepMap).forEach(function(dep) {
-      if (typeof serializedDepMap[dep] == 'string')
-        depMap[dep] = new PackageName(serializedDepMap[dep]);
-    });
-  });
-  return deps;
-}
-
-var savePromise;
-exports.save = function() {
-  if (savePromise)
-    return savePromise.then(exports.save);
-
-  return Promise.resolve()
-  .then(function() {
-    return config.loader.write();
-  })
-  .then(function() {
-    return config.pjson.write();
-  })
-  .then(function() {
-    return asp(mkdirp)(config.pjson.packages);
-  })
-  .then(function() {
-    return asp(fs.writeFile)(path.resolve(config.pjson.packages, '.dependencies.json'), JSON.stringify(getSerializedDeps(config.deps), null, 2));
-  })
-  .then(function() {
-    savePromise = undefined;
-  });
-};
-
-// checks to see if the package.json map config
-// is accurately reflected in the config file
-// - if the config file has a property not in the package.json, we set it in the package.json
-// - if the package.json has a property not in the config, we set it in the config
-// - where there is a conflict, we specifically ask which value to use
-/*
-function checkMapConfig() {
-  var conflictPromises = [];
-
-  if (config.map && hasProperties(config.map)) {
-
-    var depMap;
-
-    return Promise.resolve()
-    .then(function() {
-      if (!config.name)
-        return ui.input('Enter project name to use contextual mappings', 'app')
-        .then(function(name) {
-          config.name = name;
-
-          // if the lib directory is not in package.json, and we've given a name
-          // then the new lib default is the name not 'lib'
-          if (!pjsonCache.directories || !pjsonCache.directories.lib)
-            config.lib = path.resolve(config.dir, config.name);
-        });
-    })
-    .then(function() {
-      depMap = config.depMap[config.name] = config.depMap[config.name] || {};
-    })
-    .then(function() {
-      // check everything in package.json is reflected in config
-      return Promise.all(Object.keys(config.map).map(function(d) {
-        var curMap = config.map[d];
-
-        // ensure package-relative maps are relative and not named
-        if (curMap.startsWith(config.name) && curMap.endsWith('/'))
-          curMap = config.map[d] = '.' + curMap.substr(config.name.length);
-
-        // maps are package-relative
-        if (curMap.startsWith('./'))
-          curMap = config.name + curMap.substr(1);
-
-        if (depMap[d] && depMap[d].exactName !== curMap) {
-          return ui.confirm('The config file has a mapping, `' + d + ' -> ' + depMap[d].exactName
-            + '`, while in the %package.json% this is mapped to `' + curMap + '`. Update the package.json?')
-          .then(function(override) {
-            if (override) {
-              var mapVal = depMap[d].exactName;
-              if (mapVal.startsWith(config.name) && mapVal.endsWith('/'))
-                mapVal = '.' + mapVal.substr(config.name.length);
-              config.map[d] = mapVal;
-            }
-            else {
-              depMap[d] = new PackageName(curMap);
-            }
-          });
-        }
-        else if (!depMap[d]) {
-          depMap[d] = new PackageName(curMap);
-        }
-      }))
-    })
-    .then(function() {
-      // check everything in config is reflected in package.json
-      return Promise.all(Object.keys(depMap).map(function(d) {
-        // we've handled all package.json now
-        if (config.map[d])
-          return;
-
-        config.map[d] = depMap[d].exactName;
-      }));
-    });
-  }
-
-  return Promise.resolve();
-}
-*/
Index: node_modules/jspm/lib/semver.js
===================================================================
--- node_modules/jspm/lib/semver.js	(revision )
+++ node_modules/jspm/lib/semver.js	(revision )
@@ -1,211 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-
-require('core-js/es6/string');
-
-var semverRegEx = /^(\d+)(?:\.(\d+)(?:\.(\d+)(?:-([\da-z-]+(?:\.[\da-z-]+)*)(?:\+([\da-z-]+(?:\.[\da-z-]+)*))?)?)?)?$/i;
-var numRegEx = /^\d+$/;
-
-function toInt(num) {
-  return parseInt(num, 10);
-}
-
-function parseSemver(v) {
-  var semver = v.match(semverRegEx);
-  if (!semver)
-    return {
-      tag: v
-    };
-  else
-    return {
-      major: toInt(semver[1]),
-      minor: toInt(semver[2]),
-      patch: toInt(semver[3]),
-      pre: semver[4] && semver[4].split('.')
-    };
-}
-
-var parts = ['major', 'minor', 'patch'];
-function semverCompareParsed(v1, v2, edge) {
-  // not semvers - tags have equal precedence
-  if (v1.tag && v2.tag)
-    return 0;
-
-  // semver beats non-semver
-  if (v1.tag)
-    return -1;
-  if (v2.tag)
-    return 1;
-
-  // compare version numbers
-  for (var i = 0; i < parts.length; i++) {
-    var part = parts[i];
-    var part1 = v1[part];
-    var part2 = v2[part];
-    if (part1 === part2)
-      continue;
-    if (isNaN(part1))
-      return -1;
-    if (isNaN(part2))
-      return 1;
-    return part1 > part2 ? 1 : -1;
-  }
-
-  if (!v1.pre && !v2.pre)
-    return 0;
-
-  if (!v1.pre)
-    return edge ? 0 : 1;
-  if (!v2.pre)
-    return -1;
-
-  // prerelease comparison
-  for (var j = 0, l = Math.min(v1.pre.length, v2.pre.length); j < l; j++) {
-    if (v1.pre[j] === v2.pre[j])
-      continue;
-
-    var isNum1 = v1.pre[j].match(numRegEx);
-    var isNum2 = v2.pre[j].match(numRegEx);
-
-    // numeric has lower precedence
-    if (isNum1 && !isNum2)
-      return -1;
-    if (isNum2 && !isNum1)
-      return 1;
-
-    // compare parts
-    if (isNum1 && isNum2)
-      return toInt(v1.pre[j]) > toInt(v2.pre[j]) ? 1 : -1;
-    else
-      return v1.pre[j] > v2.pre[j] ? 1 : -1;
-  }
-
-  if (v1.pre.length === v2.pre.length)
-    return 0;
-
-  // more pre-release fields win if equal
-  return v1.pre.length > v2.pre.length ? 1 : -1;
-}
-
-// match against a parsed range object
-// saves operation repetition
-// doesn't support tags
-// if not semver or fuzzy, assume exact
-function matchParsed(range, version, edge) {
-  var rangeVersion = range.version;
-
-  if (rangeVersion.tag)
-    return rangeVersion.tag === version.tag;
-
-  // if the version is less than the range, it's not a match
-  if (semverCompareParsed(rangeVersion, version, edge) === 1)
-    return false;
-
-  // now we just have to check that the version isn't too high for the range
-  if (isNaN(version.minor) || isNaN(version.patch))
-    return false;
-
-  // if the version has a prerelease, ensure the range version has a prerelease in it
-  // and that we match the range version up to the prerelease exactly
-  if (version.pre) {
-    if (!edge &&
-        !(rangeVersion.major === version.major &&
-          rangeVersion.minor === version.minor &&
-          rangeVersion.patch === version.patch))
-      return false;
-    return range.semver || range.fuzzy || rangeVersion.pre && rangeVersion.pre.join('.') === version.pre.join('.');
-  }
-
-  // check semver range
-  if (range.semver) {
-    // ^0
-    if (rangeVersion.major === 0 && isNaN(rangeVersion.minor))
-      return version.major < 1;
-    // ^1..
-    else if (rangeVersion.major >= 1)
-      return rangeVersion.major === version.major;
-    // ^0.1, ^0.2
-    else if (rangeVersion.minor >= 1)
-      return version.major === 0 && rangeVersion.minor === version.minor;
-    // ^0.0.x falls down to exact match below
-  }
-
-  // check fuzzy range (we can assume rangeVersion.minor exists, due to behaviour switch)
-  if (range.fuzzy)
-    return version.major === rangeVersion.major && version.minor <= rangeVersion.minor;
-
-  // exact match
-  // eg 001.002.003 matches 1.2.3
-  return !rangeVersion.pre && rangeVersion.major === version.major && rangeVersion.minor === version.minor && rangeVersion.patch === version.patch;
-}
-
-/*
- * semver       - is this a semver range
- * fuzzy        - is this a fuzzy range
- * version      - the parsed version object
- */
-function parseRange(range) {
-  var rangeObj = {};
-
-  ((rangeObj.semver = range.startsWith('^')) ||
-      (rangeObj.fuzzy = range.startsWith('~'))
-  ) && (range = range.substr(1)); // jshint ignore:line
-
-  var rangeVersion = rangeObj.version = parseSemver(range);
-
-  if (rangeVersion.tag)
-    return rangeObj;
-
-  // 0, 0.1 behave like ~0, ~0.1
-  if (!rangeObj.fuzzy && !rangeObj.semver && (isNaN(rangeVersion.minor) || isNaN(rangeVersion.patch)))
-    rangeObj.fuzzy = true;
-
-  // ~1, ~0 behave like ^1, ^0
-  if (rangeObj.fuzzy && isNaN(rangeVersion.minor)) {
-    rangeObj.semver = true;
-    rangeObj.fuzzy = false;
-  }
-
-  // ^0.0 behaves like ~0.0
-  if (rangeObj.semver && rangeObj.major === 0 && !isNaN(rangeVersion.minor) && isNaN(rangeVersion.patch)) {
-    rangeObj.semver = false;
-    rangeObj.fuzzy = true;
-  }
-
-  return rangeObj;
-}
-
-exports.semverRegEx = semverRegEx;
-
-exports.compare = function(v1, v2) {
-  return semverCompareParsed(parseSemver(v1), parseSemver(v2));
-};
-
-exports.match = function match(range, version) {
-  // supported range types:
-  // 0.2, 1, ~1.2.3, ^1.2.3, ^0.4.3-alpha.1
-  if (range === '' || range === '*')
-    return true;
-  return matchParsed(parseRange(range), parseSemver(version));
-};
-
-exports.matchUnstable = function match(range, version) {
-  // supported range types:
-  // 0.2, 1, ~1.2.3, ^1.2.3, ^0.4.3-alpha.1
-  if (range === '' || range === '*')
-    return true;
-  return matchParsed(parseRange(range), parseSemver(version), true);
-};
Index: node_modules/jspm/lib/install.js
===================================================================
--- node_modules/jspm/lib/install.js	(revision )
+++ node_modules/jspm/lib/install.js	(revision )
@@ -1,1090 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-
-require('core-js/es6/string');
-
-var config = require('./config');
-var Promise = require('rsvp').Promise;
-var asp = require('rsvp').denodeify;
-var pkg = require('./package');
-var semver = require('./semver');
-var PackageName = require('./config/package-name');
-var ui = require('./ui');
-var path = require('path');
-var link = require('./link');
-var globalConfig = require('./global-config');
-
-var rimraf = require('rimraf');
-
-var alphabetize = require('./common').alphabetize;
-var cascadeDelete = require('./common').cascadeDelete;
-var hasProperties = require('./common').hasProperties;
-
-var fs = require('graceful-fs');
-
-var primaryRanges = {};
-var secondaryRanges = {};
-
-var installedResolves = {};
-var installingResolves = {};
-
-var installed;
-var installing = {
-  baseMap: {},
-  depMap: {}
-};
-
-// NB remove assertions for release
-// function assert(statement, name) {
-//  if (!statement)
-//    throw new TypeError('Assertion Failed: ' + name);
-// }
-
-/*
- * Main install API wrapper
- *
- * install('jquery')
- * install('jquery', {options})
- * install('jquery', 'github:components/jquery')
- * install('jquery', 'github:components/jquery', {options})
- * install(true) - from package.json
- * install(true, {options}) - from package.json
- *
- * options.force - skip cache
- * options.inject
- * options.link means symlink linked versions in ranges to jspm_packages where available
- * options.lock - lock existing tree dependencies
- * options.latest - new install tree has all deps installed to latest - no rollback deduping
- * options.unlink
- * options.quick - lock and skip hash checks
- * options.dev - store in devDependencies
- * options.production - only install dependencies, not devDependencies
- * options.update - we're updating the targets
- *
- * options.summary - show fork and resolution summary
- */
-exports.install = function(targets, options) {
-  if (typeof targets === 'string') {
-    var name = targets;
-    targets = {};
-    targets[name] = typeof options === 'string' ? options : '';
-    options = typeof options === 'object' ? options : arguments[2];
-  }
-  options = options || {};
-
-  return config.load()
-  .then(function() {
-    installed = installed || config.loader;
-
-    if (options.force)
-      config.force = true;
-
-    if (options.link || options.quick)
-      options.lock = true;
-
-    var d, existingTargets = {};
-
-    if (!options.production) {
-      for (d in config.pjson.devDependencies)
-        existingTargets[d] = config.pjson.devDependencies[d];
-    }
-
-    for (d in config.pjson.dependencies)
-      existingTargets[d] = config.pjson.dependencies[d];
-
-    if (targets === true)
-      targets = existingTargets;
-    // check and set targets for update
-    else if (targets && options.update)
-      for (d in targets) {
-        if (!existingTargets[d])
-          throw '%' + d + '% is not an existing dependency to update.';
-        targets[d] = existingTargets[d];
-      }
-
-    targets = pkg.processDeps(targets, globalConfig.config.defaultRegistry);
-
-    return Promise.all(Object.keys(targets).map(function(name) {
-      return install(name, targets[name], options);
-    }))
-    .then(function() {
-      return saveInstall();
-    })
-    .then(function() {
-      // after every install, show fork and resolution summary
-      if (options.summary !== false)
-        showVersions(true);
-    });
-  });
-};
-
-/*
- * install('jquery', 'jquery', { latest, lock, parent, inject, link, unlink, override } [, seen])
- *
- * Install modes:
- *  - Default  a. The new install tree is set to use exact latest versions of primaries,
- *                including for existing primaries.
- *                Secondaries tend to their latest ideal version.
- *             b. Forks within the new tree are deduped for secondaries by checking for
- *                rollback of the higher version.
- *             c. Forks against the existing tree are handled by upgrading the existing
- *                tree, at both primary and secondary levels, with the secondary fork
- *                potentially rolling back as well.
- *             (this is `jspm install package`)
- *
- *  - Lock     No existing dependencies are altered.
- *             New installs otherwise follow default behaviour for secondary deduping.
- *             (this is reproducible installs, `jspm install` without arguments)
- *
- *  - Latest   Secondaries set exactly to latest.
- *             Forks against existing tree follow default behaviour.
- *             (this is `jspm update`)
- *
- * Lock and Latest can be combined, which won't do anything for existing
- * installs but will give latest secondaries on new installs.
- *
- * Secondary installs are those with a parent.
- *
- * Seen allows correct completion with circular package installs
- *
- */
-
-/*
- * jspm.install('jquery')
- * jspm.install('jquery', 'github:components/jquery@^2.0.0')
- * jspm.install('jquery', '2')
- * jspm.install('jquery', 'github:components/jquery')
- * jspm.install('jquery', { force: true });
- * jspm.install({ jquery: '1.2.3' }, { force: true })
- */
-function install(name, target, options, seen) {
-  // we install a target range, to an exact version resolution
-  var resolution;
-  var dependencyDownloads;
-  var existing;
-
-  return Promise.resolve()
-  .then(function() {
-    if (options.link)
-      return Promise.resolve(target);
-
-    return pkg.locate(target);
-  })
-  .then(function(located) {
-    target = located;
-
-    config.loader.ensureRegistry(located.registry, options.inject);
-
-    if (options.link)
-      return link.lookup(target, options.edge);
-
-    // lock if necessary
-    if (options.lock && (resolution = getInstalledMatch(target, options.parent, name)))
-      return Promise.resolve();
-
-    // perform a full version lookup
-    return pkg.lookup(target, options.edge);
-  })
-  .then(function(getLatestMatch) {
-    if (!getLatestMatch)
-      return storeResolution();
-
-    // --- version constraint solving ---
-
-    // a. The new install tree is set to use exact latest versions of primaries, including for existing primaries.
-    //    Secondaries tend to their latest ideal version.
-    resolution = getLatestMatch(target.version);
-
-    if (!resolution) {
-      if (options.parent)
-        throw 'Installing `' + options.parent + '`, no version match for `' + target.exactName + '`';
-      else
-        throw 'No version match found for `' + target.exactName + '`';
-    }
-
-    // if no version range was specified on install, install to semver-compatible with the latest
-    if (!options.parent && !target.version && !options.link) {
-      if (resolution.version.match(semver.semverRegEx))
-        target.setVersion('^' + resolution.version);
-      else
-        target.setVersion(resolution.version);
-    }
-    else if (options.edge && !options.parent && !options.link) {
-      // use strictest compatible semver range if installing --edge without target, or
-      // with a range that does not include the resolved version
-      if (!target.version || !semver.match(target.version, resolution.version)) {
-        target.setVersion('^' + resolution.version);
-      }
-    }
-
-    // load our fork ranges to do a resolution
-    return loadExistingForkRanges(resolution, name, options.parent, options.inject)
-    .then(function() {
-      // here, alter means upgrade or rollback
-
-      // if we've consolidated with another resolution, we don't do altering
-      var consolidated = false;
-
-      // b. Forks within the new tree are deduped for secondaries by checking for rollback of the higher version
-      if (!options.latest)
-        resolveForks(installing, name, options.parent, resolution, function(forkVersion, forkRanges, allSecondary) {
-          // alter the other secondaries to this primary or secondary
-          if (allSecondary && forkRanges.every(function(forkRange) {
-            return semver.match(forkRange, resolution.version);
-          })) {
-            consolidated = true;
-            return resolution.version;
-          }
-
-          // alter this secondary install to the other primary or secondary
-          if (!consolidated && options.parent && semver.match(target.version, forkVersion)) {
-            consolidated = true;
-            if (forkVersion !== resolution.version) {
-              var newResolution = resolution.copy().setVersion(forkVersion);
-              logResolution(installingResolves, resolution, newResolution);
-              resolution = newResolution;
-            }
-          }
-        });
-
-      // c. Forks against the existing tree are handled by upgrading the existing tree,
-      //    at both primary and secondary levels, with the secondary fork potentially rolling back as well.
-      resolveForks(installed, name, options.parent, resolution, function(forkVersion, forkRanges) {
-        if (options.latest && semver.compare(forkVersion, resolution.version) === 1)
-          return;
-
-        if (forkRanges.every(function(forkRange) {
-          return semver.match(forkRange, resolution.version);
-        })) {
-          consolidated = true;
-          return resolution.version;
-        }
-
-        // find the best upgrade of all the fork ranges for rollback of secondaries
-        if (!consolidated && options.parent && !options.latest) {
-          var bestSecondaryRollback = resolution;
-          forkRanges.forEach(function(forkRange) {
-            var forkLatest = getLatestMatch(forkRange);
-            if (semver.compare(bestSecondaryRollback.version, forkLatest.version) === 1)
-              bestSecondaryRollback = forkLatest;
-          });
-
-          if (semver.compare(bestSecondaryRollback.version, forkVersion) === -1)
-            bestSecondaryRollback = getLatestMatch(forkVersion);
-
-          if (semver.match(target.version, bestSecondaryRollback.version)) {
-            consolidated = true;
-            logResolution(installingResolves, resolution, bestSecondaryRollback);
-            resolution = bestSecondaryRollback;
-            return bestSecondaryRollback.version;
-          }
-        }
-      });
-
-      // solve and save resolution solution synchronously - this lock avoids solution conflicts
-      storeResolution();
-    });
-  })
-  .then(function() {
-
-    // -- handle circular installs --
-
-    seen = seen || [];
-    if (seen.indexOf(resolution.exactName) !== -1)
-      return;
-    seen.push(resolution.exactName);
-
-    // allow custom resolutions
-    if (!resolution.registry)
-      return;
-
-    // -- download --
-    return Promise.resolve()
-    .then(function() {
-      if (options.link)
-        return link.symlink(resolution, downloadDeps);
-
-      if (options.inject)
-        return pkg.inject(resolution, downloadDeps);
-
-      // override, quick, unlink options passed
-      return pkg.download(resolution, options, downloadDeps);
-    })
-    .then(function(fresh) {
-      resolution.fresh = fresh;
-      // log sub-dependencies before child completion for nicer output
-      if (options.parent)
-        logInstall(name, target, resolution, options);
-
-      return dependencyDownloads;
-    })
-    .then(function() {
-      if (!options.parent)
-        logInstall(name, target, resolution, options);
-    });
-  });
-
-  // store resolution in config
-  function storeResolution() {
-    var curMap;
-    if (options.parent) {
-      curMap = (existing ? installed : installing).depMap;
-      curMap[options.parent] = curMap[options.parent] || {};
-      curMap[options.parent][name] = resolution.copy();
-    }
-    else {
-      curMap = (existing ? installed : installing).baseMap;
-      curMap[name] = resolution.copy();
-    }
-
-    // update the dependency range tree
-    if (!options.parent) {
-      if (!primaryRanges[name] || primaryRanges[name].exactName !== target.exactName)
-        primaryRanges[name] = target.copy();
-      // store in package.json
-      if (!options.link) {
-        if (name in config.pjson.dependencies)
-          config.pjson.dependencies[name] = primaryRanges[name];
-        else if (name in config.pjson.devDependencies)
-          config.pjson.devDependencies[name] = primaryRanges[name];
-        else if (!options.dev) {
-          config.pjson.dependencies[name] = primaryRanges[name];
-        }
-        else {
-          config.pjson.devDependencies[name] = primaryRanges[name];
-        }
-
-        if (options.override)
-          config.pjson.overrides[resolution.exactName] = options.override;
-      }
-    }
-    else {
-      // update the secondary ranges
-      secondaryRanges[options.parent] = secondaryRanges[options.parent] || {};
-      if (!secondaryRanges[options.parent][name])
-        secondaryRanges[options.parent][name] = target.copy();
-      else
-        if (secondaryRanges[options.parent][name] && secondaryRanges[options.parent][name].exactName !== target.exactName)
-          ui.log('warn', 'Currently installed dependency ranges of `' + options.parent + '` are not consistent ( %' + secondaryRanges[options.parent][name].exactName + '% should be %' + target.exactName + '%)');
-    }
-  }
-
-  // trigger dependency downloads
-  // this can be triggered twice
-  //  - once by initial preload, and once post-build if additional dependencies are discovered
-  function downloadDeps(depMap) {
-    // clear existing dependencies on first run for existing installs
-    if (!dependencyDownloads && existing)
-      installed.depMap[resolution.exactName] = {};
-
-    dependencyDownloads = (dependencyDownloads || Promise.resolve()).then(function() {
-      return Promise.all(Object.keys(depMap).map(function(dep) {
-        return install(dep, depMap[dep], {
-          latest: options.latest,
-          lock: options.lock,
-          parent: resolution.exactName,
-          inject: options.inject,
-          quick: options.quick
-        }, seen);
-      }));
-    });
-  }
-}
-
-function getInstalledMatch(target, parent, name) {
-  // use the config lock if provided
-  if (parent) {
-    if (installed.depMap[parent] && installed.depMap[parent][name])
-      return installed.depMap[parent][name];
-  }
-  else {
-    if (installed.baseMap[name])
-      return installed.baseMap[name];
-  }
-
-  // otherwise seek an installed match
-  var match;
-  function checkMatch(pkg) {
-    if (pkg.name !== target.name)
-      return;
-    if (semver.match(target.version, pkg.version)) {
-      if (!match || match && semver.compare(pkg.version, match.version) === 1)
-        match = pkg.copy();
-    }
-  }
-  Object.keys(installed.baseMap).forEach(function(name) {
-    checkMatch(installed.baseMap[name]);
-  });
-  Object.keys(installed.depMap).forEach(function(parent) {
-    var depMap = installed.depMap[parent];
-    Object.keys(depMap).forEach(function(name) {
-      checkMatch(depMap[name]);
-    });
-  });
-  return match;
-}
-
-function saveInstall() {
-  return Promise.resolve()
-  .then(function() {
-
-    // merge the installing tree into the installed
-    Object.keys(installing.baseMap).forEach(function(p) {
-      installed.baseMap[p] = installing.baseMap[p];
-    });
-
-    Object.keys(installing.depMap).forEach(function(p) {
-      installed.depMap[p] = installing.depMap[p];
-    });
-
-    return clean();
-  })
-  .then(function() {
-    if (hasProperties(installedResolves)) {
-      ui.log('');
-      ui.log('info', 'The following existing package versions were altered by install deduping:');
-      ui.log('');
-      Object.keys(installedResolves).forEach(function(pkg) {
-        var pkgName = new PackageName(pkg);
-        ui.log('info', '  %' + pkgName.package + '% ' + getUpdateRangeText(pkgName, new PackageName(installedResolves[pkg])));
-      });
-      ui.log('');
-      installedResolves = {};
-      ui.log('info', 'To keep existing dependencies locked during install, use the %--lock% option.');
-    }
-
-    if (hasProperties(installingResolves)) {
-      ui.log('');
-      ui.log('info', 'The following new package versions were substituted by install deduping:');
-      ui.log('');
-      Object.keys(installingResolves).forEach(function(pkg) {
-        var pkgName = new PackageName(pkg);
-        ui.log('info', '  %' + pkgName.package + '% ' + getUpdateRangeText(pkgName, new PackageName(installingResolves[pkg])));
-      });
-      ui.log('') ;
-      installingResolves = {};
-    }
-
-    // then save
-    return config.save();
-  });
-}
-
-var logged = {};
-function logInstall(name, target, resolution, options) {
-  if (logged[target.exactName + '=' + resolution.exactName])
-    return;
-
-  // don't log secondary fresh
-  if (options.parent && resolution.fresh)
-    return;
-
-  logged[target.exactName + '=' + resolution.exactName] = true;
-
-  var verb;
-  if (options.inject)
-    verb = 'Injected';
-
-  else if (!resolution.fresh) {
-    if (!options.link)
-      verb = 'Installed';
-    else
-      verb = 'Linked';
-  }
-  else {
-    if (options.quick)
-      return;
-    if (!options.link)
-      verb = 'Up to date -';
-    else
-      verb = 'Already linked -';
-  }
-
-  if (options.parent)
-    ui.log('ok', verb + ' `' + target.exactName + '` (' + resolution.version + ')');
-  else
-    ui.log('ok', verb + ' %' + name + '% as `' + target.exactName + '` (' + resolution.version + ')');
-}
-
-function getUpdateRangeText(existing, update) {
-  if (existing.name === update.name)
-    return '`' + existing.version + '` -> `' + update.version + '`';
-  else
-    return '`' + existing.exactName + '` -> `' + update.exactName + '`';
-}
-
-// go through the baseMap and depMap, changing FROM to TO
-// keep a log of what we did in resolveLog
-function doResolution(tree, from, to) {
-  if (from.exactName === to.exactName)
-    return;
-
-  // add this to the resolve log, including deep-updating resolution chains
-  logResolution(tree === installed ? installedResolves : installingResolves, from, to);
-
-  Object.keys(tree.baseMap).forEach(function(dep) {
-    if (tree.baseMap[dep].exactName === from.exactName)
-      tree.baseMap[dep] = to.copy();
-  });
-
-  Object.keys(tree.depMap).forEach(function(parent) {
-    var curMap = tree.depMap[parent];
-    Object.keys(curMap).forEach(function(dep) {
-      if (curMap[dep].exactName === from.exactName)
-        curMap[dep] = to.copy();
-    });
-  });
-}
-
-function logResolution(resolveLog, from, to) {
-  resolveLog[from.exactName] = to.exactName;
-
-  Object.keys(resolveLog).forEach(function(resolveFrom) {
-    if (resolveLog[resolveFrom] === from.exactName)
-      resolveLog[resolveFrom] = to.exactName;
-  });
-}
-
-// name and parentName are the existing resolution target
-// so we only look up forks and not the original as well
-function loadExistingForkRanges(resolution, name, parentName, inject) {
-  var tree = installed;
-  return Promise.all(Object.keys(tree.baseMap).map(function(dep) {
-    if (!parentName && dep === name)
-      return;
-
-    var primary = tree.baseMap[dep];
-    if (primary.name !== resolution.name)
-      return;
-
-    return loadExistingRange(dep, null, inject);
-  }))
-  .then(function() {
-    return Promise.all(Object.keys(tree.depMap).map(function(parent) {
-      var curDepMap = tree.depMap[parent];
-
-      return Promise.all(Object.keys(curDepMap).map(function(dep) {
-        if (parent === parentName && dep === name)
-          return;
-
-        var secondary = curDepMap[dep];
-
-        if (secondary.name !== resolution.name)
-          return;
-
-        return loadExistingRange(dep, parent, inject);
-      }));
-    }));
-  });
-}
-
-function visitForkRanges(tree, resolution, name, parentName, visit) {
-  // now that we've got all the version ranges we need for consideration,
-  // go through and run resolutions against the fork list
-  Object.keys(tree.baseMap).forEach(function(dep) {
-    var primary = tree.baseMap[dep];
-    if (primary.name !== resolution.name)
-      return;
-
-    visit(dep, null, primary, primaryRanges[dep]);
-  });
-
-  Object.keys(tree.depMap).forEach(function(parent) {
-    var curDepMap = tree.depMap[parent];
-
-    Object.keys(curDepMap).forEach(function(dep) {
-      var secondary = curDepMap[dep];
-
-      if (secondary.name !== resolution.name)
-        return;
-
-      // its not a fork of itself
-      if (dep === name && parent === parentName)
-        return;
-
-      // skip if we don't have a range
-      if (!secondaryRanges[parent])
-        return;
-
-      visit(dep, parent, secondary, secondaryRanges[parent][dep]);
-    });
-  });
-}
-
-// find all forks of this resolution in the tree
-// calling resolve(forkVersion, forkRanges, allSecondary)
-// for each unique fork version
-// sync resolution to avoid conflicts
-function resolveForks(tree, name, parentName, resolution, resolve) {
-  // forks is a map from fork versions to an object, { ranges, hasPrimary }
-  // hasPrimary indicates whether any of these ranges are primary ranges
-  var forks = {};
-  var forkVersions = [];
-
-  visitForkRanges(tree, resolution, name, parentName, function(dep, parent, resolved, range) {
-    if (!range)
-      return;
-
-    // we only work with stuff within it's own matching range
-    // not user overrides
-    if (range.name !== resolved.name || !semver.match(range.version, resolved.version))
-      return;
-
-    var forkObj = forks[resolved.version];
-    if (!forkObj) {
-      forkObj = forks[resolved.version] = { ranges: [], allSecondary: true };
-      forkVersions.push(resolved.version);
-    }
-
-    if (!parent)
-      forkObj.allSecondary = false;
-
-    forkObj.ranges.push(range.version);
-  });
-
-  // now run through and resolve the forks
-  forkVersions.sort(semver.compare).reverse().forEach(function(forkVersion) {
-    var forkObj = forks[forkVersion];
-
-    var newVersion = resolve(forkVersion, forkObj.ranges, forkObj.allSecondary);
-    if (!newVersion || newVersion === forkVersion)
-      return;
-
-    var from = resolution.copy().setVersion(forkVersion);
-    var to = resolution.copy().setVersion(newVersion);
-
-    doResolution(tree, from, to);
-  });
-}
-
-var secondaryDepsPromises = {};
-function loadExistingRange(name, parent, inject) {
-  if (parent && secondaryRanges[parent] && secondaryRanges[parent][name])
-    return;
-  else if (!parent && primaryRanges[name])
-    return;
-
-  var _target;
-
-  return Promise.resolve()
-  .then(function() {
-    if (!parent)
-      return config.pjson.dependencies[name] || config.pjson.devDependencies[name];
-
-    return Promise.resolve()
-    .then(function() {
-      if (secondaryDepsPromises[parent])
-        return secondaryDepsPromises[parent];
-
-      return Promise.resolve()
-      .then(function() {
-        var parentPkg = new PackageName(parent);
-
-        // if the package is installed but not in jspm_packages
-        // then we wait on the getPackageConfig or download of the package here
-        return (secondaryDepsPromises[parent] = new Promise(function(resolve, reject) {
-          if (inject)
-            return pkg.inject(parentPkg, resolve).catch(reject);
-
-          if (config.deps[parentPkg.exactName])
-            return resolve();
-
-          pkg.download(parentPkg, {}, resolve).then(resolve, reject);
-        })
-        .then(function(depMap) {
-          if (depMap)
-            return depMap;
-
-          return config.deps[new PackageName(parent).exactName];
-        }));
-      });
-    })
-    .then(function(deps) {
-      return deps[name];
-    });
-  })
-  .then(function(target) {
-    if (!target) {
-      if (parent && installed.depMap[parent] && installed.depMap[parent].name) {
-        delete installed.depMap[parent].name;
-        ui.log('warn', '%' + parent + '% dependency %' + name + '% was removed from the config file to reflect the installed package.');
-      }
-      else if (!parent) {
-        ui.log('warn', '%' + name + '% is installed in the config file, but is not a dependency in the package.json. It is advisable to add it to the package.json file.');
-      }
-      return;
-    }
-
-    _target = target.copy();
-    // locate the target
-    return pkg.locate(_target)
-    .then(function(located) {
-      if (parent) {
-        secondaryRanges[parent] = secondaryRanges[parent] || {};
-        secondaryRanges[parent][name] = located;
-      }
-      else {
-        primaryRanges[name] = located;
-      }
-    });
-  });
-}
-
-
-// given an exact package, find all the forks, and display the ranges
-function showInstallGraph(pkg) {
-  installed = installed || config.loader;
-  pkg = new PackageName(pkg);
-  var lastParent;
-  var found;
-  return loadExistingForkRanges(pkg, config.loader.local)
-  .then(function() {
-    ui.log('info', '\nInstalled versions of %' + pkg.name + '%');
-    visitForkRanges(installed, pkg, null, null, function(name, parent, resolved, range) {
-      found = true;
-      if (range.version === '')
-        range.version = '*';
-      var rangeVersion = range.name === resolved.name ? range.version : range.exactName;
-      if (range.version === '*')
-        range.version = '';
-
-      if (!parent)
-        ui.log('info', '\n       %' + name + '% `' + resolved.version + '` (' + rangeVersion + ')');
-      else {
-        if (lastParent !== parent) {
-          ui.log('info', '\n  ' + parent);
-          lastParent = parent;
-        }
-        ui.log('info', '    ' + name + ' `' + resolved.version + '` (' + rangeVersion + ')');
-      }
-    });
-    if (!found)
-      ui.log('warn', 'Package `' + pkg.name + '` not found.');
-    ui.log('');
-  });
-}
-exports.showInstallGraph = showInstallGraph;
-
-
-function showVersions(forks) {
-  installed = installed || config.loader;
-
-  var versions = {};
-  var haveLinked = false;
-  var linkedVersions = {};
-
-  function addDep(dep) {
-    var vList = versions[dep.name] = versions[dep.name] || [];
-    var version = dep.version;
-    try {
-      if (fs.readlinkSync(dep.getPath()))
-        linkedVersions[dep.exactName] = true;
-    }
-    catch(e) {}
-    if (vList.indexOf(version) === -1)
-      vList.push(version);
-  }
-
-  Object.keys(installed.baseMap).forEach(function(dep) {
-    addDep(installed.baseMap[dep]);
-  });
-  Object.keys(installed.depMap).forEach(function(parent) {
-    var curMap = installed.depMap[parent];
-    Object.keys(curMap).forEach(function(dep) {
-      addDep(curMap[dep]);
-    });
-  });
-
-  versions = alphabetize(versions);
-
-  var vLen = Object.keys(versions).map(function(dep) {
-    return dep.length;
-  }).reduce(function(a, b) {
-    return Math.max(a, b);
-  }, 0);
-
-  var shownIntro = false;
-
-  Object.keys(versions).forEach(function(dep) {
-    var vList = versions[dep].sort(semver.compare).map(function(version) {
-      if (linkedVersions[dep + '@' + version]) {
-        haveLinked = true;
-        return '%' + version + '%';
-      }
-      else
-        return '`' + version + '`';
-    });
-
-    if (forks && vList.length === 1)
-      return;
-
-    if (!shownIntro) {
-      ui.log('info', 'Installed ' + (forks ? 'Forks' : 'Versions') + '\n');
-      shownIntro = true;
-    }
-
-    var padding = vLen - dep.length;
-    var paddingString = '';
-    while(padding--)
-      paddingString += ' ';
-
-    ui.log('info', '  ' + paddingString + '%' + dep + '% ' + vList.join(' '));
-  });
-
-  if (haveLinked) {
-    ui.log('info', '\nBold versions are linked. To unlink use %jspm install --unlink [name]%.');
-  }
-  if (shownIntro) {
-    ui.log('info', '\nTo inspect individual package constraints, use %jspm inspect registry:name%.\n');
-  }
-  else if (forks) {
-    ui.log('ok', 'Install tree has no forks.');
-  }
-}
-exports.showVersions = showVersions;
-
-/*
- * Configuration cleaning
- *
- * 1. Construct list of all packages in main tree tracing from package.json primary installs
- * 2. Remove all orphaned dependencies not in this list
- * 3. Remove any package.json overrides that will never match this list
- * 4. Remove packages in .dependencies.json that aren't used at all
- * 5. Remove anything from jspm_packages not in this list
- *
- */
-function clean() {
-  var packageList = [];
-
-  return config.load()
-  .then(function() {
-
-    // 1. getDependentPackages for each of baseMap
-    Object.keys(config.loader.baseMap).forEach(function(dep) {
-      getDependentPackages(config.loader.baseMap[dep].exactName, packageList);
-    });
-
-    // 2. now that we have the package list, remove everything not in it
-    Object.keys(config.loader.depMap).forEach(function(dep) {
-      if (packageList.indexOf(dep) === -1) {
-        ui.log('info', 'Clearing configuration for `' + dep + '`');
-        delete config.loader.depMap[dep];
-      }
-    });
-
-    // 3. remove package.json overrides which will never match any packages
-    var usedOverrides = [];
-    packageList.forEach(function(pkgName) {
-      var pkgVersion = pkgName.split('@').pop();
-      pkgName = pkgName.substr(0, pkgName.length - pkgVersion.length - 1);
-
-      var overrideVersion = Object.keys(config.pjson.overrides)
-      .filter(function(overrideName) {
-        return overrideName.startsWith(pkgName + '@');
-      })
-      .map(function(overrideName) {
-        return overrideName.split('@').pop();
-      })
-      .filter(function(overrideVersion) {
-        return semver.match('^' + overrideVersion, pkgVersion);
-      })
-      .sort(semver.compare).pop();
-      if (overrideVersion)
-        usedOverrides.push(pkgName + '@' + overrideVersion);
-    });
-    Object.keys(config.pjson.overrides).forEach(function(overrideName) {
-      if (usedOverrides.indexOf(overrideName) == -1) {
-        ui.log('info', 'Removing unused package.json override `' + overrideName + '`');
-        delete config.pjson.overrides[overrideName];
-      }
-    });
-  })
-
-  .then(function() {
-    return asp(fs.lstat)(config.pjson.packages)
-    .catch(function(e) {
-      if (e.code == 'ENOENT')
-        return;
-      throw e;
-    }).then(function(stats) {
-      // Skip if jspm_packages is symlinked or not existing
-      if (!stats || stats.isSymbolicLink())
-        return;
-
-      // 4. Remove packages in .dependencies.json that aren't used at all
-      Object.keys(config.deps).forEach(function(dep) {
-        if (packageList.indexOf(dep) == -1)
-          delete config.deps[dep];
-      });
-
-      // 5. Remove anything from jspm_packages not in this list
-      return readDirWithDepth(config.pjson.packages, function(dirname) {
-        if (dirname.split(path.sep).pop().indexOf('@') <= 0)
-          return true;
-      })
-      .then(function(packageDirs) {
-        return Promise.all(
-        packageDirs
-        .filter(function(dir) {
-          var exactName = path.relative(config.pjson.packages, dir).replace(path.sep, ':').replace(/\\/g, '/'); // (win)
-          var remove = packageList.indexOf(exactName) === -1;
-          if (remove)
-            ui.log('info', 'Removing package files for `' + exactName + '`');
-          return remove;
-        })
-        .map(function(dir) {
-          return asp(rimraf)(dir)
-          .then(function() {
-            var filename = dir + '.js';
-            return new Promise(function(resolve) {
-              fs.exists(filename, resolve);
-            }).then(function(exists) {
-              if (exists) return asp(fs.unlink)(filename);
-            });
-          })
-          .then(function() {
-            return cascadeDelete(dir);
-          });
-        }));
-      });
-    });
-  })
-
-  .then(function() {
-    return config.save();
-  });
-}
-exports.clean = clean;
-
-// depthCheck returns true to keep going (files being ignored), false to add the dir to the flat list
-function readDirWithDepth(dir, depthCheck) {
-  var flatDirs = [];
-  return asp(fs.readdir)(dir)
-  .then(function(files) {
-    if (!files)
-      return [];
-    return Promise.all(files.map(function(file) {
-      var filepath = path.resolve(dir, file);
-
-      // ensure it is a directory
-      return asp(fs.lstat)(filepath)
-      .then(function(fileInfo) {
-        if (!fileInfo.isDirectory())
-          return;
-
-        if (!depthCheck(filepath))
-          return flatDirs.push(filepath);
-
-        // keep going
-        return readDirWithDepth(filepath, depthCheck)
-        .then(function(items) {
-          items.forEach(function(item) {
-            flatDirs.push(item);
-          });
-        });
-      });
-    }));
-  })
-  .then(function() {
-    return flatDirs;
-  });
-}
-
-
-function getDependentPackages(pkg, packages) {
-  packages.push(pkg);
-  // get all immediate children of this package
-  // for those children not already seen (in packages list),
-  // run getDependentPackages in turn on those
-  var depMap = config.loader.depMap[pkg];
-  if (!depMap)
-    return;
-  Object.keys(depMap).forEach(function(dep) {
-    var curPkg = depMap[dep].exactName;
-    if (packages.indexOf(curPkg) !== -1)
-      return;
-    getDependentPackages(curPkg, packages);
-  });
-
-  return packages;
-}
-
-exports.uninstall = function(names) {
-  if (!(names instanceof Array))
-    names = [names];
-
-  return config.load()
-  .then(function() {
-    installed = installed || config.loader;
-
-    names.forEach(function(name) {
-      if (!config.pjson.dependencies[name] && !config.pjson.devDependencies[name])
-        ui.log('warn', 'Dependency %' + name + '% is not an existing primary install.');
-
-      delete config.pjson.dependencies[name];
-      delete config.pjson.devDependencies[name];
-      delete installed.baseMap[name];
-    });
-
-    return clean();
-  });
-};
-
-/*
- * Resolve all installs of the given package to a specific version
- */
-exports.resolveOnly = function(pkg) {
-  pkg = new PackageName(pkg);
-
-  if (!pkg.version || !pkg.registry) {
-    ui.log('warn', 'Resolve --only must take an exact package of the form `registry:pkg@version`.');
-    return Promise.reject();
-  }
-
-  var didSomething = false;
-
-  return config.load()
-  .then(function() {
-    Object.keys(config.loader.baseMap).forEach(function(name) {
-      var curPkg = config.loader.baseMap[name];
-      if (curPkg.registry === pkg.registry && curPkg.package === pkg.package && curPkg.version !== pkg.version) {
-        didSomething = true;
-        ui.log('info', 'Primary install ' + getUpdateRangeText(curPkg, pkg));
-        config.loader.baseMap[name] = pkg.copy();
-      }
-    });
-
-    Object.keys(config.loader.depMap).forEach(function(parent) {
-      var curMap = config.loader.depMap[parent];
-      Object.keys(curMap).forEach(function(name) {
-        var curPkg = curMap[name];
-        if (curPkg.registry === pkg.registry && curPkg.package === pkg.package && curPkg.version !== pkg.version) {
-          didSomething = true;
-          ui.log('info', 'In %' + parent + '% ' + getUpdateRangeText(curPkg, pkg));
-          curMap[name] = pkg.copy();
-        }
-      });
-    });
-
-    return config.save();
-  })
-  .then(function() {
-    if (didSomething)
-      ui.log('ok', 'Resolution to only use `' + pkg.exactName + '` completed successfully.');
-    else
-      ui.log('ok', '`' + pkg.exactName + '` is already the only version of the package in use.');
-  });
-};
Index: node_modules/jspm/lib/package.js
===================================================================
--- node_modules/jspm/lib/package.js	(revision )
+++ node_modules/jspm/lib/package.js	(revision )
@@ -1,847 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-
-require('core-js/es6/string');
-
-var request = require('request');
-var ui = require('./ui');
-var semver = require('./semver');
-var Promise = require('rsvp').Promise;
-var asp = require('rsvp').denodeify;
-var build = require('./build');
-var config = require('./config');
-var mkdirp = require('mkdirp');
-var rimraf = require('rimraf');
-var path = require('path');
-var registry = require('./registry');
-var PackageName = require('./config/package-name');
-var globalConfig = require('./global-config');
-var readJSON = require('./common').readJSON;
-var getRedirectContents = require('./common').getRedirectContents;
-var ncp = require('ncp');
-var crypto = require('crypto');
-var fs = require('graceful-fs');
-
-var jspmVersion = require('../package.json').version.split('.').splice(0, 2).join('.');
-
-// we cache registry lookups here to allow reductions in config saving
-var registryCache = exports.registryCache = {};
-
-function md5(input) {
-  var md5Hash = crypto.createHash('md5');
-  md5Hash.update(input);
-  return md5Hash.digest('hex');
-}
-
-var _pkg = module.exports;
-
-// given a name like 'jquery', 'github:repo/thatwasmoved'
-// add the default registry endpoint to the name
-// so we now have 'jspm:jquery', 'github:repo/thatwasmoved'
-// then run the locate hook (if provided) of the registry
-// following redirects until the locate hook converges
-// getting 'github:components/jquery' and 'github:repo/redirected'
-// at this point, we have the final name for the target
-var locateCache = {};
-// target is a PackageName object
-exports.locate = function(target) {
-  if (!target.registry) {
-    target = new PackageName(target.exactName);
-    target.setRegistry(globalConfig.config.defaultRegistry);
-  }
-
-  var endpoint = registry.load(target.registry);
-
-  if (!endpoint.locate)
-    return Promise.resolve(target);
-
-  locateCache[target.registry] = locateCache[target.registry] || {};
-
-  // NB enable versioned locate
-  return Promise.resolve()
-  .then(function() {
-    if (locateCache[target.registry][target.package])
-      return locateCache[target.registry][target.package];
-
-    return (locateCache[target.registry][target.package] = Promise.resolve(endpoint.locate(target.package))
-    .then(function(located) {
-      // NB support versioned registry
-      if (target.registry === globalConfig.config.defaultRegistry)
-        registryCache[target.package] = located.redirect;
-      return located;
-    }));
-  })
-  .then(function(located) {
-    if (!located)
-      return target;
-
-    if (located.redirect) {
-      var newTarget = new PackageName(located.redirect);
-      newTarget.setVersion(target.version);
-      return _pkg.locate(newTarget);
-    }
-
-    if (located.notfound)
-      throw 'Repo `' + target.name + '` not found.' +
-        (target.registry != 'npm' && target.package.split('/').length == 1 ? ' Perhaps try %jspm install npm:' + target.package + '%.' : '');
-
-    throw 'Invalid registry locate response for %' + target.registry + '%';
-  }, function() {
-    throw 'Error locating `' + target.name + '`.';
-  });
-};
-
-var lookupPromises = {};
-var lookups = {};
-
-exports.lookup = function(pkg, edge) {
-  return Promise.resolve()
-
-  // load the version map
-  .then(function() {
-    if (lookupPromises[pkg.package])
-      return lookupPromises[pkg.package];
-
-    ui.log('info', 'Looking up `' + pkg.name + '`');
-
-    lookupPromises[pkg.package] = Promise.resolve(registry.load(pkg.registry).lookup(pkg.package));
-    return lookupPromises[pkg.package];
-  })
-  .then(function(lookup) {
-    if (lookup.notfound)
-      throw 'Repo `' + pkg.name + '` not found!';
-
-    if (!lookup.versions)
-      throw 'Invalid registry lookup response for %' + pkg.registry + '%';
-
-    lookups[pkg.package] = lookup.versions;
-
-    return function(version) {
-      var opts = {edge: edge, latestVersion: lookup.latest};
-      var lookupObj = getVersionMatch(version, lookup.versions, opts);
-      if (!lookupObj)
-        return;
-
-      return new PackageName(pkg.name + '@' + lookupObj.version, true);
-    };
-  }, function() {
-    throw 'Error looking up `' + pkg.name + '`.';
-  });
-};
-
-exports.getVersionMatch = getVersionMatch;
-function getVersionMatch(pkgVersion, versions, options) {
-  // unescape pkgVersion for comparison
-  if (pkgVersion)
-    pkgVersion = decodeURIComponent(pkgVersion);
-
-  var version;
-  var stableSemver = [];
-  var unstableSemver = [];
-  var stableExact = [];
-  var unstableExact = [];
-  var edge = options && options.edge;
-
-  Object.keys(versions).forEach(function(v) {
-    version = versions[v];
-    var stable = version.stable;
-    var semverMatch = v.match(semver.semverRegEx);
-    var valid = semverMatch && semverMatch[1] && semverMatch[2] && semverMatch[3];
-    var pre = valid && semverMatch[4];
-
-    // store a reverse lookup
-    version.version = v;
-
-    // ignore non-semver or prerelease, unless explictly marked as stable
-    if (!valid) {
-      // unstable unless explicitly stable. in --edge prioritize all after 'master'
-      if (stable && !edge)
-        stableExact.push(v);
-      else
-        unstableExact.push(v);
-    }
-    // stable unless explicitly unstable or indetermate and a prerelease
-    // --edge considers all semver to be stable
-    else if (!edge && (stable === false || (stable !== true && pre)))
-      unstableSemver.push(v);
-    else
-      stableSemver.push(v);
-  });
-
-  function compareDesc(a, b) {
-    return semver.compare(b, a);
-  }
-
-  if (!pkgVersion) {
-    var latest = options && options.latestVersion && versions[options.latestVersion];
-    if (!edge && latest)
-      return latest;
-    stableSemver.sort(compareDesc);
-
-    if (stableSemver[0])
-      return versions[stableSemver[0]];
-
-    unstableSemver.sort(compareDesc);
-    if (unstableSemver[0])
-      return versions[unstableSemver[0]];
-
-    if (latest)
-      return latest;
-
-    stableExact.sort();
-    if (stableExact[0])
-      return versions[stableExact[0]];
-
-    // an ugly practicality. ideally designed out in future.
-    if (versions.master)
-      return versions.master;
-
-    unstableExact.sort();
-    if (unstableExact[0])
-      return versions[unstableExact[0]];
-  }
-  else {
-    var i, ver;
-    stableSemver.sort(compareDesc);
-    // find highest stable match in tags
-    for (i = 0; i < stableSemver.length; i++) {
-      ver = stableSemver[i];
-      var match = edge ? semver.matchUnstable : semver.match;
-      if (match(pkgVersion, ver))
-        return versions[ver];
-    }
-    unstableSemver.sort(compareDesc);
-    for (i = 0; i < unstableSemver.length; i++) {
-      ver = unstableSemver[i];
-      if (semver.match(pkgVersion, ver))
-        return versions[ver];
-    }
-    // finally check for an exact tag match
-    if (versions[pkgVersion])
-      return versions[pkgVersion];
-  }
-}
-
-// returns {hash,depRanges} or {notfound} or {linked}
-function getPackageDirInfo(dir) {
-  return Promise.resolve()
-  .then(function() {
-    // check if the folder already exists
-    return asp(fs.stat)(dir)
-    .then(function(stats) {
-      if (stats.isDirectory())
-        return true;
-      return asp(fs.unlink)(dir);
-    })
-    .catch(function(err) {
-      if (err.code === 'ENOENT')
-        return;
-      throw err;
-    });
-  })
-  .then(function(exists) {
-    if (!exists)
-      return { notfound: true };
-
-    // if it is linked, then it is fresh
-    return asp(fs.lstat)(dir)
-    .then(function(stats) {
-      return stats.isSymbolicLink();
-    })
-    .then(function(linked) {
-      if (linked)
-        return { linked: true };
-
-      // otherwise do the hash check
-      var hash;
-      return asp(fs.readFile)(path.resolve(dir, '.jspm-hash'))
-      .then(function(_hash) {
-        hash = _hash.toString();
-      })
-      .then(function() {
-        return readJSON(dir + '.deps.json');
-      })
-      .then(function(depJSON) {
-        var depRanges = {};
-        Object.keys(depJSON).forEach(function(dep) {
-          if (typeof depJSON[dep] == 'string')
-            depRanges[dep] = new PackageName(depJSON[dep]);
-        });
-        return { hash: hash, depRanges: depRanges };
-      }, function(err) {
-        if (err.code === 'ENOENT')
-          return { notfound: true };
-        throw err;
-      });
-    });
-  });
-}
-
-function processDeps(deps, registry) {
-  var outdeps = {};
-  if (!deps)
-    return outdeps;
-  Object.keys(deps).forEach(function(p) {
-    var dep = deps[p];
-
-    if (dep instanceof PackageName) {
-      outdeps[p] = dep;
-      return outdeps[p];
-    }
-
-    var outPackage;
-
-    // jquery: github:components/jquery
-    // jquery: jquery@1.5
-    // -> RHS is dep
-    if (dep.indexOf(':') !== -1)
-      outPackage = dep;
-
-    else if (!registry)
-      throw new TypeError('Install of %' + p + '% to `' + dep + '` has no registry property provided.');
-
-    // jquery: components/jquery@1.5
-    else if (dep.lastIndexOf('@') > 0)
-      outPackage = registry + ':' + dep;
-
-    // jquery: 1.5
-    else
-      outPackage = registry + ':' + p + '@' + dep;
-
-    outdeps[p] = new PackageName(outPackage, true);
-  });
-  return outdeps;
-}
-exports.processDeps = processDeps;
-
-var injecting = {};
-exports.inject = function(pkg, depLoad) {
-  if (injecting[pkg.exactName]) {
-    injecting[pkg.exactName].depLoad.then(function(depMap) {
-      depLoad(depMap);
-      return depMap;
-    });
-    return injecting[pkg.exactName].promise;
-  }
-
-  injecting[pkg.exactName] = {};
-
-  var depResolve, depReject;
-  injecting[pkg.exactName].depLoad = new Promise(function(resolve, reject) {
-    depResolve = resolve;
-    depReject = reject;
-  })
-  .then(function(depMap) {
-    depLoad(depMap);
-    return depMap;
-  });
-
-  var remote = registry.load(pkg.registry).remote;
-
-  if (!remote)
-    throw 'Cannot inject from registry %' + pkg.registry + '% as it has no remote.';
-
-  // NB remove rejectUnauthorized
-  var url = remote + (remote.endsWith('/') ? '' : '/') + pkg.exactName.substr(pkg.exactName.indexOf(':') + 1) + '/.jspm.json';
-  injecting[pkg.exactName].promise = asp(request)({
-    method: 'get',
-    url: url,
-    rejectUnauthorized: false
-  }).then(function(res) {
-    if (res.statusCode !== 200)
-      throw new Error('Error requesting package.json for `' + pkg.exactName + '` at %' + url + '%.');
-
-    try {
-      return JSON.parse(res.body);
-    }
-    catch(e) {
-      throw new Error('Unable to parse package.json');
-    }
-  })
-  .then(function(pjson) {
-    depResolve(processDeps(pjson.dependencies, pjson.registry));
-    return pjson;
-  }, depReject);
-  return injecting[pkg.exactName].promise;
-};
-
-function getDepRanges(pjson) {
-  var depRanges = processDeps(pjson.dependencies, pjson.registry);
-  
-  // dont install re-mapped dependencies
-  Object.keys(depRanges).forEach(function(dep) {
-    if (pjson.map && pjson.map[dep])
-      delete depRanges[dep];
-  });
-
-  return depRanges;
-}
-
-
-// note if it is a symlink, we leave it unaltered
-var downloading = {};
-// options.override
-// options.unlink
-// options.quick
-exports.download = function(pkg, options, installDeps) {
-  var sentDeps;
-  // called twice, ensure we don't duplicate install requests back
-  function depsCallback(depRanges) {
-    if (sentDeps)
-      Object.keys(depRanges).forEach(function(dep) {
-        if (sentDeps.indexOf(dep) != -1)
-          delete depRanges[dep];
-      });
-    else
-      sentDeps = Object.keys(depRanges);
-    if (installDeps)
-      installDeps(depRanges);
-    return depRanges;
-  }
-
-  // download queue
-  if (downloading[pkg.exactName]) {
-    downloading[pkg.exactName].preload.then(depsCallback);
-    downloading[pkg.exactName].postload.then(depsCallback);
-    return downloading[pkg.exactName].promise;
-  }
-  var postloadResolve, preloadResolve;
-  downloading[pkg.exactName] = {
-    preload: new Promise(function(resolve) {
-      preloadResolve = resolve;
-    })
-    .then(depsCallback),
-    postload: new Promise(function(resolve) {
-      postloadResolve = resolve;
-    })
-    .then(depsCallback)
-  };
-
-  // download
-  var override = options.override;
-  var downloadDir = pkg.getPath();
-  var getPackageConfigPromise;
-
-  downloading[pkg.exactName].promise = Promise.resolve()
-  .then(function() {
-    // if we have no constraint information, it's immediately a not-found
-    if (!config.deps[pkg.exactName])
-      return { notfound: true };
-
-    // otherwise check the folder info
-    return getPackageDirInfo(downloadDir);
-  })
-  .then(function(dirInfo) {
-    if (dirInfo.linked && !options.unlink)
-      return preloadResolve(config.deps[pkg.exactName]);
-
-    var cacheDir = path.resolve(config.HOME, '.jspm', 'packages', pkg.registry, pkg.exactPackage);
-
-    var endpoint = registry.load(pkg.registry);
-
-    var hash;
-    var fullHash;
-    var meta;
-
-    var fresh;
-
-    return (options.quick && dirInfo.hash ? Promise.resolve(true) : Promise.all([
-      // ensure we have the hash from the lookup
-      _pkg.lookup(pkg, options.edge)
-      .then(function() {
-        var lookupObj = lookups[pkg.package][pkg.version];
-        if (!lookupObj && !options.link)
-          throw 'Unable to resolve version %' + pkg.version + '% for `' + pkg.package + '`.';
-
-        if (lookupObj) {
-          hash = lookupObj.hash;
-          meta = lookupObj.meta;
-        }
-        // linked packages have no lookup object
-        else {
-          hash = '';
-          meta = {};
-        }
-      }),
-
-      // and the override
-      Promise.resolve()
-      .then(function() {
-        // load the registry endpoint
-        var endpoint = registry.load(globalConfig.config.defaultRegistry);
-
-        // get the override
-        if (endpoint.getOverride) {
-          if (!override) {
-            var overrideVersion = Object.keys(config.pjson.overrides)
-            .filter(function(overrideName) {
-              return overrideName.startsWith(pkg.name + '@');
-            })
-            .map(function(overrideName) {
-              return overrideName.split('@').pop();
-            })
-            .filter(function(overrideVersion) {
-              return semver.match('^' + overrideVersion, pkg.version);
-            })
-            .sort(semver.compare).pop();
-            if (overrideVersion) {
-              override = config.pjson.overrides[pkg.name + '@' + overrideVersion];
-              ui.log('warn', 'Using local override for `' + pkg.exactName + '`');
-            }
-          }
-          return endpoint.getOverride(pkg.registry, pkg.package, pkg.version, override);
-        }
-
-        return override;
-      })
-      .then(function(_override) {
-        override = _override;
-      })
-    ]))
-    .then(function() {
-      if (options.quick && dirInfo.hash)
-        return true;
-
-      // create the full package hash by combining it with the override and registry code hash
-      fullHash = hash + md5(JSON.stringify(override || {})) + endpoint.versionString + jspmVersion + '.1';
-
-      if (config.force)
-        return false;
-
-      return dirInfo.hash === fullHash;
-    })
-    .then(function(_fresh) {
-      fresh = _fresh;
-      if (fresh) {
-        // this can't trigger twice, so if its a second call its just a noop
-        preloadResolve(config.deps[pkg.exactName]);
-        return true;
-      }
-
-      // ensure global cache is fresh / download if not
-      return Promise.resolve(config.force ? false : getPackageDirInfo(cacheDir))
-      .then(function(cacheInfo) {
-        if (cacheInfo.hash && cacheInfo.hash === fullHash) {
-          config.deps[pkg.exactName] = cacheInfo.depRanges;
-          preloadResolve(cacheInfo.depRanges);
-          return;
-        }
-
-        ui.log('info', 'Downloading `' + pkg.exactName + '`');
-
-        if (endpoint.getPackageConfig)
-          getPackageConfigPromise = Promise.resolve()
-          .then(function() {
-            return endpoint.getPackageConfig(pkg.package, pkg.version, hash, meta);
-          })
-          .then(function(pjson) {
-            return derivePackageConfig(pkg, pjson, override);
-          }, function() {
-            throw 'Error getting package config for `' + pkg.name + '`.';
-          })
-          .then(function(pjson) {
-            preloadResolve(getDepRanges(pjson));
-            return pjson;
-          });
-
-        return Promise.resolve(cacheDir)
-        // ensure the download directory exists
-        .then(asp(mkdirp))
-        // clear the directory
-        .then(function() {
-          return asp(rimraf)(cacheDir);
-        })
-        .then(function() {
-          return asp(fs.unlink)(cacheDir + '.js')
-          .catch(function() {});
-        })
-        // create it
-        .then(function() {
-          return asp(mkdirp)(cacheDir);
-        })
-        // do the download
-        .then(function() {
-          return endpoint.download(pkg.package, pkg.version, hash, meta, cacheDir);
-        })
-
-        // process the package fully
-        .then(function(pjson) {
-          // if we have a getPackageConfig, we use that pjson
-          if (endpoint.getPackageConfig)
-            return getPackageConfigPromise;
-
-          // if no pjson returned by download, just read from download folder
-          return Promise.resolve(pjson || readJSON(path.resolve(cacheDir, 'package.json')))
-          .then(function(pjson) {
-            return derivePackageConfig(pkg, pjson, override);
-          });
-        }, function(err) {
-          if (err)
-            ui.log('err', err && err.stack || err);
-          throw 'Error downloading `' + pkg.name + '`.';
-        })
-        .then(function(pjson) {
-          return _pkg.processPackage(pkg, cacheDir, pjson, postloadResolve);
-        })
-        // create the main file in the cache folder
-        .then(function(pjson) {
-          return _pkg.createMain(pkg, pjson, cacheDir)
-          .then(function() {
-            return pjson;
-          });
-        })
-        // create the deps file in the cache folder
-        .then(function(pjson) {
-          var depRanges = getDepRanges(pjson);
-          var rangeMap = {};
-          Object.keys(depRanges).forEach(function(dep) {
-            rangeMap[dep] = depRanges[dep].exactName;
-          });
-          config.deps[pkg.exactName] = depRanges;
-          return asp(fs.writeFile(cacheDir + '.deps.json', JSON.stringify(rangeMap, null, 2)));
-        })
-        // we've now finished creating the cache directory
-        .then(function() {
-          return asp(fs.writeFile)(path.resolve(cacheDir, '.jspm-hash'), fullHash);
-        });
-      })
-      // copy global cache to local install
-      // clear the directory
-      .then(function() {
-        // in case it was linked, try and remove
-        return asp(fs.unlink)(downloadDir)
-        .catch(function(e) {
-          if (e.code === 'EISDIR' || e.code === 'EPERM' || e.code === 'ENOENT')
-            return;
-          throw e;
-        });
-      })
-      .then(function() {
-        return asp(mkdirp)(downloadDir);
-      })
-      .then(function() {
-        return asp(rimraf)(downloadDir);
-      })
-      .then(function() {
-        return asp(ncp)(cacheDir, downloadDir);
-      })
-      .then(function() {
-        // copy main file from cached folder (if it exists)
-        return asp(ncp)(cacheDir + '.js', downloadDir + '.js')
-        .catch(function(err) {
-          if (err instanceof Array)
-            err = err[0];
-          if (err.code == 'ENOENT')
-            return;
-          throw err;
-        });
-      })
-      .then(function() {
-        return fresh;
-      });
-    });
-  });
-  return downloading[pkg.exactName].promise;
-};
-
-
-// like config.derivePackageConfig, but applies the
-// registry processPackageConfig operation as well
-function derivePackageConfig(pkg, pjson, override) {
-  pjson = config.derivePackageConfig(pjson, override);
-
-  var endpoint = registry.load(pjson.registry || pkg.registry);
-  return Promise.resolve(endpoint.processPackageConfig ? endpoint.processPackageConfig(pjson, pkg.exactName) : pjson)
-  .then(function(pjson) {
-    if (!pjson)
-      throw new Error('processPackageConfig must return the processed package.json object.');
-    pjson.registry = pjson.registry || pkg.registry;
-    return pjson;
-  })
-  .catch(function() {
-    throw 'Error processing package config for `' + pkg.name + '`.';
-  });
-}
-exports.derivePackageConfig = derivePackageConfig;
-
-
-/*
- Given a raw package in a folder,
- apply the package.json build operations etc
-
- Also saves the hash into the folder
-
- pjson is optional if provided by getPackageConfig
-
- NB this function should be deprecated
-*/
-exports.processPackage = function(pkg, dir, pjson, postload, isCDN) {
-  // any package which takes longer than 10 seconds to process
-  var timeout = setTimeout(function() {
-    ui.log('warn', 'It\'s taking a long time to process the dependencies of `' + pkg.exactName + '`.\n' +
-      'This package may need an %ignore% property to indicate test or example folders for jspm to skip.\n');
-  }, 10000);
-  var endpoint = registry.load(pjson.registry || pkg.registry);
-  var deps;
-  var buildErrors = [];
-  var curDeps = [];
-
-  return Promise.resolve()
-
-  .then(function() {
-    // now that we have the derived pjson, do the registry build
-    if (endpoint.build)
-      return Promise.resolve()
-      .then(function() {
-        curDeps = pjson.dependencies && Object.keys(pjson.dependencies) || [];
-        return endpoint.build(pjson, dir);
-      })
-      .catch(function() {
-        throw 'Error building package `' + pkg.name + '`.';
-      });
-  })
-
-  // apply build operations from the package.json
-  .then(function(_buildErrors) {
-    if (_buildErrors)
-      buildErrors = buildErrors.concat(_buildErrors);
-
-    // if we gained a new dependency, download it
-    postload(getDepRanges(pjson));
-
-    // don't build in dependencies
-    if (!isCDN) {
-      deps = pjson.dependencies;
-      delete pjson.dependencies;
-    }
-    else {
-      deps = pjson.dependencies;
-      pjson.dependencies = processDeps(pjson.dependencies, pjson.registry);
-    }
-
-    return build.buildPackage(dir, pjson, isCDN);
-  })
-
-  // save the final calculated package.json in place
-  .then(function(_buildErrors) {
-    if (_buildErrors)
-      buildErrors = buildErrors.concat(_buildErrors);
-    pjson.dependencies = deps;
-  })
-  .then(function() {
-    // write build errors
-    if (buildErrors.length)
-      return asp(fs.writeFile)(path.resolve(dir, '.jspm.errors'), buildErrors.join('\n\n'));
-  })
-  .then(function() {
-    clearTimeout(timeout);
-    return pjson;
-  });
-};
-
-exports.createMain = function(pkg, pjson, downloadDir) {
-  var lastNamePart, main;
-  var mainPath;
-  var pluginMain;
-
-  return Promise.resolve()
-
-  // create the main entry point
-  .then(function() {
-    lastNamePart = pkg.name.split('/').pop().split(':').pop();
-    main = typeof pjson.main === 'string' && pjson.main;
-
-    // we don't need to ensure it exists for plugin mains
-    // as they can have custom locate functions
-    if (main && main.indexOf('!') !== -1) {
-      pluginMain = true;
-      return true;
-    }
-
-    if (!main)
-      return false;
-
-    if (main.startsWith('./')) {
-      main = main.substr(2);    
-    }
-    
-    return new Promise(function(resolve) {
-      // Check to see if main points to an actual file or not
-      // i.e. does it include extension.
-      mainPath = path.resolve(downloadDir, main);
-      fs.exists(mainPath, resolve);
-    });
-  })
-  .then(function(exists) {
-    main = main || 'index';
-
-    return new Promise(function(resolve) {
-      // `main` does not have extension (or it does not point to an actual file).
-      // Try again with `.js` extension
-      mainPath = path.resolve(downloadDir, main + '.js');
-      fs.exists(mainPath, resolve);
-    })
-    .then(function(_exists) {
-      if (!_exists)
-        mainPath = path.resolve(downloadDir, main);
-      return exists || _exists;
-    });
-  })
-  .then(function(exists) {
-    if (exists)
-      return exists;
-
-    main = lastNamePart;
-
-    if (main.endsWith('.js'))
-      main = main.substr(0, main.length - 3);
-
-    return new Promise(function(resolve) {
-      mainPath = path.resolve(downloadDir, main + '.js');
-      fs.exists(mainPath, resolve);
-    });
-  })
-  .then(function(exists) {
-    // don't create a main if it doesn't exist
-    if (!exists) {
-      if (pjson.main !== false)
-        ui.log('warn', 'Main entry point not found for `' + pkg.exactName + '`.\nAdjust this property in the package.json or with an override, setting %"main": false% if this is the intention.\n');
-      return;
-    }
-
-    // create the main pointer
-    var mainFile = path.resolve(downloadDir, '../' + lastNamePart + '@' + pkg.version + '.js');
-
-    // plugin mains are redirected by CommonJS
-    if (pluginMain)
-      return asp(fs.writeFile)(mainFile, getRedirectContents('cjs', pkg.exactName + '/' + main));
-
-    // otherwise detect the format of the main
-    return asp(fs.readFile)(mainPath)
-    .catch(function(err) {
-      if (err.code == 'EISDIR')
-        return;
-      throw err;
-    })
-    .then(function(source) {
-      if (typeof source == 'undefined')
-        return;
-      var format = pjson.format || build.detectFormat(source.toString()).format;
-
-      return asp(fs.writeFile)(mainFile, getRedirectContents(format, pkg.exactName + '/' + main));
-    });
-  });
-};
Index: node_modules/jspm/lib/registry.js
===================================================================
--- node_modules/jspm/lib/registry.js	(revision )
+++ node_modules/jspm/lib/registry.js	(revision )
@@ -1,255 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-var fs = require('graceful-fs');
-var path = require('path');
-var config = require('./config');
-var globalConfig = require('./global-config');
-var ui = require('./ui');
-var dextend = require('./common').dextend;
-var Promise = require('rsvp').Promise;
-
-/*
-  Registry API
-  See https://github.com/jspm/jspm-cli/wiki/Registry-API for the spec
-*/
-var registryClasses = {};
-
-process.on('exit', function() {
-  // dispose all loaded registries
-  // allows for saving cache state using sync fs
-  for (var e in registryClasses) {
-    if (registryClasses[e].dispose)
-      registryClasses[e].dispose();
-  }
-});
-
-var registryHooks = ['locate', 'lookup', 'download', 'getPackageConfig', 'processPackageConfig', 'build', 'getOverride'];
-
-exports.load = function(registry) {
-  if (registryClasses[registry])
-    return registryClasses[registry];
-
-  try {
-    // ensure the tmpDir exists
-    var tmpDir = path.resolve(config.HOME, '.jspm', registry + '-cache');
-    if (!fs.existsSync(tmpDir))
-      fs.mkdirSync(tmpDir);
-
-    var options = dextend({
-      timeouts: {
-        lookup: 60,
-        download: 300,
-        build: 120
-      },
-      tmpDir: tmpDir,
-      apiVersion: '1.6'
-    }, globalConfig.config.registries[registry] || {});
-
-    options.name = registry;
-    if (globalConfig.config.strictSSL === false || globalConfig.config.strictSSL == 'false')
-      options.strictSSL = false;
-
-    if (!options.handler)
-      throw 'Registry %' + registry + '% not found.';
-
-    var RegistryClass = require(options.handler);
-    var registryPackageJSON = require(options.handler + '/package.json');
-    var versionString = registryPackageJSON.name + '@' + registryPackageJSON.version.split('.').splice(0, 2).join('.');
-    options.versionString = versionString;
-
-    var registryInstance = registryClasses[registry] = new RegistryClass(options, ui);
-    registryInstance.constructor = RegistryClass;
-
-    var timeoutLookup = options.timeouts.lookup * 1000;
-    var timeoutDownload = options.timeouts.download * 1000;
-    var timeoutBuild = options.timeouts.build * 1000;
-
-    registryInstance.versionString = registryInstance.versionString || versionString;
-
-    var maxRetries = globalConfig.config.maxRetries || 3;
-
-    // patch the calls to apply timeout and retry logic
-    registryHooks.forEach(function(hook) {
-      if (!registryInstance[hook])
-        return;
-
-      var runHook = registryInstance[hook];
-      registryInstance[hook] = function() {
-        var self = this;
-        var args = arguments;
-        var retries = 0;
-        var timeout;
-        if (hook == 'download')
-          timeout = timeoutDownload;
-        else if (hook == 'build')
-          timeout = timeoutBuild;
-        else
-          timeout = timeoutLookup;
-
-        return new Promise(function(resolve, reject) {
-
-          function tryHook() {
-            var active = true;
-
-            var timer = setTimeout(function() {
-              active = false;
-              checkRetry();
-            }, timeout);
-
-            // in case registry is being reconfigured, chain on a promise
-            // which delivers the registry to use, when it is ready
-            (self.reconfigPromise_ || Promise.resolve(self))
-            .then(function(endpoint) {
-              self = endpoint;
-              return runHook.apply(self, args);
-            })
-            .then(function(result) {
-              clearTimeout(timer);
-              if (active)
-                resolve(result);
-            }, function(err) {
-              clearTimeout(timer);
-              if (!active)
-                return;
-              active = false;
-              return checkConfigure(err) || checkRetry(err);
-            });
-          }
-
-          /* When err.config is set, that indicates config credentials are somehow the cause.
-           * Call the configure hook and reinstantiate the registry with new config */
-          function checkConfigure(err) {
-            if (err && err.config && !self.triedConfig) {
-              // Place promise chain on existing instance, to block subsequent hooks.
-              // Also print warning for only for first such error, if multiple in a batch
-              if (!self.reconfigPromise_) {
-                ui.log('warn', err.message);
-
-                self.reconfigPromise_ = exports.configure(registry)
-                .then(function() {
-                  // replace registered instance
-                  delete registryClasses[registry];
-                  var instance = exports.load(registry);
-                  instance.triedConfig = true;
-                  return instance;
-                });
-              }
-
-              tryHook();
-              return true;
-            }
-          }
-
-          function checkRetry(err) {
-            // don't retry build or processPackageConfig
-            if (hook === 'build' || hook === 'processPackageConfig')
-              retries = maxRetries;
-
-            retries++;
-            var retriable = !err || err.retriable;
-            var retry = retriable && retries <= maxRetries;
-
-            var msg = (err ? 'Error' : 'Timed out') + ' on ' + hook +
-               (typeof args[0] === 'string' ? ' for `' + registry + ':' + args[0] + '`' : '') +
-               (retry ? ', retrying (' + retries + ').' : '') +
-
-               (!err ? '\nTo increase the timeout run %jspm config registries.' + registry + '.timeouts.' + (hook == 'download' || hook == 'build' ? hook : 'lookup') + ' ' + timeout / 1000 * 2 + '%' : '') +
-               (err ? '\n' + (!err.hideStack && err.stack || err) : '');
-            ui.log('warn', msg);
-            if (retry)
-              return tryHook();
-            else
-              return reject();
-          }
-
-          tryHook();
-        });
-      };
-    });
-
-    return registryInstance;
-  }
-  catch(e) {
-    ui.log('err', !e.hideStack && e.stack || e);
-    throw 'Unable to load registry %' + registry + '%';
-  }
-};
-
-exports.configure = function(registry) {
-  var registryConfig = globalConfig.config.registries[registry] || {},
-      RegistryClass;
-
-  if (!registryConfig.handler)
-    throw 'Registry %' + registry + '% not found.';
-
-  var handler = registryConfig.handler;
-  delete registryConfig.handler;
-
-  try {
-    RegistryClass = require(handler);
-  }
-  catch(e) {
-    throw 'Registry handler `' + handler + '` not installed.';
-  }
-
-  registryConfig.name = registry;
-  registryConfig.strictSSL = globalConfig.config.strictSSL;
-
-  return Promise.resolve(RegistryClass.configure && RegistryClass.configure(registryConfig, ui) || registryConfig)
-  .then(function(_config) {
-    delete _config.name;
-    delete _config.strictSSL;
-    _config.handler = handler;
-    globalConfig.config.registries[registry] = _config;
-  })
-  .then(function() {
-    globalConfig.save();
-  });
-};
-
-// jspm registry create mycompany jspm-github
-// creates a custom registry based on the given handler
-exports.create = function(name, handler, override) {
-
-  // handle override prompts etc
-  if (!override && globalConfig.config.registries[name]) {
-    if (globalConfig.config.registries[name].handler === handler)
-      return ui.confirm('Registry %' + name + '% already exists. Do you want to reconfigure it now?')
-      .then(function(configure) {
-        if (configure)
-          return Promise.resolve(exports.configure(name))
-          .then(function() {
-            ui.log('ok', 'Registry %' + name + '% configured successfully.');
-            return false;
-          });
-        else
-          return false;
-      });
-    else
-      return ui.confirm('Registry %' + name + '% already exists, but based on `' + globalConfig.config.registries[name].handler + '`. Are you sure you want to override it?')
-      .then(function(override) {
-        if (override)
-          return Promise.resolve(exports.create(name, handler, true));
-        return false;
-      });
-  }
-
-  var registryConfig = globalConfig.config.registries[name] = globalConfig.config.registries[name] || {};
-  registryConfig.handler = handler;
-
-  // load the registry and configure it
-  return exports.configure(name);
-};
Index: node_modules/jspm/lib/global-config.js
===================================================================
--- node_modules/jspm/lib/global-config.js	(revision )
+++ node_modules/jspm/lib/global-config.js	(revision )
@@ -1,181 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-
-var ui = require('./ui');
-var fs = require('graceful-fs');
-var path = require('path');
-var HOME = require('./config').HOME;
-var lockFile = require('proper-lockfile');
-var dprepend = require('./common').dprepend;
-var readJSONSync = require('./common').readJSONSync;
-var stringify = require('./common').stringify;
-
-// global config - automatically created and loaded on startup
-exports.registries = [];
-var globalConfigFile = HOME + path.sep + '.jspm' + path.sep + 'config';
-
-// old windows HOME migration
-// can deprecate with jspm 0.15.3
-if (process.env.USERPROFILE && HOME !== process.env.USERPROFILE && !fs.existsSync(path.join(HOME, '.jspm')) && fs.existsSync(path.join(process.env.USERPROFILE, '.jspm'))) {
-  var OLD_HOME = process.env.USERPROFILE;
-  var from = path.join(OLD_HOME, '.jspm');
-  var to = path.join(HOME, '.jspm');
-  ui.log('info', 'Migrating global jspm folder from `' + from + '` to `' + to + '`...');
-  try {
-    ui.log('info', 'Copying configuration...');
-    var oldConfig = fs.readFileSync(path.resolve(from, 'config'));
-    fs.mkdirSync(to);
-    fs.writeFileSync(path.resolve(to, 'config'), oldConfig);
-    ui.log('ok', 'Migration successful. Note that linked packages will need to be relinked.');
-  }
-  catch (e) {
-    ui.log('err', 'Error migrating to new jspm folder\n' + (e && e.stack || e));
-  }
-}
-
-// Begin file lock
-lock();
-
-// after loading, we'll dprepend all defaults to `exports.config` in this `try` block
-exports.config = readJSONSync(globalConfigFile);
-
-// NB can deprecate with jspm 0.14
-if (!exports.config.defaultRegistry && exports.config.registry)
-  exports.config.defaultRegistry = exports.config.registry;
-if (!exports.config.registries && exports.config.endpoints)
-  exports.config.registries = exports.config.endpoints;
-
-// NB add this to deprecate 0.14
-// delete exports.config.registry;
-// delete exports.config.endpoints;
-
-// config upgrade paths
-// NB can deprecate with jspm < 10
-if (exports.config.github) {
-  dprepend(exports.config.registries.github, exports.config.github);
-  delete exports.config.github;
-}
-
-// populate default registry configuration
-dprepend(exports.config, {
-  defaultTranspiler: 'babel',
-  defaultRegistry: 'jspm',
-  strictSSL: true,
-  registries: {
-    github: {
-      handler: 'jspm-github',
-      remote: 'https://github.jspm.io'
-    },
-    npm: {
-      handler: 'jspm-npm',
-      remote: 'https://npm.jspm.io'
-    },
-    jspm: {
-      handler: 'jspm-registry',
-      remote: 'https://registry.jspm.io'
-    }
-  }
-});
-
-try{
-  if (HOME)
-    save();
-} catch(ex) {
-  console.error('Unable to initialize JSPM home configuration folder!');
-}
-// end file lock
-unlock();
-
-function save() {
-  try {
-    fs.mkdirSync(HOME + path.sep + '.jspm');
-  }
-  catch (e) {
-    if (e.code !== 'EEXIST')
-      throw 'Unable to create jspm system folder\n' + e.stack;
-  }
-  try {
-    lock();
-    var existing = readJSONSync(globalConfigFile);
-    // only write to a new file if the local changes are different
-    if (JSON.stringify(existing) != JSON.stringify(exports.config)) {
-      fs.writeFileSync(globalConfigFile, stringify(exports.config));
-    }
-  }
-  catch (e) {
-    throw 'Unable to write global configuration file\n' + e.stack;
-  }
-  finally {
-    unlock();
-  }
-}
-exports.save = save;
-
-exports.set = function(name, val) {
-  var nameParts = name.split('.');
-
-  var config = exports.config;
-  var part;
-  while (nameParts.length > 1) {
-    part = nameParts.shift();
-    config[part] = typeof config[part] === 'object' ? config[part] : {};
-    config = config[part];
-  }
-  if (val !== undefined) {
-    config[nameParts[0]] = val;
-  }
-  else {
-    // If no value is specified, then remove property from config
-    delete config[nameParts[0]];
-  }
-
-  save();
-};
-
-var _unlock;
-function lock() {
-  if (!_unlock) {
-    try {
-      _unlock = lockFile.lockSync(globalConfigFile, {
-        retries: {
-          retries: 10,
-          minTimeout: 20,
-          maxTimeout: 300,
-          randomize: true
-        },
-        realpath: false
-      });
-    } catch (e) {
-      if (e.code === 'ELOCKED')
-        throw 'Unable to lock global config file %' + globalConfigFile + '%, not overwriting';
-    }
-  }
-}
-function unlock() {
-  if (_unlock) {
-    _unlock();
-    _unlock = undefined;
-  }
-}
-// Map SIGINT & SIGTERM to process exit
-// so that lockfile removes the lockfile automatically
-process
-  .once('SIGINT', function () {
-    process.exit(1);
-  })
-  .once('SIGTERM', function () {
-    process.exit(1);
-  });
Index: node_modules/jspm/api.js
===================================================================
--- node_modules/jspm/api.js	(revision )
+++ node_modules/jspm/api.js	(revision )
@@ -1,154 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-
-var install = require('./lib/install');
-var bundle = require('./lib/bundle');
-var core = require('./lib/core');
-var ui = require('./lib/ui');
-var EventEmitter = require('events').EventEmitter;
-var SystemJSLoader = require('systemjs').constructor;
-var config = require('./lib/config');
-var path = require('path');
-var toFileURL = require('./lib/common').toFileURL;
-
-require('rsvp').on('error', function(reason) {
-  ui.log('warn', 'Unhandled promise rejection.\n' + reason && reason.stack || reason || '' + '\n');
-});
-
-var API = module.exports = new EventEmitter();
-
-API.setPackagePath = function(packagePath) {
-  if (config.loaded && process.env.jspmConfigPath !== path.resolve(packagePath, 'package.json'))
-    throw new Error('Configuration has already been loaded. Call setPackagePath before using other APIs.');
-  process.env.jspmConfigPath = path.resolve(packagePath, 'package.json');
-};
-API.setPackagePath('.');
-
-/*
- * jspm.on('log', function(type, msg) { console.log(msg); });
- * jspm.on('prompt', function(prompt, callback) {
- *   if (prompt.type == 'confirm')
- *     callback({ confirm: true });
- *   if (prompt.type == 'input')
- *     callback({ input: value });
- * });
- *
- * Prompt as defined in https://github.com/SBoudrias/Inquirer.js/tree/master#question
- * Callback answer defined in https://github.com/SBoudrias/Inquirer.js/tree/master#answers
- */
-ui.setResolver(API);
-ui.useDefaults();
-
-API.promptDefaults = function(_useDefaults) {
-  ui.useDefaults(_useDefaults);
-};
-
-API.version = require('./package.json').version;
-
-/*
- * Loader API
- */
-
-var apiLoader;
-API.normalize = function(name, parentName) {
-  apiLoader = apiLoader || new API.Loader();
-  return apiLoader.normalize(name, parentName);
-};
-
-API.import = function(name, parentName) {
-  apiLoader = apiLoader || new API.Loader();
-  return apiLoader.import(name, parentName);
-};
-
-API.Loader = function() {
-  config.loadSync();
-
-  var cfg = config.loader.getConfig();
-  cfg.baseURL = toFileURL(config.pjson.baseURL);
-
-  var loader = new SystemJSLoader();
-  loader.config(cfg);
-
-  return loader;
-};
-
-/*
- * Builder API
- */
-API.Builder = bundle.Builder;
-
-// options.inject
-// options.sourceMaps
-// options.minify
-API.bundle = function(expression, fileName, options) {
-  return bundle.bundle(expression, fileName, options);
-};
-
-/*
- * Remove the bundle configuration.
- * This will allow you to move back to separate file mode
- * returns a promise
- */
-API.unbundle = function() {
-  return bundle.unbundle();
-};
-
-
-/*
- * Creates a distributable script file that can be used entirely on its own independent of SystemJS and jspm.
- * returns a promise
- * options.minify, options.sourceMaps
- */
-API.bundleSFX = function(expression, fileName, options) {
-  return bundle.bundleSFX(expression, fileName, options);
-};
-
-
-/*
- * Package Management API
- *
-
-/*
- * Installs a library in the current folder
- * returns a promise
- *
- * jspm.install('jquery')
- * jspm.install('jquery', 'github:components/jquery@^2.0.0')
- * jspm.install('jquery', '2')
- * jspm.install('jquery', 'github:components/jquery')
- * jspm.install('jquery', { force: true });
- * jspm.install({ jquery: '1.2.3' }, { force: true })
- * jspm.install(true, options) // install from package.json
- *
- */
-API.install = function(name, target, options) {
-  return install.install(name, target, options);
-};
-
-/* Uninstalls a library in the current folder.
- * returns a promise
- *
- * jspm.uninstall('jquery')
- * jspm.uninstall(['jquery', 'handlebars'])
- *
- */
-API.uninstall = function(names) {
-  return install.uninstall(names);
-};
-
-API.dlLoader = function(transpiler) {
-  return core.checkDlLoader(transpiler);
-};
Index: node_modules/jspm/cli.js
===================================================================
--- node_modules/jspm/cli.js	(revision )
+++ node_modules/jspm/cli.js	(revision )
@@ -1,623 +0,0 @@
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
- require('core-js/es6/string');
-
-var ui = require('./lib/ui');
-var chalk = require('chalk');
-var config = require('./lib/config');
-var globalConfig = require('./lib/global-config');
-var core = require('./lib/core');
-var bundle = require('./lib/bundle');
-var registry = require('./lib/registry');
-var install = require('./lib/install');
-var fs = require('graceful-fs');
-var Promise = require('rsvp').Promise;
-
-var link = require('./lib/link');
-
-var build = require('./lib/build');
-
-require('rsvp').on('error', function(reason) {
-  ui.log('warn', 'Unhandled promise rejection.\n' + reason && reason.stack || reason || '' + '\n');
-});
-
-process.on('uncaughtException', function(err) {
-  ui.log('err', err.stack || err);
-});
-
-/* jshint laxbreak: true */
-
-(function() {
-  function showHeader() {
-    ui.log('\n'
-      + '  ' + chalk.bgWhite('      ') + '\n'
-      + '  \033[47m\033[93m\033[1m jspm \033[0m\033[90m  ' + chalk.grey('Browser Package Management') + '\n'
-      + '  ' + chalk.bgWhite('      ') + '\n'
-    );
-  }
-
-  function showInstructions() {
-    showHeader();
-    ui.log('\n'
-      + 'jspm run main                      Run a jspm module in Node\n'
-      + '\n'
-      + 'jspm init [basepath] [--prompts]   Create / validate project configuration file\n'
-      + '\n'
-      + 'jspm install <name[=target]+> [--force skips cache] [--latest] [--dev]\n'
-      + '  install jquery                   Install a package looked up in the jspm registry\n'
-      + '  install react=npm:react          Install a package from a registry to latest\n'
-      + '  install jquery=2 react           Install a package to a version or range\n'
-      + '\n'
-      + '  install                          Reproducible / shrinkwrap install package.json\n'
-      + '\n'
-      + '  install react --lock             Stable install, locking existing dependencies\n'
-      + '\n'
-      + '  install react=npm:react --edge   Install a package from a registry to latest unstable\n'
-      + '\n'
-      + '  install ts --dev                 Install a package as devDependency\n'
-      + '\n'
-      + '  install dep -o override.json     Install with the given custom override\n'
-      + '  install dep -o "{override json}"   useful for testing package overrides\n'
-      + '\n'
-      + 'jspm update                        Update all packages from package.json\n'
-      + 'jspm uninstall name                Uninstall a package and clean dependencies\n'
-      + 'jspm clean                         Clear unused and orphaned dependencies\n'
-      + '\n'
-      + 'jspm inspect [--forks]             View all installed package versions\n'
-      + 'jspm inspect npm:source-map        View the versions and ranges of a package\n'
-      + '\n'
-      + 'jspm inject <name[=target]> [--force] [--latest] [--lock] [-o]\n'
-      + '  inject jquery                    Identical to install, but injects config\n'
-      + '                                   only instead of downloading the package\n'
-      + '\n'
-      + 'jspm link registry:pkg@version     Link a local folder as an installable package\n'
-      + 'jspm install --link registry:name  Install a linked package\n'
-      + '\n'
-      + 'jspm dl-loader [--edge --latest]   Download the browser loader files\n'
-      + 'jspm dl-loader [babel|traceur|typescript]\n'
-      + '\n'
-      + 'jspm resolve --only registry:package@version\n'
-      + '  resolve --only npm:jquery@2.1.1  Resolve all versions of a package to the given version\n'
-      + '\n'
-      + 'jspm setmode <mode>\n'
-      + '  setmode local                    Switch to locally downloaded libraries\n'
-      + '  setmode remote                   Switch to CDN external package sources\n'
-      + '\n'
-      + 'jspm bundle moduleA + module/b [outfile] [--minify] [--no-mangle] [--inject] [--skip-source-maps] [--source-map-contents]\n'
-      + 'jspm bundle-sfx app/main [outfile] [--format <amd|cjs|global>] [--minify]\n'
-      + 'jspm unbundle                      Remove injected bundle configuration\n'
-      + 'jspm depcache moduleName           Stores dep cache in config for flat pipelining\n'
-      + '\n'
-      + 'jspm registry <command>            Manage registries\n'
-      + '  registry config <name>           Configure an existing registry\n'
-      + '  registry create <name> <pkg>     Create a new custom registry instance\n'
-      // + '  registry export <registry-name>  Export an registry programatically\n'
-      + '\n'
-      + 'jspm config <option> <setting>     Configure jspm global options\n'
-      + '                                   Stored in ~/.jspm/config\n'
-      + '\n'
-      + 'jspm cache-clear                   Clear global caches, not recommended\n'
-      + '\n'
-      + 'Global Flags\n'
-      + ' --yes | -y                        Skip prompts / use default inputs\n'
-      + ' --log <ok|warn|err>               Set log level\n'
-      + ' --cwd [path]                      Set the working directory\n'
-    );
-  }
-
-  function showVersion() {
-    // deprecate localJspm
-    ui.log(require('./package.json').version + '\n'
-      + (process.env.globalJspm === 'true' || process.env.localJspm === 'false' ? 'Running against global jspm install.' : 'Running against local jspm install.'));
-  }
-
-  function dwalk(obj, visitor, pname) {
-    for (var p in obj) {
-      if (!obj.hasOwnProperty(p))
-        continue;
-      if (typeof obj[p] === 'object')
-        dwalk(obj[p], visitor, (pname ? pname + '.' : '') + p);
-      else
-        visitor((pname ? pname + '.' : '') + p, obj[p]);
-    }
-  }
-
-
-  // takes commandline args, space-separated
-  // flags is array of flag names
-  // optFlags is array of flags that have option values
-  // optFlags suck up arguments until next flag
-  // returns { [flag]: true / false, ..., [optFlag]: value, ..., args: [all non-flag args] }
-  function readOptions(inArgs, flags, optFlags) {
-    // output options object
-    var options = { args: [] };
-
-    flags = flags || [];
-    optFlags = optFlags || [];
-
-    var curOptionFlag;
-
-    function getFlagMatch(arg, flags) {
-      var index;
-
-      if (arg.startsWith('--')) {
-        index = flags.indexOf(arg.substr(2));
-        if (index !== -1)
-          return flags[index];
-      }
-      else if (arg.startsWith('-')) {
-        return flags.filter(function(f) {
-          return f.substr(0, 1) === arg.substr(1, 1);
-        })[0];
-      }
-    }
-
-    // de-sugar any coupled single-letter flags
-    // -abc -> -a -b -c
-    var args = [];
-    inArgs.forEach(function(arg) {
-      if (arg[0] == '-' && arg.length > 1 && arg[1] != '-') {
-        for (var i = 1; i < arg.length; i++)
-          args.push('-' + arg[i]);
-      }
-      else {
-        args.push(arg);
-      }
-    });
-
-    args.forEach(function(arg) {
-      var flag = getFlagMatch(arg, flags);
-      var optFlag = getFlagMatch(arg, optFlags);
-
-      // option flag -> suck up args
-      if (optFlag) {
-        curOptionFlag = optFlag;
-        options[curOptionFlag] = [];
-      }
-      // normal boolean flag
-      else if (flag) {
-        options[flag] = true;
-      }
-      // value argument
-      else {
-        if (curOptionFlag)
-          options[curOptionFlag].push(arg);
-        else
-          options.args.push(arg);
-      }
-    });
-
-    // flag values are strings
-    optFlags.forEach(function(flag) {
-      options[flag] = (options[flag] || []).join(' ');
-    });
-
-    return options;
-  }
-
-  // this will get a value in its true type from the CLI
-  function readValue(val) {
-    val = val.trim();
-    if (val === 'true' || val === 'false')
-      return eval(val);
-    else if (parseInt(val).toString() == val)
-      return parseInt(val);
-    else
-      return val;
-  }
-
-  // [].concat() to avoid mutating the given process.argv
-  var args = process.argv.slice(2),
-      options;
-
-  var logArgIndex = args.indexOf('--log');
-  if (logArgIndex > -1) {
-    ui.setLogLevel(args[logArgIndex + 1]);
-    args.splice(logArgIndex, 2);
-  }
-
-  var cwdArgIndex = args.indexOf('--cwd');
-  if (cwdArgIndex > -1) {
-    args.splice(cwdArgIndex, 2);
-  }
-
-  switch(args[0]) {
-    case 'run':
-      core.run(args[1]);
-      break;
-
-    case 'inject':
-      var inject = true;
-
-    case 'update':
-      var doUpdate = !inject;
-
-    case 'i':
-    case 'isntall':
-    case 'install':
-      options = readOptions(args, ['force', 'link', 'yes', 'lock', 'latest',
-                                   'unlink', 'quick', 'dev', 'edge', 'production'], ['override']);
-      options.inject = inject;
-      options.update = doUpdate;
-
-      args = options.args;
-
-      var depMap;
-      for (var i = 1; i < args.length; i++) {
-        depMap = depMap || {};
-        var name, target;
-        var arg = args[i];
-        name = arg.split('=')[0];
-        target = arg.split('=')[1];
-
-        if (!target) {
-          target = name;
-          if (name.indexOf(':') !== -1)
-            name = name.substr(name.indexOf(':') + 1);
-          if (name.indexOf('@') > 0)
-            name = name.substr(0, name.lastIndexOf('@'));
-        }
-
-        if (target.indexOf(':') === -1)
-          target = globalConfig.config.defaultRegistry + ':' + target;
-
-        depMap[name] = target || '';
-      }
-
-      var override = options.override;
-      if (override) {
-        if (!override.startsWith('{')) {
-          try {
-            options.override = fs.readFileSync(override);
-          }
-          catch(e) {
-            return ui.log('err', 'Unable to read override file %' + override + '%.');
-          }
-          try {
-            options.override = JSON.parse(options.override);
-          }
-          catch(e) {
-            return ui.log('err', 'Invalid JSON in override file %' + override + '%.');
-          }
-        }
-        else {
-          options.override = eval('(' + override + ')');
-        }
-      }
-
-      if (options.yes)
-        ui.useDefaults();
-
-      // jspm install with no arguments is locked
-      if (!depMap && !doUpdate)
-        options.lock = true;
-
-      // no install package -> install from package.json dependencies
-      (depMap ? install.install(depMap, options) : install.install(true, options))
-      .then(function() {
-        return core.checkDlLoader();
-      })
-      .then(function() {
-        return core.setMode(inject ? 'remote' : 'local');
-      })
-      .then(function() {
-        ui.log('');
-        ui.log('ok', 'Install complete.');
-        process.exit();
-      }, function(err) {
-        // something happened (cancel / err)
-        if (err)
-          ui.log('err', err.stack || err);
-        ui.log('warn', 'Installation changes not saved.');
-        process.exit(1);
-      });
-
-      break;
-
-    case 'r':
-    case 'remove':
-    case 'uninstall':
-      options = readOptions(args, ['yes']);
-
-      if (options.yes)
-        ui.useDefaults();
-
-      install.uninstall(options.args.splice(1))
-      .then(function() {
-        ui.log('');
-        ui.log('ok', 'Uninstall complete.');
-      }, function(err) {
-        ui.log('err', err.stack || err);
-        ui.log('warn', 'Uninstall changes not saved.');
-        process.exit(1);
-      });
-      break;
-
-    case 'resolve':
-      options = readOptions(args, null, ['only']);
-
-      if (!options.only)
-        return ui.log('warn', 'Use %jspm resolve --only registry:pkg@version%');
-
-      install.resolveOnly(options.only)
-      .catch(function(err) {
-        if (!err)
-          ui.log('err', 'Resolve operation not performed.');
-        else
-          ui.log('err', err.stack || err);
-        process.exit(1);
-      });
-      break;
-
-    case 'clean':
-      options = readOptions(args, ['yes']);
-      args = options.args;
-
-      if (options.yes)
-        ui.useDefaults();
-
-      install.clean()
-      .then(function() {
-        ui.log('');
-        ui.log('ok', 'Project cleaned successfully.');
-      }, function(err) {
-        ui.log('err', err.stack || err);
-        process.exit(1);
-      });
-      break;
-
-    case 'inspect':
-      options = readOptions(args, ['forks']);
-      args = options.args;
-
-      config.load()
-      .then(function() {
-        if (!args[1])
-          return install.showVersions(options.forks);
-        if (!args[1].includes(':'))
-          return ui.log('warn', 'Enter a full package name of the format `registry:repo`.');
-        return install.showInstallGraph(args[1]);
-      })
-      .catch(function(e) {
-        ui.log('err', e.stack || e);
-      });
-      break;
-
-    case 'init':
-      options = readOptions(args, ['yes', 'prompts']);
-      if (options.yes)
-        ui.useDefaults();
-      core.init(options.args[1], options.prompts);
-      break;
-
-    case 'dl-loader':
-      options = readOptions(args, ['source', 'latest', 'edge', 'yes', 'traceur', 'babel', 'typescript']);
-      if (options.yes)
-        ui.useDefaults();
-      core.dlLoader(options.args[1] || options.traceur && 'traceur' || options.babel && 'babel' || options.typescript && 'typescript', options.source, options.edge, options.latest);
-      break;
-
-    case 'setmode':
-      options = readOptions(args, ['yes']);
-      if (options.yes)
-        ui.useDefaults();
-      core.setMode(args.splice(1))
-      .then(function(msg) {
-        ui.log('ok', msg);
-      }, function(err) {
-        ui.log('err', err.stack || err);
-      });
-      break;
-
-    case 'depcache':
-      options = readOptions(args, ['yes']);
-      if (options.yes)
-        ui.useDefaults();
-      if (!args[1])
-        ui.log('warn', 'depCache requires a module name to trace.');
-      else
-        bundle.depCache(args[1]);
-      break;
-
-    case 'b':
-    case 'bundle-sfx':
-      var sfxBundle = true;
-
-    case 'bundle':
-      options = readOptions(args, ['inject', 'yes', 'skip-source-maps', 'minify',
-          'no-mangle', 'hires-source-maps', 'no-runtime', 'inline-source-maps', 'source-map-contents'], ['format', 'global-name', 'globals', 'global-defs']);
-
-      if (options.yes)
-        ui.useDefaults();
-      options.sourceMaps = !options['skip-source-maps'];
-      options.lowResSourceMaps = !options['hires-source-maps'];
-      options.mangle = !options['no-mangle'];
-      options.sourceMapContents = !!options['source-map-contents'];
-
-      if (options['inline-source-maps'])
-        options.sourceMaps = 'inline';
-
-      if (options['global-name'])
-        options.globalName = options['global-name'];
-
-      if (options.inject)
-        options.injectConfig = true;
-
-      options.format = options.format;
-
-      if (options.globals)
-        options.globalDeps = eval('(' + options.globals + ')');
-
-      if (options['global-defs'])
-        options.globalDefs = eval('(' + options['global-defs'] + ')');
-
-      var bArgs = options.args.splice(1);
-
-      if (bArgs.length === 0)
-        return ui.log('warn', 'You must provide at least one module as the starting point for bundling');
-
-      if (bArgs.length < 2) {
-        (sfxBundle ? bundle.bundleSFX : bundle.bundle)(bArgs[0], undefined, options)
-        .catch(function() {
-          process.exit(1);
-        });
-      }
-      else {
-        var secondLastArg = bArgs[bArgs.length - 2].trim();
-        var signChar = secondLastArg.substr(secondLastArg.length - 1, 1);
-        var expression = '';
-        var fileName;
-
-        // we can write: jspm bundle app + other
-        if (['+', '-'].indexOf(signChar) !== -1) {
-          expression = bArgs.join(' ');
-        }
-        // or we can write: jspm bundle app + other out.js
-        else {
-          expression = bArgs.splice(0, bArgs.length - 1).join(' ');
-          fileName = bArgs[bArgs.length - 1];
-        }
-        (sfxBundle ? bundle.bundleSFX : bundle.bundle)(expression, fileName, options)
-        .catch(function() {
-          process.exit(1);
-        });
-      }
-      break;
-
-    case 'unbundle':
-      bundle.unbundle()
-      .catch(function(e) {
-        ui.log('err', e.stack || e);
-        process.exit(1);
-      });
-      break;
-
-    case 'build':
-      options = readOptions(args, ['yes']);
-      if (options.yes)
-        ui.useDefaults();
-      core.build();
-      break;
-
-    case 'compile':
-      options = readOptions(args, ['transpile', 'minify', 'removeJSExtensions', 'yes'], ['map', 'format']);
-      if (options.yes)
-        ui.useDefaults();
-      if (options.map) {
-        var mapParts = options.map.split('=');
-        options.map = {};
-        options.map[mapParts[0]] = mapParts[1];
-      }
-
-      build.compileDir(args[1], options)
-      .then(function() {
-        ui.log('ok', 'Compilation complete');
-      }, function(e) {
-        ui.log('err', e.stack || e);
-      });
-      break;
-
-    case 'link':
-      options = readOptions(args, ['force', 'yes']);
-
-      if (options.yes)
-        ui.useDefaults();
-
-      args = options.args;
-
-      var linkname = args[2] || args[1] || '';
-      var linkpath = args[2] || '.';
-
-      link.link(linkname, linkpath, options.force);
-      break;
-
-    case 'registry':
-      options = readOptions(args, ['yes']);
-
-      if (options.yes)
-        ui.useDefaults();
-
-      var action = args[1];
-
-      if (action === 'config') {
-        if (!args[2])
-          return ui.log('warn', 'You must provide an registry name to configure.');
-        return Promise.resolve(registry.configure(args[2]))
-        .then(function() {
-          ui.log('ok', 'Registry %' + args[2] + '% configured successfully.');
-        }, function(err) {
-          ui.log('err', err.stack || err);
-        });
-      }
-      else if (action === 'create') {
-        if (!args[2])
-          return ui.log('warn', 'You must provide an registry name to create.');
-        if (!args[3])
-          return ui.log('warn', 'You must provide the registry module name to generate from.');
-        return Promise.resolve(registry.create(args[2], args[3]))
-        .then(function(created) {
-          if (created)
-            ui.log('ok', 'Enpoint %' + args[2] + '% created successfully.');
-        }, function(err) {
-          ui.log('err', err.stack || err);
-        });
-      }
-      else if (action === 'export') {
-        if (!args[2])
-          return ui.log('warn', 'You must provide an registry name to export.');
-        if (!globalConfig.config.registries[args[2]])
-          return ui.log('warn', 'Registry %' + args[2] + '% does not exist.');
-
-        var registryConfig = globalConfig.config.registries[args[2]];
-
-        dwalk(registryConfig, function(p, value) {
-          process.stdout.write('jspm config registries.' + args[2] + '.' + p + ' ' + value + '\n');
-        });
-      }
-      else {
-        showInstructions();
-        ui.log('warn', 'Invalid registry argument %' + args[1] + '%.');
-      }
-      break;
-
-    case 'c':
-    case 'config':
-      var property = args[1];
-      var value = readValue(args.splice(2).join(' '));
-      globalConfig.set(property, value);
-      break;
-
-    case 'cc':
-    case 'cache-clear':
-      core.cacheClear();
-      break;
-
-    case '--help':
-    case '-h':
-      showInstructions();
-      break;
-
-    case '--version':
-    case '-v':
-      showVersion();
-      break;
-
-    default:
-      showInstructions();
-      if (args[0])
-        ui.log('warn', 'Invalid argument %' + args[0] + '%.');
-  }
-})();
Index: node_modules/jspm/jspm.js
===================================================================
--- node_modules/jspm/jspm.js	(revision )
+++ node_modules/jspm/jspm.js	(revision )
@@ -1,43 +0,0 @@
-#!/usr/bin/env node
-
-/*
- *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)
- *
- *   Licensed under the Apache License, Version 2.0 (the "License");
- *   you may not use this file except in compliance with the License.
- *   You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *   Unless required by applicable law or agreed to in writing, software
- *   distributed under the License is distributed on an "AS IS" BASIS,
- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *   See the License for the specific language governing permissions and
- *   limitations under the License.
- */
-
-var Liftoff = require('liftoff');
-var path = require('path');
-
-var jspmCLI = new Liftoff({
-  name: 'jspm',
-  configName: 'package',
-  extensions: {
-    '.json': null
-  }
-});
-
-var args = process.argv.slice(2);
-var cwdArgIndex = args.indexOf('--cwd');
-if (cwdArgIndex > -1) {
-  process.chdir(args[cwdArgIndex + 1]);
-}
-
-jspmCLI.launch({ cwd: process.cwd() }, function(env) {
-  process.env.jspmConfigPath = env.configPath || '';
-  process.env.globalJspm = !env.modulePath;
-  if (env.modulePath)
-    require(path.resolve(env.modulePath, '../cli'));
-  else
-    require('./cli');
-});
Index: node_modules/jspm/LICENSE
===================================================================
--- node_modules/jspm/LICENSE	(revision )
+++ node_modules/jspm/LICENSE	(revision )
@@ -1,202 +0,0 @@
-
-                                 Apache License
-                           Version 2.0, January 2011
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
\ No newline at end of file
Index: node_modules/jspm/CONTRIBUTORS
===================================================================
--- node_modules/jspm/CONTRIBUTORS	(revision )
+++ node_modules/jspm/CONTRIBUTORS	(revision )
@@ -1,49 +0,0 @@
-Guy Bedford <guybedford@gmail.com>
-Anurag Priyam <anurag08priyam@gmail.com>
-Jarred de Beer <jarr2000@gmail.com>
-Peter Robins <github@peterrobins.co.uk>
-Lindsey Dew <lindsey.dew@guardian.co.uk>
-Toran Billups <toranb@gmail.com>
-Max Peterson <computmaxer@gmail.com>
-James Pamplin <james.pamplin@guardian.co.uk>
-Tauren Mills <Tauren.Mills@nike.com>
-Duy Nguyen <duyn.ng@gmail.com>
-Joseph Orbegoso Pea <joe@trusktr.io>
-Aleksandar Djindjic <djindjic@gmail.com>
-Mark Stickley <markstickley@theyakshack.co.uk>
-Chris Truter <jeffpalentine@gmail.com>
-Douglas Duteil <douglasduteil@gmail.com>
-subesokun <subesokun@gmail.com>
-Mark Stickley <marks@blinkbox.com>
-Guy Paterson-Jones <guy.paterson.jones@gmail.com>
-Adam Palinkas <adampalinkas@gmail.com>
-Sébastien Cevey <seb.cevey@guardian.co.uk>
-Suyash Verma <dextrous93@gmail.com>
-Gheric Speiginer <gheric.speiginer@gmail.com>
-David Blurton <david.blurton@gmail.com>
-Beni Buess <bbuess@astina.ch>
-Tyler Kellen <tyler@sleekcode.net>
-Jim Cummins <jim.for.cy@gmail.com>
-Christopher Bennage <christopher@bennage.com>
-Jack Franklin <jack@jackfranklin.net>
-Vsevolod Strukchinsky <floatdrop@gmail.com>
-Jon Stevens <latchkey@gmail.com> 
-Micah Zoltu <micah@zoltu.net> 
-Samuel Mehrbrodt <s.mehrbrodt@gmail.com>
-Chris Wheatley <chriswheatley87@gmail.com>
-Vladimir Matveev <vladima@microsoft.com>
-James Schultz <james.schultz.mn@mac.com>
-Eric Eastwood <contact@ericeastwood.com>
-Seth Mastous <mast0076@gmail.com>
-Jonathan Liuti <liuti.john@gmail.com>
-Josh Brown <joshua.anthony.brown@gmail.com>
-James Ravenscroft <web@jravenscroft.co.uk>
-Teoh Han Hui <teohhanhui@gmail.com>
-Oleksii Rudenko <oleksii.rudenko@n-fuse.de>
-Robert Kenny
-Shuhel Ahmed <shuhel@ymail.com>
-Laurent Goudet <lgoudet@gmail.com>
-Mato Ilic <info@matoilic.ch>
-Stefan Rumzucker <rumzucker@gmail.com>
-brillout
-Hampus Persson <h@hmps.se>
\ No newline at end of file
Index: node_modules/jspm/package.json
===================================================================
--- node_modules/jspm/package.json	(revision )
+++ node_modules/jspm/package.json	(revision )
@@ -1,68 +0,0 @@
-{
-  "name": "jspm",
-  "description": "Registry and format agnostic JavaScript package manager",
-  "version": "0.16.53",
-  "main": "./api.js",
-  "author": "",
-  "dependencies": {
-    "chalk": "^1.1.1",
-    "core-js": "^1.2.6",
-    "glob": "^6.0.1",
-    "graceful-fs": "^4.1.2",
-    "jspm-github": "^0.13.17",
-    "jspm-npm": "^0.26.12",
-    "jspm-registry": "^0.4.0",
-    "liftoff": "^2.2.0",
-    "minimatch": "^3.0.0",
-    "mkdirp": "~0.5.1",
-    "ncp": "^2.0.0",
-    "proper-lockfile": "^1.1.2",
-    "request": "^2.67.0",
-    "rimraf": "^2.4.4",
-    "rsvp": "^3.1.0",
-    "semver": "^5.1.0",
-    "systemjs": "0.19.46",
-    "systemjs-builder": "0.15.36",
-    "traceur": "0.0.105",
-    "uglify-js": "^2.6.1"
-  },
-  "registry": "npm",
-  "devDependencies": {
-    "istanbul": "^0.3.13",
-    "jshint": "~2.8.0",
-    "mocha": "~2.2.5"
-  },
-  "repository": {
-    "type": "git",
-    "url": "https://github.com/jspm/jspm.git"
-  },
-  "bin": {
-    "jspm": "./jspm.js"
-  },
-  "scripts": {
-    "test": "npm run jshint && npm run mocha",
-    "istanbul": "istanbul cover ./node_modules/.bin/_mocha -i='lib/**/*.js'",
-    "coverage": "npm run istanbul -- --report html",
-    "mocha": "mocha",
-    "jshint": "jshint api.js cli.js jspm.js lib test",
-    "gitbook": "gitbook build docs"
-  },
-  "bugs": {
-    "url": "https://github.com/jspm/jspm/issues"
-  },
-  "homepage": "https://github.com/jspm/jspm",
-  "directories": {
-    "test": "test"
-  },
-  "files": [
-    "lib",
-    "LICENSE",
-    "CONTRIBUTORS",
-    "README.md",
-    "api.js",
-    "cli.js",
-    "jspm.js",
-    "docs"
-  ],
-  "license": "Apache-2.0"
-}
Index: node_modules/eslint/bin/eslint.js
===================================================================
--- node_modules/eslint/bin/eslint.js	(revision )
+++ node_modules/eslint/bin/eslint.js	(revision )
@@ -1,75 +0,0 @@
-#!/usr/bin/env node
-
-/**
- * @fileoverview Main CLI that is run via the eslint command.
- * @author Nicholas C. Zakas
- */
-
-/* eslint no-console:off */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const useStdIn = (process.argv.indexOf("--stdin") > -1),
-    init = (process.argv.indexOf("--init") > -1),
-    debug = (process.argv.indexOf("--debug") > -1);
-
-// must do this initialization *before* other requires in order to work
-if (debug) {
-    require("debug").enable("eslint:*,-eslint:code-path");
-}
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-// now we can safely include the other modules that use debug
-const concat = require("concat-stream"),
-    cli = require("../lib/cli"),
-    path = require("path"),
-    fs = require("fs");
-
-//------------------------------------------------------------------------------
-// Execution
-//------------------------------------------------------------------------------
-
-process.once("uncaughtException", err => {
-
-    // lazy load
-    const lodash = require("lodash");
-
-    if (typeof err.messageTemplate === "string" && err.messageTemplate.length > 0) {
-        const template = lodash.template(fs.readFileSync(path.resolve(__dirname, `../messages/${err.messageTemplate}.txt`), "utf-8"));
-        const pkg = require("../package.json");
-
-        console.error("\nOops! Something went wrong! :(");
-        console.error(`\nESLint: ${pkg.version}.\n${template(err.messageData || {})}`);
-    } else {
-
-        console.error(err.message);
-        console.error(err.stack);
-    }
-
-    process.exitCode = 1;
-});
-
-if (useStdIn) {
-    process.stdin.pipe(concat({ encoding: "string" }, text => {
-        process.exitCode = cli.execute(process.argv, text);
-    }));
-} else if (init) {
-    const configInit = require("../lib/config/config-initializer");
-
-    configInit.initializeConfig().then(() => {
-        process.exitCode = 0;
-    }).catch(err => {
-        process.exitCode = 1;
-        console.error(err.message);
-        console.error(err.stack);
-    });
-} else {
-    process.exitCode = cli.execute(process.argv);
-}
Index: node_modules/eslint/lib/util/ajv.js
===================================================================
--- node_modules/eslint/lib/util/ajv.js	(revision )
+++ node_modules/eslint/lib/util/ajv.js	(revision )
@@ -1,29 +0,0 @@
-/**
- * @fileoverview The instance of Ajv validator.
- * @author Evgeny Poberezkin
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const Ajv = require("ajv"),
-    metaSchema = require("ajv/lib/refs/json-schema-draft-04.json");
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-const ajv = new Ajv({
-    meta: false,
-    validateSchema: false,
-    missingRefs: "ignore",
-    verbose: true
-});
-
-ajv.addMetaSchema(metaSchema);
-// eslint-disable-next-line no-underscore-dangle
-ajv._opts.defaultMeta = metaSchema.id;
-
-module.exports = ajv;
Index: node_modules/eslint/lib/util/glob.js
===================================================================
--- node_modules/eslint/lib/util/glob.js	(revision )
+++ node_modules/eslint/lib/util/glob.js	(revision )
@@ -1,63 +0,0 @@
-/**
- * @fileoverview An inherited `glob.GlobSync` to support .gitignore patterns.
- * @author Kael Zhang
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const Sync = require("glob").GlobSync,
-    util = require("util");
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-const IGNORE = Symbol("ignore");
-
-/**
- * Subclass of `glob.GlobSync`
- * @param {string}     pattern      Pattern to be matched.
- * @param {Object}     options      `options` for `glob`
- * @param {function()} shouldIgnore Method to check whether a directory should be ignored.
- * @constructor
- */
-function GlobSync(pattern, options, shouldIgnore) {
-
-    /**
-     * We don't put this thing to argument `options` to avoid
-     * further problems, such as `options` validation.
-     *
-     * Use `Symbol` as much as possible to avoid confliction.
-     */
-    this[IGNORE] = shouldIgnore;
-
-    Sync.call(this, pattern, options);
-}
-
-util.inherits(GlobSync, Sync);
-
-/* eslint no-underscore-dangle: ["error", { "allow": ["_readdir", "_mark"] }] */
-
-GlobSync.prototype._readdir = function(abs, inGlobStar) {
-
-    /**
-     * `options.nodir` makes `options.mark` as `true`.
-     * Mark `abs` first
-     * to make sure `"node_modules"` will be ignored immediately with ignore pattern `"node_modules/"`.
-
-     * There is a built-in cache about marked `File.Stat` in `glob`, so that we could not worry about the extra invocation of `this._mark()`
-     */
-    const marked = this._mark(abs);
-
-    if (this[IGNORE](marked)) {
-        return null;
-    }
-
-    return Sync.prototype._readdir.call(this, abs, inGlobStar);
-};
-
-
-module.exports = GlobSync;
Index: node_modules/eslint/lib/util/hash.js
===================================================================
--- node_modules/eslint/lib/util/hash.js	(revision )
+++ node_modules/eslint/lib/util/hash.js	(revision )
@@ -1,35 +0,0 @@
-/**
- * @fileoverview Defining the hashing function in one place.
- * @author Michael Ficarra
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const murmur = require("imurmurhash");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-/**
- * hash the given string
- * @param  {string} str the string to hash
- * @returns {string}    the hash
- */
-function hash(str) {
-    return murmur(str).result().toString(36);
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = hash;
Index: node_modules/eslint/lib/util/patterns/letters.js
===================================================================
--- node_modules/eslint/lib/util/patterns/letters.js	(revision )
+++ node_modules/eslint/lib/util/patterns/letters.js	(revision )
@@ -1,36 +0,0 @@
-/**
- * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).
- * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js
- * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.
- * @author Kevin Partington
- * @license MIT License (from JSCS). See below.
- */
-
-/*
- * The MIT License (MIT)
- *
- * Copyright 2013-2016 Dulin Marat and other contributors
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-"use strict";
-
-module.exports = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/;
Index: node_modules/eslint/lib/util/keywords.js
===================================================================
--- node_modules/eslint/lib/util/keywords.js	(revision )
+++ node_modules/eslint/lib/util/keywords.js	(revision )
@@ -1,67 +0,0 @@
-/**
- * @fileoverview A shared list of ES3 keywords.
- * @author Josh Perez
- */
-"use strict";
-
-module.exports = [
-    "abstract",
-    "boolean",
-    "break",
-    "byte",
-    "case",
-    "catch",
-    "char",
-    "class",
-    "const",
-    "continue",
-    "debugger",
-    "default",
-    "delete",
-    "do",
-    "double",
-    "else",
-    "enum",
-    "export",
-    "extends",
-    "false",
-    "final",
-    "finally",
-    "float",
-    "for",
-    "function",
-    "goto",
-    "if",
-    "implements",
-    "import",
-    "in",
-    "instanceof",
-    "int",
-    "interface",
-    "long",
-    "native",
-    "new",
-    "null",
-    "package",
-    "private",
-    "protected",
-    "public",
-    "return",
-    "short",
-    "static",
-    "super",
-    "switch",
-    "synchronized",
-    "this",
-    "throw",
-    "throws",
-    "transient",
-    "true",
-    "try",
-    "typeof",
-    "var",
-    "void",
-    "volatile",
-    "while",
-    "with"
-];
Index: node_modules/eslint/lib/util/npm-util.js
===================================================================
--- node_modules/eslint/lib/util/npm-util.js	(revision )
+++ node_modules/eslint/lib/util/npm-util.js	(revision )
@@ -1,179 +0,0 @@
-/**
- * @fileoverview Utility for executing npm commands.
- * @author Ian VanSchooten
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const fs = require("fs"),
-    spawn = require("cross-spawn"),
-    path = require("path"),
-    log = require("../logging");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Find the closest package.json file, starting at process.cwd (by default),
- * and working up to root.
- *
- * @param   {string} [startDir=process.cwd()] Starting directory
- * @returns {string}                          Absolute path to closest package.json file
- */
-function findPackageJson(startDir) {
-    let dir = path.resolve(startDir || process.cwd());
-
-    do {
-        const pkgFile = path.join(dir, "package.json");
-
-        if (!fs.existsSync(pkgFile) || !fs.statSync(pkgFile).isFile()) {
-            dir = path.join(dir, "..");
-            continue;
-        }
-        return pkgFile;
-    } while (dir !== path.resolve(dir, ".."));
-    return null;
-}
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-/**
- * Install node modules synchronously and save to devDependencies in package.json
- * @param   {string|string[]} packages Node module or modules to install
- * @returns {void}
- */
-function installSyncSaveDev(packages) {
-    if (!Array.isArray(packages)) {
-        packages = [packages];
-    }
-    const npmProcess = spawn.sync("npm", ["i", "--save-dev"].concat(packages),
-        { stdio: "inherit" });
-    const error = npmProcess.error;
-
-    if (error && error.code === "ENOENT") {
-        const pluralS = packages.length > 1 ? "s" : "";
-
-        log.error(`Could not execute npm. Please install the following package${pluralS} with your package manager of choice: ${packages.join(", ")}`);
-    }
-}
-
-/**
- * Fetch `peerDependencies` of the given package by `npm show` command.
- * @param {string} packageName The package name to fetch peerDependencies.
- * @returns {Object} Gotten peerDependencies. Returns null if npm was not found.
- */
-function fetchPeerDependencies(packageName) {
-    const npmProcess = spawn.sync(
-        "npm",
-        ["show", "--json", packageName, "peerDependencies"],
-        { encoding: "utf8" }
-    );
-
-    const error = npmProcess.error;
-
-    if (error && error.code === "ENOENT") {
-        return null;
-    }
-    const fetchedText = npmProcess.stdout.trim();
-
-    return JSON.parse(fetchedText || "{}");
-
-
-}
-
-/**
- * Check whether node modules are include in a project's package.json.
- *
- * @param   {string[]} packages           Array of node module names
- * @param   {Object}  opt                 Options Object
- * @param   {boolean} opt.dependencies    Set to true to check for direct dependencies
- * @param   {boolean} opt.devDependencies Set to true to check for development dependencies
- * @param   {boolean} opt.startdir        Directory to begin searching from
- * @returns {Object}                      An object whose keys are the module names
- *                                        and values are booleans indicating installation.
- */
-function check(packages, opt) {
-    let deps = [];
-    const pkgJson = (opt) ? findPackageJson(opt.startDir) : findPackageJson();
-    let fileJson;
-
-    if (!pkgJson) {
-        throw new Error("Could not find a package.json file. Run 'npm init' to create one.");
-    }
-
-    try {
-        fileJson = JSON.parse(fs.readFileSync(pkgJson, "utf8"));
-    } catch (e) {
-        log.info("Could not read package.json file. Please check that the file contains valid JSON.");
-        throw new Error(e);
-    }
-
-    if (opt.devDependencies && typeof fileJson.devDependencies === "object") {
-        deps = deps.concat(Object.keys(fileJson.devDependencies));
-    }
-    if (opt.dependencies && typeof fileJson.dependencies === "object") {
-        deps = deps.concat(Object.keys(fileJson.dependencies));
-    }
-    return packages.reduce((status, pkg) => {
-        status[pkg] = deps.indexOf(pkg) !== -1;
-        return status;
-    }, {});
-}
-
-/**
- * Check whether node modules are included in the dependencies of a project's
- * package.json.
- *
- * Convienience wrapper around check().
- *
- * @param   {string[]} packages  Array of node modules to check.
- * @param   {string}   rootDir   The directory contianing a package.json
- * @returns {Object}             An object whose keys are the module names
- *                               and values are booleans indicating installation.
- */
-function checkDeps(packages, rootDir) {
-    return check(packages, { dependencies: true, startDir: rootDir });
-}
-
-/**
- * Check whether node modules are included in the devDependencies of a project's
- * package.json.
- *
- * Convienience wrapper around check().
- *
- * @param   {string[]} packages  Array of node modules to check.
- * @returns {Object}             An object whose keys are the module names
- *                               and values are booleans indicating installation.
- */
-function checkDevDeps(packages) {
-    return check(packages, { devDependencies: true });
-}
-
-/**
- * Check whether package.json is found in current path.
- *
- * @param   {string=} startDir Starting directory
- * @returns {boolean} Whether a package.json is found in current path.
- */
-function checkPackageJson(startDir) {
-    return !!findPackageJson(startDir);
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = {
-    installSyncSaveDev,
-    fetchPeerDependencies,
-    checkDeps,
-    checkDevDeps,
-    checkPackageJson
-};
Index: node_modules/eslint/lib/util/glob-util.js
===================================================================
--- node_modules/eslint/lib/util/glob-util.js	(revision )
+++ node_modules/eslint/lib/util/glob-util.js	(revision )
@@ -1,182 +0,0 @@
-/**
- * @fileoverview Utilities for working with globs and the filesystem.
- * @author Ian VanSchooten
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const fs = require("fs"),
-    path = require("path"),
-    GlobSync = require("./glob"),
-
-    pathUtil = require("./path-util"),
-    IgnoredPaths = require("../ignored-paths");
-
-const debug = require("debug")("eslint:glob-util");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks if a provided path is a directory and returns a glob string matching
- * all files under that directory if so, the path itself otherwise.
- *
- * Reason for this is that `glob` needs `/**` to collect all the files under a
- * directory where as our previous implementation without `glob` simply walked
- * a directory that is passed. So this is to maintain backwards compatibility.
- *
- * Also makes sure all path separators are POSIX style for `glob` compatibility.
- *
- * @param {Object}   [options]                    An options object
- * @param {string[]} [options.extensions=[".js"]] An array of accepted extensions
- * @param {string}   [options.cwd=process.cwd()]  The cwd to use to resolve relative pathnames
- * @returns {Function} A function that takes a pathname and returns a glob that
- *                     matches all files with the provided extensions if
- *                     pathname is a directory.
- */
-function processPath(options) {
-    const cwd = (options && options.cwd) || process.cwd();
-    let extensions = (options && options.extensions) || [".js"];
-
-    extensions = extensions.map(ext => ext.replace(/^\./, ""));
-
-    let suffix = "/**";
-
-    if (extensions.length === 1) {
-        suffix += `/*.${extensions[0]}`;
-    } else {
-        suffix += `/*.{${extensions.join(",")}}`;
-    }
-
-    /**
-     * A function that converts a directory name to a glob pattern
-     *
-     * @param {string} pathname The directory path to be modified
-     * @returns {string} The glob path or the file path itself
-     * @private
-     */
-    return function(pathname) {
-        let newPath = pathname;
-        const resolvedPath = path.resolve(cwd, pathname);
-
-        if (fs.existsSync(resolvedPath) && fs.statSync(resolvedPath).isDirectory()) {
-            newPath = pathname.replace(/[/\\]$/, "") + suffix;
-        }
-
-        return pathUtil.convertPathToPosix(newPath);
-    };
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * Resolves any directory patterns into glob-based patterns for easier handling.
- * @param   {string[]} patterns    File patterns (such as passed on the command line).
- * @param   {Object} options       An options object.
- * @returns {string[]} The equivalent glob patterns and filepath strings.
- */
-function resolveFileGlobPatterns(patterns, options) {
-
-    const processPathExtensions = processPath(options);
-
-    return patterns.filter(p => p.length).map(processPathExtensions);
-}
-
-/**
- * Build a list of absolute filesnames on which ESLint will act.
- * Ignored files are excluded from the results, as are duplicates.
- *
- * @param   {string[]} globPatterns            Glob patterns.
- * @param   {Object}   [options]               An options object.
- * @param   {string}   [options.cwd]           CWD (considered for relative filenames)
- * @param   {boolean}  [options.ignore]        False disables use of .eslintignore.
- * @param   {string}   [options.ignorePath]    The ignore file to use instead of .eslintignore.
- * @param   {string}   [options.ignorePattern] A pattern of files to ignore.
- * @returns {string[]} Resolved absolute filenames.
- */
-function listFilesToProcess(globPatterns, options) {
-    options = options || { ignore: true };
-    const files = [],
-        added = {};
-
-    const cwd = (options && options.cwd) || process.cwd();
-
-    /**
-     * Executes the linter on a file defined by the `filename`. Skips
-     * unsupported file extensions and any files that are already linted.
-     * @param {string} filename The file to be processed
-     * @param {boolean} shouldWarnIgnored Whether or not a report should be made if
-     *                                    the file is ignored
-     * @param {IgnoredPaths} ignoredPaths An instance of IgnoredPaths
-     * @returns {void}
-     */
-    function addFile(filename, shouldWarnIgnored, ignoredPaths) {
-        let ignored = false;
-        let isSilentlyIgnored;
-
-        if (ignoredPaths.contains(filename, "default")) {
-            ignored = (options.ignore !== false) && shouldWarnIgnored;
-            isSilentlyIgnored = !shouldWarnIgnored;
-        }
-
-        if (options.ignore !== false) {
-            if (ignoredPaths.contains(filename, "custom")) {
-                if (shouldWarnIgnored) {
-                    ignored = true;
-                } else {
-                    isSilentlyIgnored = true;
-                }
-            }
-        }
-
-        if (isSilentlyIgnored && !ignored) {
-            return;
-        }
-
-        if (added[filename]) {
-            return;
-        }
-        files.push({ filename, ignored });
-        added[filename] = true;
-    }
-
-    debug("Creating list of files to process.");
-    globPatterns.forEach(pattern => {
-        const file = path.resolve(cwd, pattern);
-
-        if (fs.existsSync(file) && fs.statSync(file).isFile()) {
-            const ignoredPaths = new IgnoredPaths(options);
-
-            addFile(fs.realpathSync(file), true, ignoredPaths);
-        } else {
-
-            // regex to find .hidden or /.hidden patterns, but not ./relative or ../relative
-            const globIncludesDotfiles = /(?:(?:^\.)|(?:[/\\]\.))[^/\\.].*/.test(pattern);
-
-            const ignoredPaths = new IgnoredPaths(Object.assign({}, options, { dotfiles: options.dotfiles || globIncludesDotfiles }));
-            const shouldIgnore = ignoredPaths.getIgnoredFoldersGlobChecker();
-            const globOptions = {
-                nodir: true,
-                dot: true,
-                cwd
-            };
-
-            new GlobSync(pattern, globOptions, shouldIgnore).found.forEach(globMatch => {
-                addFile(path.resolve(cwd, globMatch), false, ignoredPaths);
-            });
-        }
-    });
-
-    return files;
-}
-
-module.exports = {
-    resolveFileGlobPatterns,
-    listFilesToProcess
-};
Index: node_modules/eslint/lib/util/path-util.js
===================================================================
--- node_modules/eslint/lib/util/path-util.js	(revision )
+++ node_modules/eslint/lib/util/path-util.js	(revision )
@@ -1,74 +0,0 @@
-/**
- * @fileoverview Common helpers for operations on filenames and paths
- * @author Ian VanSchooten
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const path = require("path");
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-/**
- * Replace Windows with posix style paths
- *
- * @param {string} filepath   Path to convert
- * @returns {string}          Converted filepath
- */
-function convertPathToPosix(filepath) {
-    const normalizedFilepath = path.normalize(filepath);
-    const posixFilepath = normalizedFilepath.replace(/\\/g, "/");
-
-    return posixFilepath;
-}
-
-/**
- * Converts an absolute filepath to a relative path from a given base path
- *
- * For example, if the filepath is `/my/awesome/project/foo.bar`,
- * and the base directory is `/my/awesome/project/`,
- * then this function should return `foo.bar`.
- *
- * path.relative() does something similar, but it requires a baseDir (`from` argument).
- * This function makes it optional and just removes a leading slash if the baseDir is not given.
- *
- * It does not take into account symlinks (for now).
- *
- * @param {string} filepath  Path to convert to relative path.  If already relative,
- *                           it will be assumed to be relative to process.cwd(),
- *                           converted to absolute, and then processed.
- * @param {string} [baseDir] Absolute base directory to resolve the filepath from.
- *                           If not provided, all this function will do is remove
- *                           a leading slash.
- * @returns {string} Relative filepath
- */
-function getRelativePath(filepath, baseDir) {
-    let relativePath;
-
-    if (!path.isAbsolute(filepath)) {
-        filepath = path.resolve(filepath);
-    }
-    if (baseDir) {
-        if (!path.isAbsolute(baseDir)) {
-            throw new Error("baseDir should be an absolute path");
-        }
-        relativePath = path.relative(baseDir, filepath);
-    } else {
-        relativePath = filepath.replace(/^\//, "");
-    }
-    return relativePath;
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = {
-    convertPathToPosix,
-    getRelativePath
-};
Index: node_modules/eslint/lib/util/traverser.js
===================================================================
--- node_modules/eslint/lib/util/traverser.js	(revision )
+++ node_modules/eslint/lib/util/traverser.js	(revision )
@@ -1,45 +0,0 @@
-/**
- * @fileoverview Wrapper around estraverse
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const estraverse = require("estraverse");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const KEY_BLACKLIST = new Set([
-    "parent",
-    "leadingComments",
-    "trailingComments"
-]);
-
-/**
- * Wrapper around an estraverse controller that ensures the correct keys
- * are visited.
- * @constructor
- */
-class Traverser extends estraverse.Controller {
-    traverse(node, visitor) {
-        visitor.fallback = Traverser.getKeys;
-        return super.traverse(node, visitor);
-    }
-
-    /**
-     * Calculates the keys to use for traversal.
-     * @param {ASTNode} node The node to read keys from.
-     * @returns {string[]} An array of keys to visit on the node.
-     * @private
-     */
-    static getKeys(node) {
-        return Object.keys(node).filter(key => !KEY_BLACKLIST.has(key));
-    }
-}
-
-module.exports = Traverser;
Index: node_modules/eslint/lib/util/rule-fixer.js
===================================================================
--- node_modules/eslint/lib/util/rule-fixer.js	(revision )
+++ node_modules/eslint/lib/util/rule-fixer.js	(revision )
@@ -1,140 +0,0 @@
-/**
- * @fileoverview An object that creates fix commands for rules.
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-// none!
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Creates a fix command that inserts text at the specified index in the source text.
- * @param {int} index The 0-based index at which to insert the new text.
- * @param {string} text The text to insert.
- * @returns {Object} The fix command.
- * @private
- */
-function insertTextAt(index, text) {
-    return {
-        range: [index, index],
-        text
-    };
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * Creates code fixing commands for rules.
- */
-
-const ruleFixer = Object.freeze({
-
-    /**
-     * Creates a fix command that inserts text after the given node or token.
-     * The fix is not applied until applyFixes() is called.
-     * @param {ASTNode|Token} nodeOrToken The node or token to insert after.
-     * @param {string} text The text to insert.
-     * @returns {Object} The fix command.
-     */
-    insertTextAfter(nodeOrToken, text) {
-        return this.insertTextAfterRange(nodeOrToken.range, text);
-    },
-
-    /**
-     * Creates a fix command that inserts text after the specified range in the source text.
-     * The fix is not applied until applyFixes() is called.
-     * @param {int[]} range The range to replace, first item is start of range, second
-     *      is end of range.
-     * @param {string} text The text to insert.
-     * @returns {Object} The fix command.
-     */
-    insertTextAfterRange(range, text) {
-        return insertTextAt(range[1], text);
-    },
-
-    /**
-     * Creates a fix command that inserts text before the given node or token.
-     * The fix is not applied until applyFixes() is called.
-     * @param {ASTNode|Token} nodeOrToken The node or token to insert before.
-     * @param {string} text The text to insert.
-     * @returns {Object} The fix command.
-     */
-    insertTextBefore(nodeOrToken, text) {
-        return this.insertTextBeforeRange(nodeOrToken.range, text);
-    },
-
-    /**
-     * Creates a fix command that inserts text before the specified range in the source text.
-     * The fix is not applied until applyFixes() is called.
-     * @param {int[]} range The range to replace, first item is start of range, second
-     *      is end of range.
-     * @param {string} text The text to insert.
-     * @returns {Object} The fix command.
-     */
-    insertTextBeforeRange(range, text) {
-        return insertTextAt(range[0], text);
-    },
-
-    /**
-     * Creates a fix command that replaces text at the node or token.
-     * The fix is not applied until applyFixes() is called.
-     * @param {ASTNode|Token} nodeOrToken The node or token to remove.
-     * @param {string} text The text to insert.
-     * @returns {Object} The fix command.
-     */
-    replaceText(nodeOrToken, text) {
-        return this.replaceTextRange(nodeOrToken.range, text);
-    },
-
-    /**
-     * Creates a fix command that replaces text at the specified range in the source text.
-     * The fix is not applied until applyFixes() is called.
-     * @param {int[]} range The range to replace, first item is start of range, second
-     *      is end of range.
-     * @param {string} text The text to insert.
-     * @returns {Object} The fix command.
-     */
-    replaceTextRange(range, text) {
-        return {
-            range,
-            text
-        };
-    },
-
-    /**
-     * Creates a fix command that removes the node or token from the source.
-     * The fix is not applied until applyFixes() is called.
-     * @param {ASTNode|Token} nodeOrToken The node or token to remove.
-     * @returns {Object} The fix command.
-     */
-    remove(nodeOrToken) {
-        return this.removeRange(nodeOrToken.range);
-    },
-
-    /**
-     * Creates a fix command that removes the specified range of text from the source.
-     * The fix is not applied until applyFixes() is called.
-     * @param {int[]} range The range to remove, first item is start of range, second
-     *      is end of range.
-     * @returns {Object} The fix command.
-     */
-    removeRange(range) {
-        return {
-            range,
-            text: ""
-        };
-    }
-
-});
-
-
-module.exports = ruleFixer;
Index: node_modules/eslint/lib/util/xml-escape.js
===================================================================
--- node_modules/eslint/lib/util/xml-escape.js	(revision )
+++ node_modules/eslint/lib/util/xml-escape.js	(revision )
@@ -1,34 +0,0 @@
-/**
- * @fileoverview XML character escaper
- * @author George Chung
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * Returns the escaped value for a character
- * @param {string} s string to examine
- * @returns {string} severity level
- * @private
- */
-module.exports = function(s) {
-    return (`${s}`).replace(/[<>&"'\x00-\x1F\x7F\u0080-\uFFFF]/g, c => { // eslint-disable-line no-control-regex
-        switch (c) {
-            case "<":
-                return "&lt;";
-            case ">":
-                return "&gt;";
-            case "&":
-                return "&amp;";
-            case "\"":
-                return "&quot;";
-            case "'":
-                return "&apos;";
-            default:
-                return `&#${c.charCodeAt(0)};`;
-        }
-    });
-};
Index: node_modules/eslint/lib/util/fix-tracker.js
===================================================================
--- node_modules/eslint/lib/util/fix-tracker.js	(revision )
+++ node_modules/eslint/lib/util/fix-tracker.js	(revision )
@@ -1,120 +0,0 @@
-/**
- * @fileoverview Helper class to aid in constructing fix commands.
- * @author Alan Pierce
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * A helper class to combine fix options into a fix command. Currently, it
- * exposes some "retain" methods that extend the range of the text being
- * replaced so that other fixes won't touch that region in the same pass.
- */
-class FixTracker {
-
-    /**
-     * Create a new FixTracker.
-     *
-     * @param {ruleFixer} fixer A ruleFixer instance.
-     * @param {SourceCode} sourceCode A SourceCode object for the current code.
-     */
-    constructor(fixer, sourceCode) {
-        this.fixer = fixer;
-        this.sourceCode = sourceCode;
-        this.retainedRange = null;
-    }
-
-    /**
-     * Mark the given range as "retained", meaning that other fixes may not
-     * may not modify this region in the same pass.
-     *
-     * @param {int[]} range The range to retain.
-     * @returns {FixTracker} The same RuleFixer, for chained calls.
-     */
-    retainRange(range) {
-        this.retainedRange = range;
-        return this;
-    }
-
-    /**
-     * Given a node, find the function containing it (or the entire program) and
-     * mark it as retained, meaning that other fixes may not modify it in this
-     * pass. This is useful for avoiding conflicts in fixes that modify control
-     * flow.
-     *
-     * @param {ASTNode} node The node to use as a starting point.
-     * @returns {FixTracker} The same RuleFixer, for chained calls.
-     */
-    retainEnclosingFunction(node) {
-        const functionNode = astUtils.getUpperFunction(node);
-
-        return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);
-    }
-
-    /**
-     * Given a node or token, find the token before and afterward, and mark that
-     * range as retained, meaning that other fixes may not modify it in this
-     * pass. This is useful for avoiding conflicts in fixes that make a small
-     * change to the code where the AST should not be changed.
-     *
-     * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting
-     *      point. The token to the left and right are use in the range.
-     * @returns {FixTracker} The same RuleFixer, for chained calls.
-     */
-    retainSurroundingTokens(nodeOrToken) {
-        const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;
-        const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;
-
-        return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);
-    }
-
-    /**
-     * Create a fix command that replaces the given range with the given text,
-     * accounting for any retained ranges.
-     *
-     * @param {int[]} range The range to remove in the fix.
-     * @param {string} text The text to insert in place of the range.
-     * @returns {Object} The fix command.
-     */
-    replaceTextRange(range, text) {
-        let actualRange;
-
-        if (this.retainedRange) {
-            actualRange = [
-                Math.min(this.retainedRange[0], range[0]),
-                Math.max(this.retainedRange[1], range[1])
-            ];
-        } else {
-            actualRange = range;
-        }
-
-        return this.fixer.replaceTextRange(
-            actualRange,
-            this.sourceCode.text.slice(actualRange[0], range[0]) +
-                text +
-                this.sourceCode.text.slice(range[1], actualRange[1])
-        );
-    }
-
-    /**
-     * Create a fix command that removes the given node or token, accounting for
-     * any retained ranges.
-     *
-     * @param {ASTNode|Token} nodeOrToken The node or token to remove.
-     * @returns {Object} The fix command.
-     */
-    remove(nodeOrToken) {
-        return this.replaceTextRange(nodeOrToken.range, "");
-    }
-}
-
-module.exports = FixTracker;
Index: node_modules/eslint/lib/util/source-code.js
===================================================================
--- node_modules/eslint/lib/util/source-code.js	(revision )
+++ node_modules/eslint/lib/util/source-code.js	(revision )
@@ -1,465 +0,0 @@
-/**
- * @fileoverview Abstraction of JavaScript source code.
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const TokenStore = require("../token-store"),
-    Traverser = require("./traverser"),
-    astUtils = require("../ast-utils"),
-    lodash = require("lodash");
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-/**
- * Validates that the given AST has the required information.
- * @param {ASTNode} ast The Program node of the AST to check.
- * @throws {Error} If the AST doesn't contain the correct information.
- * @returns {void}
- * @private
- */
-function validate(ast) {
-
-    if (!ast.tokens) {
-        throw new Error("AST is missing the tokens array.");
-    }
-
-    if (!ast.comments) {
-        throw new Error("AST is missing the comments array.");
-    }
-
-    if (!ast.loc) {
-        throw new Error("AST is missing location information.");
-    }
-
-    if (!ast.range) {
-        throw new Error("AST is missing range information");
-    }
-}
-
-/**
- * Finds a JSDoc comment node in an array of comment nodes.
- * @param {ASTNode[]} comments The array of comment nodes to search.
- * @param {int} line Line number to look around
- * @returns {ASTNode} The node if found, null if not.
- * @private
- */
-function findJSDocComment(comments, line) {
-
-    if (comments) {
-        for (let i = comments.length - 1; i >= 0; i--) {
-            if (comments[i].type === "Block" && comments[i].value.charAt(0) === "*") {
-
-                if (line - comments[i].loc.end.line <= 1) {
-                    return comments[i];
-                }
-                break;
-
-            }
-        }
-    }
-
-    return null;
-}
-
-/**
- * Check to see if its a ES6 export declaration
- * @param {ASTNode} astNode - any node
- * @returns {boolean} whether the given node represents a export declaration
- * @private
- */
-function looksLikeExport(astNode) {
-    return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" ||
-        astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
-}
-
-/**
- * Merges two sorted lists into a larger sorted list in O(n) time
- * @param {Token[]} tokens The list of tokens
- * @param {Token[]} comments The list of comments
- * @returns {Token[]} A sorted list of tokens and comments
- */
-function sortedMerge(tokens, comments) {
-    const result = [];
-    let tokenIndex = 0;
-    let commentIndex = 0;
-
-    while (tokenIndex < tokens.length || commentIndex < comments.length) {
-        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {
-            result.push(tokens[tokenIndex++]);
-        } else {
-            result.push(comments[commentIndex++]);
-        }
-    }
-
-    return result;
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-class SourceCode extends TokenStore {
-
-    /**
-     * Represents parsed source code.
-     * @param {string} text - The source code text.
-     * @param {ASTNode} ast - The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
-     * @constructor
-     */
-    constructor(text, ast) {
-        validate(ast);
-
-        super(ast.tokens, ast.comments);
-
-        /**
-         * The flag to indicate that the source code has Unicode BOM.
-         * @type boolean
-         */
-        this.hasBOM = (text.charCodeAt(0) === 0xFEFF);
-
-        /**
-         * The original text source code.
-         * BOM was stripped from this text.
-         * @type string
-         */
-        this.text = (this.hasBOM ? text.slice(1) : text);
-
-        /**
-         * The parsed AST for the source code.
-         * @type ASTNode
-         */
-        this.ast = ast;
-
-        // Check the source text for the presence of a shebang since it is parsed as a standard line comment.
-        const shebangMatched = this.text.match(astUtils.SHEBANG_MATCHER);
-        const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];
-
-        if (hasShebang) {
-            ast.comments[0].type = "Shebang";
-        }
-
-        this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);
-
-        /**
-         * The source code split into lines according to ECMA-262 specification.
-         * This is done to avoid each rule needing to do so separately.
-         * @type string[]
-         */
-        this.lines = [];
-        this.lineStartIndices = [0];
-
-        const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
-        let match;
-
-        /*
-         * Previously, this was implemented using a regex that
-         * matched a sequence of non-linebreak characters followed by a
-         * linebreak, then adding the lengths of the matches. However,
-         * this caused a catastrophic backtracking issue when the end
-         * of a file contained a large number of non-newline characters.
-         * To avoid this, the current implementation just matches newlines
-         * and uses match.index to get the correct line start indices.
-         */
-        while ((match = lineEndingPattern.exec(this.text))) {
-            this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
-            this.lineStartIndices.push(match.index + match[0].length);
-        }
-        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));
-
-        // Cache for comments found using getComments().
-        this._commentCache = new WeakMap();
-
-        // don't allow modification of this object
-        Object.freeze(this);
-        Object.freeze(this.lines);
-    }
-
-    /**
-     * Split the source code into multiple lines based on the line delimiters
-     * @param {string} text Source code as a string
-     * @returns {string[]} Array of source code lines
-     * @public
-     */
-    static splitLines(text) {
-        return text.split(astUtils.createGlobalLinebreakMatcher());
-    }
-
-    /**
-     * Gets the source code for the given node.
-     * @param {ASTNode=} node The AST node to get the text for.
-     * @param {int=} beforeCount The number of characters before the node to retrieve.
-     * @param {int=} afterCount The number of characters after the node to retrieve.
-     * @returns {string} The text representing the AST node.
-     */
-    getText(node, beforeCount, afterCount) {
-        if (node) {
-            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),
-                node.range[1] + (afterCount || 0));
-        }
-        return this.text;
-    }
-
-    /**
-     * Gets the entire source text split into an array of lines.
-     * @returns {Array} The source text as an array of lines.
-     */
-    getLines() {
-        return this.lines;
-    }
-
-    /**
-     * Retrieves an array containing all comments in the source code.
-     * @returns {ASTNode[]} An array of comment nodes.
-     */
-    getAllComments() {
-        return this.ast.comments;
-    }
-
-    /**
-     * Gets all comments for the given node.
-     * @param {ASTNode} node The AST node to get the comments for.
-     * @returns {Object} The list of comments indexed by their position.
-     * @public
-     */
-    getComments(node) {
-        if (this._commentCache.has(node)) {
-            return this._commentCache.get(node);
-        }
-
-        const comments = {
-            leading: [],
-            trailing: []
-        };
-
-        /*
-         * Return all comments as leading comments of the Program node when
-         * there is no executable code.
-         */
-        if (node.type === "Program") {
-            if (node.body.length === 0) {
-                comments.leading = node.comments;
-            }
-        } else {
-
-            /* Return comments as trailing comments of nodes that only contain
-             * comments (to mimic the comment attachment behavior present in Espree).
-             */
-            if ((node.type === "BlockStatement" || node.type === "ClassBody") && node.body.length === 0 ||
-                node.type === "ObjectExpression" && node.properties.length === 0 ||
-                node.type === "ArrayExpression" && node.elements.length === 0 ||
-                node.type === "SwitchStatement" && node.cases.length === 0
-            ) {
-                comments.trailing = this.getTokens(node, {
-                    includeComments: true,
-                    filter: astUtils.isCommentToken
-                });
-            }
-
-            /*
-             * Iterate over tokens before and after node and collect comment tokens.
-             * Do not include comments that exist outside of the parent node
-             * to avoid duplication.
-             */
-            let currentToken = this.getTokenBefore(node, { includeComments: true });
-
-            while (currentToken && astUtils.isCommentToken(currentToken)) {
-                if (node.parent && (currentToken.start < node.parent.start)) {
-                    break;
-                }
-                comments.leading.push(currentToken);
-                currentToken = this.getTokenBefore(currentToken, { includeComments: true });
-            }
-
-            comments.leading.reverse();
-
-            currentToken = this.getTokenAfter(node, { includeComments: true });
-
-            while (currentToken && astUtils.isCommentToken(currentToken)) {
-                if (node.parent && (currentToken.end > node.parent.end)) {
-                    break;
-                }
-                comments.trailing.push(currentToken);
-                currentToken = this.getTokenAfter(currentToken, { includeComments: true });
-            }
-        }
-
-        this._commentCache.set(node, comments);
-        return comments;
-    }
-
-    /**
-     * Retrieves the JSDoc comment for a given node.
-     * @param {ASTNode} node The AST node to get the comment for.
-     * @returns {ASTNode} The Block comment node containing the JSDoc for the
-     *      given node or null if not found.
-     * @public
-     */
-    getJSDocComment(node) {
-        let parent = node.parent;
-        const leadingComments = this.getCommentsBefore(node);
-
-        switch (node.type) {
-            case "ClassDeclaration":
-            case "FunctionDeclaration":
-                if (looksLikeExport(parent)) {
-                    return findJSDocComment(this.getCommentsBefore(parent), parent.loc.start.line);
-                }
-                return findJSDocComment(leadingComments, node.loc.start.line);
-
-            case "ClassExpression":
-                return findJSDocComment(this.getCommentsBefore(parent.parent), parent.parent.loc.start.line);
-
-            case "ArrowFunctionExpression":
-            case "FunctionExpression":
-                if (parent.type !== "CallExpression" && parent.type !== "NewExpression") {
-                    let parentLeadingComments = this.getCommentsBefore(parent);
-
-                    while (!parentLeadingComments.length && !/Function/.test(parent.type) && parent.type !== "MethodDefinition" && parent.type !== "Property") {
-                        parent = parent.parent;
-
-                        if (!parent) {
-                            break;
-                        }
-
-                        parentLeadingComments = this.getCommentsBefore(parent);
-                    }
-
-                    return parent && parent.type !== "FunctionDeclaration" && parent.type !== "Program" ? findJSDocComment(parentLeadingComments, parent.loc.start.line) : null;
-                } else if (leadingComments.length) {
-                    return findJSDocComment(leadingComments, node.loc.start.line);
-                }
-
-            // falls through
-
-            default:
-                return null;
-        }
-    }
-
-    /**
-     * Gets the deepest node containing a range index.
-     * @param {int} index Range index of the desired node.
-     * @returns {ASTNode} The node if found or null if not found.
-     */
-    getNodeByRangeIndex(index) {
-        let result = null;
-        const traverser = new Traverser();
-
-        traverser.traverse(this.ast, {
-            enter(node) {
-                if (node.range[0] <= index && index < node.range[1]) {
-                    result = node;
-                } else {
-                    this.skip();
-                }
-            },
-            leave(node) {
-                if (node === result) {
-                    this.break();
-                }
-            }
-        });
-
-        return result;
-    }
-
-    /**
-     * Determines if two tokens have at least one whitespace character
-     * between them. This completely disregards comments in making the
-     * determination, so comments count as zero-length substrings.
-     * @param {Token} first The token to check after.
-     * @param {Token} second The token to check before.
-     * @returns {boolean} True if there is only space between tokens, false
-     *  if there is anything other than whitespace between tokens.
-     */
-    isSpaceBetweenTokens(first, second) {
-        const text = this.text.slice(first.range[1], second.range[0]);
-
-        return /\s/.test(text.replace(/\/\*.*?\*\//g, ""));
-    }
-
-    /**
-    * Converts a source text index into a (line, column) pair.
-    * @param {number} index The index of a character in a file
-    * @returns {Object} A {line, column} location object with a 0-indexed column
-    */
-    getLocFromIndex(index) {
-        if (typeof index !== "number") {
-            throw new TypeError("Expected `index` to be a number.");
-        }
-
-        if (index < 0 || index > this.text.length) {
-            throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);
-        }
-
-        /*
-         * For an argument of this.text.length, return the location one "spot" past the last character
-         * of the file. If the last character is a linebreak, the location will be column 0 of the next
-         * line; otherwise, the location will be in the next column on the same line.
-         *
-         * See getIndexFromLoc for the motivation for this special case.
-         */
-        if (index === this.text.length) {
-            return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };
-        }
-
-        /*
-         * To figure out which line rangeIndex is on, determine the last index at which rangeIndex could
-         * be inserted into lineIndices to keep the list sorted.
-         */
-        const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);
-
-        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };
-    }
-
-    /**
-    * Converts a (line, column) pair into a range index.
-    * @param {Object} loc A line/column location
-    * @param {number} loc.line The line number of the location (1-indexed)
-    * @param {number} loc.column The column number of the location (0-indexed)
-    * @returns {number} The range index of the location in the file.
-    */
-    getIndexFromLoc(loc) {
-        if (typeof loc !== "object" || typeof loc.line !== "number" || typeof loc.column !== "number") {
-            throw new TypeError("Expected `loc` to be an object with numeric `line` and `column` properties.");
-        }
-
-        if (loc.line <= 0) {
-            throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);
-        }
-
-        if (loc.line > this.lineStartIndices.length) {
-            throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);
-        }
-
-        const lineStartIndex = this.lineStartIndices[loc.line - 1];
-        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];
-        const positionIndex = lineStartIndex + loc.column;
-
-        /*
-         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of
-         * the given line, provided that the line number is valid element of this.lines. Since the
-         * last element of this.lines is an empty string for files with trailing newlines, add a
-         * special case where getting the index for the first location after the end of the file
-         * will return the length of the file, rather than throwing an error. This allows rules to
-         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.
-         */
-        if (
-            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||
-            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex
-        ) {
-            throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);
-        }
-
-        return positionIndex;
-    }
-}
-
-module.exports = SourceCode;
Index: node_modules/eslint/lib/util/module-resolver.js
===================================================================
--- node_modules/eslint/lib/util/module-resolver.js	(revision )
+++ node_modules/eslint/lib/util/module-resolver.js	(revision )
@@ -1,85 +0,0 @@
-/**
- * @fileoverview Implements the Node.js require.resolve algorithm
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const Module = require("module");
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-const DEFAULT_OPTIONS = {
-
-    /*
-     * module.paths is an array of paths to search for resolving things relative
-     * to this file. Module.globalPaths contains all of the special Node.js
-     * directories that can also be searched for modules.
-     *
-     * Need to check for existence of module.paths because Jest seems not to
-     * include it. See https://github.com/eslint/eslint/issues/5791.
-     */
-    lookupPaths: module.paths ? module.paths.concat(Module.globalPaths) : Module.globalPaths.concat()
-};
-
-/**
- * Resolves modules based on a set of options.
- */
-class ModuleResolver {
-
-    /**
-     * Resolves modules based on a set of options.
-     * @param {Object} options The options for resolving modules.
-     * @param {string[]} options.lookupPaths An array of paths to include in the
-     *      lookup with the highest priority paths coming first.
-     */
-    constructor(options) {
-        this.options = Object.assign({}, DEFAULT_OPTIONS, options || {});
-    }
-
-    /**
-     * Resolves the file location of a given module relative to the configured
-     * lookup paths.
-     * @param {string} name The module name to resolve.
-     * @param {string} extraLookupPath An extra path to look into for the module.
-     *      This path is used with the highest priority.
-     * @returns {string} The resolved file path for the module.
-     * @throws {Error} If the module cannot be resolved.
-     */
-    resolve(name, extraLookupPath) {
-
-        /*
-         * First, clone the lookup paths so we're not messing things up for
-         * subsequent calls to this function. Then, move the extraLookupPath to the
-         * top of the lookup paths list so it will be searched first.
-         */
-        const lookupPaths = this.options.lookupPaths.concat();
-
-        lookupPaths.unshift(extraLookupPath);
-
-        /**
-         * Module._findPath is an internal method to Node.js, then one they use to
-         * lookup file paths when require() is called. So, we are hooking into the
-         * exact same logic that Node.js uses.
-         */
-        const result = Module._findPath(name, lookupPaths); // eslint-disable-line no-underscore-dangle
-
-        if (!result) {
-            throw new Error(`Cannot find module '${name}'`);
-        }
-
-        return result;
-    }
-}
-
-//------------------------------------------------------------------------------
-// Public API
-//------------------------------------------------------------------------------
-
-module.exports = ModuleResolver;
Index: node_modules/eslint/lib/util/source-code-util.js
===================================================================
--- node_modules/eslint/lib/util/source-code-util.js	(revision )
+++ node_modules/eslint/lib/util/source-code-util.js	(revision )
@@ -1,109 +0,0 @@
-/**
- * @fileoverview Tools for obtaining SourceCode objects.
- * @author Ian VanSchooten
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const CLIEngine = require("../cli-engine"),
-    globUtil = require("./glob-util"),
-    baseDefaultOptions = require("../../conf/default-cli-options");
-
-const debug = require("debug")("eslint:source-code-util");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Get the SourceCode object for a single file
- * @param   {string}     filename The fully resolved filename to get SourceCode from.
- * @param   {Object}     options  A CLIEngine options object.
- * @returns {Array}               Array of the SourceCode object representing the file
- *                                and fatal error message.
- */
-function getSourceCodeOfFile(filename, options) {
-    debug("getting sourceCode of", filename);
-    const opts = Object.assign({}, options, { rules: {} });
-    const cli = new CLIEngine(opts);
-    const results = cli.executeOnFiles([filename]);
-
-    if (results && results.results[0] && results.results[0].messages[0] && results.results[0].messages[0].fatal) {
-        const msg = results.results[0].messages[0];
-
-        throw new Error(`(${filename}:${msg.line}:${msg.column}) ${msg.message}`);
-    }
-    const sourceCode = cli.linter.getSourceCode();
-
-    return sourceCode;
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-
-/**
- * This callback is used to measure execution status in a progress bar
- * @callback progressCallback
- * @param {number} The total number of times the callback will be called.
- */
-
-/**
- * Gets the SourceCode of a single file, or set of files.
- * @param   {string[]|string}  patterns   A filename, directory name, or glob,
- *                                        or an array of them
- * @param   {Object}           [options]  A CLIEngine options object. If not provided,
- *                                        the default cli options will be used.
- * @param   {progressCallback} [cb]       Callback for reporting execution status
- * @returns {Object}                      The SourceCode of all processed files.
- */
-function getSourceCodeOfFiles(patterns, options, cb) {
-    const sourceCodes = {};
-    let opts;
-
-    if (typeof patterns === "string") {
-        patterns = [patterns];
-    }
-
-    const defaultOptions = Object.assign({}, baseDefaultOptions, { cwd: process.cwd() });
-
-    if (typeof options === "undefined") {
-        opts = defaultOptions;
-    } else if (typeof options === "function") {
-        cb = options;
-        opts = defaultOptions;
-    } else if (typeof options === "object") {
-        opts = Object.assign({}, defaultOptions, options);
-    }
-    debug("constructed options:", opts);
-    patterns = globUtil.resolveFileGlobPatterns(patterns, opts);
-
-    const filenames = globUtil.listFilesToProcess(patterns, opts)
-        .filter(fileInfo => !fileInfo.ignored)
-        .reduce((files, fileInfo) => files.concat(fileInfo.filename), []);
-
-    if (filenames.length === 0) {
-        debug(`Did not find any files matching pattern(s): ${patterns}`);
-    }
-    filenames.forEach(filename => {
-        const sourceCode = getSourceCodeOfFile(filename, opts);
-
-        if (sourceCode) {
-            debug("got sourceCode of", filename);
-            sourceCodes[filename] = sourceCode;
-        }
-        if (cb) {
-            cb(filenames.length); // eslint-disable-line callback-return
-        }
-    });
-    return sourceCodes;
-}
-
-module.exports = {
-    getSourceCodeOfFiles
-};
Index: node_modules/eslint/lib/util/source-code-fixer.js
===================================================================
--- node_modules/eslint/lib/util/source-code-fixer.js	(revision )
+++ node_modules/eslint/lib/util/source-code-fixer.js	(revision )
@@ -1,150 +0,0 @@
-/**
- * @fileoverview An object that caches and applies source code fixes.
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const debug = require("debug")("eslint:text-fixer");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const BOM = "\uFEFF";
-
-/**
- * Compares items in a messages array by range.
- * @param {Message} a The first message.
- * @param {Message} b The second message.
- * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.
- * @private
- */
-function compareMessagesByFixRange(a, b) {
-    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];
-}
-
-/**
- * Compares items in a messages array by line and column.
- * @param {Message} a The first message.
- * @param {Message} b The second message.
- * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.
- * @private
- */
-function compareMessagesByLocation(a, b) {
-    return a.line - b.line || a.column - b.column;
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * Utility for apply fixes to source code.
- * @constructor
- */
-function SourceCodeFixer() {
-    Object.freeze(this);
-}
-
-/**
- * Applies the fixes specified by the messages to the given text. Tries to be
- * smart about the fixes and won't apply fixes over the same area in the text.
- * @param {string} sourceText The text to apply the changes to.
- * @param {Message[]} messages The array of messages reported by ESLint.
- * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed
- * @returns {Object} An object containing the fixed text and any unfixed messages.
- */
-SourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {
-    debug("Applying fixes");
-
-    if (shouldFix === false) {
-        debug("shouldFix parameter was false, not attempting fixes");
-        return {
-            fixed: false,
-            messages,
-            output: sourceText
-        };
-    }
-
-    // clone the array
-    const remainingMessages = [],
-        fixes = [],
-        bom = sourceText.startsWith(BOM) ? BOM : "",
-        text = bom ? sourceText.slice(1) : sourceText;
-    let lastPos = Number.NEGATIVE_INFINITY,
-        output = bom;
-
-    /**
-     * Try to use the 'fix' from a problem.
-     * @param   {Message} problem The message object to apply fixes from
-     * @returns {boolean}         Whether fix was successfully applied
-     */
-    function attemptFix(problem) {
-        const fix = problem.fix;
-        const start = fix.range[0];
-        const end = fix.range[1];
-
-        // Remain it as a problem if it's overlapped or it's a negative range
-        if (lastPos >= start || start > end) {
-            remainingMessages.push(problem);
-            return false;
-        }
-
-        // Remove BOM.
-        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {
-            output = "";
-        }
-
-        // Make output to this fix.
-        output += text.slice(Math.max(0, lastPos), Math.max(0, start));
-        output += fix.text;
-        lastPos = end;
-        return true;
-    }
-
-    messages.forEach(problem => {
-        if (problem.hasOwnProperty("fix")) {
-            fixes.push(problem);
-        } else {
-            remainingMessages.push(problem);
-        }
-    });
-
-    if (fixes.length) {
-        debug("Found fixes to apply");
-        let fixesWereApplied = false;
-
-        for (const problem of fixes.sort(compareMessagesByFixRange)) {
-            if (typeof shouldFix !== "function" || shouldFix(problem)) {
-                attemptFix(problem);
-
-                // The only time attemptFix will fail is if a previous fix was
-                // applied which conflicts with it.  So we can mark this as true.
-                fixesWereApplied = true;
-            } else {
-                remainingMessages.push(problem);
-            }
-        }
-        output += text.slice(Math.max(0, lastPos));
-
-        return {
-            fixed: fixesWereApplied,
-            messages: remainingMessages.sort(compareMessagesByLocation),
-            output
-        };
-    }
-
-    debug("No fixes to apply");
-    return {
-        fixed: false,
-        messages,
-        output: bom + text
-    };
-
-};
-
-module.exports = SourceCodeFixer;
Index: node_modules/eslint/lib/util/node-event-generator.js
===================================================================
--- node_modules/eslint/lib/util/node-event-generator.js	(revision )
+++ node_modules/eslint/lib/util/node-event-generator.js	(revision )
@@ -1,322 +0,0 @@
-/**
- * @fileoverview The event generator for AST nodes.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const esquery = require("esquery");
-const lodash = require("lodash");
-
-//------------------------------------------------------------------------------
-// Typedefs
-//------------------------------------------------------------------------------
-
-/**
- * An object describing an AST selector
- * @typedef {Object} ASTSelector
- * @property {string} rawSelector The string that was parsed into this selector
- * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering
- * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector
- * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,
- * or `null` if all node types could cause a match
- * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector
- * @property {number} identifierCount The total number of identifier queries in this selector
- */
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
-* Gets the possible types of a selector
-* @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector
-* @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it
-*/
-function getPossibleTypes(parsedSelector) {
-    switch (parsedSelector.type) {
-        case "identifier":
-            return [parsedSelector.value];
-
-        case "matches": {
-            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);
-
-            if (typesForComponents.every(typesForComponent => typesForComponent)) {
-                return lodash.union.apply(null, typesForComponents);
-            }
-            return null;
-        }
-
-        case "compound": {
-            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);
-
-            // If all of the components could match any type, then the compound could also match any type.
-            if (!typesForComponents.length) {
-                return null;
-            }
-
-            /*
-             * If at least one of the components could only match a particular type, the compound could only match
-             * the intersection of those types.
-             */
-            return lodash.intersection.apply(null, typesForComponents);
-        }
-
-        case "child":
-        case "descendant":
-        case "sibling":
-        case "adjacent":
-            return getPossibleTypes(parsedSelector.right);
-
-        default:
-            return null;
-
-    }
-}
-
-/**
- * Counts the number of class, pseudo-class, and attribute queries in this selector
- * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior
- * @returns {number} The number of class, pseudo-class, and attribute queries in this selector
- */
-function countClassAttributes(parsedSelector) {
-    switch (parsedSelector.type) {
-        case "child":
-        case "descendant":
-        case "sibling":
-        case "adjacent":
-            return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);
-
-        case "compound":
-        case "not":
-        case "matches":
-            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);
-
-        case "attribute":
-        case "field":
-        case "nth-child":
-        case "nth-last-child":
-            return 1;
-
-        default:
-            return 0;
-    }
-}
-
-/**
- * Counts the number of identifier queries in this selector
- * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior
- * @returns {number} The number of identifier queries
- */
-function countIdentifiers(parsedSelector) {
-    switch (parsedSelector.type) {
-        case "child":
-        case "descendant":
-        case "sibling":
-        case "adjacent":
-            return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);
-
-        case "compound":
-        case "not":
-        case "matches":
-            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);
-
-        case "identifier":
-            return 1;
-
-        default:
-            return 0;
-    }
-}
-
-/**
- * Compares the specificity of two selector objects, with CSS-like rules.
- * @param {ASTSelector} selectorA An AST selector descriptor
- * @param {ASTSelector} selectorB Another AST selector descriptor
- * @returns {number}
- * a value less than 0 if selectorA is less specific than selectorB
- * a value greater than 0 if selectorA is more specific than selectorB
- * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically
- * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically
- */
-function compareSpecificity(selectorA, selectorB) {
-    return selectorA.attributeCount - selectorB.attributeCount ||
-        selectorA.identifierCount - selectorB.identifierCount ||
-        (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);
-}
-
-/**
- * Parses a raw selector string, and throws a useful error if parsing fails.
- * @param {string} rawSelector A raw AST selector
- * @returns {Object} An object (from esquery) describing the matching behavior of this selector
- * @throws {Error} An error if the selector is invalid
- */
-function tryParseSelector(rawSelector) {
-    try {
-        return esquery.parse(rawSelector.replace(/:exit$/, ""));
-    } catch (err) {
-        if (typeof err.offset === "number") {
-            throw new Error(`Syntax error in selector "${rawSelector}" at position ${err.offset}: ${err.message}`);
-        }
-        throw err;
-    }
-}
-
-/**
- * Parses a raw selector string, and returns the parsed selector along with specificity and type information.
- * @param {string} rawSelector A raw AST selector
- * @returns {ASTSelector} A selector descriptor
- */
-const parseSelector = lodash.memoize(rawSelector => {
-    const parsedSelector = tryParseSelector(rawSelector);
-
-    return {
-        rawSelector,
-        isExit: rawSelector.endsWith(":exit"),
-        parsedSelector,
-        listenerTypes: getPossibleTypes(parsedSelector),
-        attributeCount: countClassAttributes(parsedSelector),
-        identifierCount: countIdentifiers(parsedSelector)
-    };
-});
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * The event generator for AST nodes.
- * This implements below interface.
- *
- * ```ts
- * interface EventGenerator {
- *     emitter: EventEmitter;
- *     enterNode(node: ASTNode): void;
- *     leaveNode(node: ASTNode): void;
- * }
- * ```
- */
-class NodeEventGenerator {
-
-    /**
-    * @param {EventEmitter} emitter - An event emitter which is the destination of events. This emitter must already
-    * have registered listeners for all of the events that it needs to listen for.
-    * @returns {NodeEventGenerator} new instance
-    */
-    constructor(emitter) {
-        this.emitter = emitter;
-        this.currentAncestry = [];
-        this.enterSelectorsByNodeType = new Map();
-        this.exitSelectorsByNodeType = new Map();
-        this.anyTypeEnterSelectors = [];
-        this.anyTypeExitSelectors = [];
-
-        const eventNames = typeof emitter.eventNames === "function"
-
-            // Use the built-in eventNames() function if available (Node 6+)
-            ? emitter.eventNames()
-
-            /*
-             * Otherwise, use the private _events property.
-             * Using a private property isn't ideal here, but this seems to
-             * be the best way to get a list of event names without overriding
-             * addEventListener, which would hurt performance. This property
-             * is widely used and unlikely to be removed in a future version
-             * (see https://github.com/nodejs/node/issues/1817). Also, future
-             * node versions will have eventNames() anyway.
-             */
-            : Object.keys(emitter._events); // eslint-disable-line no-underscore-dangle
-
-        eventNames.forEach(rawSelector => {
-            const selector = parseSelector(rawSelector);
-
-            if (selector.listenerTypes) {
-                selector.listenerTypes.forEach(nodeType => {
-                    const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;
-
-                    if (!typeMap.has(nodeType)) {
-                        typeMap.set(nodeType, []);
-                    }
-                    typeMap.get(nodeType).push(selector);
-                });
-            } else {
-                (selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors).push(selector);
-            }
-        });
-
-        this.anyTypeEnterSelectors.sort(compareSpecificity);
-        this.anyTypeExitSelectors.sort(compareSpecificity);
-        this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));
-        this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));
-    }
-
-    /**
-     * Checks a selector against a node, and emits it if it matches
-     * @param {ASTNode} node The node to check
-     * @param {ASTSelector} selector An AST selector descriptor
-     * @returns {void}
-     */
-    applySelector(node, selector) {
-        if (esquery.matches(node, selector.parsedSelector, this.currentAncestry)) {
-            this.emitter.emit(selector.rawSelector, node);
-        }
-    }
-
-    /**
-     * Applies all appropriate selectors to a node, in specificity order
-     * @param {ASTNode} node The node to check
-     * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited
-     * @returns {void}
-     */
-    applySelectors(node, isExit) {
-        const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];
-        const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
-
-        /*
-         * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.
-         * Iterate through each of them, applying selectors in the right order.
-         */
-        let selectorsByTypeIndex = 0;
-        let anyTypeSelectorsIndex = 0;
-
-        while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {
-            if (
-                selectorsByTypeIndex >= selectorsByNodeType.length ||
-                anyTypeSelectorsIndex < anyTypeSelectors.length &&
-                compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0
-            ) {
-                this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);
-            } else {
-                this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);
-            }
-        }
-    }
-
-    /**
-     * Emits an event of entering AST node.
-     * @param {ASTNode} node - A node which was entered.
-     * @returns {void}
-     */
-    enterNode(node) {
-        if (node.parent) {
-            this.currentAncestry.unshift(node.parent);
-        }
-        this.applySelectors(node, false);
-    }
-
-    /**
-     * Emits an event of leaving AST node.
-     * @param {ASTNode} node - A node which was left.
-     * @returns {void}
-     */
-    leaveNode(node) {
-        this.applySelectors(node, true);
-        this.currentAncestry.shift();
-    }
-}
-
-module.exports = NodeEventGenerator;
Index: node_modules/eslint/lib/util/apply-disable-directives.js
===================================================================
--- node_modules/eslint/lib/util/apply-disable-directives.js	(revision )
+++ node_modules/eslint/lib/util/apply-disable-directives.js	(revision )
@@ -1,131 +0,0 @@
-/**
- * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments
- * @author Teddy Katz
- */
-
-"use strict";
-
-const lodash = require("lodash");
-
-/**
- * Compares the locations of two objects in a source file
- * @param {{line: number, column: number}} itemA The first object
- * @param {{line: number, column: number}} itemB The second object
- * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if
- * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.
- */
-function compareLocations(itemA, itemB) {
-    return itemA.line - itemB.line || itemA.column - itemB.column;
-}
-
-/**
- * This is the same as the exported function, except that it doesn't handle disable-line and disable-next-line directives.
- * @param {Object} options options (see the exported function)
- * @returns {Problem[]} Filtered problems (see the exported function)
- */
-function applyDirectives(options) {
-    const problems = [];
-    let nextDirectiveIndex = 0;
-    let globalDisableActive = false;
-
-    // disabledRules is only used when there is no active global /* eslint-disable */ comment.
-    const disabledRules = new Set();
-
-    // enabledRules is only used when there is an active global /* eslint-disable */ comment.
-    const enabledRules = new Set();
-
-    for (const problem of options.problems) {
-        while (
-            nextDirectiveIndex < options.directives.length &&
-            compareLocations(options.directives[nextDirectiveIndex], problem) <= 0
-        ) {
-            const directive = options.directives[nextDirectiveIndex++];
-
-            switch (directive.type) {
-                case "disable":
-                    if (directive.ruleId === null) {
-                        globalDisableActive = true;
-                        enabledRules.clear();
-                    } else if (globalDisableActive) {
-                        enabledRules.delete(directive.ruleId);
-                    } else {
-                        disabledRules.add(directive.ruleId);
-                    }
-                    break;
-
-                case "enable":
-                    if (directive.ruleId === null) {
-                        globalDisableActive = false;
-                        disabledRules.clear();
-                    } else if (globalDisableActive) {
-                        enabledRules.add(directive.ruleId);
-                    } else {
-                        disabledRules.delete(directive.ruleId);
-                    }
-                    break;
-
-                // no default
-            }
-        }
-
-        if (
-            globalDisableActive && enabledRules.has(problem.ruleId) ||
-            !globalDisableActive && !disabledRules.has(problem.ruleId)
-        ) {
-            problems.push(problem);
-        }
-    }
-
-    return problems;
-}
-
-/**
- * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list
- * of reported problems, determines which problems should be reported.
- * @param {Object} options Information about directives and problems
- * @param {{
- *      type: ("disable"|"enable"|"disable-line"|"disable-next-line"),
- *      ruleId: (string|null),
- *      line: number,
- *      column: number
- * }} options.directives Directive comments found in the file, with one-based columns.
- * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable
- * comment for two different rules is represented as two directives).
- * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems
- * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.
- * @returns {{ruleId: (string|null), line: number, column: number}[]}
- * A list of reported problems that were not disabled by the directive comments.
- */
-module.exports = options => {
-    const blockDirectives = options.directives
-        .filter(directive => directive.type === "disable" || directive.type === "enable")
-        .sort(compareLocations);
-
-    const lineDirectives = lodash.flatMap(options.directives, directive => {
-        switch (directive.type) {
-            case "disable":
-            case "enable":
-                return [];
-
-            case "disable-line":
-                return [
-                    { type: "disable", line: directive.line, column: 1, ruleId: directive.ruleId },
-                    { type: "enable", line: directive.line + 1, column: 0, ruleId: directive.ruleId }
-                ];
-
-            case "disable-next-line":
-                return [
-                    { type: "disable", line: directive.line + 1, column: 1, ruleId: directive.ruleId },
-                    { type: "enable", line: directive.line + 2, column: 0, ruleId: directive.ruleId }
-                ];
-
-            default:
-                throw new TypeError(`Unrecognized directive type '${directive.type}'`);
-        }
-    }).sort(compareLocations);
-
-    const problemsAfterBlockDirectives = applyDirectives({ problems: options.problems, directives: blockDirectives });
-    const problemsAfterLineDirectives = applyDirectives({ problems: problemsAfterBlockDirectives, directives: lineDirectives });
-
-    return problemsAfterLineDirectives.sort(compareLocations);
-};
Index: node_modules/eslint/lib/rules/semi.js
===================================================================
--- node_modules/eslint/lib/rules/semi.js	(revision )
+++ node_modules/eslint/lib/rules/semi.js	(revision )
@@ -1,228 +0,0 @@
-/**
- * @fileoverview Rule to flag missing semicolons.
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const FixTracker = require("../util/fix-tracker");
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow semicolons instead of ASI",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "code",
-
-        schema: {
-            anyOf: [
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["never"]
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 1
-                },
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["always"]
-                        },
-                        {
-                            type: "object",
-                            properties: {
-                                omitLastInOneLineBlock: { type: "boolean" }
-                            },
-                            additionalProperties: false
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 2
-                }
-            ]
-        }
-    },
-
-    create(context) {
-
-        const OPT_OUT_PATTERN = /^[-[(/+`]/; // One of [(/+-`
-        const options = context.options[1];
-        const never = context.options[0] === "never",
-            exceptOneLine = options && options.omitLastInOneLineBlock === true,
-            sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Reports a semicolon error with appropriate location and message.
-         * @param {ASTNode} node The node with an extra or missing semicolon.
-         * @param {boolean} missing True if the semicolon is missing.
-         * @returns {void}
-         */
-        function report(node, missing) {
-            const lastToken = sourceCode.getLastToken(node);
-            let message,
-                fix,
-                loc = lastToken.loc;
-
-            if (!missing) {
-                message = "Missing semicolon.";
-                loc = loc.end;
-                fix = function(fixer) {
-                    return fixer.insertTextAfter(lastToken, ";");
-                };
-            } else {
-                message = "Extra semicolon.";
-                loc = loc.start;
-                fix = function(fixer) {
-
-                    // Expand the replacement range to include the surrounding
-                    // tokens to avoid conflicting with no-extra-semi.
-                    // https://github.com/eslint/eslint/issues/7928
-                    return new FixTracker(fixer, sourceCode)
-                        .retainSurroundingTokens(lastToken)
-                        .remove(lastToken);
-                };
-            }
-
-            context.report({
-                node,
-                loc,
-                message,
-                fix
-            });
-
-        }
-
-        /**
-         * Check if a semicolon is unnecessary, only true if:
-         *   - next token is on a new line and is not one of the opt-out tokens
-         *   - next token is a valid statement divider
-         * @param {Token} lastToken last token of current node.
-         * @returns {boolean} whether the semicolon is unnecessary.
-         */
-        function isUnnecessarySemicolon(lastToken) {
-            if (!astUtils.isSemicolonToken(lastToken)) {
-                return false;
-            }
-
-            const nextToken = sourceCode.getTokenAfter(lastToken);
-
-            if (!nextToken) {
-                return true;
-            }
-
-            const lastTokenLine = lastToken.loc.end.line;
-            const nextTokenLine = nextToken.loc.start.line;
-            const isOptOutToken = OPT_OUT_PATTERN.test(nextToken.value) && nextToken.value !== "++" && nextToken.value !== "--";
-            const isDivider = (astUtils.isClosingBraceToken(nextToken) || astUtils.isSemicolonToken(nextToken));
-
-            return (lastTokenLine !== nextTokenLine && !isOptOutToken) || isDivider;
-        }
-
-        /**
-         * Checks a node to see if it's in a one-liner block statement.
-         * @param {ASTNode} node The node to check.
-         * @returns {boolean} whether the node is in a one-liner block statement.
-         */
-        function isOneLinerBlock(node) {
-            const nextToken = sourceCode.getTokenAfter(node);
-
-            if (!nextToken || nextToken.value !== "}") {
-                return false;
-            }
-
-            const parent = node.parent;
-
-            return parent && parent.type === "BlockStatement" &&
-              parent.loc.start.line === parent.loc.end.line;
-        }
-
-        /**
-         * Checks a node to see if it's followed by a semicolon.
-         * @param {ASTNode} node The node to check.
-         * @returns {void}
-         */
-        function checkForSemicolon(node) {
-            const lastToken = sourceCode.getLastToken(node);
-
-            if (never) {
-                if (isUnnecessarySemicolon(lastToken)) {
-                    report(node, true);
-                }
-            } else {
-                if (!astUtils.isSemicolonToken(lastToken)) {
-                    if (!exceptOneLine || !isOneLinerBlock(node)) {
-                        report(node);
-                    }
-                } else {
-                    if (exceptOneLine && isOneLinerBlock(node)) {
-                        report(node, true);
-                    }
-                }
-            }
-        }
-
-        /**
-         * Checks to see if there's a semicolon after a variable declaration.
-         * @param {ASTNode} node The node to check.
-         * @returns {void}
-         */
-        function checkForSemicolonForVariableDeclaration(node) {
-            const ancestors = context.getAncestors(),
-                parentIndex = ancestors.length - 1,
-                parent = ancestors[parentIndex];
-
-            if ((parent.type !== "ForStatement" || parent.init !== node) &&
-                (!/^For(?:In|Of)Statement/.test(parent.type) || parent.left !== node)
-            ) {
-                checkForSemicolon(node);
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            VariableDeclaration: checkForSemicolonForVariableDeclaration,
-            ExpressionStatement: checkForSemicolon,
-            ReturnStatement: checkForSemicolon,
-            ThrowStatement: checkForSemicolon,
-            DoWhileStatement: checkForSemicolon,
-            DebuggerStatement: checkForSemicolon,
-            BreakStatement: checkForSemicolon,
-            ContinueStatement: checkForSemicolon,
-            ImportDeclaration: checkForSemicolon,
-            ExportAllDeclaration: checkForSemicolon,
-            ExportNamedDeclaration(node) {
-                if (!node.declaration) {
-                    checkForSemicolon(node);
-                }
-            },
-            ExportDefaultDeclaration(node) {
-                if (!/(?:Class|Function)Declaration/.test(node.declaration.type)) {
-                    checkForSemicolon(node);
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/yoda.js
===================================================================
--- node_modules/eslint/lib/rules/yoda.js	(revision )
+++ node_modules/eslint/lib/rules/yoda.js	(revision )
@@ -1,308 +0,0 @@
-/**
- * @fileoverview Rule to require or disallow yoda comparisons
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//--------------------------------------------------------------------------
-// Requirements
-//--------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//--------------------------------------------------------------------------
-// Helpers
-//--------------------------------------------------------------------------
-
-/**
- * Determines whether an operator is a comparison operator.
- * @param {string} operator The operator to check.
- * @returns {boolean} Whether or not it is a comparison operator.
- */
-function isComparisonOperator(operator) {
-    return (/^(==|===|!=|!==|<|>|<=|>=)$/).test(operator);
-}
-
-/**
- * Determines whether an operator is an equality operator.
- * @param {string} operator The operator to check.
- * @returns {boolean} Whether or not it is an equality operator.
- */
-function isEqualityOperator(operator) {
-    return (/^(==|===)$/).test(operator);
-}
-
-/**
- * Determines whether an operator is one used in a range test.
- * Allowed operators are `<` and `<=`.
- * @param {string} operator The operator to check.
- * @returns {boolean} Whether the operator is used in range tests.
- */
-function isRangeTestOperator(operator) {
-    return ["<", "<="].indexOf(operator) >= 0;
-}
-
-/**
- * Determines whether a non-Literal node is a negative number that should be
- * treated as if it were a single Literal node.
- * @param {ASTNode} node Node to test.
- * @returns {boolean} True if the node is a negative number that looks like a
- *                    real literal and should be treated as such.
- */
-function looksLikeLiteral(node) {
-    return (node.type === "UnaryExpression" &&
-        node.operator === "-" &&
-        node.prefix &&
-        node.argument.type === "Literal" &&
-        typeof node.argument.value === "number");
-}
-
-/**
- * Attempts to derive a Literal node from nodes that are treated like literals.
- * @param {ASTNode} node Node to normalize.
- * @param {number} [defaultValue] The default value to be returned if the node
- *                                is not a Literal.
- * @returns {ASTNode} One of the following options.
- *  1. The original node if the node is already a Literal
- *  2. A normalized Literal node with the negative number as the value if the
- *     node represents a negative number literal.
- *  3. The Literal node which has the `defaultValue` argument if it exists.
- *  4. Otherwise `null`.
- */
-function getNormalizedLiteral(node, defaultValue) {
-    if (node.type === "Literal") {
-        return node;
-    }
-
-    if (looksLikeLiteral(node)) {
-        return {
-            type: "Literal",
-            value: -node.argument.value,
-            raw: `-${node.argument.value}`
-        };
-    }
-
-    if (defaultValue) {
-        return {
-            type: "Literal",
-            value: defaultValue,
-            raw: String(defaultValue)
-        };
-    }
-
-    return null;
-}
-
-/**
- * Checks whether two expressions reference the same value. For example:
- *     a = a
- *     a.b = a.b
- *     a[0] = a[0]
- *     a['b'] = a['b']
- * @param   {ASTNode} a Left side of the comparison.
- * @param   {ASTNode} b Right side of the comparison.
- * @returns {boolean}   True if both sides match and reference the same value.
- */
-function same(a, b) {
-    if (a.type !== b.type) {
-        return false;
-    }
-
-    switch (a.type) {
-        case "Identifier":
-            return a.name === b.name;
-
-        case "Literal":
-            return a.value === b.value;
-
-        case "MemberExpression": {
-            const nameA = astUtils.getStaticPropertyName(a);
-
-            // x.y = x["y"]
-            if (nameA) {
-                return (
-                    same(a.object, b.object) &&
-                    nameA === astUtils.getStaticPropertyName(b)
-                );
-            }
-
-            // x[0] = x[0]
-            // x[y] = x[y]
-            // x.y = x.y
-            return (
-                a.computed === b.computed &&
-                same(a.object, b.object) &&
-                same(a.property, b.property)
-            );
-        }
-
-        case "ThisExpression":
-            return true;
-
-        default:
-            return false;
-    }
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow \"Yoda\" conditions",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["always", "never"]
-            },
-            {
-                type: "object",
-                properties: {
-                    exceptRange: {
-                        type: "boolean"
-                    },
-                    onlyEquality: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ],
-
-        fixable: "code"
-    },
-
-    create(context) {
-
-        // Default to "never" (!always) if no option
-        const always = (context.options[0] === "always");
-        const exceptRange = (context.options[1] && context.options[1].exceptRange);
-        const onlyEquality = (context.options[1] && context.options[1].onlyEquality);
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Determines whether node represents a range test.
-         * A range test is a "between" test like `(0 <= x && x < 1)` or an "outside"
-         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and
-         * both operators must be `<` or `<=`. Finally, the literal on the left side
-         * must be less than or equal to the literal on the right side so that the
-         * test makes any sense.
-         * @param {ASTNode} node LogicalExpression node to test.
-         * @returns {boolean} Whether node is a range test.
-         */
-        function isRangeTest(node) {
-            const left = node.left,
-                right = node.right;
-
-            /**
-             * Determines whether node is of the form `0 <= x && x < 1`.
-             * @returns {boolean} Whether node is a "between" range test.
-             */
-            function isBetweenTest() {
-                let leftLiteral, rightLiteral;
-
-                return (node.operator === "&&" &&
-                    (leftLiteral = getNormalizedLiteral(left.left)) &&
-                    (rightLiteral = getNormalizedLiteral(right.right, Number.POSITIVE_INFINITY)) &&
-                    leftLiteral.value <= rightLiteral.value &&
-                    same(left.right, right.left));
-            }
-
-            /**
-             * Determines whether node is of the form `x < 0 || 1 <= x`.
-             * @returns {boolean} Whether node is an "outside" range test.
-             */
-            function isOutsideTest() {
-                let leftLiteral, rightLiteral;
-
-                return (node.operator === "||" &&
-                    (leftLiteral = getNormalizedLiteral(left.right, Number.NEGATIVE_INFINITY)) &&
-                    (rightLiteral = getNormalizedLiteral(right.left)) &&
-                    leftLiteral.value <= rightLiteral.value &&
-                    same(left.left, right.right));
-            }
-
-            /**
-             * Determines whether node is wrapped in parentheses.
-             * @returns {boolean} Whether node is preceded immediately by an open
-             *                    paren token and followed immediately by a close
-             *                    paren token.
-             */
-            function isParenWrapped() {
-                return astUtils.isParenthesised(sourceCode, node);
-            }
-
-            return (node.type === "LogicalExpression" &&
-                left.type === "BinaryExpression" &&
-                right.type === "BinaryExpression" &&
-                isRangeTestOperator(left.operator) &&
-                isRangeTestOperator(right.operator) &&
-                (isBetweenTest() || isOutsideTest()) &&
-                isParenWrapped());
-        }
-
-        const OPERATOR_FLIP_MAP = {
-            "===": "===",
-            "!==": "!==",
-            "==": "==",
-            "!=": "!=",
-            "<": ">",
-            ">": "<",
-            "<=": ">=",
-            ">=": "<="
-        };
-
-        /**
-        * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.
-        * @param {ASTNode} node The BinaryExpression node
-        * @returns {string} A string representation of the node with the sides and operator flipped
-        */
-        function getFlippedString(node) {
-            const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
-            const textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);
-            const textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);
-            const leftText = sourceCode.getText().slice(node.range[0], sourceCode.getTokenBefore(operatorToken).range[1]);
-            const rightText = sourceCode.getText().slice(sourceCode.getTokenAfter(operatorToken).range[0], node.range[1]);
-
-            return rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            BinaryExpression(node) {
-                const expectedLiteral = always ? node.left : node.right;
-                const expectedNonLiteral = always ? node.right : node.left;
-
-                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.
-                if (
-                    (expectedNonLiteral.type === "Literal" || looksLikeLiteral(expectedNonLiteral)) &&
-                    !(expectedLiteral.type === "Literal" || looksLikeLiteral(expectedLiteral)) &&
-                    !(!isEqualityOperator(node.operator) && onlyEquality) &&
-                    isComparisonOperator(node.operator) &&
-                    !(exceptRange && isRangeTest(context.getAncestors().pop()))
-                ) {
-                    context.report({
-                        node,
-                        message: "Expected literal to be on the {{expectedSide}} side of {{operator}}.",
-                        data: {
-                            operator: node.operator,
-                            expectedSide: always ? "left" : "right"
-                        },
-                        fix: fixer => fixer.replaceText(node, getFlippedString(node))
-                    });
-                }
-
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/curly.js
===================================================================
--- node_modules/eslint/lib/rules/curly.js	(revision )
+++ node_modules/eslint/lib/rules/curly.js	(revision )
@@ -1,395 +0,0 @@
-/**
- * @fileoverview Rule to flag statements without curly braces
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent brace style for all control statements",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: {
-            anyOf: [
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["all"]
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 1
-                },
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["multi", "multi-line", "multi-or-nest"]
-                        },
-                        {
-                            enum: ["consistent"]
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 2
-                }
-            ]
-        },
-
-        fixable: "code"
-    },
-
-    create(context) {
-
-        const multiOnly = (context.options[0] === "multi");
-        const multiLine = (context.options[0] === "multi-line");
-        const multiOrNest = (context.options[0] === "multi-or-nest");
-        const consistent = (context.options[1] === "consistent");
-
-        const sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Determines if a given node is a one-liner that's on the same line as it's preceding code.
-         * @param {ASTNode} node The node to check.
-         * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.
-         * @private
-         */
-        function isCollapsedOneLiner(node) {
-            const before = sourceCode.getTokenBefore(node);
-            const last = sourceCode.getLastToken(node);
-            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;
-
-            return before.loc.start.line === lastExcludingSemicolon.loc.end.line;
-        }
-
-        /**
-         * Determines if a given node is a one-liner.
-         * @param {ASTNode} node The node to check.
-         * @returns {boolean} True if the node is a one-liner.
-         * @private
-         */
-        function isOneLiner(node) {
-            const first = sourceCode.getFirstToken(node),
-                last = sourceCode.getLastToken(node);
-
-            return first.loc.start.line === last.loc.end.line;
-        }
-
-        /**
-         * Checks if the given token is an `else` token or not.
-         *
-         * @param {Token} token - The token to check.
-         * @returns {boolean} `true` if the token is an `else` token.
-         */
-        function isElseKeywordToken(token) {
-            return token.value === "else" && token.type === "Keyword";
-        }
-
-        /**
-         * Gets the `else` keyword token of a given `IfStatement` node.
-         * @param {ASTNode} node - A `IfStatement` node to get.
-         * @returns {Token} The `else` keyword token.
-         */
-        function getElseKeyword(node) {
-            return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);
-        }
-
-        /**
-         * Checks a given IfStatement node requires braces of the consequent chunk.
-         * This returns `true` when below:
-         *
-         * 1. The given node has the `alternate` node.
-         * 2. There is a `IfStatement` which doesn't have `alternate` node in the
-         *    trailing statement chain of the `consequent` node.
-         *
-         * @param {ASTNode} node - A IfStatement node to check.
-         * @returns {boolean} `true` if the node requires braces of the consequent chunk.
-         */
-        function requiresBraceOfConsequent(node) {
-            if (node.alternate && node.consequent.type === "BlockStatement") {
-                if (node.consequent.body.length >= 2) {
-                    return true;
-                }
-
-                node = node.consequent.body[0];
-                while (node) {
-                    if (node.type === "IfStatement" && !node.alternate) {
-                        return true;
-                    }
-                    node = astUtils.getTrailingStatement(node);
-                }
-            }
-
-            return false;
-        }
-
-        /**
-         * Reports "Expected { after ..." error
-         * @param {ASTNode} node The node to report.
-         * @param {ASTNode} bodyNode The body node that is incorrectly missing curly brackets
-         * @param {string} name The name to report.
-         * @param {string} suffix Additional string to add to the end of a report.
-         * @returns {void}
-         * @private
-         */
-        function reportExpectedBraceError(node, bodyNode, name, suffix) {
-            context.report({
-                node,
-                loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
-                message: "Expected { after '{{name}}'{{suffix}}.",
-                data: {
-                    name,
-                    suffix: (suffix ? ` ${suffix}` : "")
-                },
-                fix: fixer => fixer.replaceText(bodyNode, `{${sourceCode.getText(bodyNode)}}`)
-            });
-        }
-
-        /**
-        * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.
-        * @param {Token} closingBracket The } token
-        * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.
-        */
-        function needsSemicolon(closingBracket) {
-            const tokenBefore = sourceCode.getTokenBefore(closingBracket);
-            const tokenAfter = sourceCode.getTokenAfter(closingBracket);
-            const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);
-
-            if (astUtils.isSemicolonToken(tokenBefore)) {
-
-                // If the last statement already has a semicolon, don't add another one.
-                return false;
-            }
-
-            if (!tokenAfter) {
-
-                // If there are no statements after this block, there is no need to add a semicolon.
-                return false;
-            }
-
-            if (lastBlockNode.type === "BlockStatement" && lastBlockNode.parent.type !== "FunctionExpression" && lastBlockNode.parent.type !== "ArrowFunctionExpression") {
-
-                // If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),
-                // don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause
-                // a SyntaxError if it was followed by `else`.
-                return false;
-            }
-
-            if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {
-
-                // If the next token is on the same line, insert a semicolon.
-                return true;
-            }
-
-            if (/^[([/`+-]/.test(tokenAfter.value)) {
-
-                // If the next token starts with a character that would disrupt ASI, insert a semicolon.
-                return true;
-            }
-
-            if (tokenBefore.type === "Punctuator" && (tokenBefore.value === "++" || tokenBefore.value === "--")) {
-
-                // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.
-                return true;
-            }
-
-            // Otherwise, do not insert a semicolon.
-            return false;
-        }
-
-        /**
-         * Reports "Unnecessary { after ..." error
-         * @param {ASTNode} node The node to report.
-         * @param {ASTNode} bodyNode The block statement that is incorrectly surrounded by parens
-         * @param {string} name The name to report.
-         * @param {string} suffix Additional string to add to the end of a report.
-         * @returns {void}
-         * @private
-         */
-        function reportUnnecessaryBraceError(node, bodyNode, name, suffix) {
-            context.report({
-                node,
-                loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
-                message: "Unnecessary { after '{{name}}'{{suffix}}.",
-                data: {
-                    name,
-                    suffix: (suffix ? ` ${suffix}` : "")
-                },
-                fix(fixer) {
-
-                    // `do while` expressions sometimes need a space to be inserted after `do`.
-                    // e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`
-                    const needsPrecedingSpace = node.type === "DoWhileStatement" &&
-                        sourceCode.getTokenBefore(bodyNode).range[1] === bodyNode.range[0] &&
-                        !astUtils.canTokensBeAdjacent("do", sourceCode.getFirstToken(bodyNode, { skip: 1 }));
-
-                    const openingBracket = sourceCode.getFirstToken(bodyNode);
-                    const closingBracket = sourceCode.getLastToken(bodyNode);
-                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);
-
-                    if (needsSemicolon(closingBracket)) {
-
-                        /*
-                         * If removing braces would cause a SyntaxError due to multiple statements on the same line (or
-                         * change the semantics of the code due to ASI), don't perform a fix.
-                         */
-                        return null;
-                    }
-
-                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +
-                        sourceCode.getText(lastTokenInBlock) +
-                        sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);
-
-                    return fixer.replaceText(bodyNode, (needsPrecedingSpace ? " " : "") + resultingBodyText);
-                }
-            });
-        }
-
-        /**
-         * Prepares to check the body of a node to see if it's a block statement.
-         * @param {ASTNode} node The node to report if there's a problem.
-         * @param {ASTNode} body The body node to check for blocks.
-         * @param {string} name The name to report if there's a problem.
-         * @param {string} suffix Additional string to add to the end of a report.
-         * @returns {Object} a prepared check object, with "actual", "expected", "check" properties.
-         *   "actual" will be `true` or `false` whether the body is already a block statement.
-         *   "expected" will be `true` or `false` if the body should be a block statement or not, or
-         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change
-         *   the final behavior of "check".
-         *   "check" will be a function reporting appropriate problems depending on the other
-         *   properties.
-         */
-        function prepareCheck(node, body, name, suffix) {
-            const hasBlock = (body.type === "BlockStatement");
-            let expected = null;
-
-            if (node.type === "IfStatement" && node.consequent === body && requiresBraceOfConsequent(node)) {
-                expected = true;
-            } else if (multiOnly) {
-                if (hasBlock && body.body.length === 1) {
-                    expected = false;
-                }
-            } else if (multiLine) {
-                if (!isCollapsedOneLiner(body)) {
-                    expected = true;
-                }
-            } else if (multiOrNest) {
-                if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {
-                    const leadingComments = sourceCode.getCommentsBefore(body.body[0]);
-
-                    expected = leadingComments.length > 0;
-                } else if (!isOneLiner(body)) {
-                    expected = true;
-                }
-            } else {
-                expected = true;
-            }
-
-            return {
-                actual: hasBlock,
-                expected,
-                check() {
-                    if (this.expected !== null && this.expected !== this.actual) {
-                        if (this.expected) {
-                            reportExpectedBraceError(node, body, name, suffix);
-                        } else {
-                            reportUnnecessaryBraceError(node, body, name, suffix);
-                        }
-                    }
-                }
-            };
-        }
-
-        /**
-         * Prepares to check the bodies of a "if", "else if" and "else" chain.
-         * @param {ASTNode} node The first IfStatement node of the chain.
-         * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more
-         *   information.
-         */
-        function prepareIfChecks(node) {
-            const preparedChecks = [];
-
-            do {
-                preparedChecks.push(prepareCheck(node, node.consequent, "if", "condition"));
-                if (node.alternate && node.alternate.type !== "IfStatement") {
-                    preparedChecks.push(prepareCheck(node, node.alternate, "else"));
-                    break;
-                }
-                node = node.alternate;
-            } while (node);
-
-            if (consistent) {
-
-                /*
-                 * If any node should have or already have braces, make sure they
-                 * all have braces.
-                 * If all nodes shouldn't have braces, make sure they don't.
-                 */
-                const expected = preparedChecks.some(preparedCheck => {
-                    if (preparedCheck.expected !== null) {
-                        return preparedCheck.expected;
-                    }
-                    return preparedCheck.actual;
-                });
-
-                preparedChecks.forEach(preparedCheck => {
-                    preparedCheck.expected = expected;
-                });
-            }
-
-            return preparedChecks;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            IfStatement(node) {
-                if (node.parent.type !== "IfStatement") {
-                    prepareIfChecks(node).forEach(preparedCheck => {
-                        preparedCheck.check();
-                    });
-                }
-            },
-
-            WhileStatement(node) {
-                prepareCheck(node, node.body, "while", "condition").check();
-            },
-
-            DoWhileStatement(node) {
-                prepareCheck(node, node.body, "do").check();
-            },
-
-            ForStatement(node) {
-                prepareCheck(node, node.body, "for", "condition").check();
-            },
-
-            ForInStatement(node) {
-                prepareCheck(node, node.body, "for-in").check();
-            },
-
-            ForOfStatement(node) {
-                prepareCheck(node, node.body, "for-of").check();
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/radix.js
===================================================================
--- node_modules/eslint/lib/rules/radix.js	(revision )
+++ node_modules/eslint/lib/rules/radix.js	(revision )
@@ -1,171 +0,0 @@
-/**
- * @fileoverview Rule to flag use of parseInt without a radix argument
- * @author James Allardice
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const MODE_ALWAYS = "always",
-    MODE_AS_NEEDED = "as-needed";
-
-/**
- * Checks whether a given variable is shadowed or not.
- *
- * @param {eslint-scope.Variable} variable - A variable to check.
- * @returns {boolean} `true` if the variable is shadowed.
- */
-function isShadowed(variable) {
-    return variable.defs.length >= 1;
-}
-
-/**
- * Checks whether a given node is a MemberExpression of `parseInt` method or not.
- *
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`
- *      method.
- */
-function isParseIntMethod(node) {
-    return (
-        node.type === "MemberExpression" &&
-        !node.computed &&
-        node.property.type === "Identifier" &&
-        node.property.name === "parseInt"
-    );
-}
-
-/**
- * Checks whether a given node is a valid value of radix or not.
- *
- * The following values are invalid.
- *
- * - A literal except numbers.
- * - undefined.
- *
- * @param {ASTNode} radix - A node of radix to check.
- * @returns {boolean} `true` if the node is valid.
- */
-function isValidRadix(radix) {
-    return !(
-        (radix.type === "Literal" && typeof radix.value !== "number") ||
-        (radix.type === "Identifier" && radix.name === "undefined")
-    );
-}
-
-/**
- * Checks whether a given node is a default value of radix or not.
- *
- * @param {ASTNode} radix - A node of radix to check.
- * @returns {boolean} `true` if the node is the literal node of `10`.
- */
-function isDefaultRadix(radix) {
-    return radix.type === "Literal" && radix.value === 10;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce the consistent use of the radix argument when using `parseInt()`",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["always", "as-needed"]
-            }
-        ]
-    },
-
-    create(context) {
-        const mode = context.options[0] || MODE_ALWAYS;
-
-        /**
-         * Checks the arguments of a given CallExpression node and reports it if it
-         * offends this rule.
-         *
-         * @param {ASTNode} node - A CallExpression node to check.
-         * @returns {void}
-         */
-        function checkArguments(node) {
-            const args = node.arguments;
-
-            switch (args.length) {
-                case 0:
-                    context.report({
-                        node,
-                        message: "Missing parameters."
-                    });
-                    break;
-
-                case 1:
-                    if (mode === MODE_ALWAYS) {
-                        context.report({
-                            node,
-                            message: "Missing radix parameter."
-                        });
-                    }
-                    break;
-
-                default:
-                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {
-                        context.report({
-                            node,
-                            message: "Redundant radix parameter."
-                        });
-                    } else if (!isValidRadix(args[1])) {
-                        context.report({
-                            node,
-                            message: "Invalid radix parameter."
-                        });
-                    }
-                    break;
-            }
-        }
-
-        return {
-            "Program:exit"() {
-                const scope = context.getScope();
-                let variable;
-
-                // Check `parseInt()`
-                variable = astUtils.getVariableByName(scope, "parseInt");
-                if (!isShadowed(variable)) {
-                    variable.references.forEach(reference => {
-                        const node = reference.identifier;
-
-                        if (astUtils.isCallee(node)) {
-                            checkArguments(node.parent);
-                        }
-                    });
-                }
-
-                // Check `Number.parseInt()`
-                variable = astUtils.getVariableByName(scope, "Number");
-                if (!isShadowed(variable)) {
-                    variable.references.forEach(reference => {
-                        const node = reference.identifier.parent;
-
-                        if (isParseIntMethod(node) && astUtils.isCallee(node)) {
-                            checkArguments(node.parent);
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/eqeqeq.js
===================================================================
--- node_modules/eslint/lib/rules/eqeqeq.js	(revision )
+++ node_modules/eslint/lib/rules/eqeqeq.js	(revision )
@@ -1,180 +0,0 @@
-/**
- * @fileoverview Rule to flag statements that use != and == instead of !== and ===
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require the use of `===` and `!==`",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: {
-            anyOf: [
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["always"]
-                        },
-                        {
-                            type: "object",
-                            properties: {
-                                null: {
-                                    enum: ["always", "never", "ignore"]
-                                }
-                            },
-                            additionalProperties: false
-                        }
-                    ],
-                    additionalItems: false
-                },
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["smart", "allow-null"]
-                        }
-                    ],
-                    additionalItems: false
-                }
-            ]
-        },
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const config = context.options[0] || "always";
-        const options = context.options[1] || {};
-        const sourceCode = context.getSourceCode();
-
-        const nullOption = (config === "always")
-            ? options.null || "always"
-            : "ignore";
-        const enforceRuleForNull = (nullOption === "always");
-        const enforceInverseRuleForNull = (nullOption === "never");
-
-        /**
-         * Checks if an expression is a typeof expression
-         * @param  {ASTNode} node The node to check
-         * @returns {boolean} if the node is a typeof expression
-         */
-        function isTypeOf(node) {
-            return node.type === "UnaryExpression" && node.operator === "typeof";
-        }
-
-        /**
-         * Checks if either operand of a binary expression is a typeof operation
-         * @param {ASTNode} node The node to check
-         * @returns {boolean} if one of the operands is typeof
-         * @private
-         */
-        function isTypeOfBinary(node) {
-            return isTypeOf(node.left) || isTypeOf(node.right);
-        }
-
-        /**
-         * Checks if operands are literals of the same type (via typeof)
-         * @param {ASTNode} node The node to check
-         * @returns {boolean} if operands are of same type
-         * @private
-         */
-        function areLiteralsAndSameType(node) {
-            return node.left.type === "Literal" && node.right.type === "Literal" &&
-                    typeof node.left.value === typeof node.right.value;
-        }
-
-        /**
-         * Checks if one of the operands is a literal null
-         * @param {ASTNode} node The node to check
-         * @returns {boolean} if operands are null
-         * @private
-         */
-        function isNullCheck(node) {
-            return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);
-        }
-
-        /**
-         * Gets the location (line and column) of the binary expression's operator
-         * @param {ASTNode} node The binary expression node to check
-         * @param {string} operator The operator to find
-         * @returns {Object} { line, column } location of operator
-         * @private
-         */
-        function getOperatorLocation(node) {
-            const opToken = sourceCode.getTokenAfter(node.left);
-
-            return { line: opToken.loc.start.line, column: opToken.loc.start.column };
-        }
-
-        /**
-         * Reports a message for this rule.
-         * @param {ASTNode} node The binary expression node that was checked
-         * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')
-         * @returns {void}
-         * @private
-         */
-        function report(node, expectedOperator) {
-            context.report({
-                node,
-                loc: getOperatorLocation(node),
-                message: "Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.",
-                data: { expectedOperator, actualOperator: node.operator },
-                fix(fixer) {
-
-                    // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.
-                    if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {
-                        const operatorToken = sourceCode.getFirstTokenBetween(
-                            node.left,
-                            node.right,
-                            token => token.value === node.operator
-                        );
-
-                        return fixer.replaceText(operatorToken, expectedOperator);
-                    }
-                    return null;
-                }
-            });
-        }
-
-        return {
-            BinaryExpression(node) {
-                const isNull = isNullCheck(node);
-
-                if (node.operator !== "==" && node.operator !== "!=") {
-                    if (enforceInverseRuleForNull && isNull) {
-                        report(node, node.operator.slice(0, -1));
-                    }
-                    return;
-                }
-
-                if (config === "smart" && (isTypeOfBinary(node) ||
-                        areLiteralsAndSameType(node) || isNull)) {
-                    return;
-                }
-
-                if (!enforceRuleForNull && isNull) {
-                    return;
-                }
-
-                report(node, `${node.operator}=`);
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/indent.js
===================================================================
--- node_modules/eslint/lib/rules/indent.js	(revision )
+++ node_modules/eslint/lib/rules/indent.js	(revision )
@@ -1,1512 +0,0 @@
-/**
- * @fileoverview This option sets a specific tab width for your code
- *
- * @author Teddy Katz
- * @author Vitaly Puzrin
- * @author Gyandeep Singh
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-const astUtils = require("../ast-utils");
-const createTree = require("functional-red-black-tree");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const KNOWN_NODES = new Set([
-    "AssignmentExpression",
-    "AssignmentPattern",
-    "ArrayExpression",
-    "ArrayPattern",
-    "ArrowFunctionExpression",
-    "AwaitExpression",
-    "BlockStatement",
-    "BinaryExpression",
-    "BreakStatement",
-    "CallExpression",
-    "CatchClause",
-    "ClassBody",
-    "ClassDeclaration",
-    "ClassExpression",
-    "ConditionalExpression",
-    "ContinueStatement",
-    "DoWhileStatement",
-    "DebuggerStatement",
-    "EmptyStatement",
-    "ExperimentalRestProperty",
-    "ExperimentalSpreadProperty",
-    "ExpressionStatement",
-    "ForStatement",
-    "ForInStatement",
-    "ForOfStatement",
-    "FunctionDeclaration",
-    "FunctionExpression",
-    "Identifier",
-    "IfStatement",
-    "Literal",
-    "LabeledStatement",
-    "LogicalExpression",
-    "MemberExpression",
-    "MetaProperty",
-    "MethodDefinition",
-    "NewExpression",
-    "ObjectExpression",
-    "ObjectPattern",
-    "Program",
-    "Property",
-    "RestElement",
-    "ReturnStatement",
-    "SequenceExpression",
-    "SpreadElement",
-    "Super",
-    "SwitchCase",
-    "SwitchStatement",
-    "TaggedTemplateExpression",
-    "TemplateElement",
-    "TemplateLiteral",
-    "ThisExpression",
-    "ThrowStatement",
-    "TryStatement",
-    "UnaryExpression",
-    "UpdateExpression",
-    "VariableDeclaration",
-    "VariableDeclarator",
-    "WhileStatement",
-    "WithStatement",
-    "YieldExpression",
-    "JSXIdentifier",
-    "JSXNamespacedName",
-    "JSXMemberExpression",
-    "JSXEmptyExpression",
-    "JSXExpressionContainer",
-    "JSXElement",
-    "JSXClosingElement",
-    "JSXOpeningElement",
-    "JSXAttribute",
-    "JSXSpreadAttribute",
-    "JSXText",
-    "ExportDefaultDeclaration",
-    "ExportNamedDeclaration",
-    "ExportAllDeclaration",
-    "ExportSpecifier",
-    "ImportDeclaration",
-    "ImportSpecifier",
-    "ImportDefaultSpecifier",
-    "ImportNamespaceSpecifier"
-]);
-
-/*
- * General rule strategy:
- * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another
- *    specified token or to the first column.
- * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a
- *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly
- *    brace of the BlockStatement.
- * 3. After traversing the AST, calculate the expected indentation levels of every token according to the
- *    OffsetStorage container.
- * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,
- *    and report the token if the two values are not equal.
- */
-
-
-/**
- * A mutable balanced binary search tree that stores (key, value) pairs. The keys are numeric, and must be unique.
- * This is intended to be a generic wrapper around a balanced binary search tree library, so that the underlying implementation
- * can easily be swapped out.
- */
-class BinarySearchTree {
-
-    /**
-     * Creates an empty tree
-     */
-    constructor() {
-        this._rbTree = createTree();
-    }
-
-    /**
-     * Inserts an entry into the tree.
-     * @param {number} key The entry's key
-     * @param {*} value The entry's value
-     * @returns {void}
-     */
-    insert(key, value) {
-        const iterator = this._rbTree.find(key);
-
-        if (iterator.valid) {
-            this._rbTree = iterator.update(value);
-        } else {
-            this._rbTree = this._rbTree.insert(key, value);
-        }
-    }
-
-    /**
-     * Finds the entry with the largest key less than or equal to the provided key
-     * @param {number} key The provided key
-     * @returns {{key: number, value: *}|null} The found entry, or null if no such entry exists.
-     */
-    findLe(key) {
-        const iterator = this._rbTree.le(key);
-
-        return iterator && { key: iterator.key, value: iterator.value };
-    }
-
-    /**
-     * Deletes all of the keys in the interval [start, end)
-     * @param {number} start The start of the range
-     * @param {number} end The end of the range
-     * @returns {void}
-     */
-    deleteRange(start, end) {
-
-        // Exit without traversing the tree if the range has zero size.
-        if (start === end) {
-            return;
-        }
-        const iterator = this._rbTree.ge(start);
-
-        while (iterator.valid && iterator.key < end) {
-            this._rbTree = this._rbTree.remove(iterator.key);
-            iterator.next();
-        }
-    }
-}
-
-/**
- * A helper class to get token-based info related to indentation
- */
-class TokenInfo {
-
-    /**
-     * @param {SourceCode} sourceCode A SourceCode object
-     */
-    constructor(sourceCode) {
-        this.sourceCode = sourceCode;
-        this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {
-            if (!map.has(token.loc.start.line)) {
-                map.set(token.loc.start.line, token);
-            }
-            if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {
-                map.set(token.loc.end.line, token);
-            }
-            return map;
-        }, new Map());
-    }
-
-    /**
-    * Gets the first token on a given token's line
-    * @param {Token|ASTNode} token a node or token
-    * @returns {Token} The first token on the given line
-    */
-    getFirstTokenOfLine(token) {
-        return this.firstTokensByLineNumber.get(token.loc.start.line);
-    }
-
-    /**
-    * Determines whether a token is the first token in its line
-    * @param {Token} token The token
-    * @returns {boolean} `true` if the token is the first on its line
-    */
-    isFirstTokenOfLine(token) {
-        return this.getFirstTokenOfLine(token) === token;
-    }
-
-    /**
-     * Get the actual indent of a token
-     * @param {Token} token Token to examine. This should be the first token on its line.
-     * @returns {string} The indentation characters that precede the token
-     */
-    getTokenIndent(token) {
-        return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);
-    }
-}
-
-/**
- * A class to store information on desired offsets of tokens from each other
- */
-class OffsetStorage {
-
-    /**
-     * @param {TokenInfo} tokenInfo a TokenInfo instance
-     * @param {number} indentSize The desired size of each indentation level
-     */
-    constructor(tokenInfo, indentSize) {
-        this._tokenInfo = tokenInfo;
-        this._indentSize = indentSize;
-
-        this._tree = new BinarySearchTree();
-        this._tree.insert(0, { offset: 0, from: null, force: false });
-
-        this._lockedFirstTokens = new WeakMap();
-        this._desiredIndentCache = new WeakMap();
-        this._ignoredTokens = new WeakSet();
-    }
-
-    _getOffsetDescriptor(token) {
-        return this._tree.findLe(token.range[0]).value;
-    }
-
-    /**
-     * Sets the offset column of token B to match the offset column of token A.
-     * **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In
-     * most cases, `setDesiredOffset` should be used instead.
-     * @param {Token} baseToken The first token
-     * @param {Token} offsetToken The second token, whose offset should be matched to the first token
-     * @returns {void}
-     */
-    matchOffsetOf(baseToken, offsetToken) {
-
-        /*
-         * lockedFirstTokens is a map from a token whose indentation is controlled by the "first" option to
-         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first
-         * token of each element in the array after the first will be mapped to the first token of the first
-         * element. The desired indentation of each of these tokens is computed based on the desired indentation
-         * of the "first" element, rather than through the normal offset mechanism.
-         */
-        this._lockedFirstTokens.set(offsetToken, baseToken);
-    }
-
-    /**
-     * Sets the desired offset of a token.
-     *
-     * This uses a line-based offset collapsing behavior to handle tokens on the same line.
-     * For example, consider the following two cases:
-     *
-     * (
-     *     [
-     *         bar
-     *     ]
-     * )
-     *
-     * ([
-     *     bar
-     * ])
-     *
-     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from
-     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is
-     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)
-     * from the start of its line.
-     *
-     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level
-     * between the `(` and the `[` tokens gets "collapsed" because the two tokens are on the same line. As a result, the
-     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented
-     * by 1 indent level from the start of the line.
-     *
-     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,
-     * without needing to check which lines those tokens are on.
-     *
-     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive
-     * behavior can occur. For example, consider the following cases:
-     *
-     * foo(
-     * ).
-     *     bar(
-     *         baz
-     *     )
-     *
-     * foo(
-     * ).bar(
-     *     baz
-     * )
-     *
-     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`
-     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`
-     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no
-     * collapsing would occur).
-     *
-     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and
-     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed
-     * in the second case.
-     *
-     * @param {Token} token The token
-     * @param {Token} fromToken The token that `token` should be offset from
-     * @param {number} offset The desired indent level
-     * @returns {void}
-     */
-    setDesiredOffset(token, fromToken, offset) {
-        return this.setDesiredOffsets(token.range, fromToken, offset);
-    }
-
-    /**
-    * Sets the desired offset of all tokens in a range
-    * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.
-    * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains
-    * it). This means that the offset of each token is updated O(AST depth) times.
-    * It would not be performant to store and update the offsets for each token independently, because the rule would end
-    * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.
-    *
-    * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following
-    * list could represent the state of the offset tree at a given point:
-    *
-    * * Tokens starting in the interval [0, 15) are aligned with the beginning of the file
-    * * Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token
-    * * Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token
-    * * Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token
-    * * Tokens starting in the interval [820, ∞) are offset by 1 indent level from the `baz` token
-    *
-    * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:
-    * `setDesiredOffsets([30, 43], fooToken, 1);`
-    *
-    * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.
-    * @param {Token} fromToken The token that this is offset from
-    * @param {number} offset The desired indent level
-    * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.
-    * @returns {void}
-    */
-    setDesiredOffsets(range, fromToken, offset, force) {
-
-        /*
-         * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset
-         * descriptor. The tree for the example above would have the following nodes:
-         *
-         * * key: 0, value: { offset: 0, from: null }
-         * * key: 15, value: { offset: 1, from: barToken }
-         * * key: 30, value: { offset: 1, from: fooToken }
-         * * key: 43, value: { offset: 2, from: barToken }
-         * * key: 820, value: { offset: 1, from: bazToken }
-         *
-         * To find the offset descriptor for any given token, one needs to find the node with the largest key
-         * which is <= token.start. To make this operation fast, the nodes are stored in a balanced binary
-         * search tree indexed by key.
-         */
-
-        const descriptorToInsert = { offset, from: fromToken, force };
-
-        const descriptorAfterRange = this._tree.findLe(range[1]).value;
-
-        const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];
-        const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);
-
-        // First, remove any existing nodes in the range from the tree.
-        this._tree.deleteRange(range[0] + 1, range[1]);
-
-        // Insert a new node into the tree for this range
-        this._tree.insert(range[0], descriptorToInsert);
-
-        /*
-         * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,
-         * even if it's in the current range.
-         */
-        if (fromTokenIsInRange) {
-            this._tree.insert(fromToken.range[0], fromTokenDescriptor);
-            this._tree.insert(fromToken.range[1], descriptorToInsert);
-        }
-
-        /*
-         * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following
-         * tokens the same as it was before.
-         */
-        this._tree.insert(range[1], descriptorAfterRange);
-    }
-
-    /**
-    * Gets the desired indent of a token
-    * @param {Token} token The token
-    * @returns {number} The desired indent of the token
-    */
-    getDesiredIndent(token) {
-        if (!this._desiredIndentCache.has(token)) {
-
-            if (this._ignoredTokens.has(token)) {
-
-                // If the token is ignored, use the actual indent of the token as the desired indent.
-                // This ensures that no errors are reported for this token.
-                this._desiredIndentCache.set(token, this._tokenInfo.getTokenIndent(token).length / this._indentSize);
-            } else if (this._lockedFirstTokens.has(token)) {
-                const firstToken = this._lockedFirstTokens.get(token);
-
-                this._desiredIndentCache.set(
-                    token,
-
-                    // (indentation for the first element's line)
-                    this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +
-
-                        // (space between the start of the first element's line and the first element)
-                        (firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column) / this._indentSize
-                );
-            } else {
-                const offsetInfo = this._getOffsetDescriptor(token);
-                const offset = (
-                    offsetInfo.from &&
-                    offsetInfo.from.loc.start.line === token.loc.start.line &&
-                    !offsetInfo.force
-                ) ? 0 : offsetInfo.offset;
-
-                this._desiredIndentCache.set(token, offset + (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : 0));
-            }
-        }
-        return this._desiredIndentCache.get(token);
-    }
-
-    /**
-    * Ignores a token, preventing it from being reported.
-    * @param {Token} token The token
-    * @returns {void}
-    */
-    ignoreToken(token) {
-        if (this._tokenInfo.isFirstTokenOfLine(token)) {
-            this._ignoredTokens.add(token);
-        }
-    }
-
-    /**
-     * Gets the first token that the given token's indentation is dependent on
-     * @param {Token} token The token
-     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level
-     */
-    getFirstDependency(token) {
-        return this._getOffsetDescriptor(token).from;
-    }
-}
-
-const ELEMENT_LIST_SCHEMA = {
-    oneOf: [
-        {
-            type: "integer",
-            minimum: 0
-        },
-        {
-            enum: ["first", "off"]
-        }
-    ]
-};
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent indentation",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["tab"]
-                    },
-                    {
-                        type: "integer",
-                        minimum: 0
-                    }
-                ]
-            },
-            {
-                type: "object",
-                properties: {
-                    SwitchCase: {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    VariableDeclarator: {
-                        oneOf: [
-                            {
-                                type: "integer",
-                                minimum: 0
-                            },
-                            {
-                                type: "object",
-                                properties: {
-                                    var: {
-                                        type: "integer",
-                                        minimum: 0
-                                    },
-                                    let: {
-                                        type: "integer",
-                                        minimum: 0
-                                    },
-                                    const: {
-                                        type: "integer",
-                                        minimum: 0
-                                    }
-                                },
-                                additionalProperties: false
-                            }
-                        ]
-                    },
-                    outerIIFEBody: {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    MemberExpression: {
-                        oneOf: [
-                            {
-                                type: "integer",
-                                minimum: 0
-                            },
-                            {
-                                enum: ["off"]
-                            }
-                        ]
-                    },
-                    FunctionDeclaration: {
-                        type: "object",
-                        properties: {
-                            parameters: ELEMENT_LIST_SCHEMA,
-                            body: {
-                                type: "integer",
-                                minimum: 0
-                            }
-                        },
-                        additionalProperties: false
-                    },
-                    FunctionExpression: {
-                        type: "object",
-                        properties: {
-                            parameters: ELEMENT_LIST_SCHEMA,
-                            body: {
-                                type: "integer",
-                                minimum: 0
-                            }
-                        },
-                        additionalProperties: false
-                    },
-                    CallExpression: {
-                        type: "object",
-                        properties: {
-                            arguments: ELEMENT_LIST_SCHEMA
-                        },
-                        additionalProperties: false
-                    },
-                    ArrayExpression: ELEMENT_LIST_SCHEMA,
-                    ObjectExpression: ELEMENT_LIST_SCHEMA,
-                    ImportDeclaration: ELEMENT_LIST_SCHEMA,
-                    flatTernaryExpressions: {
-                        type: "boolean"
-                    },
-                    ignoredNodes: {
-                        type: "array",
-                        items: {
-                            type: "string",
-                            not: {
-                                pattern: ":exit$"
-                            }
-                        }
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const DEFAULT_VARIABLE_INDENT = 1;
-        const DEFAULT_PARAMETER_INDENT = 1;
-        const DEFAULT_FUNCTION_BODY_INDENT = 1;
-
-        let indentType = "space";
-        let indentSize = 4;
-        const options = {
-            SwitchCase: 0,
-            VariableDeclarator: {
-                var: DEFAULT_VARIABLE_INDENT,
-                let: DEFAULT_VARIABLE_INDENT,
-                const: DEFAULT_VARIABLE_INDENT
-            },
-            outerIIFEBody: 1,
-            FunctionDeclaration: {
-                parameters: DEFAULT_PARAMETER_INDENT,
-                body: DEFAULT_FUNCTION_BODY_INDENT
-            },
-            FunctionExpression: {
-                parameters: DEFAULT_PARAMETER_INDENT,
-                body: DEFAULT_FUNCTION_BODY_INDENT
-            },
-            CallExpression: {
-                arguments: DEFAULT_PARAMETER_INDENT
-            },
-            MemberExpression: 1,
-            ArrayExpression: 1,
-            ObjectExpression: 1,
-            ImportDeclaration: 1,
-            flatTernaryExpressions: false,
-            ignoredNodes: []
-        };
-
-        if (context.options.length) {
-            if (context.options[0] === "tab") {
-                indentSize = 1;
-                indentType = "tab";
-            } else {
-                indentSize = context.options[0];
-                indentType = "space";
-            }
-
-            if (context.options[1]) {
-                lodash.merge(options, context.options[1]);
-
-                if (typeof options.VariableDeclarator === "number") {
-                    options.VariableDeclarator = {
-                        var: options.VariableDeclarator,
-                        let: options.VariableDeclarator,
-                        const: options.VariableDeclarator
-                    };
-                }
-            }
-        }
-
-        const sourceCode = context.getSourceCode();
-        const tokenInfo = new TokenInfo(sourceCode);
-        const offsets = new OffsetStorage(tokenInfo, indentSize);
-        const parameterParens = new WeakSet();
-
-        /**
-         * Creates an error message for a line, given the expected/actual indentation.
-         * @param {int} expectedAmount The expected amount of indentation characters for this line
-         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line
-         * @param {int} actualTabs The actual number of indentation tabs that were found on this line
-         * @returns {string} An error message for this line
-         */
-        function createErrorMessage(expectedAmount, actualSpaces, actualTabs) {
-            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`; // e.g. "2 tabs"
-            const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`; // e.g. "space"
-            const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`; // e.g. "tabs"
-            let foundStatement;
-
-            if (actualSpaces > 0) {
-
-                // Abbreviate the message if the expected indentation is also spaces.
-                // e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'
-                foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
-            } else if (actualTabs > 0) {
-                foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
-            } else {
-                foundStatement = "0";
-            }
-
-            return `Expected indentation of ${expectedStatement} but found ${foundStatement}.`;
-        }
-
-        /**
-         * Reports a given indent violation
-         * @param {Token} token Token violating the indent rule
-         * @param {int} neededIndentLevel Expected indentation level
-         * @param {int} gottenSpaces Actual number of indentation spaces for the token
-         * @param {int} gottenTabs Actual number of indentation tabs for the token
-         * @returns {void}
-         */
-        function report(token, neededIndentLevel) {
-            const actualIndent = Array.from(tokenInfo.getTokenIndent(token));
-            const numSpaces = actualIndent.filter(char => char === " ").length;
-            const numTabs = actualIndent.filter(char => char === "\t").length;
-            const neededChars = neededIndentLevel * indentSize;
-
-            context.report({
-                node: token,
-                message: createErrorMessage(neededChars, numSpaces, numTabs),
-                loc: {
-                    start: { line: token.loc.start.line, column: 0 },
-                    end: { line: token.loc.start.line, column: token.loc.start.column }
-                },
-                fix(fixer) {
-                    const range = [token.range[0] - token.loc.start.column, token.range[0]];
-                    const newText = (indentType === "space" ? " " : "\t").repeat(neededChars);
-
-                    return fixer.replaceTextRange(range, newText);
-                }
-            });
-        }
-
-        /**
-         * Checks if a token's indentation is correct
-         * @param {Token} token Token to examine
-         * @param {int} desiredIndentLevel needed indent level
-         * @returns {boolean} `true` if the token's indentation is correct
-         */
-        function validateTokenIndent(token, desiredIndentLevel) {
-            const indentation = tokenInfo.getTokenIndent(token);
-            const expectedChar = indentType === "space" ? " " : "\t";
-
-            return indentation === expectedChar.repeat(desiredIndentLevel * indentSize) ||
-
-                // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.
-                indentation.includes(" ") && indentation.includes("\t");
-        }
-
-        /**
-         * Check to see if the node is a file level IIFE
-         * @param {ASTNode} node The function node to check.
-         * @returns {boolean} True if the node is the outer IIFE
-         */
-        function isOuterIIFE(node) {
-
-            /*
-             * Verify that the node is an IIFE
-             */
-            if (!node.parent || node.parent.type !== "CallExpression" || node.parent.callee !== node) {
-                return false;
-            }
-
-            /*
-             * Navigate legal ancestors to determine whether this IIFE is outer.
-             * A "legal ancestor" is an expression or statement that causes the function to get executed immediately.
-             * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.
-             */
-            let statement = node.parent && node.parent.parent;
-
-            while (
-                statement.type === "UnaryExpression" && ["!", "~", "+", "-"].indexOf(statement.operator) > -1 ||
-                statement.type === "AssignmentExpression" ||
-                statement.type === "LogicalExpression" ||
-                statement.type === "SequenceExpression" ||
-                statement.type === "VariableDeclarator"
-            ) {
-                statement = statement.parent;
-            }
-
-            return (statement.type === "ExpressionStatement" || statement.type === "VariableDeclaration") && statement.parent.type === "Program";
-        }
-
-        /**
-        * Check indentation for lists of elements (arrays, objects, function params)
-        * @param {ASTNode[]} elements List of elements that should be offset
-        * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['
-        * @param {Token} endToken The end token of the list, e.g. ']'
-        * @param {number|string} offset The amount that the elements should be offset
-        * @returns {void}
-        */
-        function addElementListIndent(elements, startToken, endToken, offset) {
-
-            /**
-            * Gets the first token of a given element, including surrounding parentheses.
-            * @param {ASTNode} element A node in the `elements` list
-            * @returns {Token} The first token of this element
-            */
-            function getFirstToken(element) {
-                let token = sourceCode.getTokenBefore(element);
-
-                while (astUtils.isOpeningParenToken(token) && token !== startToken) {
-                    token = sourceCode.getTokenBefore(token);
-                }
-                return sourceCode.getTokenAfter(token);
-            }
-
-            // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)
-            offsets.setDesiredOffsets(
-                [startToken.range[1], endToken.range[0]],
-                startToken,
-                typeof offset === "number" ? offset : 1
-            );
-            offsets.setDesiredOffset(endToken, startToken, 0);
-
-            // If the preference is "first" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.
-            if (offset === "first" && elements.length && !elements[0]) {
-                return;
-            }
-            elements.forEach((element, index) => {
-                if (!element) {
-
-                    // Skip holes in arrays
-                    return;
-                }
-                if (offset === "off") {
-
-                    // Ignore the first token of every element if the "off" option is used
-                    offsets.ignoreToken(getFirstToken(element));
-                }
-
-                // Offset the following elements correctly relative to the first element
-                if (index === 0) {
-                    return;
-                }
-                if (offset === "first" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {
-                    offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));
-                } else {
-                    const previousElement = elements[index - 1];
-                    const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);
-
-                    if (previousElement && sourceCode.getLastToken(previousElement).loc.start.line > startToken.loc.end.line) {
-                        offsets.setDesiredOffsets(element.range, firstTokenOfPreviousElement, 0);
-                    }
-                }
-            });
-        }
-
-        /**
-         * Check and decide whether to check for indentation for blockless nodes
-         * Scenarios are for or while statements without braces around them
-         * @param {ASTNode} node node to examine
-         * @returns {void}
-         */
-        function addBlocklessNodeIndent(node) {
-            if (node.type !== "BlockStatement") {
-                const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);
-
-                let firstBodyToken = sourceCode.getFirstToken(node);
-                let lastBodyToken = sourceCode.getLastToken(node);
-
-                while (
-                    astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) &&
-                    astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))
-                ) {
-                    firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);
-                    lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);
-                }
-
-                offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);
-
-                /*
-                 * For blockless nodes with semicolon-first style, don't indent the semicolon.
-                 * e.g.
-                 * if (foo) bar()
-                 * ; [1, 2, 3].map(foo)
-                 */
-                const lastToken = sourceCode.getLastToken(node);
-
-                if (node.type !== "EmptyStatement" && astUtils.isSemicolonToken(lastToken)) {
-                    offsets.setDesiredOffset(lastToken, lastParentToken, 0);
-                }
-            }
-        }
-
-        /**
-        * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)
-        * @param {ASTNode} node A CallExpression or NewExpression node
-        * @returns {void}
-        */
-        function addFunctionCallIndent(node) {
-            let openingParen;
-
-            if (node.arguments.length) {
-                openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);
-            } else {
-                openingParen = sourceCode.getLastToken(node, 1);
-            }
-            const closingParen = sourceCode.getLastToken(node);
-
-            parameterParens.add(openingParen);
-            parameterParens.add(closingParen);
-            offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);
-
-            addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);
-        }
-
-        /**
-        * Checks the indentation of parenthesized values, given a list of tokens in a program
-        * @param {Token[]} tokens A list of tokens
-        * @returns {void}
-        */
-        function addParensIndent(tokens) {
-            const parenStack = [];
-            const parenPairs = [];
-
-            tokens.forEach(nextToken => {
-
-                // Accumulate a list of parenthesis pairs
-                if (astUtils.isOpeningParenToken(nextToken)) {
-                    parenStack.push(nextToken);
-                } else if (astUtils.isClosingParenToken(nextToken)) {
-                    parenPairs.unshift({ left: parenStack.pop(), right: nextToken });
-                }
-            });
-
-            parenPairs.forEach(pair => {
-                const leftParen = pair.left;
-                const rightParen = pair.right;
-
-                // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.
-                if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {
-                    const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));
-
-                    parenthesizedTokens.forEach(token => {
-                        if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {
-                            offsets.setDesiredOffset(token, leftParen, 1);
-                        }
-                    });
-                }
-
-                offsets.setDesiredOffset(rightParen, leftParen, 0);
-            });
-        }
-
-        /**
-        * Ignore all tokens within an unknown node whose offset do not depend
-        * on another token's offset within the unknown node
-        * @param {ASTNode} node Unknown Node
-        * @returns {void}
-        */
-        function ignoreNode(node) {
-            const unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));
-
-            unknownNodeTokens.forEach(token => {
-                if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {
-                    const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);
-
-                    if (token === firstTokenOfLine) {
-                        offsets.ignoreToken(token);
-                    } else {
-                        offsets.setDesiredOffset(token, firstTokenOfLine, 0);
-                    }
-                }
-            });
-        }
-
-        /**
-         * Check whether the given token is on the first line of a statement.
-         * @param {Token} token The token to check.
-         * @param {ASTNode} leafNode The expression node that the token belongs directly.
-         * @returns {boolean} `true` if the token is on the first line of a statement.
-         */
-        function isOnFirstLineOfStatement(token, leafNode) {
-            let node = leafNode;
-
-            while (node.parent && !node.parent.type.endsWith("Statement") && !node.parent.type.endsWith("Declaration")) {
-                node = node.parent;
-            }
-            node = node.parent;
-
-            return !node || node.loc.start.line === token.loc.start.line;
-        }
-
-        const baseOffsetListeners = {
-            "ArrayExpression, ArrayPattern"(node) {
-                const openingBracket = sourceCode.getFirstToken(node);
-                const closingBracket = sourceCode.getTokenAfter(lodash.findLast(node.elements) || openingBracket, astUtils.isClosingBracketToken);
-
-                addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);
-            },
-
-            "ObjectExpression, ObjectPattern"(node) {
-                const openingCurly = sourceCode.getFirstToken(node);
-                const closingCurly = sourceCode.getTokenAfter(
-                    node.properties.length ? node.properties[node.properties.length - 1] : openingCurly,
-                    astUtils.isClosingBraceToken
-                );
-
-                addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);
-            },
-
-            ArrowFunctionExpression(node) {
-                const firstToken = sourceCode.getFirstToken(node);
-
-                if (astUtils.isOpeningParenToken(firstToken)) {
-                    const openingParen = firstToken;
-                    const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);
-
-                    parameterParens.add(openingParen);
-                    parameterParens.add(closingParen);
-                    addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);
-                }
-                addBlocklessNodeIndent(node.body);
-
-                let arrowToken;
-
-                if (node.params.length) {
-                    arrowToken = sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isArrowToken);
-                } else {
-                    arrowToken = sourceCode.getFirstToken(node, astUtils.isArrowToken);
-                }
-                offsets.setDesiredOffset(arrowToken, sourceCode.getFirstToken(node), 0);
-            },
-
-            AssignmentExpression(node) {
-                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
-
-                offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);
-                offsets.ignoreToken(operator);
-                offsets.ignoreToken(sourceCode.getTokenAfter(operator));
-            },
-
-            "BinaryExpression, LogicalExpression"(node) {
-                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
-
-                /*
-                * For backwards compatibility, don't check BinaryExpression indents, e.g.
-                * var foo = bar &&
-                *                   baz;
-                */
-
-                const tokenAfterOperator = sourceCode.getTokenAfter(operator);
-
-                offsets.ignoreToken(operator);
-                offsets.ignoreToken(tokenAfterOperator);
-                offsets.setDesiredOffset(tokenAfterOperator, operator, 0);
-                offsets.setDesiredOffsets([tokenAfterOperator.range[1], node.range[1]], tokenAfterOperator, 1);
-            },
-
-            "BlockStatement, ClassBody"(node) {
-
-                let blockIndentLevel;
-
-                if (node.parent && isOuterIIFE(node.parent)) {
-                    blockIndentLevel = options.outerIIFEBody;
-                } else if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "ArrowFunctionExpression")) {
-                    blockIndentLevel = options.FunctionExpression.body;
-                } else if (node.parent && node.parent.type === "FunctionDeclaration") {
-                    blockIndentLevel = options.FunctionDeclaration.body;
-                } else {
-                    blockIndentLevel = 1;
-                }
-
-                /*
-                 * For blocks that aren't lone statements, ensure that the opening curly brace
-                 * is aligned with the parent.
-                 */
-                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
-                    offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);
-                }
-                addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);
-            },
-
-            CallExpression: addFunctionCallIndent,
-
-
-            "ClassDeclaration[superClass], ClassExpression[superClass]"(node) {
-                const classToken = sourceCode.getFirstToken(node);
-                const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);
-
-                offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);
-            },
-
-            ConditionalExpression(node) {
-                const firstToken = sourceCode.getFirstToken(node);
-
-                // `flatTernaryExpressions` option is for the following style:
-                // var a =
-                //     foo > 0 ? bar :
-                //     foo < 0 ? baz :
-                //     /*else*/ qiz ;
-                if (!options.flatTernaryExpressions ||
-                    !astUtils.isTokenOnSameLine(node.test, node.consequent) ||
-                    isOnFirstLineOfStatement(firstToken, node)
-                ) {
-                    const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === "Punctuator" && token.value === "?");
-                    const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === "Punctuator" && token.value === ":");
-
-                    const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken, { includeComments: true });
-                    const lastConsequentToken = sourceCode.getTokenBefore(colonToken, { includeComments: true });
-                    const firstAlternateToken = sourceCode.getTokenAfter(colonToken);
-
-                    offsets.setDesiredOffset(questionMarkToken, firstToken, 1);
-                    offsets.setDesiredOffset(colonToken, firstToken, 1);
-
-                    offsets.setDesiredOffset(firstConsequentToken, firstToken, 1);
-
-                    /*
-                     * The alternate and the consequent should usually have the same indentation.
-                     * If they share part of a line, align the alternate against the first token of the consequent.
-                     * This allows the alternate to be indented correctly in cases like this:
-                     * foo ? (
-                     *   bar
-                     * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`
-                     *   baz // as a result, `baz` is offset by 1 rather than 2
-                     * )
-                     */
-                    if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {
-                        offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);
-                    } else {
-
-                        /**
-                         * If the alternate and consequent do not share part of a line, offset the alternate from the first
-                         * token of the conditional expression. For example:
-                         * foo ? bar
-                         *   : baz
-                         *
-                         * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up
-                         * having no expected indentation.
-                         */
-                        offsets.setDesiredOffset(firstAlternateToken, firstToken, 1);
-                    }
-
-                    offsets.setDesiredOffsets([questionMarkToken.range[1], colonToken.range[0]], firstConsequentToken, 0);
-                    offsets.setDesiredOffsets([colonToken.range[1], node.range[1]], firstAlternateToken, 0);
-                }
-            },
-
-            "DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement": node => addBlocklessNodeIndent(node.body),
-
-            ExportNamedDeclaration(node) {
-                if (node.declaration === null) {
-                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);
-
-                    // Indent the specifiers in `export {foo, bar, baz}`
-                    addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);
-
-                    if (node.source) {
-
-                        // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`
-                        offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);
-                    }
-                }
-            },
-
-            ForStatement(node) {
-                const forOpeningParen = sourceCode.getFirstToken(node, 1);
-
-                if (node.init) {
-                    offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);
-                }
-                if (node.test) {
-                    offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);
-                }
-                if (node.update) {
-                    offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);
-                }
-                addBlocklessNodeIndent(node.body);
-            },
-
-            "FunctionDeclaration, FunctionExpression"(node) {
-                const closingParen = sourceCode.getTokenBefore(node.body);
-                const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);
-
-                parameterParens.add(openingParen);
-                parameterParens.add(closingParen);
-                addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);
-            },
-
-            IfStatement(node) {
-                addBlocklessNodeIndent(node.consequent);
-                if (node.alternate && node.alternate.type !== "IfStatement") {
-                    addBlocklessNodeIndent(node.alternate);
-                }
-            },
-
-            ImportDeclaration(node) {
-                if (node.specifiers.some(specifier => specifier.type === "ImportSpecifier")) {
-                    const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);
-                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);
-
-                    addElementListIndent(node.specifiers.filter(specifier => specifier.type === "ImportSpecifier"), openingCurly, closingCurly, options.ImportDeclaration);
-                }
-
-                const fromToken = sourceCode.getLastToken(node, token => token.type === "Identifier" && token.value === "from");
-
-                if (fromToken) {
-                    offsets.setDesiredOffsets([fromToken.range[0], node.range[1]], sourceCode.getFirstToken(node), 1);
-                }
-            },
-
-            "MemberExpression, JSXMemberExpression, MetaProperty"(node) {
-                const object = node.type === "MetaProperty" ? node.meta : node.object;
-                const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);
-                const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);
-
-                const objectParenCount = sourceCode.getTokensBetween(object, node.property, { filter: astUtils.isClosingParenToken }).length;
-                const firstObjectToken = objectParenCount
-                    ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 })
-                    : sourceCode.getFirstToken(object);
-                const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);
-                const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;
-
-                if (node.computed) {
-
-                    // For computed MemberExpressions, match the closing bracket with the opening bracket.
-                    offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);
-                    offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);
-                }
-
-                /*
-                 * If the object ends on the same line that the property starts, match against the last token
-                 * of the object, to ensure that the MemberExpression is not indented.
-                 *
-                 * Otherwise, match against the first token of the object, e.g.
-                 * foo
-                 *   .bar
-                 *   .baz // <-- offset by 1 from `foo`
-                 */
-                const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line
-                    ? lastObjectToken
-                    : firstObjectToken;
-
-                if (typeof options.MemberExpression === "number") {
-
-                    // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.
-                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);
-
-                    /*
-                     * For computed MemberExpressions, match the first token of the property against the opening bracket.
-                     * Otherwise, match the first token of the property against the object.
-                     */
-                    offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);
-                } else {
-
-                    // If the MemberExpression option is off, ignore the dot and the first token of the property.
-                    offsets.ignoreToken(firstNonObjectToken);
-                    offsets.ignoreToken(secondNonObjectToken);
-
-                    // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.
-                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);
-                    offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);
-                }
-            },
-
-            NewExpression(node) {
-
-                // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`
-                if (node.arguments.length > 0 || astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {
-                    addFunctionCallIndent(node);
-                }
-            },
-
-            Property(node) {
-                if (!node.shorthand && !node.method && node.kind === "init") {
-                    const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);
-
-                    offsets.ignoreToken(sourceCode.getTokenAfter(colon));
-                }
-            },
-
-            SwitchStatement(node) {
-                const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);
-                const closingCurly = sourceCode.getLastToken(node);
-                const caseKeywords = node.cases.map(switchCase => sourceCode.getFirstToken(switchCase));
-
-                offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);
-
-                node.cases.forEach((switchCase, index) => {
-                    const caseKeyword = caseKeywords[index];
-
-                    if (!(switchCase.consequent.length === 1 && switchCase.consequent[0].type === "BlockStatement")) {
-                        const tokenAfterCurrentCase = index === node.cases.length - 1 ? closingCurly : caseKeywords[index + 1];
-
-                        offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);
-                    }
-                });
-
-                if (node.cases.length) {
-                    sourceCode.getTokensBetween(
-                        node.cases[node.cases.length - 1],
-                        closingCurly,
-                        { includeComments: true, filter: astUtils.isCommentToken }
-                    ).forEach(token => offsets.ignoreToken(token));
-                }
-            },
-
-            TemplateLiteral(node) {
-                node.expressions.forEach((expression, index) => {
-                    const previousQuasi = node.quasis[index];
-                    const nextQuasi = node.quasis[index + 1];
-                    const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode.getFirstToken(previousQuasi) : null;
-
-                    offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);
-                    offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);
-                });
-            },
-
-            VariableDeclaration(node) {
-                const variableIndent = options.VariableDeclarator.hasOwnProperty(node.kind) ? options.VariableDeclarator[node.kind] : DEFAULT_VARIABLE_INDENT;
-
-                if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {
-
-                    /*
-                     * VariableDeclarator indentation is a bit different from other forms of indentation, in that the
-                     * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,
-                     * the following indentations are correct:
-                     *
-                     * var foo = {
-                     *   ok: true
-                     * };
-                     *
-                     * var foo = {
-                     *     ok: true,
-                     *   },
-                     *   bar = 1;
-                     *
-                     * Account for when exiting the AST (after indentations have already been set for the nodes in
-                     * the declaration) by manually increasing the indentation level of the tokens in this declarator
-                     * on the same line as the start of the declaration, provided that there are declarators that
-                     * follow this one.
-                     */
-                    const firstToken = sourceCode.getFirstToken(node);
-
-                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);
-                } else {
-                    offsets.setDesiredOffsets(node.range, sourceCode.getFirstToken(node), variableIndent);
-                }
-                const lastToken = sourceCode.getLastToken(node);
-
-                if (astUtils.isSemicolonToken(lastToken)) {
-                    offsets.ignoreToken(lastToken);
-                }
-            },
-
-            VariableDeclarator(node) {
-                if (node.init) {
-                    const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);
-                    const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);
-
-                    offsets.ignoreToken(equalOperator);
-                    offsets.ignoreToken(tokenAfterOperator);
-                    offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);
-                    offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);
-                }
-            },
-
-            "JSXAttribute[value]"(node) {
-                const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === "Punctuator" && token.value === "=");
-
-                offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);
-            },
-
-            JSXElement(node) {
-                if (node.closingElement) {
-                    addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);
-                }
-            },
-
-            JSXOpeningElement(node) {
-                const firstToken = sourceCode.getFirstToken(node);
-                let closingToken;
-
-                if (node.selfClosing) {
-                    closingToken = sourceCode.getLastToken(node, { skip: 1 });
-                    offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);
-                } else {
-                    closingToken = sourceCode.getLastToken(node);
-                }
-                offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));
-                addElementListIndent(node.attributes, firstToken, closingToken, 1);
-            },
-
-            JSXClosingElement(node) {
-                const firstToken = sourceCode.getFirstToken(node);
-
-                offsets.setDesiredOffsets(node.name.range, firstToken, 1);
-                offsets.setDesiredOffset(sourceCode.getLastToken(node), firstToken, 0);
-            },
-
-            JSXExpressionContainer(node) {
-                const openingCurly = sourceCode.getFirstToken(node);
-                const closingCurly = sourceCode.getLastToken(node);
-
-                offsets.setDesiredOffsets(
-                    [openingCurly.range[1], closingCurly.range[0]],
-                    openingCurly,
-                    1
-                );
-                offsets.setDesiredOffset(closingCurly, openingCurly, 0);
-            }
-        };
-
-        const listenerCallQueue = [];
-
-        /*
-         * To ignore the indentation of a node:
-         * 1. Don't call the node's listener when entering it (if it has a listener)
-         * 2. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.
-         */
-        const offsetListeners = lodash.mapValues(
-            baseOffsetListeners,
-
-            /*
-             * Offset listener calls are deferred until traversal is finished, and are called as
-             * part of the final `Program:exit` listener. This is necessary because a node might
-             * be matched by multiple selectors.
-             *
-             * Example: Suppose there is an offset listener for `Identifier`, and the user has
-             * specified in configuration that `MemberExpression > Identifier` should be ignored.
-             * Due to selector specificity rules, the `Identifier` listener will get called first. However,
-             * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener
-             * should not have been called at all. Without doing extra selector matching, we don't know
-             * whether the Identifier matches the `MemberExpression > Identifier` selector until the
-             * `MemberExpression > Identifier` listener is called.
-             *
-             * To avoid this, the `Identifier` listener isn't called until traversal finishes and all
-             * ignored nodes are known.
-             */
-            listener =>
-                node =>
-                    listenerCallQueue.push({ listener, node })
-        );
-
-        // For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.
-        const ignoredNodes = new Set();
-        const addToIgnoredNodes = ignoredNodes.add.bind(ignoredNodes);
-
-        const ignoredNodeListeners = options.ignoredNodes.reduce(
-            (listeners, ignoredSelector) => Object.assign(listeners, { [ignoredSelector]: addToIgnoredNodes }),
-            {}
-        );
-
-        /*
-         * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation
-         * at the end.
-         *
-         * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears
-         * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored,
-         * so those listeners wouldn't be called anyway.
-         */
-        return Object.assign(
-            offsetListeners,
-            ignoredNodeListeners,
-            {
-                "*:exit"(node) {
-
-                    // If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.
-                    if (!KNOWN_NODES.has(node.type)) {
-                        ignoredNodes.add(node);
-                    }
-                },
-                "Program:exit"() {
-
-                    // Invoke the queued offset listeners for the nodes that aren't ignored.
-                    listenerCallQueue
-                        .filter(nodeInfo => !ignoredNodes.has(nodeInfo.node))
-                        .forEach(nodeInfo => nodeInfo.listener(nodeInfo.node));
-
-                    // Update the offsets for ignored nodes to prevent their child tokens from being reported.
-                    ignoredNodes.forEach(ignoreNode);
-
-                    addParensIndent(sourceCode.ast.tokens);
-
-                    /*
-                     * Create a Map from (tokenOrComment) => (precedingToken).
-                     * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.
-                     */
-                    const precedingTokens = sourceCode.ast.comments.reduce((commentMap, comment) => {
-                        const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });
-
-                        return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);
-                    }, new WeakMap());
-
-                    sourceCode.lines.forEach((line, lineIndex) => {
-                        const lineNumber = lineIndex + 1;
-
-                        if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {
-
-                            // Don't check indentation on blank lines
-                            return;
-                        }
-
-                        const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);
-
-                        if (firstTokenOfLine.loc.start.line !== lineNumber) {
-
-                            // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.
-                            return;
-                        }
-
-                        // If the token matches the expected expected indentation, don't report it.
-                        if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {
-                            return;
-                        }
-
-                        if (astUtils.isCommentToken(firstTokenOfLine)) {
-                            const tokenBefore = precedingTokens.get(firstTokenOfLine);
-                            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];
-
-                            // If a comment matches the expected indentation of the token immediately before or after, don't report it.
-                            if (
-                                tokenBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) ||
-                                tokenAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))
-                            ) {
-                                return;
-                            }
-                        }
-
-                        // Otherwise, report the token/comment.
-                        report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));
-                    });
-                }
-            }
-        );
-    }
-};
Index: node_modules/eslint/lib/rules/no-new.js
===================================================================
--- node_modules/eslint/lib/rules/no-new.js	(revision )
+++ node_modules/eslint/lib/rules/no-new.js	(revision )
@@ -1,33 +0,0 @@
-/**
- * @fileoverview Rule to flag statements with function invocation preceded by
- * "new" and not part of assignment
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `new` operators outside of assignments or comparisons",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-            "ExpressionStatement > NewExpression"(node) {
-                context.report({ node: node.parent, message: "Do not use 'new' for side effects." });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-var.js
===================================================================
--- node_modules/eslint/lib/rules/no-var.js	(revision )
+++ node_modules/eslint/lib/rules/no-var.js	(revision )
@@ -1,317 +0,0 @@
-/**
- * @fileoverview Rule to check for the usage of var.
- * @author Jamund Ferguson
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Finds the nearest function scope or global scope walking up the scope
- * hierarchy.
- *
- * @param {eslint-scope.Scope} scope - The scope to traverse.
- * @returns {eslint-scope.Scope} a function scope or global scope containing the given
- *      scope.
- */
-function getEnclosingFunctionScope(scope) {
-    while (scope.type !== "function" && scope.type !== "global") {
-        scope = scope.upper;
-    }
-    return scope;
-}
-
-/**
- * Checks whether the given variable has any references from a more specific
- * function expression (i.e. a closure).
- *
- * @param {eslint-scope.Variable} variable - A variable to check.
- * @returns {boolean} `true` if the variable is used from a closure.
- */
-function isReferencedInClosure(variable) {
-    const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);
-
-    return variable.references.some(reference =>
-        getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);
-}
-
-/**
- * Checks whether the given node is the assignee of a loop.
- *
- * @param {ASTNode} node - A VariableDeclaration node to check.
- * @returns {boolean} `true` if the declaration is assigned as part of loop
- *      iteration.
- */
-function isLoopAssignee(node) {
-    return (node.parent.type === "ForOfStatement" || node.parent.type === "ForInStatement") &&
-        node === node.parent.left;
-}
-
-/**
- * Checks whether the given variable declaration is immediately initialized.
- *
- * @param {ASTNode} node - A VariableDeclaration node to check.
- * @returns {boolean} `true` if the declaration has an initializer.
- */
-function isDeclarationInitialized(node) {
-    return node.declarations.every(declarator => declarator.init !== null);
-}
-
-const SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/;
-
-/**
- * Gets the scope node which directly contains a given node.
- *
- * @param {ASTNode} node - A node to get. This is a `VariableDeclaration` or
- *      an `Identifier`.
- * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,
- *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and
- *      `ForOfStatement`.
- */
-function getScopeNode(node) {
-    while (node) {
-        if (SCOPE_NODE_TYPE.test(node.type)) {
-            return node;
-        }
-
-        node = node.parent;
-    }
-
-    /* istanbul ignore next : unreachable */
-    return null;
-}
-
-/**
- * Checks whether a given variable is redeclared or not.
- *
- * @param {eslint-scope.Variable} variable - A variable to check.
- * @returns {boolean} `true` if the variable is redeclared.
- */
-function isRedeclared(variable) {
-    return variable.defs.length >= 2;
-}
-
-/**
- * Checks whether a given variable is used from outside of the specified scope.
- *
- * @param {ASTNode} scopeNode - A scope node to check.
- * @returns {Function} The predicate function which checks whether a given
- *      variable is used from outside of the specified scope.
- */
-function isUsedFromOutsideOf(scopeNode) {
-
-    /**
-     * Checks whether a given reference is inside of the specified scope or not.
-     *
-     * @param {eslint-scope.Reference} reference - A reference to check.
-     * @returns {boolean} `true` if the reference is inside of the specified
-     *      scope.
-     */
-    function isOutsideOfScope(reference) {
-        const scope = scopeNode.range;
-        const id = reference.identifier.range;
-
-        return id[0] < scope[0] || id[1] > scope[1];
-    }
-
-    return function(variable) {
-        return variable.references.some(isOutsideOfScope);
-    };
-}
-
-/**
- * Creates the predicate function which checks whether a variable has their references in TDZ.
- *
- * The predicate function would return `true`:
- *
- * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)
- * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)
- * - if a reference is in the expression of their initializer.  E.g. (var a = a;)
- *
- * @param {ASTNode} node - The initializer node of VariableDeclarator.
- * @returns {Function} The predicate function.
- * @private
- */
-function hasReferenceInTDZ(node) {
-    const initStart = node.range[0];
-    const initEnd = node.range[1];
-
-    return variable => {
-        const id = variable.defs[0].name;
-        const idStart = id.range[0];
-        const defaultValue = (id.parent.type === "AssignmentPattern" ? id.parent.right : null);
-        const defaultStart = defaultValue && defaultValue.range[0];
-        const defaultEnd = defaultValue && defaultValue.range[1];
-
-        return variable.references.some(reference => {
-            const start = reference.identifier.range[0];
-            const end = reference.identifier.range[1];
-
-            return !reference.init && (
-                start < idStart ||
-                (defaultValue !== null && start >= defaultStart && end <= defaultEnd) ||
-                (start >= initStart && end <= initEnd)
-            );
-        });
-    };
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require `let` or `const` instead of `var`",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: [],
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Checks whether the variables which are defined by the given declarator node have their references in TDZ.
-         *
-         * @param {ASTNode} declarator - The VariableDeclarator node to check.
-         * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.
-         */
-        function hasSelfReferenceInTDZ(declarator) {
-            if (!declarator.init) {
-                return false;
-            }
-            const variables = context.getDeclaredVariables(declarator);
-
-            return variables.some(hasReferenceInTDZ(declarator.init));
-        }
-
-        /**
-         * Checks whether it can fix a given variable declaration or not.
-         * It cannot fix if the following cases:
-         *
-         * - A variable is declared on a SwitchCase node.
-         * - A variable is redeclared.
-         * - A variable is used from outside the scope.
-         * - A variable is used from a closure within a loop.
-         * - A variable might be used before it is assigned within a loop.
-         * - A variable might be used in TDZ.
-         * - A variable is declared in statement position (e.g. a single-line `IfStatement`)
-         *
-         * ## A variable is declared on a SwitchCase node.
-         *
-         * If this rule modifies 'var' declarations on a SwitchCase node, it
-         * would generate the warnings of 'no-case-declarations' rule. And the
-         * 'eslint:recommended' preset includes 'no-case-declarations' rule, so
-         * this rule doesn't modify those declarations.
-         *
-         * ## A variable is redeclared.
-         *
-         * The language spec disallows redeclarations of `let` declarations.
-         * Those variables would cause syntax errors.
-         *
-         * ## A variable is used from outside the scope.
-         *
-         * The language spec disallows accesses from outside of the scope for
-         * `let` declarations. Those variables would cause reference errors.
-         *
-         * ## A variable is used from a closure within a loop.
-         *
-         * A `var` declaration within a loop shares the same variable instance
-         * across all loop iterations, while a `let` declaration creates a new
-         * instance for each iteration. This means if a variable in a loop is
-         * referenced by any closure, changing it from `var` to `let` would
-         * change the behavior in a way that is generally unsafe.
-         *
-         * ## A variable might be used before it is assigned within a loop.
-         *
-         * Within a loop, a `let` declaration without an initializer will be
-         * initialized to null, while a `var` declaration will retain its value
-         * from the previous iteration, so it is only safe to change `var` to
-         * `let` if we can statically determine that the variable is always
-         * assigned a value before its first access in the loop body. To keep
-         * the implementation simple, we only convert `var` to `let` within
-         * loops when the variable is a loop assignee or the declaration has an
-         * initializer.
-         *
-         * @param {ASTNode} node - A variable declaration node to check.
-         * @returns {boolean} `true` if it can fix the node.
-         */
-        function canFix(node) {
-            const variables = context.getDeclaredVariables(node);
-            const scopeNode = getScopeNode(node);
-
-            if (node.parent.type === "SwitchCase" ||
-                node.declarations.some(hasSelfReferenceInTDZ) ||
-                variables.some(isRedeclared) ||
-                variables.some(isUsedFromOutsideOf(scopeNode))
-            ) {
-                return false;
-            }
-
-            if (astUtils.isInLoop(node)) {
-                if (variables.some(isReferencedInClosure)) {
-                    return false;
-                }
-                if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {
-                    return false;
-                }
-            }
-
-            if (
-                !isLoopAssignee(node) &&
-                !(node.parent.type === "ForStatement" && node.parent.init === node) &&
-                !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)
-            ) {
-
-                // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.
-                return false;
-            }
-
-            return true;
-        }
-
-        /**
-         * Reports a given variable declaration node.
-         *
-         * @param {ASTNode} node - A variable declaration node to report.
-         * @returns {void}
-         */
-        function report(node) {
-            const varToken = sourceCode.getFirstToken(node);
-
-            context.report({
-                node,
-                message: "Unexpected var, use let or const instead.",
-
-                fix(fixer) {
-                    if (canFix(node)) {
-                        return fixer.replaceText(varToken, "let");
-                    }
-                    return null;
-                }
-            });
-        }
-
-        return {
-            "VariableDeclaration:exit"(node) {
-                if (node.kind === "var") {
-                    report(node);
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/quotes.js
===================================================================
--- node_modules/eslint/lib/rules/quotes.js	(revision )
+++ node_modules/eslint/lib/rules/quotes.js	(revision )
@@ -1,296 +0,0 @@
-/**
- * @fileoverview A rule to choose between single and double quote marks
- * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Constants
-//------------------------------------------------------------------------------
-
-const QUOTE_SETTINGS = {
-    double: {
-        quote: "\"",
-        alternateQuote: "'",
-        description: "doublequote"
-    },
-    single: {
-        quote: "'",
-        alternateQuote: "\"",
-        description: "singlequote"
-    },
-    backtick: {
-        quote: "`",
-        alternateQuote: "\"",
-        description: "backtick"
-    }
-};
-
-// An unescaped newline is a newline preceded by an even number of backslashes.
-const UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\])(\\\\)*[${Array.from(astUtils.LINEBREAKS).join("")}]`);
-
-/**
- * Switches quoting of javascript string between ' " and `
- * escaping and unescaping as necessary.
- * Only escaping of the minimal set of characters is changed.
- * Note: escaping of newlines when switching from backtick to other quotes is not handled.
- * @param {string} str - A string to convert.
- * @returns {string} The string with changed quotes.
- * @private
- */
-QUOTE_SETTINGS.double.convert =
-QUOTE_SETTINGS.single.convert =
-QUOTE_SETTINGS.backtick.convert = function(str) {
-    const newQuote = this.quote;
-    const oldQuote = str[0];
-
-    if (newQuote === oldQuote) {
-        return str;
-    }
-    return newQuote + str.slice(1, -1).replace(/\\(\${|\r\n?|\n|.)|["'`]|\${|(\r\n?|\n)/g, (match, escaped, newline) => {
-        if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
-            return escaped; // unescape
-        }
-        if (match === newQuote || newQuote === "`" && match === "${") {
-            return `\\${match}`; // escape
-        }
-        if (newline && oldQuote === "`") {
-            return "\\n"; // escape newlines
-        }
-        return match;
-    }) + newQuote;
-};
-
-const AVOID_ESCAPE = "avoid-escape";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce the consistent use of either backticks, double, or single quotes",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "code",
-
-        schema: [
-            {
-                enum: ["single", "double", "backtick"]
-            },
-            {
-                anyOf: [
-                    {
-                        enum: ["avoid-escape"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            avoidEscape: {
-                                type: "boolean"
-                            },
-                            allowTemplateLiterals: {
-                                type: "boolean"
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-
-        const quoteOption = context.options[0],
-            settings = QUOTE_SETTINGS[quoteOption || "double"],
-            options = context.options[1],
-            allowTemplateLiterals = options && options.allowTemplateLiterals === true,
-            sourceCode = context.getSourceCode();
-        let avoidEscape = options && options.avoidEscape === true;
-
-        // deprecated
-        if (options === AVOID_ESCAPE) {
-            avoidEscape = true;
-        }
-
-        /**
-         * Determines if a given node is part of JSX syntax.
-         *
-         * This function returns `true` in the following cases:
-         *
-         * - `<div className="foo"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.
-         * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.
-         *
-         * In particular, this function returns `false` in the following cases:
-         *
-         * - `<div className={"foo"}></div>`
-         * - `<div>{"foo"}</div>`
-         *
-         * In both cases, inside of the braces is handled as normal JavaScript.
-         * The braces are `JSXExpressionContainer` nodes.
-         *
-         * @param {ASTNode} node The Literal node to check.
-         * @returns {boolean} True if the node is a part of JSX, false if not.
-         * @private
-         */
-        function isJSXLiteral(node) {
-            return node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement";
-        }
-
-        /**
-         * Checks whether or not a given node is a directive.
-         * The directive is a `ExpressionStatement` which has only a string literal.
-         * @param {ASTNode} node - A node to check.
-         * @returns {boolean} Whether or not the node is a directive.
-         * @private
-         */
-        function isDirective(node) {
-            return (
-                node.type === "ExpressionStatement" &&
-                node.expression.type === "Literal" &&
-                typeof node.expression.value === "string"
-            );
-        }
-
-        /**
-         * Checks whether or not a given node is a part of directive prologues.
-         * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive
-         * @param {ASTNode} node - A node to check.
-         * @returns {boolean} Whether or not the node is a part of directive prologues.
-         * @private
-         */
-        function isPartOfDirectivePrologue(node) {
-            const block = node.parent.parent;
-
-            if (block.type !== "Program" && (block.type !== "BlockStatement" || !astUtils.isFunction(block.parent))) {
-                return false;
-            }
-
-            // Check the node is at a prologue.
-            for (let i = 0; i < block.body.length; ++i) {
-                const statement = block.body[i];
-
-                if (statement === node.parent) {
-                    return true;
-                }
-                if (!isDirective(statement)) {
-                    break;
-                }
-            }
-
-            return false;
-        }
-
-        /**
-         * Checks whether or not a given node is allowed as non backtick.
-         * @param {ASTNode} node - A node to check.
-         * @returns {boolean} Whether or not the node is allowed as non backtick.
-         * @private
-         */
-        function isAllowedAsNonBacktick(node) {
-            const parent = node.parent;
-
-            switch (parent.type) {
-
-                // Directive Prologues.
-                case "ExpressionStatement":
-                    return isPartOfDirectivePrologue(node);
-
-                // LiteralPropertyName.
-                case "Property":
-                case "MethodDefinition":
-                    return parent.key === node && !parent.computed;
-
-                // ModuleSpecifier.
-                case "ImportDeclaration":
-                case "ExportNamedDeclaration":
-                case "ExportAllDeclaration":
-                    return parent.source === node;
-
-                // Others don't allow.
-                default:
-                    return false;
-            }
-        }
-
-        return {
-
-            Literal(node) {
-                const val = node.value,
-                    rawVal = node.raw;
-
-                if (settings && typeof val === "string") {
-                    let isValid = (quoteOption === "backtick" && isAllowedAsNonBacktick(node)) ||
-                        isJSXLiteral(node) ||
-                        astUtils.isSurroundedBy(rawVal, settings.quote);
-
-                    if (!isValid && avoidEscape) {
-                        isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
-                    }
-
-                    if (!isValid) {
-                        context.report({
-                            node,
-                            message: "Strings must use {{description}}.",
-                            data: {
-                                description: settings.description
-                            },
-                            fix(fixer) {
-                                return fixer.replaceText(node, settings.convert(node.raw));
-                            }
-                        });
-                    }
-                }
-            },
-
-            TemplateLiteral(node) {
-
-                // If backticks are expected or it's a tagged template, then this shouldn't throw an errors
-                if (
-                    allowTemplateLiterals ||
-                    quoteOption === "backtick" ||
-                    node.parent.type === "TaggedTemplateExpression" && node === node.parent.quasi
-                ) {
-                    return;
-                }
-
-                // A warning should be produced if the template literal only has one TemplateElement, and has no unescaped newlines.
-                const shouldWarn = node.quasis.length === 1 && !UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);
-
-                if (shouldWarn) {
-                    context.report({
-                        node,
-                        message: "Strings must use {{description}}.",
-                        data: {
-                            description: settings.description
-                        },
-                        fix(fixer) {
-                            if (isPartOfDirectivePrologue(node)) {
-
-                                /*
-                                 * TemplateLiterals in a directive prologue aren't actually directives, but if they're
-                                 * in the directive prologue, then fixing them might turn them into directives and change
-                                 * the behavior of the code.
-                                 */
-                                return null;
-                            }
-                            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
-                        }
-                    });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/strict.js
===================================================================
--- node_modules/eslint/lib/rules/strict.js	(revision )
+++ node_modules/eslint/lib/rules/strict.js	(revision )
@@ -1,277 +0,0 @@
-/**
- * @fileoverview Rule to control usage of strict mode directives.
- * @author Brandon Mills
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const messages = {
-    function: "Use the function form of 'use strict'.",
-    global: "Use the global form of 'use strict'.",
-    multiple: "Multiple 'use strict' directives.",
-    never: "Strict mode is not permitted.",
-    unnecessary: "Unnecessary 'use strict' directive.",
-    module: "'use strict' is unnecessary inside of modules.",
-    implied: "'use strict' is unnecessary when implied strict mode is enabled.",
-    unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
-    nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
-    wrap: "Wrap {{name}} in a function with 'use strict' directive."
-};
-
-/**
- * Gets all of the Use Strict Directives in the Directive Prologue of a group of
- * statements.
- * @param {ASTNode[]} statements Statements in the program or function body.
- * @returns {ASTNode[]} All of the Use Strict Directives.
- */
-function getUseStrictDirectives(statements) {
-    const directives = [];
-
-    for (let i = 0; i < statements.length; i++) {
-        const statement = statements[i];
-
-        if (
-            statement.type === "ExpressionStatement" &&
-            statement.expression.type === "Literal" &&
-            statement.expression.value === "use strict"
-        ) {
-            directives[i] = statement;
-        } else {
-            break;
-        }
-    }
-
-    return directives;
-}
-
-/**
- * Checks whether a given parameter is a simple parameter.
- *
- * @param {ASTNode} node - A pattern node to check.
- * @returns {boolean} `true` if the node is an Identifier node.
- */
-function isSimpleParameter(node) {
-    return node.type === "Identifier";
-}
-
-/**
- * Checks whether a given parameter list is a simple parameter list.
- *
- * @param {ASTNode[]} params - A parameter list to check.
- * @returns {boolean} `true` if the every parameter is an Identifier node.
- */
-function isSimpleParameterList(params) {
-    return params.every(isSimpleParameter);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow strict mode directives",
-            category: "Strict Mode",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["never", "global", "function", "safe"]
-            }
-        ],
-
-        fixable: "code"
-    },
-
-    create(context) {
-
-        const ecmaFeatures = context.parserOptions.ecmaFeatures || {},
-            scopes = [],
-            classScopes = [];
-        let mode = context.options[0] || "safe";
-
-        if (ecmaFeatures.impliedStrict) {
-            mode = "implied";
-        } else if (mode === "safe") {
-            mode = ecmaFeatures.globalReturn ? "global" : "function";
-        }
-
-        /**
-        * Determines whether a reported error should be fixed, depending on the error type.
-        * @param {string} errorType The type of error
-        * @returns {boolean} `true` if the reported error should be fixed
-        */
-        function shouldFix(errorType) {
-            return errorType === "multiple" || errorType === "unnecessary" || errorType === "module" || errorType === "implied" || errorType === "unnecessaryInClasses";
-        }
-
-        /**
-        * Gets a fixer function to remove a given 'use strict' directive.
-        * @param {ASTNode} node The directive that should be removed
-        * @returns {Function} A fixer function
-        */
-        function getFixFunction(node) {
-            return fixer => fixer.remove(node);
-        }
-
-        /**
-         * Report a slice of an array of nodes with a given message.
-         * @param {ASTNode[]} nodes Nodes.
-         * @param {string} start Index to start from.
-         * @param {string} end Index to end before.
-         * @param {string} message Message to display.
-         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)
-         * @returns {void}
-         */
-        function reportSlice(nodes, start, end, message, fix) {
-            nodes.slice(start, end).forEach(node => {
-                context.report({ node, message, fix: fix ? getFixFunction(node) : null });
-            });
-        }
-
-        /**
-         * Report all nodes in an array with a given message.
-         * @param {ASTNode[]} nodes Nodes.
-         * @param {string} message Message to display.
-         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)
-         * @returns {void}
-         */
-        function reportAll(nodes, message, fix) {
-            reportSlice(nodes, 0, nodes.length, message, fix);
-        }
-
-        /**
-         * Report all nodes in an array, except the first, with a given message.
-         * @param {ASTNode[]} nodes Nodes.
-         * @param {string} message Message to display.
-         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)
-         * @returns {void}
-         */
-        function reportAllExceptFirst(nodes, message, fix) {
-            reportSlice(nodes, 1, nodes.length, message, fix);
-        }
-
-        /**
-         * Entering a function in 'function' mode pushes a new nested scope onto the
-         * stack. The new scope is true if the nested function is strict mode code.
-         * @param {ASTNode} node The function declaration or expression.
-         * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.
-         * @returns {void}
-         */
-        function enterFunctionInFunctionMode(node, useStrictDirectives) {
-            const isInClass = classScopes.length > 0,
-                isParentGlobal = scopes.length === 0 && classScopes.length === 0,
-                isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],
-                isStrict = useStrictDirectives.length > 0;
-
-            if (isStrict) {
-                if (!isSimpleParameterList(node.params)) {
-                    context.report({ node: useStrictDirectives[0], message: messages.nonSimpleParameterList });
-                } else if (isParentStrict) {
-                    context.report({ node: useStrictDirectives[0], message: messages.unnecessary, fix: getFixFunction(useStrictDirectives[0]) });
-                } else if (isInClass) {
-                    context.report({ node: useStrictDirectives[0], message: messages.unnecessaryInClasses, fix: getFixFunction(useStrictDirectives[0]) });
-                }
-
-                reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
-            } else if (isParentGlobal) {
-                if (isSimpleParameterList(node.params)) {
-                    context.report({ node, message: messages.function });
-                } else {
-                    context.report({
-                        node,
-                        message: messages.wrap,
-                        data: { name: astUtils.getFunctionNameWithKind(node) }
-                    });
-                }
-            }
-
-            scopes.push(isParentStrict || isStrict);
-        }
-
-        /**
-         * Exiting a function in 'function' mode pops its scope off the stack.
-         * @returns {void}
-         */
-        function exitFunctionInFunctionMode() {
-            scopes.pop();
-        }
-
-        /**
-         * Enter a function and either:
-         * - Push a new nested scope onto the stack (in 'function' mode).
-         * - Report all the Use Strict Directives (in the other modes).
-         * @param {ASTNode} node The function declaration or expression.
-         * @returns {void}
-         */
-        function enterFunction(node) {
-            const isBlock = node.body.type === "BlockStatement",
-                useStrictDirectives = isBlock
-                    ? getUseStrictDirectives(node.body.body) : [];
-
-            if (mode === "function") {
-                enterFunctionInFunctionMode(node, useStrictDirectives);
-            } else if (useStrictDirectives.length > 0) {
-                if (isSimpleParameterList(node.params)) {
-                    reportAll(useStrictDirectives, messages[mode], shouldFix(mode));
-                } else {
-                    context.report({ node: useStrictDirectives[0], message: messages.nonSimpleParameterList });
-                    reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
-                }
-            }
-        }
-
-        const rule = {
-            Program(node) {
-                const useStrictDirectives = getUseStrictDirectives(node.body);
-
-                if (node.sourceType === "module") {
-                    mode = "module";
-                }
-
-                if (mode === "global") {
-                    if (node.body.length > 0 && useStrictDirectives.length === 0) {
-                        context.report({ node, message: messages.global });
-                    }
-                    reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
-                } else {
-                    reportAll(useStrictDirectives, messages[mode], shouldFix(mode));
-                }
-            },
-            FunctionDeclaration: enterFunction,
-            FunctionExpression: enterFunction,
-            ArrowFunctionExpression: enterFunction
-        };
-
-        if (mode === "function") {
-            Object.assign(rule, {
-
-                // Inside of class bodies are always strict mode.
-                ClassBody() {
-                    classScopes.push(true);
-                },
-                "ClassBody:exit"() {
-                    classScopes.pop();
-                },
-
-                "FunctionDeclaration:exit": exitFunctionInFunctionMode,
-                "FunctionExpression:exit": exitFunctionInFunctionMode,
-                "ArrowFunctionExpression:exit": exitFunctionInFunctionMode
-            });
-        }
-
-        return rule;
-    }
-};
Index: node_modules/eslint/lib/rules/max-len.js
===================================================================
--- node_modules/eslint/lib/rules/max-len.js	(revision )
+++ node_modules/eslint/lib/rules/max-len.js	(revision )
@@ -1,366 +0,0 @@
-/**
- * @fileoverview Rule to check for max length on a line.
- * @author Matt DuVall <http://www.mattduvall.com>
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Constants
-//------------------------------------------------------------------------------
-
-const OPTIONS_SCHEMA = {
-    type: "object",
-    properties: {
-        code: {
-            type: "integer",
-            minimum: 0
-        },
-        comments: {
-            type: "integer",
-            minimum: 0
-        },
-        tabWidth: {
-            type: "integer",
-            minimum: 0
-        },
-        ignorePattern: {
-            type: "string"
-        },
-        ignoreComments: {
-            type: "boolean"
-        },
-        ignoreStrings: {
-            type: "boolean"
-        },
-        ignoreUrls: {
-            type: "boolean"
-        },
-        ignoreTemplateLiterals: {
-            type: "boolean"
-        },
-        ignoreRegExpLiterals: {
-            type: "boolean"
-        },
-        ignoreTrailingComments: {
-            type: "boolean"
-        }
-    },
-    additionalProperties: false
-};
-
-const OPTIONS_OR_INTEGER_SCHEMA = {
-    anyOf: [
-        OPTIONS_SCHEMA,
-        {
-            type: "integer",
-            minimum: 0
-        }
-    ]
-};
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce a maximum line length",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            OPTIONS_OR_INTEGER_SCHEMA,
-            OPTIONS_OR_INTEGER_SCHEMA,
-            OPTIONS_SCHEMA
-        ]
-    },
-
-    create(context) {
-
-        /*
-         * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:
-         * - They're matching an entire string that we know is a URI
-         * - We're matching part of a string where we think there *might* be a URL
-         * - We're only concerned about URLs, as picking out any URI would cause
-         *   too many false positives
-         * - We don't care about matching the entire URL, any small segment is fine
-         */
-        const URL_REGEXP = /[^:/?#]:\/\/[^?#]/;
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Computes the length of a line that may contain tabs. The width of each
-         * tab will be the number of spaces to the next tab stop.
-         * @param {string} line The line.
-         * @param {int} tabWidth The width of each tab stop in spaces.
-         * @returns {int} The computed line length.
-         * @private
-         */
-        function computeLineLength(line, tabWidth) {
-            let extraCharacterCount = 0;
-
-            line.replace(/\t/g, (match, offset) => {
-                const totalOffset = offset + extraCharacterCount,
-                    previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,
-                    spaceCount = tabWidth - previousTabStopOffset;
-
-                extraCharacterCount += spaceCount - 1; // -1 for the replaced tab
-            });
-            return Array.from(line).length + extraCharacterCount;
-        }
-
-        // The options object must be the last option specified…
-        const lastOption = context.options[context.options.length - 1];
-        const options = typeof lastOption === "object" ? Object.create(lastOption) : {};
-
-        // …but max code length…
-        if (typeof context.options[0] === "number") {
-            options.code = context.options[0];
-        }
-
-        // …and tabWidth can be optionally specified directly as integers.
-        if (typeof context.options[1] === "number") {
-            options.tabWidth = context.options[1];
-        }
-
-        const maxLength = options.code || 80,
-            tabWidth = options.tabWidth || 4,
-            ignoreComments = options.ignoreComments || false,
-            ignoreStrings = options.ignoreStrings || false,
-            ignoreTemplateLiterals = options.ignoreTemplateLiterals || false,
-            ignoreRegExpLiterals = options.ignoreRegExpLiterals || false,
-            ignoreTrailingComments = options.ignoreTrailingComments || options.ignoreComments || false,
-            ignoreUrls = options.ignoreUrls || false,
-            maxCommentLength = options.comments;
-        let ignorePattern = options.ignorePattern || null;
-
-        if (ignorePattern) {
-            ignorePattern = new RegExp(ignorePattern);
-        }
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Tells if a given comment is trailing: it starts on the current line and
-         * extends to or past the end of the current line.
-         * @param {string} line The source line we want to check for a trailing comment on
-         * @param {number} lineNumber The one-indexed line number for line
-         * @param {ASTNode} comment The comment to inspect
-         * @returns {boolean} If the comment is trailing on the given line
-         */
-        function isTrailingComment(line, lineNumber, comment) {
-            return comment &&
-                (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&
-                (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
-        }
-
-        /**
-         * Tells if a comment encompasses the entire line.
-         * @param {string} line The source line with a trailing comment
-         * @param {number} lineNumber The one-indexed line number this is on
-         * @param {ASTNode} comment The comment to remove
-         * @returns {boolean} If the comment covers the entire line
-         */
-        function isFullLineComment(line, lineNumber, comment) {
-            const start = comment.loc.start,
-                end = comment.loc.end,
-                isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();
-
-            return comment &&
-                (start.line < lineNumber || (start.line === lineNumber && isFirstTokenOnLine)) &&
-                (end.line > lineNumber || (end.line === lineNumber && end.column === line.length));
-        }
-
-        /**
-         * Gets the line after the comment and any remaining trailing whitespace is
-         * stripped.
-         * @param {string} line The source line with a trailing comment
-         * @param {number} lineNumber The one-indexed line number this is on
-         * @param {ASTNode} comment The comment to remove
-         * @returns {string} Line without comment and trailing whitepace
-         */
-        function stripTrailingComment(line, lineNumber, comment) {
-
-            // loc.column is zero-indexed
-            return line.slice(0, comment.loc.start.column).replace(/\s+$/, "");
-        }
-
-        /**
-         * Ensure that an array exists at [key] on `object`, and add `value` to it.
-         *
-         * @param {Object} object the object to mutate
-         * @param {string} key the object's key
-         * @param {*} value the value to add
-         * @returns {void}
-         * @private
-         */
-        function ensureArrayAndPush(object, key, value) {
-            if (!Array.isArray(object[key])) {
-                object[key] = [];
-            }
-            object[key].push(value);
-        }
-
-        /**
-         * Retrieves an array containing all strings (" or ') in the source code.
-         *
-         * @returns {ASTNode[]} An array of string nodes.
-         */
-        function getAllStrings() {
-            return sourceCode.ast.tokens.filter(token => token.type === "String");
-        }
-
-        /**
-         * Retrieves an array containing all template literals in the source code.
-         *
-         * @returns {ASTNode[]} An array of template literal nodes.
-         */
-        function getAllTemplateLiterals() {
-            return sourceCode.ast.tokens.filter(token => token.type === "Template");
-        }
-
-
-        /**
-         * Retrieves an array containing all RegExp literals in the source code.
-         *
-         * @returns {ASTNode[]} An array of RegExp literal nodes.
-         */
-        function getAllRegExpLiterals() {
-            return sourceCode.ast.tokens.filter(token => token.type === "RegularExpression");
-        }
-
-
-        /**
-         * A reducer to group an AST node by line number, both start and end.
-         *
-         * @param {Object} acc the accumulator
-         * @param {ASTNode} node the AST node in question
-         * @returns {Object} the modified accumulator
-         * @private
-         */
-        function groupByLineNumber(acc, node) {
-            for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {
-                ensureArrayAndPush(acc, i, node);
-            }
-            return acc;
-        }
-
-        /**
-         * Check the program for max length
-         * @param {ASTNode} node Node to examine
-         * @returns {void}
-         * @private
-         */
-        function checkProgramForMaxLength(node) {
-
-            // split (honors line-ending)
-            const lines = sourceCode.lines,
-
-                // list of comments to ignore
-                comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? sourceCode.getAllComments() : [];
-
-                // we iterate over comments in parallel with the lines
-            let commentsIndex = 0;
-
-            const strings = getAllStrings();
-            const stringsByLine = strings.reduce(groupByLineNumber, {});
-
-            const templateLiterals = getAllTemplateLiterals();
-            const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});
-
-            const regExpLiterals = getAllRegExpLiterals();
-            const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});
-
-            lines.forEach((line, i) => {
-
-                // i is zero-indexed, line numbers are one-indexed
-                const lineNumber = i + 1;
-
-                /*
-                 * if we're checking comment length; we need to know whether this
-                 * line is a comment
-                 */
-                let lineIsComment = false;
-
-                /*
-                 * We can short-circuit the comment checks if we're already out of
-                 * comments to check.
-                 */
-                if (commentsIndex < comments.length) {
-                    let comment = null;
-
-                    // iterate over comments until we find one past the current line
-                    do {
-                        comment = comments[++commentsIndex];
-                    } while (comment && comment.loc.start.line <= lineNumber);
-
-                    // and step back by one
-                    comment = comments[--commentsIndex];
-
-                    if (isFullLineComment(line, lineNumber, comment)) {
-                        lineIsComment = true;
-                    } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {
-                        line = stripTrailingComment(line, lineNumber, comment);
-                    }
-                }
-                if (ignorePattern && ignorePattern.test(line) ||
-                    ignoreUrls && URL_REGEXP.test(line) ||
-                    ignoreStrings && stringsByLine[lineNumber] ||
-                    ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] ||
-                    ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]
-                ) {
-
-                    // ignore this line
-                    return;
-                }
-
-                const lineLength = computeLineLength(line, tabWidth);
-                const commentLengthApplies = lineIsComment && maxCommentLength;
-
-                if (lineIsComment && ignoreComments) {
-                    return;
-                }
-
-                if (commentLengthApplies) {
-                    if (lineLength > maxCommentLength) {
-                        context.report({
-                            node,
-                            loc: { line: lineNumber, column: 0 },
-                            message: "Line {{lineNumber}} exceeds the maximum comment line length of {{maxCommentLength}}.",
-                            data: {
-                                lineNumber: i + 1,
-                                maxCommentLength
-                            }
-                        });
-                    }
-                } else if (lineLength > maxLength) {
-                    context.report({
-                        node,
-                        loc: { line: lineNumber, column: 0 },
-                        message: "Line {{lineNumber}} exceeds the maximum line length of {{maxLength}}.",
-                        data: {
-                            lineNumber: i + 1,
-                            maxLength
-                        }
-                    });
-                }
-            });
-        }
-
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            Program: checkProgramForMaxLength
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/new-cap.js
===================================================================
--- node_modules/eslint/lib/rules/new-cap.js	(revision )
+++ node_modules/eslint/lib/rules/new-cap.js	(revision )
@@ -1,271 +0,0 @@
-/**
- * @fileoverview Rule to flag use of constructors without capital letters
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const CAPS_ALLOWED = [
-    "Array",
-    "Boolean",
-    "Date",
-    "Error",
-    "Function",
-    "Number",
-    "Object",
-    "RegExp",
-    "String",
-    "Symbol"
-];
-
-/**
- * Ensure that if the key is provided, it must be an array.
- * @param {Object} obj Object to check with `key`.
- * @param {string} key Object key to check on `obj`.
- * @param {*} fallback If obj[key] is not present, this will be returned.
- * @returns {string[]} Returns obj[key] if it's an Array, otherwise `fallback`
- */
-function checkArray(obj, key, fallback) {
-
-    /* istanbul ignore if */
-    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
-        throw new TypeError(`${key}, if provided, must be an Array`);
-    }
-    return obj[key] || fallback;
-}
-
-/**
- * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.
- * @param {Object} map Accumulator object for the reduce.
- * @param {string} key Object key to set to `true`.
- * @returns {Object} Returns the updated Object for further reduction.
- */
-function invert(map, key) {
-    map[key] = true;
-    return map;
-}
-
-/**
- * Creates an object with the cap is new exceptions as its keys and true as their values.
- * @param {Object} config Rule configuration
- * @returns {Object} Object with cap is new exceptions.
- */
-function calculateCapIsNewExceptions(config) {
-    let capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);
-
-    if (capIsNewExceptions !== CAPS_ALLOWED) {
-        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
-    }
-
-    return capIsNewExceptions.reduce(invert, {});
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require constructor names to begin with a capital letter",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    newIsCap: {
-                        type: "boolean"
-                    },
-                    capIsNew: {
-                        type: "boolean"
-                    },
-                    newIsCapExceptions: {
-                        type: "array",
-                        items: {
-                            type: "string"
-                        }
-                    },
-                    newIsCapExceptionPattern: {
-                        type: "string"
-                    },
-                    capIsNewExceptions: {
-                        type: "array",
-                        items: {
-                            type: "string"
-                        }
-                    },
-                    capIsNewExceptionPattern: {
-                        type: "string"
-                    },
-                    properties: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const config = context.options[0] ? Object.assign({}, context.options[0]) : {};
-
-        config.newIsCap = config.newIsCap !== false;
-        config.capIsNew = config.capIsNew !== false;
-        const skipProperties = config.properties === false;
-
-        const newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {});
-        const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern) : null;
-
-        const capIsNewExceptions = calculateCapIsNewExceptions(config);
-        const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern) : null;
-
-        const listeners = {};
-
-        const sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Get exact callee name from expression
-         * @param {ASTNode} node CallExpression or NewExpression node
-         * @returns {string} name
-         */
-        function extractNameFromExpression(node) {
-
-            let name = "";
-
-            if (node.callee.type === "MemberExpression") {
-                const property = node.callee.property;
-
-                if (property.type === "Literal" && (typeof property.value === "string")) {
-                    name = property.value;
-                } else if (property.type === "Identifier" && !node.callee.computed) {
-                    name = property.name;
-                }
-            } else {
-                name = node.callee.name;
-            }
-            return name;
-        }
-
-        /**
-         * Returns the capitalization state of the string -
-         * Whether the first character is uppercase, lowercase, or non-alphabetic
-         * @param {string} str String
-         * @returns {string} capitalization state: "non-alpha", "lower", or "upper"
-         */
-        function getCap(str) {
-            const firstChar = str.charAt(0);
-
-            const firstCharLower = firstChar.toLowerCase();
-            const firstCharUpper = firstChar.toUpperCase();
-
-            if (firstCharLower === firstCharUpper) {
-
-                // char has no uppercase variant, so it's non-alphabetic
-                return "non-alpha";
-            } else if (firstChar === firstCharLower) {
-                return "lower";
-            }
-            return "upper";
-
-        }
-
-        /**
-         * Check if capitalization is allowed for a CallExpression
-         * @param {Object} allowedMap Object mapping calleeName to a Boolean
-         * @param {ASTNode} node CallExpression node
-         * @param {string} calleeName Capitalized callee name from a CallExpression
-         * @param {Object} pattern RegExp object from options pattern
-         * @returns {boolean} Returns true if the callee may be capitalized
-         */
-        function isCapAllowed(allowedMap, node, calleeName, pattern) {
-            const sourceText = sourceCode.getText(node.callee);
-
-            if (allowedMap[calleeName] || allowedMap[sourceText]) {
-                return true;
-            }
-
-            if (pattern && pattern.test(sourceText)) {
-                return true;
-            }
-
-            if (calleeName === "UTC" && node.callee.type === "MemberExpression") {
-
-                // allow if callee is Date.UTC
-                return node.callee.object.type === "Identifier" &&
-                    node.callee.object.name === "Date";
-            }
-
-            return skipProperties && node.callee.type === "MemberExpression";
-        }
-
-        /**
-         * Reports the given message for the given node. The location will be the start of the property or the callee.
-         * @param {ASTNode} node CallExpression or NewExpression node.
-         * @param {string} message The message to report.
-         * @returns {void}
-         */
-        function report(node, message) {
-            let callee = node.callee;
-
-            if (callee.type === "MemberExpression") {
-                callee = callee.property;
-            }
-
-            context.report({ node, loc: callee.loc.start, message });
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        if (config.newIsCap) {
-            listeners.NewExpression = function(node) {
-
-                const constructorName = extractNameFromExpression(node);
-
-                if (constructorName) {
-                    const capitalization = getCap(constructorName);
-                    const isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);
-
-                    if (!isAllowed) {
-                        report(node, "A constructor name should not start with a lowercase letter.");
-                    }
-                }
-            };
-        }
-
-        if (config.capIsNew) {
-            listeners.CallExpression = function(node) {
-
-                const calleeName = extractNameFromExpression(node);
-
-                if (calleeName) {
-                    const capitalization = getCap(calleeName);
-                    const isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);
-
-                    if (!isAllowed) {
-                        report(node, "A function with a name starting with an uppercase letter should only be used as a constructor.");
-                    }
-                }
-            };
-        }
-
-        return listeners;
-    }
-};
Index: node_modules/eslint/lib/rules/no-eval.js
===================================================================
--- node_modules/eslint/lib/rules/no-eval.js	(revision )
+++ node_modules/eslint/lib/rules/no-eval.js	(revision )
@@ -1,308 +0,0 @@
-/**
- * @fileoverview Rule to flag use of eval() statement
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const candidatesOfGlobalObject = Object.freeze([
-    "global",
-    "window"
-]);
-
-/**
- * Checks a given node is a Identifier node of the specified name.
- *
- * @param {ASTNode} node - A node to check.
- * @param {string} name - A name to check.
- * @returns {boolean} `true` if the node is a Identifier node of the name.
- */
-function isIdentifier(node, name) {
-    return node.type === "Identifier" && node.name === name;
-}
-
-/**
- * Checks a given node is a Literal node of the specified string value.
- *
- * @param {ASTNode} node - A node to check.
- * @param {string} name - A name to check.
- * @returns {boolean} `true` if the node is a Literal node of the name.
- */
-function isConstant(node, name) {
-    switch (node.type) {
-        case "Literal":
-            return node.value === name;
-
-        case "TemplateLiteral":
-            return (
-                node.expressions.length === 0 &&
-                node.quasis[0].value.cooked === name
-            );
-
-        default:
-            return false;
-    }
-}
-
-/**
- * Checks a given node is a MemberExpression node which has the specified name's
- * property.
- *
- * @param {ASTNode} node - A node to check.
- * @param {string} name - A name to check.
- * @returns {boolean} `true` if the node is a MemberExpression node which has
- *      the specified name's property
- */
-function isMember(node, name) {
-    return (
-        node.type === "MemberExpression" &&
-        (node.computed ? isConstant : isIdentifier)(node.property, name)
-    );
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of `eval()`",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allowIndirect: { type: "boolean" }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const allowIndirect = Boolean(
-            context.options[0] &&
-            context.options[0].allowIndirect
-        );
-        const sourceCode = context.getSourceCode();
-        let funcInfo = null;
-
-        /**
-         * Pushs a variable scope (Program or Function) information to the stack.
-         *
-         * This is used in order to check whether or not `this` binding is a
-         * reference to the global object.
-         *
-         * @param {ASTNode} node - A node of the scope. This is one of Program,
-         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.
-         * @returns {void}
-         */
-        function enterVarScope(node) {
-            const strict = context.getScope().isStrict;
-
-            funcInfo = {
-                upper: funcInfo,
-                node,
-                strict,
-                defaultThis: false,
-                initialized: strict
-            };
-        }
-
-        /**
-         * Pops a variable scope from the stack.
-         *
-         * @returns {void}
-         */
-        function exitVarScope() {
-            funcInfo = funcInfo.upper;
-        }
-
-        /**
-         * Reports a given node.
-         *
-         * `node` is `Identifier` or `MemberExpression`.
-         * The parent of `node` might be `CallExpression`.
-         *
-         * The location of the report is always `eval` `Identifier` (or possibly
-         * `Literal`). The type of the report is `CallExpression` if the parent is
-         * `CallExpression`. Otherwise, it's the given node type.
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function report(node) {
-            let locationNode = node;
-            const parent = node.parent;
-
-            if (node.type === "MemberExpression") {
-                locationNode = node.property;
-            }
-            if (parent.type === "CallExpression" && parent.callee === node) {
-                node = parent;
-            }
-
-            context.report({
-                node,
-                loc: locationNode.loc.start,
-                message: "eval can be harmful."
-            });
-        }
-
-        /**
-         * Reports accesses of `eval` via the global object.
-         *
-         * @param {eslint-scope.Scope} globalScope - The global scope.
-         * @returns {void}
-         */
-        function reportAccessingEvalViaGlobalObject(globalScope) {
-            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {
-                const name = candidatesOfGlobalObject[i];
-                const variable = astUtils.getVariableByName(globalScope, name);
-
-                if (!variable) {
-                    continue;
-                }
-
-                const references = variable.references;
-
-                for (let j = 0; j < references.length; ++j) {
-                    const identifier = references[j].identifier;
-                    let node = identifier.parent;
-
-                    // To detect code like `window.window.eval`.
-                    while (isMember(node, name)) {
-                        node = node.parent;
-                    }
-
-                    // Reports.
-                    if (isMember(node, "eval")) {
-                        report(node);
-                    }
-                }
-            }
-        }
-
-        /**
-         * Reports all accesses of `eval` (excludes direct calls to eval).
-         *
-         * @param {eslint-scope.Scope} globalScope - The global scope.
-         * @returns {void}
-         */
-        function reportAccessingEval(globalScope) {
-            const variable = astUtils.getVariableByName(globalScope, "eval");
-
-            if (!variable) {
-                return;
-            }
-
-            const references = variable.references;
-
-            for (let i = 0; i < references.length; ++i) {
-                const reference = references[i];
-                const id = reference.identifier;
-
-                if (id.name === "eval" && !astUtils.isCallee(id)) {
-
-                    // Is accessing to eval (excludes direct calls to eval)
-                    report(id);
-                }
-            }
-        }
-
-        if (allowIndirect) {
-
-            // Checks only direct calls to eval. It's simple!
-            return {
-                "CallExpression:exit"(node) {
-                    const callee = node.callee;
-
-                    if (isIdentifier(callee, "eval")) {
-                        report(callee);
-                    }
-                }
-            };
-        }
-
-        return {
-            "CallExpression:exit"(node) {
-                const callee = node.callee;
-
-                if (isIdentifier(callee, "eval")) {
-                    report(callee);
-                }
-            },
-
-            Program(node) {
-                const scope = context.getScope(),
-                    features = context.parserOptions.ecmaFeatures || {},
-                    strict =
-                        scope.isStrict ||
-                        node.sourceType === "module" ||
-                        (features.globalReturn && scope.childScopes[0].isStrict);
-
-                funcInfo = {
-                    upper: null,
-                    node,
-                    strict,
-                    defaultThis: true,
-                    initialized: true
-                };
-            },
-
-            "Program:exit"() {
-                const globalScope = context.getScope();
-
-                exitVarScope();
-                reportAccessingEval(globalScope);
-                reportAccessingEvalViaGlobalObject(globalScope);
-            },
-
-            FunctionDeclaration: enterVarScope,
-            "FunctionDeclaration:exit": exitVarScope,
-            FunctionExpression: enterVarScope,
-            "FunctionExpression:exit": exitVarScope,
-            ArrowFunctionExpression: enterVarScope,
-            "ArrowFunctionExpression:exit": exitVarScope,
-
-            ThisExpression(node) {
-                if (!isMember(node.parent, "eval")) {
-                    return;
-                }
-
-                /*
-                 * `this.eval` is found.
-                 * Checks whether or not the value of `this` is the global object.
-                 */
-                if (!funcInfo.initialized) {
-                    funcInfo.initialized = true;
-                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(
-                        funcInfo.node,
-                        sourceCode
-                    );
-                }
-
-                if (!funcInfo.strict && funcInfo.defaultThis) {
-
-                    // `this.eval` is possible built-in `eval`.
-                    report(node.parent);
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-sync.js
===================================================================
--- node_modules/eslint/lib/rules/no-sync.js	(revision )
+++ node_modules/eslint/lib/rules/no-sync.js	(revision )
@@ -1,53 +0,0 @@
-/**
- * @fileoverview Rule to check for properties whose identifier ends with the string Sync
- * @author Matt DuVall<http://mattduvall.com/>
- */
-
-/* jshint node:true */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow synchronous methods",
-            category: "Node.js and CommonJS",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allowAtRootLevel: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const selector = context.options[0] && context.options[0].allowAtRootLevel
-            ? ":function MemberExpression[property.name=/.*Sync$/]"
-            : "MemberExpression[property.name=/.*Sync$/]";
-
-        return {
-            [selector](node) {
-                context.report({
-                    node,
-                    message: "Unexpected sync method: '{{propertyName}}'.",
-                    data: {
-                        propertyName: node.property.name
-                    }
-                });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-tabs.js
===================================================================
--- node_modules/eslint/lib/rules/no-tabs.js	(revision )
+++ node_modules/eslint/lib/rules/no-tabs.js	(revision )
@@ -1,47 +0,0 @@
-/**
- * @fileoverview Rule to check for tabs inside a file
- * @author Gyandeep Singh
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-const regex = /\t/;
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow all tabs",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        schema: []
-    },
-
-    create(context) {
-        return {
-            Program(node) {
-                context.getSourceCode().getLines().forEach((line, index) => {
-                    const match = regex.exec(line);
-
-                    if (match) {
-                        context.report({
-                            node,
-                            loc: {
-                                line: index + 1,
-                                column: match.index + 1
-                            },
-                            message: "Unexpected tab character."
-                        });
-                    }
-                });
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-void.js
===================================================================
--- node_modules/eslint/lib/rules/no-void.js	(revision )
+++ node_modules/eslint/lib/rules/no-void.js	(revision )
@@ -1,37 +0,0 @@
-/**
- * @fileoverview Rule to disallow use of void operator.
- * @author Mike Sidorov
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `void` operators",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            UnaryExpression(node) {
-                if (node.operator === "void") {
-                    context.report({ node, message: "Expected 'undefined' and instead saw 'void'." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-with.js
===================================================================
--- node_modules/eslint/lib/rules/no-with.js	(revision )
+++ node_modules/eslint/lib/rules/no-with.js	(revision )
@@ -1,32 +0,0 @@
-/**
- * @fileoverview Rule to flag use of with statement
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `with` statements",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-            WithStatement(node) {
-                context.report({ node, message: "Unexpected use of 'with' statement." });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/one-var.js
===================================================================
--- node_modules/eslint/lib/rules/one-var.js	(revision )
+++ node_modules/eslint/lib/rules/one-var.js	(revision )
@@ -1,367 +0,0 @@
-/**
- * @fileoverview A rule to control the use of single variable declarations.
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce variables to be declared either together or separately in functions",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["always", "never"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            var: {
-                                enum: ["always", "never"]
-                            },
-                            let: {
-                                enum: ["always", "never"]
-                            },
-                            const: {
-                                enum: ["always", "never"]
-                            }
-                        },
-                        additionalProperties: false
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            initialized: {
-                                enum: ["always", "never"]
-                            },
-                            uninitialized: {
-                                enum: ["always", "never"]
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-
-        const MODE_ALWAYS = "always",
-            MODE_NEVER = "never";
-
-        const mode = context.options[0] || MODE_ALWAYS;
-
-        const options = {
-        };
-
-        if (typeof mode === "string") { // simple options configuration with just a string
-            options.var = { uninitialized: mode, initialized: mode };
-            options.let = { uninitialized: mode, initialized: mode };
-            options.const = { uninitialized: mode, initialized: mode };
-        } else if (typeof mode === "object") { // options configuration is an object
-            if (mode.hasOwnProperty("var") && typeof mode.var === "string") {
-                options.var = { uninitialized: mode.var, initialized: mode.var };
-            }
-            if (mode.hasOwnProperty("let") && typeof mode.let === "string") {
-                options.let = { uninitialized: mode.let, initialized: mode.let };
-            }
-            if (mode.hasOwnProperty("const") && typeof mode.const === "string") {
-                options.const = { uninitialized: mode.const, initialized: mode.const };
-            }
-            if (mode.hasOwnProperty("uninitialized")) {
-                if (!options.var) {
-                    options.var = {};
-                }
-                if (!options.let) {
-                    options.let = {};
-                }
-                if (!options.const) {
-                    options.const = {};
-                }
-                options.var.uninitialized = mode.uninitialized;
-                options.let.uninitialized = mode.uninitialized;
-                options.const.uninitialized = mode.uninitialized;
-            }
-            if (mode.hasOwnProperty("initialized")) {
-                if (!options.var) {
-                    options.var = {};
-                }
-                if (!options.let) {
-                    options.let = {};
-                }
-                if (!options.const) {
-                    options.const = {};
-                }
-                options.var.initialized = mode.initialized;
-                options.let.initialized = mode.initialized;
-                options.const.initialized = mode.initialized;
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        const functionStack = [];
-        const blockStack = [];
-
-        /**
-         * Increments the blockStack counter.
-         * @returns {void}
-         * @private
-         */
-        function startBlock() {
-            blockStack.push({
-                let: { initialized: false, uninitialized: false },
-                const: { initialized: false, uninitialized: false }
-            });
-        }
-
-        /**
-         * Increments the functionStack counter.
-         * @returns {void}
-         * @private
-         */
-        function startFunction() {
-            functionStack.push({ initialized: false, uninitialized: false });
-            startBlock();
-        }
-
-        /**
-         * Decrements the blockStack counter.
-         * @returns {void}
-         * @private
-         */
-        function endBlock() {
-            blockStack.pop();
-        }
-
-        /**
-         * Decrements the functionStack counter.
-         * @returns {void}
-         * @private
-         */
-        function endFunction() {
-            functionStack.pop();
-            endBlock();
-        }
-
-        /**
-         * Records whether initialized or uninitialized variables are defined in current scope.
-         * @param {string} statementType node.kind, one of: "var", "let", or "const"
-         * @param {ASTNode[]} declarations List of declarations
-         * @param {Object} currentScope The scope being investigated
-         * @returns {void}
-         * @private
-         */
-        function recordTypes(statementType, declarations, currentScope) {
-            for (let i = 0; i < declarations.length; i++) {
-                if (declarations[i].init === null) {
-                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
-                        currentScope.uninitialized = true;
-                    }
-                } else {
-                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
-                        currentScope.initialized = true;
-                    }
-                }
-            }
-        }
-
-        /**
-         * Determines the current scope (function or block)
-         * @param  {string} statementType node.kind, one of: "var", "let", or "const"
-         * @returns {Object} The scope associated with statementType
-         */
-        function getCurrentScope(statementType) {
-            let currentScope;
-
-            if (statementType === "var") {
-                currentScope = functionStack[functionStack.length - 1];
-            } else if (statementType === "let") {
-                currentScope = blockStack[blockStack.length - 1].let;
-            } else if (statementType === "const") {
-                currentScope = blockStack[blockStack.length - 1].const;
-            }
-            return currentScope;
-        }
-
-        /**
-         * Counts the number of initialized and uninitialized declarations in a list of declarations
-         * @param {ASTNode[]} declarations List of declarations
-         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations
-         * @private
-         */
-        function countDeclarations(declarations) {
-            const counts = { uninitialized: 0, initialized: 0 };
-
-            for (let i = 0; i < declarations.length; i++) {
-                if (declarations[i].init === null) {
-                    counts.uninitialized++;
-                } else {
-                    counts.initialized++;
-                }
-            }
-            return counts;
-        }
-
-        /**
-         * Determines if there is more than one var statement in the current scope.
-         * @param {string} statementType node.kind, one of: "var", "let", or "const"
-         * @param {ASTNode[]} declarations List of declarations
-         * @returns {boolean} Returns true if it is the first var declaration, false if not.
-         * @private
-         */
-        function hasOnlyOneStatement(statementType, declarations) {
-
-            const declarationCounts = countDeclarations(declarations);
-            const currentOptions = options[statementType] || {};
-            const currentScope = getCurrentScope(statementType);
-
-            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
-                if (currentScope.uninitialized || currentScope.initialized) {
-                    return false;
-                }
-            }
-
-            if (declarationCounts.uninitialized > 0) {
-                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
-                    return false;
-                }
-            }
-            if (declarationCounts.initialized > 0) {
-                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
-                    return false;
-                }
-            }
-            recordTypes(statementType, declarations, currentScope);
-            return true;
-        }
-
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            Program: startFunction,
-            FunctionDeclaration: startFunction,
-            FunctionExpression: startFunction,
-            ArrowFunctionExpression: startFunction,
-            BlockStatement: startBlock,
-            ForStatement: startBlock,
-            ForInStatement: startBlock,
-            ForOfStatement: startBlock,
-            SwitchStatement: startBlock,
-
-            VariableDeclaration(node) {
-                const parent = node.parent;
-                const type = node.kind;
-
-                if (!options[type]) {
-                    return;
-                }
-
-                const declarations = node.declarations;
-                const declarationCounts = countDeclarations(declarations);
-
-                // always
-                if (!hasOnlyOneStatement(type, declarations)) {
-                    if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {
-                        context.report({
-                            node,
-                            message: "Combine this with the previous '{{type}}' statement.",
-                            data: {
-                                type
-                            }
-                        });
-                    } else {
-                        if (options[type].initialized === MODE_ALWAYS) {
-                            context.report({
-                                node,
-                                message: "Combine this with the previous '{{type}}' statement with initialized variables.",
-                                data: {
-                                    type
-                                }
-                            });
-                        }
-                        if (options[type].uninitialized === MODE_ALWAYS) {
-                            if (node.parent.left === node && (node.parent.type === "ForInStatement" || node.parent.type === "ForOfStatement")) {
-                                return;
-                            }
-                            context.report({
-                                node,
-                                message: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
-                                data: {
-                                    type
-                                }
-                            });
-                        }
-                    }
-                }
-
-                // never
-                if (parent.type !== "ForStatement" || parent.init !== node) {
-                    const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;
-
-                    if (totalDeclarations > 1) {
-
-                        if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {
-
-                            // both initialized and uninitialized
-                            context.report({
-                                node,
-                                message: "Split '{{type}}' declarations into multiple statements.",
-                                data: {
-                                    type
-                                }
-                            });
-                        } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
-
-                            // initialized
-                            context.report({
-                                node,
-                                message: "Split initialized '{{type}}' declarations into multiple statements.",
-                                data: {
-                                    type
-                                }
-                            });
-                        } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
-
-                            // uninitialized
-                            context.report({
-                                node,
-                                message: "Split uninitialized '{{type}}' declarations into multiple statements.",
-                                data: {
-                                    type
-                                }
-                            });
-                        }
-                    }
-                }
-            },
-
-            "ForStatement:exit": endBlock,
-            "ForOfStatement:exit": endBlock,
-            "ForInStatement:exit": endBlock,
-            "SwitchStatement:exit": endBlock,
-            "BlockStatement:exit": endBlock,
-            "Program:exit": endFunction,
-            "FunctionDeclaration:exit": endFunction,
-            "FunctionExpression:exit": endFunction,
-            "ArrowFunctionExpression:exit": endFunction
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/eol-last.js
===================================================================
--- node_modules/eslint/lib/rules/eol-last.js	(revision )
+++ node_modules/eslint/lib/rules/eol-last.js	(revision )
@@ -1,94 +0,0 @@
-/**
- * @fileoverview Require or disallow newline at the end of files
- * @author Nodeca Team <https://github.com/nodeca>
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow newline at the end of files",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "whitespace",
-        schema: [
-            {
-                enum: ["always", "never", "unix", "windows"]
-            }
-        ]
-    },
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            Program: function checkBadEOF(node) {
-                const sourceCode = context.getSourceCode(),
-                    src = sourceCode.getText(),
-                    location = {
-                        column: lodash.last(sourceCode.lines).length,
-                        line: sourceCode.lines.length
-                    },
-                    LF = "\n",
-                    CRLF = `\r${LF}`,
-                    endsWithNewline = lodash.endsWith(src, LF);
-
-                let mode = context.options[0] || "always",
-                    appendCRLF = false;
-
-                if (mode === "unix") {
-
-                    // `"unix"` should behave exactly as `"always"`
-                    mode = "always";
-                }
-                if (mode === "windows") {
-
-                    // `"windows"` should behave exactly as `"always"`, but append CRLF in the fixer for backwards compatibility
-                    mode = "always";
-                    appendCRLF = true;
-                }
-                if (mode === "always" && !endsWithNewline) {
-
-                    // File is not newline-terminated, but should be
-                    context.report({
-                        node,
-                        loc: location,
-                        message: "Newline required at end of file but not found.",
-                        fix(fixer) {
-                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);
-                        }
-                    });
-                } else if (mode === "never" && endsWithNewline) {
-
-                    // File is newline-terminated, but shouldn't be
-                    context.report({
-                        node,
-                        loc: location,
-                        message: "Newline not allowed at end of file.",
-                        fix(fixer) {
-                            const finalEOLs = /(?:\r?\n)+$/,
-                                match = finalEOLs.exec(sourceCode.text),
-                                start = match.index,
-                                end = sourceCode.text.length;
-
-                            return fixer.replaceTextRange([start, end], "");
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/id-match.js
===================================================================
--- node_modules/eslint/lib/rules/id-match.js	(revision )
+++ node_modules/eslint/lib/rules/id-match.js	(revision )
@@ -1,144 +0,0 @@
-/**
- * @fileoverview Rule to flag non-matching identifiers
- * @author Matthieu Larcher
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require identifiers to match a specified regular expression",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "string"
-            },
-            {
-                type: "object",
-                properties: {
-                    properties: {
-                        type: "boolean"
-                    }
-                }
-            }
-        ]
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        const pattern = context.options[0] || "^.+$",
-            regexp = new RegExp(pattern);
-
-        const options = context.options[1] || {},
-            properties = !!options.properties,
-            onlyDeclarations = !!options.onlyDeclarations;
-
-        /**
-         * Checks if a string matches the provided pattern
-         * @param {string} name The string to check.
-         * @returns {boolean} if the string is a match
-         * @private
-         */
-        function isInvalid(name) {
-            return !regexp.test(name);
-        }
-
-        /**
-         * Verifies if we should report an error or not based on the effective
-         * parent node and the identifier name.
-         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported
-         * @param {string} name The identifier name of the identifier node
-         * @returns {boolean} whether an error should be reported or not
-         */
-        function shouldReport(effectiveParent, name) {
-            return effectiveParent.type !== "CallExpression" &&
-                effectiveParent.type !== "NewExpression" &&
-                isInvalid(name);
-        }
-
-        /**
-         * Reports an AST node as a rule violation.
-         * @param {ASTNode} node The node to report.
-         * @returns {void}
-         * @private
-         */
-        function report(node) {
-            context.report({
-                node,
-                message: "Identifier '{{name}}' does not match the pattern '{{pattern}}'.",
-                data: {
-                    name: node.name,
-                    pattern
-                }
-            });
-        }
-
-        return {
-
-            Identifier(node) {
-                const name = node.name,
-                    parent = node.parent,
-                    effectiveParent = (parent.type === "MemberExpression") ? parent.parent : parent;
-
-                if (parent.type === "MemberExpression") {
-
-                    if (!properties) {
-                        return;
-                    }
-
-                    // Always check object names
-                    if (parent.object.type === "Identifier" &&
-                        parent.object.name === name) {
-                        if (isInvalid(name)) {
-                            report(node);
-                        }
-
-                    // Report AssignmentExpressions only if they are the left side of the assignment
-                    } else if (effectiveParent.type === "AssignmentExpression" &&
-                        (effectiveParent.right.type !== "MemberExpression" ||
-                        effectiveParent.left.type === "MemberExpression" &&
-                        effectiveParent.left.property.name === name)) {
-                        if (isInvalid(name)) {
-                            report(node);
-                        }
-                    }
-
-                } else if (parent.type === "Property") {
-
-                    if (!properties || parent.key.name !== name) {
-                        return;
-                    }
-
-                    if (shouldReport(effectiveParent, name)) {
-                        report(node);
-                    }
-
-                } else {
-                    const isDeclaration = effectiveParent.type === "FunctionDeclaration" || effectiveParent.type === "VariableDeclarator";
-
-                    if (onlyDeclarations && !isDeclaration) {
-                        return;
-                    }
-
-                    if (shouldReport(effectiveParent, name)) {
-                        report(node);
-                    }
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-alert.js
===================================================================
--- node_modules/eslint/lib/rules/no-alert.js	(revision )
+++ node_modules/eslint/lib/rules/no-alert.js	(revision )
@@ -1,131 +0,0 @@
-/**
- * @fileoverview Rule to flag use of alert, confirm, prompt
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const getPropertyName = require("../ast-utils").getStaticPropertyName;
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks if the given name is a prohibited identifier.
- * @param {string} name The name to check
- * @returns {boolean} Whether or not the name is prohibited.
- */
-function isProhibitedIdentifier(name) {
-    return /^(alert|confirm|prompt)$/.test(name);
-}
-
-/**
- * Reports the given node and identifier name.
- * @param {RuleContext} context The ESLint rule context.
- * @param {ASTNode} node The node to report on.
- * @param {string} identifierName The name of the identifier.
- * @returns {void}
- */
-function report(context, node, identifierName) {
-    context.report(node, "Unexpected {{name}}.", { name: identifierName });
-}
-
-/**
- * Finds the eslint-scope reference in the given scope.
- * @param {Object} scope The scope to search.
- * @param {ASTNode} node The identifier node.
- * @returns {Reference|null} Returns the found reference or null if none were found.
- */
-function findReference(scope, node) {
-    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&
-            reference.identifier.range[1] === node.range[1]);
-
-    if (references.length === 1) {
-        return references[0];
-    }
-    return null;
-}
-
-/**
- * Checks if the given identifier node is shadowed in the given scope.
- * @param {Object} scope The current scope.
- * @param {Object} globalScope The global scope.
- * @param {string} node The identifier node to check
- * @returns {boolean} Whether or not the name is shadowed.
- */
-function isShadowed(scope, globalScope, node) {
-    const reference = findReference(scope, node);
-
-    return reference && reference.resolved && reference.resolved.defs.length > 0;
-}
-
-/**
- * Checks if the given identifier node is a ThisExpression in the global scope or the global window property.
- * @param {Object} scope The current scope.
- * @param {Object} globalScope The global scope.
- * @param {string} node The identifier node to check
- * @returns {boolean} Whether or not the node is a reference to the global object.
- */
-function isGlobalThisReferenceOrGlobalWindow(scope, globalScope, node) {
-    if (scope.type === "global" && node.type === "ThisExpression") {
-        return true;
-    } else if (node.name === "window") {
-        return !isShadowed(scope, globalScope, node);
-    }
-
-    return false;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of `alert`, `confirm`, and `prompt`",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        let globalScope;
-
-        return {
-
-            Program() {
-                globalScope = context.getScope();
-            },
-
-            CallExpression(node) {
-                const callee = node.callee,
-                    currentScope = context.getScope();
-
-                // without window.
-                if (callee.type === "Identifier") {
-                    const identifierName = callee.name;
-
-                    if (!isShadowed(currentScope, globalScope, callee) && isProhibitedIdentifier(callee.name)) {
-                        report(context, node, identifierName);
-                    }
-
-                } else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(currentScope, globalScope, callee.object)) {
-                    const identifierName = getPropertyName(callee);
-
-                    if (isProhibitedIdentifier(identifierName)) {
-                        report(context, node, identifierName);
-                    }
-                }
-
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-empty.js
===================================================================
--- node_modules/eslint/lib/rules/no-empty.js	(revision )
+++ node_modules/eslint/lib/rules/no-empty.js	(revision )
@@ -1,78 +0,0 @@
-/**
- * @fileoverview Rule to flag use of an empty block statement
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow empty block statements",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allowEmptyCatch: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0] || {},
-            allowEmptyCatch = options.allowEmptyCatch || false;
-
-        const sourceCode = context.getSourceCode();
-
-        return {
-            BlockStatement(node) {
-
-                // if the body is not empty, we can just return immediately
-                if (node.body.length !== 0) {
-                    return;
-                }
-
-                // a function is generally allowed to be empty
-                if (astUtils.isFunction(node.parent)) {
-                    return;
-                }
-
-                if (allowEmptyCatch && node.parent.type === "CatchClause") {
-                    return;
-                }
-
-                // any other block is only allowed to be empty, if it contains a comment
-                if (sourceCode.getCommentsInside(node).length > 0) {
-                    return;
-                }
-
-                context.report({ node, message: "Empty block statement." });
-            },
-
-            SwitchStatement(node) {
-
-                if (typeof node.cases === "undefined" || node.cases.length === 0) {
-                    context.report({ node, message: "Empty switch statement." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-octal.js
===================================================================
--- node_modules/eslint/lib/rules/no-octal.js	(revision )
+++ node_modules/eslint/lib/rules/no-octal.js	(revision )
@@ -1,35 +0,0 @@
-/**
- * @fileoverview Rule to flag when initializing octal literal
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow octal literals",
-            category: "Best Practices",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            Literal(node) {
-                if (typeof node.value === "number" && /^0[0-7]/.test(node.raw)) {
-                    context.report({ node, message: "Octal literals should not be used." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-proto.js
===================================================================
--- node_modules/eslint/lib/rules/no-proto.js	(revision )
+++ node_modules/eslint/lib/rules/no-proto.js	(revision )
@@ -1,38 +0,0 @@
-/**
- * @fileoverview Rule to flag usage of __proto__ property
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of the `__proto__` property",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            MemberExpression(node) {
-
-                if (node.property &&
-                        (node.property.type === "Identifier" && node.property.name === "__proto__" && !node.computed) ||
-                        (node.property.type === "Literal" && node.property.value === "__proto__")) {
-                    context.report({ node, message: "The '__proto__' property is deprecated." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-undef.js
===================================================================
--- node_modules/eslint/lib/rules/no-undef.js	(revision )
+++ node_modules/eslint/lib/rules/no-undef.js	(revision )
@@ -1,71 +0,0 @@
-/**
- * @fileoverview Rule to flag references to undeclared variables.
- * @author Mark Macdonald
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks if the given node is the argument of a typeof operator.
- * @param {ASTNode} node The AST node being checked.
- * @returns {boolean} Whether or not the node is the argument of a typeof operator.
- */
-function hasTypeOfOperator(node) {
-    const parent = node.parent;
-
-    return parent.type === "UnaryExpression" && parent.operator === "typeof";
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of undeclared variables unless mentioned in `/*global */` comments",
-            category: "Variables",
-            recommended: true
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    typeof: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0];
-        const considerTypeOf = options && options.typeof === true || false;
-
-        return {
-            "Program:exit"(/* node */) {
-                const globalScope = context.getScope();
-
-                globalScope.through.forEach(ref => {
-                    const identifier = ref.identifier;
-
-                    if (!considerTypeOf && hasTypeOfOperator(identifier)) {
-                        return;
-                    }
-
-                    context.report({
-                        node: identifier,
-                        message: "'{{name}}' is not defined.",
-                        data: identifier
-                    });
-                });
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/camelcase.js
===================================================================
--- node_modules/eslint/lib/rules/camelcase.js	(revision )
+++ node_modules/eslint/lib/rules/camelcase.js	(revision )
@@ -1,143 +0,0 @@
-/**
- * @fileoverview Rule to flag non-camelcased identifiers
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce camelcase naming convention",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    properties: {
-                        enum: ["always", "never"]
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation
-        const reported = [];
-        const ALLOWED_PARENT_TYPES = new Set(["CallExpression", "NewExpression"]);
-
-        /**
-         * Checks if a string contains an underscore and isn't all upper-case
-         * @param {string} name The string to check.
-         * @returns {boolean} if the string is underscored
-         * @private
-         */
-        function isUnderscored(name) {
-
-            // if there's an underscore, it might be A_CONSTANT, which is okay
-            return name.indexOf("_") > -1 && name !== name.toUpperCase();
-        }
-
-        /**
-         * Reports an AST node as a rule violation.
-         * @param {ASTNode} node The node to report.
-         * @returns {void}
-         * @private
-         */
-        function report(node) {
-            if (reported.indexOf(node) < 0) {
-                reported.push(node);
-                context.report({ node, message: "Identifier '{{name}}' is not in camel case.", data: { name: node.name } });
-            }
-        }
-
-        const options = context.options[0] || {};
-        let properties = options.properties || "";
-
-        if (properties !== "always" && properties !== "never") {
-            properties = "always";
-        }
-
-        return {
-
-            Identifier(node) {
-
-                /*
-                 * Leading and trailing underscores are commonly used to flag
-                 * private/protected identifiers, strip them
-                 */
-                const name = node.name.replace(/^_+|_+$/g, ""),
-                    effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;
-
-                // MemberExpressions get special rules
-                if (node.parent.type === "MemberExpression") {
-
-                    // "never" check properties
-                    if (properties === "never") {
-                        return;
-                    }
-
-                    // Always report underscored object names
-                    if (node.parent.object.type === "Identifier" &&
-                            node.parent.object.name === node.name &&
-                            isUnderscored(name)) {
-                        report(node);
-
-                    // Report AssignmentExpressions only if they are the left side of the assignment
-                    } else if (effectiveParent.type === "AssignmentExpression" &&
-                            isUnderscored(name) &&
-                            (effectiveParent.right.type !== "MemberExpression" ||
-                            effectiveParent.left.type === "MemberExpression" &&
-                            effectiveParent.left.property.name === node.name)) {
-                        report(node);
-                    }
-
-                // Properties have their own rules
-                } else if (node.parent.type === "Property") {
-
-                    // "never" check properties
-                    if (properties === "never") {
-                        return;
-                    }
-
-                    if (node.parent.parent && node.parent.parent.type === "ObjectPattern" &&
-                            node.parent.key === node && node.parent.value !== node) {
-                        return;
-                    }
-
-                    if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {
-                        report(node);
-                    }
-
-                // Check if it's an import specifier
-                } else if (["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"].indexOf(node.parent.type) >= 0) {
-
-                    // Report only if the local imported identifier is underscored
-                    if (node.parent.local && node.parent.local.name === node.name && isUnderscored(name)) {
-                        report(node);
-                    }
-
-                // Report anything that is underscored that isn't a CallExpression
-                } else if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {
-                    report(node);
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/id-length.js
===================================================================
--- node_modules/eslint/lib/rules/id-length.js	(revision )
+++ node_modules/eslint/lib/rules/id-length.js	(revision )
@@ -1,116 +0,0 @@
-/**
- * @fileoverview Rule that warns when identifier names are shorter or longer
- * than the values provided in configuration.
- * @author Burak Yigit Kaya aka BYK
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce minimum and maximum identifier lengths",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    min: {
-                        type: "number"
-                    },
-                    max: {
-                        type: "number"
-                    },
-                    exceptions: {
-                        type: "array",
-                        uniqueItems: true,
-                        items: {
-                            type: "string"
-                        }
-                    },
-                    properties: {
-                        enum: ["always", "never"]
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0] || {};
-        const minLength = typeof options.min !== "undefined" ? options.min : 2;
-        const maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
-        const properties = options.properties !== "never";
-        const exceptions = (options.exceptions ? options.exceptions : [])
-            .reduce((obj, item) => {
-                obj[item] = true;
-
-                return obj;
-            }, {});
-
-        const SUPPORTED_EXPRESSIONS = {
-            MemberExpression: properties && function(parent) {
-                return !parent.computed && (
-
-                    // regular property assignment
-                    (parent.parent.left === parent && parent.parent.type === "AssignmentExpression" ||
-
-                    // or the last identifier in an ObjectPattern destructuring
-                    parent.parent.type === "Property" && parent.parent.value === parent &&
-                    parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent)
-                );
-            },
-            AssignmentPattern(parent, node) {
-                return parent.left === node;
-            },
-            VariableDeclarator(parent, node) {
-                return parent.id === node;
-            },
-            Property: properties && function(parent, node) {
-                return parent.key === node;
-            },
-            ImportDefaultSpecifier: true,
-            RestElement: true,
-            FunctionExpression: true,
-            ArrowFunctionExpression: true,
-            ClassDeclaration: true,
-            FunctionDeclaration: true,
-            MethodDefinition: true,
-            CatchClause: true
-        };
-
-        return {
-            Identifier(node) {
-                const name = node.name;
-                const parent = node.parent;
-
-                const isShort = name.length < minLength;
-                const isLong = name.length > maxLength;
-
-                if (!(isShort || isLong) || exceptions[name]) {
-                    return; // Nothing to report
-                }
-
-                const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];
-
-                if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {
-                    context.report({
-                        node,
-                        message: isShort
-                            ? "Identifier name '{{name}}' is too short (< {{min}})."
-                            : "Identifier name '{{name}}' is too long (> {{max}}).",
-                        data: { name, min: minLength, max: maxLength }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/max-depth.js
===================================================================
--- node_modules/eslint/lib/rules/max-depth.js	(revision )
+++ node_modules/eslint/lib/rules/max-depth.js	(revision )
@@ -1,148 +0,0 @@
-/**
- * @fileoverview A rule to set the maximum depth block can be nested in a function.
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce a maximum depth that blocks can be nested",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            maximum: {
-                                type: "integer",
-                                minimum: 0
-                            },
-                            max: {
-                                type: "integer",
-                                minimum: 0
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        const functionStack = [],
-            option = context.options[0];
-        let maxDepth = 4;
-
-        if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
-            maxDepth = option.maximum;
-        }
-        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
-            maxDepth = option.max;
-        }
-        if (typeof option === "number") {
-            maxDepth = option;
-        }
-
-        /**
-         * When parsing a new function, store it in our function stack
-         * @returns {void}
-         * @private
-         */
-        function startFunction() {
-            functionStack.push(0);
-        }
-
-        /**
-         * When parsing is done then pop out the reference
-         * @returns {void}
-         * @private
-         */
-        function endFunction() {
-            functionStack.pop();
-        }
-
-        /**
-         * Save the block and Evaluate the node
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function pushBlock(node) {
-            const len = ++functionStack[functionStack.length - 1];
-
-            if (len > maxDepth) {
-                context.report({ node, message: "Blocks are nested too deeply ({{depth}}).", data: { depth: len } });
-            }
-        }
-
-        /**
-         * Pop the saved block
-         * @returns {void}
-         * @private
-         */
-        function popBlock() {
-            functionStack[functionStack.length - 1]--;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            Program: startFunction,
-            FunctionDeclaration: startFunction,
-            FunctionExpression: startFunction,
-            ArrowFunctionExpression: startFunction,
-
-            IfStatement(node) {
-                if (node.parent.type !== "IfStatement") {
-                    pushBlock(node);
-                }
-            },
-            SwitchStatement: pushBlock,
-            TryStatement: pushBlock,
-            DoWhileStatement: pushBlock,
-            WhileStatement: pushBlock,
-            WithStatement: pushBlock,
-            ForStatement: pushBlock,
-            ForInStatement: pushBlock,
-            ForOfStatement: pushBlock,
-
-            "IfStatement:exit": popBlock,
-            "SwitchStatement:exit": popBlock,
-            "TryStatement:exit": popBlock,
-            "DoWhileStatement:exit": popBlock,
-            "WhileStatement:exit": popBlock,
-            "WithStatement:exit": popBlock,
-            "ForStatement:exit": popBlock,
-            "ForInStatement:exit": popBlock,
-            "ForOfStatement:exit": popBlock,
-
-            "FunctionDeclaration:exit": endFunction,
-            "FunctionExpression:exit": endFunction,
-            "ArrowFunctionExpression:exit": endFunction,
-            "Program:exit": endFunction
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/max-lines.js
===================================================================
--- node_modules/eslint/lib/rules/max-lines.js	(revision )
+++ node_modules/eslint/lib/rules/max-lines.js	(revision )
@@ -1,144 +0,0 @@
-/**
- * @fileoverview enforce a maximum file length
- * @author Alberto Rodríguez
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce a maximum number of lines per file",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            max: {
-                                type: "integer",
-                                minimum: 0
-                            },
-                            skipComments: {
-                                type: "boolean"
-                            },
-                            skipBlankLines: {
-                                type: "boolean"
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const option = context.options[0];
-        let max = 300;
-
-        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
-            max = option.max;
-        }
-
-        if (typeof option === "number") {
-            max = option;
-        }
-
-        const skipComments = option && option.skipComments;
-        const skipBlankLines = option && option.skipBlankLines;
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Returns whether or not a token is a comment node type
-         * @param {Token} token The token to check
-         * @returns {boolean} True if the token is a comment node
-         */
-        function isCommentNodeType(token) {
-            return token && (token.type === "Block" || token.type === "Line");
-        }
-
-        /**
-         * Returns the line numbers of a comment that don't have any code on the same line
-         * @param {Node} comment The comment node to check
-         * @returns {int[]} The line numbers
-         */
-        function getLinesWithoutCode(comment) {
-            let start = comment.loc.start.line;
-            let end = comment.loc.end.line;
-
-            let token;
-
-            token = comment;
-            do {
-                token = sourceCode.getTokenBefore(token, { includeComments: true });
-            } while (isCommentNodeType(token));
-
-            if (token && astUtils.isTokenOnSameLine(token, comment)) {
-                start += 1;
-            }
-
-            token = comment;
-            do {
-                token = sourceCode.getTokenAfter(token, { includeComments: true });
-            } while (isCommentNodeType(token));
-
-            if (token && astUtils.isTokenOnSameLine(comment, token)) {
-                end -= 1;
-            }
-
-            if (start <= end) {
-                return lodash.range(start, end + 1);
-            }
-            return [];
-        }
-
-        return {
-            "Program:exit"() {
-                let lines = sourceCode.lines.map((text, i) => ({ lineNumber: i + 1, text }));
-
-                if (skipBlankLines) {
-                    lines = lines.filter(l => l.text.trim() !== "");
-                }
-
-                if (skipComments) {
-                    const comments = sourceCode.getAllComments();
-
-                    const commentLines = lodash.flatten(comments.map(comment => getLinesWithoutCode(comment)));
-
-                    lines = lines.filter(l => !lodash.includes(commentLines, l.lineNumber));
-                }
-
-                if (lines.length > max) {
-                    context.report({
-                        loc: { line: 1, column: 0 },
-                        message: "File must be at most {{max}} lines long. It's {{actual}} lines long.",
-                        data: {
-                            max,
-                            actual: lines.length
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-caller.js
===================================================================
--- node_modules/eslint/lib/rules/no-caller.js	(revision )
+++ node_modules/eslint/lib/rules/no-caller.js	(revision )
@@ -1,39 +0,0 @@
-/**
- * @fileoverview Rule to flag use of arguments.callee and arguments.caller.
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of `arguments.caller` or `arguments.callee`",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            MemberExpression(node) {
-                const objectName = node.object.name,
-                    propertyName = node.property.name;
-
-                if (objectName === "arguments" && !node.computed && propertyName && propertyName.match(/^calle[er]$/)) {
-                    context.report({ node, message: "Avoid arguments.{{property}}.", data: { property: propertyName } });
-                }
-
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-labels.js
===================================================================
--- node_modules/eslint/lib/rules/no-labels.js	(revision )
+++ node_modules/eslint/lib/rules/no-labels.js	(revision )
@@ -1,141 +0,0 @@
-/**
- * @fileoverview Disallow Labeled Statements
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow labeled statements",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allowLoop: {
-                        type: "boolean"
-                    },
-                    allowSwitch: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0];
-        const allowLoop = Boolean(options && options.allowLoop);
-        const allowSwitch = Boolean(options && options.allowSwitch);
-        let scopeInfo = null;
-
-        /**
-         * Gets the kind of a given node.
-         *
-         * @param {ASTNode} node - A node to get.
-         * @returns {string} The kind of the node.
-         */
-        function getBodyKind(node) {
-            if (astUtils.isLoop(node)) {
-                return "loop";
-            }
-            if (node.type === "SwitchStatement") {
-                return "switch";
-            }
-            return "other";
-        }
-
-        /**
-         * Checks whether the label of a given kind is allowed or not.
-         *
-         * @param {string} kind - A kind to check.
-         * @returns {boolean} `true` if the kind is allowed.
-         */
-        function isAllowed(kind) {
-            switch (kind) {
-                case "loop": return allowLoop;
-                case "switch": return allowSwitch;
-                default: return false;
-            }
-        }
-
-        /**
-         * Checks whether a given name is a label of a loop or not.
-         *
-         * @param {string} label - A name of a label to check.
-         * @returns {boolean} `true` if the name is a label of a loop.
-         */
-        function getKind(label) {
-            let info = scopeInfo;
-
-            while (info) {
-                if (info.label === label) {
-                    return info.kind;
-                }
-                info = info.upper;
-            }
-
-            /* istanbul ignore next: syntax error */
-            return "other";
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            LabeledStatement(node) {
-                scopeInfo = {
-                    label: node.label.name,
-                    kind: getBodyKind(node.body),
-                    upper: scopeInfo
-                };
-            },
-
-            "LabeledStatement:exit"(node) {
-                if (!isAllowed(scopeInfo.kind)) {
-                    context.report({
-                        node,
-                        message: "Unexpected labeled statement."
-                    });
-                }
-
-                scopeInfo = scopeInfo.upper;
-            },
-
-            BreakStatement(node) {
-                if (node.label && !isAllowed(getKind(node.label.name))) {
-                    context.report({
-                        node,
-                        message: "Unexpected label in break statement."
-                    });
-                }
-            },
-
-            ContinueStatement(node) {
-                if (node.label && !isAllowed(getKind(node.label.name))) {
-                    context.report({
-                        node,
-                        message: "Unexpected label in continue statement."
-                    });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-shadow.js
===================================================================
--- node_modules/eslint/lib/rules/no-shadow.js	(revision )
+++ node_modules/eslint/lib/rules/no-shadow.js	(revision )
@@ -1,188 +0,0 @@
-/**
- * @fileoverview Rule to flag on declaring variables already declared in the outer scope
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow variable declarations from shadowing variables declared in the outer scope",
-            category: "Variables",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    builtinGlobals: { type: "boolean" },
-                    hoist: { enum: ["all", "functions", "never"] },
-                    allow: {
-                        type: "array",
-                        items: {
-                            type: "string"
-                        }
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const options = {
-            builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals),
-            hoist: (context.options[0] && context.options[0].hoist) || "functions",
-            allow: (context.options[0] && context.options[0].allow) || []
-        };
-
-        /**
-         * Check if variable name is allowed.
-         *
-         * @param  {ASTNode} variable The variable to check.
-         * @returns {boolean} Whether or not the variable name is allowed.
-         */
-        function isAllowed(variable) {
-            return options.allow.indexOf(variable.name) !== -1;
-        }
-
-        /**
-         * Checks if a variable of the class name in the class scope of ClassDeclaration.
-         *
-         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.
-         * So we should ignore the variable in the class scope.
-         *
-         * @param {Object} variable The variable to check.
-         * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.
-         */
-        function isDuplicatedClassNameVariable(variable) {
-            const block = variable.scope.block;
-
-            return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
-        }
-
-        /**
-         * Checks if a variable is inside the initializer of scopeVar.
-         *
-         * To avoid reporting at declarations such as `var a = function a() {};`.
-         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.
-         *
-         * @param {Object} variable The variable to check.
-         * @param {Object} scopeVar The scope variable to look for.
-         * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.
-         */
-        function isOnInitializer(variable, scopeVar) {
-            const outerScope = scopeVar.scope;
-            const outerDef = scopeVar.defs[0];
-            const outer = outerDef && outerDef.parent && outerDef.parent.range;
-            const innerScope = variable.scope;
-            const innerDef = variable.defs[0];
-            const inner = innerDef && innerDef.name.range;
-
-            return (
-                outer &&
-                inner &&
-                outer[0] < inner[0] &&
-                inner[1] < outer[1] &&
-                ((innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression") || innerDef.node.type === "ClassExpression") &&
-                outerScope === innerScope.upper
-            );
-        }
-
-        /**
-         * Get a range of a variable's identifier node.
-         * @param {Object} variable The variable to get.
-         * @returns {Array|undefined} The range of the variable's identifier node.
-         */
-        function getNameRange(variable) {
-            const def = variable.defs[0];
-
-            return def && def.name.range;
-        }
-
-        /**
-         * Checks if a variable is in TDZ of scopeVar.
-         * @param {Object} variable The variable to check.
-         * @param {Object} scopeVar The variable of TDZ.
-         * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.
-         */
-        function isInTdz(variable, scopeVar) {
-            const outerDef = scopeVar.defs[0];
-            const inner = getNameRange(variable);
-            const outer = getNameRange(scopeVar);
-
-            return (
-                inner &&
-                outer &&
-                inner[1] < outer[0] &&
-
-                // Excepts FunctionDeclaration if is {"hoist":"function"}.
-                (options.hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration")
-            );
-        }
-
-        /**
-         * Checks the current context for shadowed variables.
-         * @param {Scope} scope - Fixme
-         * @returns {void}
-         */
-        function checkForShadows(scope) {
-            const variables = scope.variables;
-
-            for (let i = 0; i < variables.length; ++i) {
-                const variable = variables[i];
-
-                // Skips "arguments" or variables of a class name in the class scope of ClassDeclaration.
-                if (variable.identifiers.length === 0 ||
-                    isDuplicatedClassNameVariable(variable) ||
-                    isAllowed(variable)
-                ) {
-                    continue;
-                }
-
-                // Gets shadowed variable.
-                const shadowed = astUtils.getVariableByName(scope.upper, variable.name);
-
-                if (shadowed &&
-                    (shadowed.identifiers.length > 0 || (options.builtinGlobals && "writeable" in shadowed)) &&
-                    !isOnInitializer(variable, shadowed) &&
-                    !(options.hoist !== "all" && isInTdz(variable, shadowed))
-                ) {
-                    context.report({
-                        node: variable.identifiers[0],
-                        message: "'{{name}}' is already declared in the upper scope.",
-                        data: variable
-                    });
-                }
-            }
-        }
-
-        return {
-            "Program:exit"() {
-                const globalScope = context.getScope();
-                const stack = globalScope.childScopes.slice();
-
-                while (stack.length) {
-                    const scope = stack.pop();
-
-                    stack.push.apply(stack, scope.childScopes);
-                    checkForShadows(scope);
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/sort-keys.js
===================================================================
--- node_modules/eslint/lib/rules/sort-keys.js	(revision )
+++ node_modules/eslint/lib/rules/sort-keys.js	(revision )
@@ -1,157 +0,0 @@
-/**
- * @fileoverview Rule to require object keys to be sorted
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils"),
-    naturalCompare = require("natural-compare");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Gets the property name of the given `Property` node.
- *
- * - If the property's key is an `Identifier` node, this returns the key's name
- *   whether it's a computed property or not.
- * - If the property has a static name, this returns the static name.
- * - Otherwise, this returns null.
- *
- * @param {ASTNode} node - The `Property` node to get.
- * @returns {string|null} The property name or null.
- * @private
- */
-function getPropertyName(node) {
-    return astUtils.getStaticPropertyName(node) || node.key.name || null;
-}
-
-/**
- * Functions which check that the given 2 names are in specific order.
- *
- * Postfix `I` is meant insensitive.
- * Postfix `N` is meant natual.
- *
- * @private
- */
-const isValidOrders = {
-    asc(a, b) {
-        return a <= b;
-    },
-    ascI(a, b) {
-        return a.toLowerCase() <= b.toLowerCase();
-    },
-    ascN(a, b) {
-        return naturalCompare(a, b) <= 0;
-    },
-    ascIN(a, b) {
-        return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;
-    },
-    desc(a, b) {
-        return isValidOrders.asc(b, a);
-    },
-    descI(a, b) {
-        return isValidOrders.ascI(b, a);
-    },
-    descN(a, b) {
-        return isValidOrders.ascN(b, a);
-    },
-    descIN(a, b) {
-        return isValidOrders.ascIN(b, a);
-    }
-};
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require object keys to be sorted",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        schema: [
-            {
-                enum: ["asc", "desc"]
-            },
-            {
-                type: "object",
-                properties: {
-                    caseSensitive: {
-                        type: "boolean"
-                    },
-                    natural: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        // Parse options.
-        const order = context.options[0] || "asc";
-        const options = context.options[1];
-        const insensitive = (options && options.caseSensitive) === false;
-        const natual = Boolean(options && options.natural);
-        const isValidOrder = isValidOrders[
-            order + (insensitive ? "I" : "") + (natual ? "N" : "")
-        ];
-
-        // The stack to save the previous property's name for each object literals.
-        let stack = null;
-
-        return {
-            ObjectExpression() {
-                stack = {
-                    upper: stack,
-                    prevName: null
-                };
-            },
-
-            "ObjectExpression:exit"() {
-                stack = stack.upper;
-            },
-
-            Property(node) {
-                if (node.parent.type === "ObjectPattern") {
-                    return;
-                }
-
-                const prevName = stack.prevName;
-                const thisName = getPropertyName(node);
-
-                stack.prevName = thisName || prevName;
-
-                if (!prevName || !thisName) {
-                    return;
-                }
-
-                if (!isValidOrder(prevName, thisName)) {
-                    context.report({
-                        node,
-                        loc: node.key.loc,
-                        message: "Expected object keys to be in {{natual}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.",
-                        data: {
-                            thisName,
-                            prevName,
-                            order,
-                            insensitive: insensitive ? "insensitive " : "",
-                            natual: natual ? "natural " : ""
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/sort-vars.js
===================================================================
--- node_modules/eslint/lib/rules/sort-vars.js	(revision )
+++ node_modules/eslint/lib/rules/sort-vars.js	(revision )
@@ -1,61 +0,0 @@
-/**
- * @fileoverview Rule to require sorting of variables within a single Variable Declaration block
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require variables within the same declaration block to be sorted",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    ignoreCase: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const configuration = context.options[0] || {},
-            ignoreCase = configuration.ignoreCase || false;
-
-        return {
-            VariableDeclaration(node) {
-                const idDeclarations = node.declarations.filter(decl => decl.id.type === "Identifier");
-
-                idDeclarations.slice(1).reduce((memo, decl) => {
-                    let lastVariableName = memo.id.name,
-                        currenVariableName = decl.id.name;
-
-                    if (ignoreCase) {
-                        lastVariableName = lastVariableName.toLowerCase();
-                        currenVariableName = currenVariableName.toLowerCase();
-                    }
-
-                    if (currenVariableName < lastVariableName) {
-                        context.report({ node: decl, message: "Variables within the same declaration block should be sorted alphabetically." });
-                        return memo;
-                    }
-                    return decl;
-
-                }, idDeclarations[0]);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/use-isnan.js
===================================================================
--- node_modules/eslint/lib/rules/use-isnan.js	(revision )
+++ node_modules/eslint/lib/rules/use-isnan.js	(revision )
@@ -1,34 +0,0 @@
-/**
- * @fileoverview Rule to flag comparisons to the value NaN
- * @author James Allardice
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require calls to `isNaN()` when checking for `NaN`",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-            BinaryExpression(node) {
-                if (/^(?:[<>]|[!=]=)=?$/.test(node.operator) && (node.left.name === "NaN" || node.right.name === "NaN")) {
-                    context.report({ node, message: "Use the isNaN function to compare with NaN." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/wrap-iife.js
===================================================================
--- node_modules/eslint/lib/rules/wrap-iife.js	(revision )
+++ node_modules/eslint/lib/rules/wrap-iife.js	(revision )
@@ -1,151 +0,0 @@
-/**
- * @fileoverview Rule to flag when IIFE is not wrapped in parens
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require parentheses around immediate `function` invocations",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["outside", "inside", "any"]
-            },
-            {
-                type: "object",
-                properties: {
-                    functionPrototypeMethods: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ],
-
-        fixable: "code"
-    },
-
-    create(context) {
-
-        const style = context.options[0] || "outside";
-        const includeFunctionPrototypeMethods = (context.options[1] && context.options[1].functionPrototypeMethods) || false;
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Check if the node is wrapped in ()
-         * @param {ASTNode} node node to evaluate
-         * @returns {boolean} True if it is wrapped
-         * @private
-         */
-        function wrapped(node) {
-            return astUtils.isParenthesised(sourceCode, node);
-        }
-
-        /**
-        * Get the function node from an IIFE
-        * @param {ASTNode} node node to evaluate
-        * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist
-        */
-        function getFunctionNodeFromIIFE(node) {
-            const callee = node.callee;
-
-            if (callee.type === "FunctionExpression") {
-                return callee;
-            }
-
-            if (includeFunctionPrototypeMethods &&
-                callee.type === "MemberExpression" &&
-                callee.object.type === "FunctionExpression" &&
-                (astUtils.getStaticPropertyName(callee) === "call" || astUtils.getStaticPropertyName(callee) === "apply")
-            ) {
-                return callee.object;
-            }
-
-            return null;
-        }
-
-
-        return {
-            CallExpression(node) {
-                const innerNode = getFunctionNodeFromIIFE(node);
-
-                if (!innerNode) {
-                    return;
-                }
-
-                const callExpressionWrapped = wrapped(node),
-                    functionExpressionWrapped = wrapped(innerNode);
-
-                if (!callExpressionWrapped && !functionExpressionWrapped) {
-                    context.report({
-                        node,
-                        message: "Wrap an immediate function invocation in parentheses.",
-                        fix(fixer) {
-                            const nodeToSurround = style === "inside" ? innerNode : node;
-
-                            return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);
-                        }
-                    });
-                } else if (style === "inside" && !functionExpressionWrapped) {
-                    context.report({
-                        node,
-                        message: "Wrap only the function expression in parens.",
-                        fix(fixer) {
-
-                            /*
-                             * The outer call expression will always be wrapped at this point.
-                             * Replace the range between the end of the function expression and the end of the call expression.
-                             * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.
-                             * Replace the parens from the outer expression, and parenthesize the function expression.
-                             */
-                            const parenAfter = sourceCode.getTokenAfter(node);
-
-                            return fixer.replaceTextRange(
-                                [innerNode.range[1], parenAfter.range[1]],
-                                `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`
-                            );
-                        }
-                    });
-                } else if (style === "outside" && !callExpressionWrapped) {
-                    context.report({
-                        node,
-                        message: "Move the invocation into the parens that contain the function.",
-                        fix(fixer) {
-
-                            /*
-                             * The inner function expression will always be wrapped at this point.
-                             * It's only necessary to replace the range between the end of the function expression
-                             * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`
-                             * should get replaced with `(bar))`.
-                             */
-                            const parenAfter = sourceCode.getTokenAfter(innerNode);
-
-                            return fixer.replaceTextRange(
-                                [parenAfter.range[0], node.range[1]],
-                                `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`
-                            );
-                        }
-                    });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/complexity.js
===================================================================
--- node_modules/eslint/lib/rules/complexity.js	(revision )
+++ node_modules/eslint/lib/rules/complexity.js	(revision )
@@ -1,168 +0,0 @@
-/**
- * @fileoverview Counts the cyclomatic complexity of each function of the script. See http://en.wikipedia.org/wiki/Cyclomatic_complexity.
- * Counts the number of if, conditional, for, whilte, try, switch/case,
- * @author Patrick Brosset
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce a maximum cyclomatic complexity allowed in a program",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            maximum: {
-                                type: "integer",
-                                minimum: 0
-                            },
-                            max: {
-                                type: "integer",
-                                minimum: 0
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const option = context.options[0];
-        let THRESHOLD = 20;
-
-        if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
-            THRESHOLD = option.maximum;
-        }
-        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
-            THRESHOLD = option.max;
-        }
-        if (typeof option === "number") {
-            THRESHOLD = option;
-        }
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        // Using a stack to store complexity (handling nested functions)
-        const fns = [];
-
-        /**
-         * When parsing a new function, store it in our function stack
-         * @returns {void}
-         * @private
-         */
-        function startFunction() {
-            fns.push(1);
-        }
-
-        /**
-         * Evaluate the node at the end of function
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function endFunction(node) {
-            const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));
-            const complexity = fns.pop();
-
-            if (complexity > THRESHOLD) {
-                context.report({
-                    node,
-                    message: "{{name}} has a complexity of {{complexity}}.",
-                    data: { name, complexity }
-                });
-            }
-        }
-
-        /**
-         * Increase the complexity of the function in context
-         * @returns {void}
-         * @private
-         */
-        function increaseComplexity() {
-            if (fns.length) {
-                fns[fns.length - 1]++;
-            }
-        }
-
-        /**
-         * Increase the switch complexity in context
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function increaseSwitchComplexity(node) {
-
-            // Avoiding `default`
-            if (node.test) {
-                increaseComplexity();
-            }
-        }
-
-        /**
-         * Increase the logical path complexity in context
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function increaseLogicalComplexity(node) {
-
-            // Avoiding &&
-            if (node.operator === "||") {
-                increaseComplexity();
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            FunctionDeclaration: startFunction,
-            FunctionExpression: startFunction,
-            ArrowFunctionExpression: startFunction,
-            "FunctionDeclaration:exit": endFunction,
-            "FunctionExpression:exit": endFunction,
-            "ArrowFunctionExpression:exit": endFunction,
-
-            CatchClause: increaseComplexity,
-            ConditionalExpression: increaseComplexity,
-            LogicalExpression: increaseLogicalComplexity,
-            ForStatement: increaseComplexity,
-            ForInStatement: increaseComplexity,
-            ForOfStatement: increaseComplexity,
-            IfStatement: increaseComplexity,
-            SwitchCase: increaseSwitchComplexity,
-            WhileStatement: increaseComplexity,
-            DoWhileStatement: increaseComplexity
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/func-names.js
===================================================================
--- node_modules/eslint/lib/rules/func-names.js	(revision )
+++ node_modules/eslint/lib/rules/func-names.js	(revision )
@@ -1,114 +0,0 @@
-/**
- * @fileoverview Rule to warn when a function expression does not have a name.
- * @author Kyle T. Nunery
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-/**
- * Checks whether or not a given variable is a function name.
- * @param {eslint-scope.Variable} variable - A variable to check.
- * @returns {boolean} `true` if the variable is a function name.
- */
-function isFunctionName(variable) {
-    return variable && variable.defs[0].type === "FunctionName";
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow named `function` expressions",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["always", "as-needed", "never"]
-            }
-        ]
-    },
-
-    create(context) {
-        const never = context.options[0] === "never";
-        const asNeeded = context.options[0] === "as-needed";
-
-        /**
-         * Determines whether the current FunctionExpression node is a get, set, or
-         * shorthand method in an object literal or a class.
-         * @param {ASTNode} node - A node to check.
-         * @returns {boolean} True if the node is a get, set, or shorthand method.
-         */
-        function isObjectOrClassMethod(node) {
-            const parent = node.parent;
-
-            return (parent.type === "MethodDefinition" || (
-                parent.type === "Property" && (
-                    parent.method ||
-                    parent.kind === "get" ||
-                    parent.kind === "set"
-                )
-            ));
-        }
-
-        /**
-         * Determines whether the current FunctionExpression node has a name that would be
-         * inferred from context in a conforming ES6 environment.
-         * @param {ASTNode} node - A node to check.
-         * @returns {boolean} True if the node would have a name assigned automatically.
-         */
-        function hasInferredName(node) {
-            const parent = node.parent;
-
-            return isObjectOrClassMethod(node) ||
-                (parent.type === "VariableDeclarator" && parent.id.type === "Identifier" && parent.init === node) ||
-                (parent.type === "Property" && parent.value === node) ||
-                (parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node) ||
-                (parent.type === "ExportDefaultDeclaration" && parent.declaration === node) ||
-                (parent.type === "AssignmentPattern" && parent.right === node);
-        }
-
-        return {
-            "FunctionExpression:exit"(node) {
-
-                // Skip recursive functions.
-                const nameVar = context.getDeclaredVariables(node)[0];
-
-                if (isFunctionName(nameVar) && nameVar.references.length > 0) {
-                    return;
-                }
-
-                const hasName = Boolean(node.id && node.id.name);
-                const name = astUtils.getFunctionNameWithKind(node);
-
-                if (never) {
-                    if (hasName) {
-                        context.report({
-                            node,
-                            message: "Unexpected named {{name}}.",
-                            data: { name }
-                        });
-                    }
-                } else {
-                    if (!hasName && (asNeeded ? !hasInferredName(node) : !isObjectOrClassMethod(node))) {
-                        context.report({
-                            node,
-                            message: "Unexpected unnamed {{name}}.",
-                            data: { name }
-                        });
-                    }
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/func-style.js
===================================================================
--- node_modules/eslint/lib/rules/func-style.js	(revision )
+++ node_modules/eslint/lib/rules/func-style.js	(revision )
@@ -1,89 +0,0 @@
-/**
- * @fileoverview Rule to enforce a particular function style
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce the consistent use of either `function` declarations or expressions",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["declaration", "expression"]
-            },
-            {
-                type: "object",
-                properties: {
-                    allowArrowFunctions: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const style = context.options[0],
-            allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions === true,
-            enforceDeclarations = (style === "declaration"),
-            stack = [];
-
-        const nodesToCheck = {
-            FunctionDeclaration(node) {
-                stack.push(false);
-
-                if (!enforceDeclarations && node.parent.type !== "ExportDefaultDeclaration") {
-                    context.report({ node, message: "Expected a function expression." });
-                }
-            },
-            "FunctionDeclaration:exit"() {
-                stack.pop();
-            },
-
-            FunctionExpression(node) {
-                stack.push(false);
-
-                if (enforceDeclarations && node.parent.type === "VariableDeclarator") {
-                    context.report({ node: node.parent, message: "Expected a function declaration." });
-                }
-            },
-            "FunctionExpression:exit"() {
-                stack.pop();
-            },
-
-            ThisExpression() {
-                if (stack.length > 0) {
-                    stack[stack.length - 1] = true;
-                }
-            }
-        };
-
-        if (!allowArrowFunctions) {
-            nodesToCheck.ArrowFunctionExpression = function() {
-                stack.push(false);
-            };
-
-            nodesToCheck["ArrowFunctionExpression:exit"] = function(node) {
-                const hasThisExpr = stack.pop();
-
-                if (enforceDeclarations && !hasThisExpr && node.parent.type === "VariableDeclarator") {
-                    context.report({ node: node.parent, message: "Expected a function declaration." });
-                }
-            };
-        }
-
-        return nodesToCheck;
-
-    }
-};
Index: node_modules/eslint/lib/rules/jsx-quotes.js
===================================================================
--- node_modules/eslint/lib/rules/jsx-quotes.js	(revision )
+++ node_modules/eslint/lib/rules/jsx-quotes.js	(revision )
@@ -1,89 +0,0 @@
-/**
- * @fileoverview A rule to ensure consistent quotes used in jsx syntax.
- * @author Mathias Schreck <https://github.com/lo1tuma>
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Constants
-//------------------------------------------------------------------------------
-
-const QUOTE_SETTINGS = {
-    "prefer-double": {
-        quote: "\"",
-        description: "singlequote",
-        convert(str) {
-            return str.replace(/'/g, "\"");
-        }
-    },
-    "prefer-single": {
-        quote: "'",
-        description: "doublequote",
-        convert(str) {
-            return str.replace(/"/g, "'");
-        }
-    }
-};
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce the consistent use of either double or single quotes in JSX attributes",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                enum: ["prefer-single", "prefer-double"]
-            }
-        ]
-    },
-
-    create(context) {
-        const quoteOption = context.options[0] || "prefer-double",
-            setting = QUOTE_SETTINGS[quoteOption];
-
-        /**
-         * Checks if the given string literal node uses the expected quotes
-         * @param {ASTNode} node - A string literal node.
-         * @returns {boolean} Whether or not the string literal used the expected quotes.
-         * @public
-         */
-        function usesExpectedQuotes(node) {
-            return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);
-        }
-
-        return {
-            JSXAttribute(node) {
-                const attributeValue = node.value;
-
-                if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {
-                    context.report({
-                        node: attributeValue,
-                        message: "Unexpected usage of {{description}}.",
-                        data: {
-                            description: setting.description
-                        },
-                        fix(fixer) {
-                            return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/max-params.js
===================================================================
--- node_modules/eslint/lib/rules/max-params.js	(revision )
+++ node_modules/eslint/lib/rules/max-params.js	(revision )
@@ -1,96 +0,0 @@
-/**
- * @fileoverview Rule to flag when a function has too many parameters
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce a maximum number of parameters in function definitions",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            maximum: {
-                                type: "integer",
-                                minimum: 0
-                            },
-                            max: {
-                                type: "integer",
-                                minimum: 0
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-
-        const option = context.options[0];
-        let numParams = 3;
-
-        if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
-            numParams = option.maximum;
-        }
-        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
-            numParams = option.max;
-        }
-        if (typeof option === "number") {
-            numParams = option;
-        }
-
-        /**
-         * Checks a function to see if it has too many parameters.
-         * @param {ASTNode} node The node to check.
-         * @returns {void}
-         * @private
-         */
-        function checkFunction(node) {
-            if (node.params.length > numParams) {
-                context.report({
-                    node,
-                    message: "{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}.",
-                    data: {
-                        name: lodash.upperFirst(astUtils.getFunctionNameWithKind(node)),
-                        count: node.params.length,
-                        max: numParams
-                    }
-                });
-            }
-        }
-
-        return {
-            FunctionDeclaration: checkFunction,
-            ArrowFunctionExpression: checkFunction,
-            FunctionExpression: checkFunction
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/new-parens.js
===================================================================
--- node_modules/eslint/lib/rules/new-parens.js	(revision )
+++ node_modules/eslint/lib/rules/new-parens.js	(revision )
@@ -1,58 +0,0 @@
-/**
- * @fileoverview Rule to flag when using constructor without parentheses
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require parentheses when invoking a constructor with no arguments",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-            NewExpression(node) {
-                if (node.arguments.length !== 0) {
-                    return; // shortcut: if there are arguments, there have to be parens
-                }
-
-                const lastToken = sourceCode.getLastToken(node);
-                const hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);
-                const hasParens = hasLastParen && astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken));
-
-                if (!hasParens) {
-                    context.report({
-                        node,
-                        message: "Missing '()' invoking a constructor.",
-                        fix: fixer => fixer.insertTextAfter(node, "()")
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-bitwise.js
===================================================================
--- node_modules/eslint/lib/rules/no-bitwise.js	(revision )
+++ node_modules/eslint/lib/rules/no-bitwise.js	(revision )
@@ -1,109 +0,0 @@
-/**
- * @fileoverview Rule to flag bitwise identifiers
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//
-// Set of bitwise operators.
-//
-const BITWISE_OPERATORS = [
-    "^", "|", "&", "<<", ">>", ">>>",
-    "^=", "|=", "&=", "<<=", ">>=", ">>>=",
-    "~"
-];
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow bitwise operators",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allow: {
-                        type: "array",
-                        items: {
-                            enum: BITWISE_OPERATORS
-                        },
-                        uniqueItems: true
-                    },
-                    int32Hint: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0] || {};
-        const allowed = options.allow || [];
-        const int32Hint = options.int32Hint === true;
-
-        /**
-         * Reports an unexpected use of a bitwise operator.
-         * @param   {ASTNode} node Node which contains the bitwise operator.
-         * @returns {void}
-         */
-        function report(node) {
-            context.report({ node, message: "Unexpected use of '{{operator}}'.", data: { operator: node.operator } });
-        }
-
-        /**
-         * Checks if the given node has a bitwise operator.
-         * @param   {ASTNode} node The node to check.
-         * @returns {boolean} Whether or not the node has a bitwise operator.
-         */
-        function hasBitwiseOperator(node) {
-            return BITWISE_OPERATORS.indexOf(node.operator) !== -1;
-        }
-
-        /**
-         * Checks if exceptions were provided, e.g. `{ allow: ['~', '|'] }`.
-         * @param   {ASTNode} node The node to check.
-         * @returns {boolean} Whether or not the node has a bitwise operator.
-         */
-        function allowedOperator(node) {
-            return allowed.indexOf(node.operator) !== -1;
-        }
-
-        /**
-         * Checks if the given bitwise operator is used for integer typecasting, i.e. "|0"
-         * @param   {ASTNode} node The node to check.
-         * @returns {boolean} whether the node is used in integer typecasting.
-         */
-        function isInt32Hint(node) {
-            return int32Hint && node.operator === "|" && node.right &&
-              node.right.type === "Literal" && node.right.value === 0;
-        }
-
-        /**
-         * Report if the given node contains a bitwise operator.
-         * @param   {ASTNode} node The node to check.
-         * @returns {void}
-         */
-        function checkNodeForBitwiseOperator(node) {
-            if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {
-                report(node);
-            }
-        }
-
-        return {
-            AssignmentExpression: checkNodeForBitwiseOperator,
-            BinaryExpression: checkNodeForBitwiseOperator,
-            UnaryExpression: checkNodeForBitwiseOperator
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-console.js
===================================================================
--- node_modules/eslint/lib/rules/no-console.js	(revision )
+++ node_modules/eslint/lib/rules/no-console.js	(revision )
@@ -1,130 +0,0 @@
-/**
- * @fileoverview Rule to flag use of console object
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of `console`",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allow: {
-                        type: "array",
-                        items: {
-                            type: "string"
-                        },
-                        minItems: 1,
-                        uniqueItems: true
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0] || {};
-        const allowed = options.allow || [];
-
-        /**
-         * Checks whether the given reference is 'console' or not.
-         *
-         * @param {eslint-scope.Reference} reference - The reference to check.
-         * @returns {boolean} `true` if the reference is 'console'.
-         */
-        function isConsole(reference) {
-            const id = reference.identifier;
-
-            return id && id.name === "console";
-        }
-
-        /**
-         * Checks whether the property name of the given MemberExpression node
-         * is allowed by options or not.
-         *
-         * @param {ASTNode} node - The MemberExpression node to check.
-         * @returns {boolean} `true` if the property name of the node is allowed.
-         */
-        function isAllowed(node) {
-            const propertyName = astUtils.getStaticPropertyName(node);
-
-            return propertyName && allowed.indexOf(propertyName) !== -1;
-        }
-
-        /**
-         * Checks whether the given reference is a member access which is not
-         * allowed by options or not.
-         *
-         * @param {eslint-scope.Reference} reference - The reference to check.
-         * @returns {boolean} `true` if the reference is a member access which
-         *      is not allowed by options.
-         */
-        function isMemberAccessExceptAllowed(reference) {
-            const node = reference.identifier;
-            const parent = node.parent;
-
-            return (
-                parent.type === "MemberExpression" &&
-                parent.object === node &&
-                !isAllowed(parent)
-            );
-        }
-
-        /**
-         * Reports the given reference as a violation.
-         *
-         * @param {eslint-scope.Reference} reference - The reference to report.
-         * @returns {void}
-         */
-        function report(reference) {
-            const node = reference.identifier.parent;
-
-            context.report({
-                node,
-                loc: node.loc,
-                message: "Unexpected console statement."
-            });
-        }
-
-        return {
-            "Program:exit"() {
-                const scope = context.getScope();
-                const consoleVar = astUtils.getVariableByName(scope, "console");
-                const shadowed = consoleVar && consoleVar.defs.length > 0;
-
-                /* 'scope.through' includes all references to undefined
-                 * variables. If the variable 'console' is not defined, it uses
-                 * 'scope.through'.
-                 */
-                const references = consoleVar
-                    ? consoleVar.references
-                    : scope.through.filter(isConsole);
-
-                if (!shadowed) {
-                    references
-                        .filter(isMemberAccessExceptAllowed)
-                        .forEach(report);
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-eq-null.js
===================================================================
--- node_modules/eslint/lib/rules/no-eq-null.js	(revision )
+++ node_modules/eslint/lib/rules/no-eq-null.js	(revision )
@@ -1,39 +0,0 @@
-/**
- * @fileoverview Rule to flag comparisons to null without a type-checking
- * operator.
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `null` comparisons without type-checking operators",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            BinaryExpression(node) {
-                const badOperator = node.operator === "==" || node.operator === "!=";
-
-                if (node.right.type === "Literal" && node.right.raw === "null" && badOperator ||
-                        node.left.type === "Literal" && node.left.raw === "null" && badOperator) {
-                    context.report({ node, message: "Use ‘===’ to compare with ‘null’." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-ternary.js
===================================================================
--- node_modules/eslint/lib/rules/no-ternary.js	(revision )
+++ node_modules/eslint/lib/rules/no-ternary.js	(revision )
@@ -1,34 +0,0 @@
-/**
- * @fileoverview Rule to flag use of ternary operators.
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow ternary operators",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            ConditionalExpression(node) {
-                context.report({ node, message: "Ternary operator used." });
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/semi-style.js
===================================================================
--- node_modules/eslint/lib/rules/semi-style.js	(revision )
+++ node_modules/eslint/lib/rules/semi-style.js	(revision )
@@ -1,118 +0,0 @@
-/**
- * @fileoverview Rule to enforce location of semicolons.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const SELECTOR = `:matches(${
-    [
-        "BreakStatement", "ContinueStatement", "DebuggerStatement",
-        "DoWhileStatement", "EmptyStatement", "ExportAllDeclaration",
-        "ExportDefaultDeclaration", "ExportNamedDeclaration",
-        "ExpressionStatement", "ImportDeclaration", "ReturnStatement",
-        "ThrowStatement", "VariableDeclaration"
-    ].join(",")
-})`;
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce location of semicolons",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        schema: [{ enum: ["last", "first"] }],
-        fixable: "whitespace"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const option = context.options[0] || "last";
-
-        /**
-         * Check whether comments exist between the given 2 tokens.
-         * @param {Token} left The left token to check.
-         * @param {Token} right The right token to check.
-         * @returns {boolean} `true` if comments exist between the given 2 tokens.
-         */
-        function commentsExistBetween(left, right) {
-            return sourceCode.getFirstTokenBetween(
-                left,
-                right,
-                {
-                    includeComments: true,
-                    filter: astUtils.isCommentToken
-                }
-            ) !== null;
-        }
-
-        /**
-         * Check the given semicolon token.
-         * @param {Token} semiToken The semicolon token to check.
-         * @param {"first"|"last"} expected The expected location to check.
-         * @returns {void}
-         */
-        function check(semiToken, expected) {
-            const prevToken = sourceCode.getTokenBefore(semiToken);
-            const nextToken = sourceCode.getTokenAfter(semiToken);
-            const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);
-            const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);
-
-            if ((expected === "last" && !prevIsSameLine) || (expected === "first" && !nextIsSameLine)) {
-                context.report({
-                    loc: semiToken.loc,
-                    message: "Expected this semicolon to be at {{pos}}.",
-                    data: {
-                        pos: (expected === "last")
-                            ? "the end of the previous line"
-                            : "the beginning of the next line"
-                    },
-                    fix(fixer) {
-                        if (prevToken && nextToken && commentsExistBetween(prevToken, nextToken)) {
-                            return null;
-                        }
-
-                        const start = prevToken ? prevToken.range[1] : semiToken.range[0];
-                        const end = nextToken ? nextToken.range[0] : semiToken.range[1];
-                        const text = (expected === "last") ? ";\n" : "\n;";
-
-                        return fixer.replaceTextRange([start, end], text);
-                    }
-                });
-            }
-        }
-
-        return {
-            [SELECTOR](node) {
-                const lastToken = sourceCode.getLastToken(node);
-
-                if (astUtils.isSemicolonToken(lastToken)) {
-                    check(lastToken, option);
-                }
-            },
-
-            ForStatement(node) {
-                const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);
-                const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);
-
-                if (firstSemi) {
-                    check(firstSemi, "last");
-                }
-                if (secondSemi) {
-                    check(secondSemi, "last");
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/wrap-regex.js
===================================================================
--- node_modules/eslint/lib/rules/wrap-regex.js	(revision )
+++ node_modules/eslint/lib/rules/wrap-regex.js	(revision )
@@ -1,52 +0,0 @@
-/**
- * @fileoverview Rule to flag when regex literals are not wrapped in parens
- * @author Matt DuVall <http://www.mattduvall.com>
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require parenthesis around regex literals",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-
-            Literal(node) {
-                const token = sourceCode.getFirstToken(node),
-                    nodeType = token.type;
-
-                if (nodeType === "RegularExpression") {
-                    const source = sourceCode.getTokenBefore(node);
-                    const ancestors = context.getAncestors();
-                    const grandparent = ancestors[ancestors.length - 1];
-
-                    if (grandparent.type === "MemberExpression" && grandparent.object === node &&
-                        (!source || source.value !== "(")) {
-                        context.report({
-                            node,
-                            message: "Wrap the regexp literal in parens to disambiguate the slash.",
-                            fix: fixer => fixer.replaceText(node, `(${sourceCode.getText(node)})`)
-                        });
-                    }
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/brace-style.js
===================================================================
--- node_modules/eslint/lib/rules/brace-style.js	(revision )
+++ node_modules/eslint/lib/rules/brace-style.js	(revision )
@@ -1,182 +0,0 @@
-/**
- * @fileoverview Rule to flag block statements that do not use the one true brace style
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent brace style for blocks",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["1tbs", "stroustrup", "allman"]
-            },
-            {
-                type: "object",
-                properties: {
-                    allowSingleLine: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ],
-
-        fixable: "whitespace"
-    },
-
-    create(context) {
-        const style = context.options[0] || "1tbs",
-            params = context.options[1] || {},
-            sourceCode = context.getSourceCode();
-
-        const OPEN_MESSAGE = "Opening curly brace does not appear on the same line as controlling statement.",
-            OPEN_MESSAGE_ALLMAN = "Opening curly brace appears on the same line as controlling statement.",
-            BODY_MESSAGE = "Statement inside of curly braces should be on next line.",
-            CLOSE_MESSAGE = "Closing curly brace does not appear on the same line as the subsequent block.",
-            CLOSE_MESSAGE_SINGLE = "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
-            CLOSE_MESSAGE_STROUSTRUP_ALLMAN = "Closing curly brace appears on the same line as the subsequent block.";
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-        * Fixes a place where a newline unexpectedly appears
-        * @param {Token} firstToken The token before the unexpected newline
-        * @param {Token} secondToken The token after the unexpected newline
-        * @returns {Function} A fixer function to remove the newlines between the tokens
-        */
-        function removeNewlineBetween(firstToken, secondToken) {
-            const textRange = [firstToken.range[1], secondToken.range[0]];
-            const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);
-
-            // Don't do a fix if there is a comment between the tokens
-            if (textBetween.trim()) {
-                return null;
-            }
-            return fixer => fixer.replaceTextRange(textRange, " ");
-        }
-
-        /**
-        * Validates a pair of curly brackets based on the user's config
-        * @param {Token} openingCurly The opening curly bracket
-        * @param {Token} closingCurly The closing curly bracket
-        * @returns {void}
-        */
-        function validateCurlyPair(openingCurly, closingCurly) {
-            const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);
-            const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);
-            const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);
-            const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);
-
-            if (style !== "allman" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {
-                context.report({
-                    node: openingCurly,
-                    message: OPEN_MESSAGE,
-                    fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)
-                });
-            }
-
-            if (style === "allman" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {
-                context.report({
-                    node: openingCurly,
-                    message: OPEN_MESSAGE_ALLMAN,
-                    fix: fixer => fixer.insertTextBefore(openingCurly, "\n")
-                });
-            }
-
-            if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {
-                context.report({
-                    node: openingCurly,
-                    message: BODY_MESSAGE,
-                    fix: fixer => fixer.insertTextAfter(openingCurly, "\n")
-                });
-            }
-
-            if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {
-                context.report({
-                    node: closingCurly,
-                    message: CLOSE_MESSAGE_SINGLE,
-                    fix: fixer => fixer.insertTextBefore(closingCurly, "\n")
-                });
-            }
-        }
-
-        /**
-        * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)
-        * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).
-        * @returns {void}
-        */
-        function validateCurlyBeforeKeyword(curlyToken) {
-            const keywordToken = sourceCode.getTokenAfter(curlyToken);
-
-            if (style === "1tbs" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
-                context.report({
-                    node: curlyToken,
-                    message: CLOSE_MESSAGE,
-                    fix: removeNewlineBetween(curlyToken, keywordToken)
-                });
-            }
-
-            if (style !== "1tbs" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
-                context.report({
-                    node: curlyToken,
-                    message: CLOSE_MESSAGE_STROUSTRUP_ALLMAN,
-                    fix: fixer => fixer.insertTextAfter(curlyToken, "\n")
-                });
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            BlockStatement(node) {
-                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
-                    validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
-                }
-            },
-            ClassBody(node) {
-                validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
-            },
-            SwitchStatement(node) {
-                const closingCurly = sourceCode.getLastToken(node);
-                const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);
-
-                validateCurlyPair(openingCurly, closingCurly);
-            },
-            IfStatement(node) {
-                if (node.consequent.type === "BlockStatement" && node.alternate) {
-
-                    // Handle the keyword after the `if` block (before `else`)
-                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));
-                }
-            },
-            TryStatement(node) {
-
-                // Handle the keyword after the `try` block (before `catch` or `finally`)
-                validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));
-
-                if (node.handler && node.finalizer) {
-
-                    // Handle the keyword after the `catch` block (before `finally`)
-                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/comma-style.js
===================================================================
--- node_modules/eslint/lib/rules/comma-style.js	(revision )
+++ node_modules/eslint/lib/rules/comma-style.js	(revision )
@@ -1,297 +0,0 @@
-/**
- * @fileoverview Comma style - enforces comma styles of two types: last and first
- * @author Vignesh Anand aka vegetableman
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent comma style",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "code",
-        schema: [
-            {
-                enum: ["first", "last"]
-            },
-            {
-                type: "object",
-                properties: {
-                    exceptions: {
-                        type: "object",
-                        additionalProperties: {
-                            type: "boolean"
-                        }
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const style = context.options[0] || "last",
-            sourceCode = context.getSourceCode();
-        const exceptions = {
-            ArrayPattern: true,
-            ArrowFunctionExpression: true,
-            CallExpression: true,
-            FunctionDeclaration: true,
-            FunctionExpression: true,
-            ImportDeclaration: true,
-            ObjectPattern: true
-        };
-
-        if (context.options.length === 2 && context.options[1].hasOwnProperty("exceptions")) {
-            const keys = Object.keys(context.options[1].exceptions);
-
-            for (let i = 0; i < keys.length; i++) {
-                exceptions[keys[i]] = context.options[1].exceptions[keys[i]];
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Modified text based on the style
-         * @param {string} styleType Style type
-         * @param {string} text Source code text
-         * @returns {string} modified text
-         * @private
-         */
-        function getReplacedText(styleType, text) {
-            switch (styleType) {
-                case "between":
-                    return `,${text.replace("\n", "")}`;
-
-                case "first":
-                    return `${text},`;
-
-                case "last":
-                    return `,${text}`;
-
-                default:
-                    return "";
-            }
-        }
-
-        /**
-         * Determines the fixer function for a given style.
-         * @param {string} styleType comma style
-         * @param {ASTNode} previousItemToken The token to check.
-         * @param {ASTNode} commaToken The token to check.
-         * @param {ASTNode} currentItemToken The token to check.
-         * @returns {Function} Fixer function
-         * @private
-         */
-        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {
-            const text =
-                sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) +
-                sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);
-            const range = [previousItemToken.range[1], currentItemToken.range[0]];
-
-            return function(fixer) {
-                return fixer.replaceTextRange(range, getReplacedText(styleType, text));
-            };
-        }
-
-        /**
-         * Validates the spacing around single items in lists.
-         * @param {Token} previousItemToken The last token from the previous item.
-         * @param {Token} commaToken The token representing the comma.
-         * @param {Token} currentItemToken The first token of the current item.
-         * @param {Token} reportItem The item to use when reporting an error.
-         * @returns {void}
-         * @private
-         */
-        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {
-
-            // if single line
-            if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
-                    astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
-
-                // do nothing.
-
-            } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
-                    !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
-
-                // lone comma
-                context.report({
-                    node: reportItem,
-                    loc: {
-                        line: commaToken.loc.end.line,
-                        column: commaToken.loc.start.column
-                    },
-                    message: "Bad line breaking before and after ','.",
-                    fix: getFixerFunction("between", previousItemToken, commaToken, currentItemToken)
-                });
-
-            } else if (style === "first" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
-
-                context.report({
-                    node: reportItem,
-                    message: "',' should be placed first.",
-                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
-                });
-
-            } else if (style === "last" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
-
-                context.report({
-                    node: reportItem,
-                    loc: {
-                        line: commaToken.loc.end.line,
-                        column: commaToken.loc.end.column
-                    },
-                    message: "',' should be placed last.",
-                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
-                });
-            }
-        }
-
-        /**
-         * Checks the comma placement with regards to a declaration/property/element
-         * @param {ASTNode} node The binary expression node to check
-         * @param {string} property The property of the node containing child nodes.
-         * @private
-         * @returns {void}
-         */
-        function validateComma(node, property) {
-            const items = node[property],
-                arrayLiteral = (node.type === "ArrayExpression" || node.type === "ArrayPattern");
-
-            if (items.length > 1 || arrayLiteral) {
-
-                // seed as opening [
-                let previousItemToken = sourceCode.getFirstToken(node);
-
-                items.forEach(item => {
-                    const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,
-                        currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),
-                        reportItem = item || currentItemToken,
-                        tokenBeforeComma = sourceCode.getTokenBefore(commaToken);
-
-                    // Check if previous token is wrapped in parentheses
-                    if (tokenBeforeComma && astUtils.isClosingParenToken(tokenBeforeComma)) {
-                        previousItemToken = tokenBeforeComma;
-                    }
-
-                    /*
-                     * This works by comparing three token locations:
-                     * - previousItemToken is the last token of the previous item
-                     * - commaToken is the location of the comma before the current item
-                     * - currentItemToken is the first token of the current item
-                     *
-                     * These values get switched around if item is undefined.
-                     * previousItemToken will refer to the last token not belonging
-                     * to the current item, which could be a comma or an opening
-                     * square bracket. currentItemToken could be a comma.
-                     *
-                     * All comparisons are done based on these tokens directly, so
-                     * they are always valid regardless of an undefined item.
-                     */
-                    if (astUtils.isCommaToken(commaToken)) {
-                        validateCommaItemSpacing(previousItemToken, commaToken,
-                            currentItemToken, reportItem);
-                    }
-
-                    if (item) {
-                        const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);
-
-                        previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];
-                    }
-                });
-
-                /*
-                 * Special case for array literals that have empty last items, such
-                 * as [ 1, 2, ]. These arrays only have two items show up in the
-                 * AST, so we need to look at the token to verify that there's no
-                 * dangling comma.
-                 */
-                if (arrayLiteral) {
-
-                    const lastToken = sourceCode.getLastToken(node),
-                        nextToLastToken = sourceCode.getTokenBefore(lastToken);
-
-                    if (astUtils.isCommaToken(nextToLastToken)) {
-                        validateCommaItemSpacing(
-                            sourceCode.getTokenBefore(nextToLastToken),
-                            nextToLastToken,
-                            lastToken,
-                            lastToken
-                        );
-                    }
-                }
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        const nodes = {};
-
-        if (!exceptions.VariableDeclaration) {
-            nodes.VariableDeclaration = function(node) {
-                validateComma(node, "declarations");
-            };
-        }
-        if (!exceptions.ObjectExpression) {
-            nodes.ObjectExpression = function(node) {
-                validateComma(node, "properties");
-            };
-        }
-        if (!exceptions.ObjectPattern) {
-            nodes.ObjectPattern = function(node) {
-                validateComma(node, "properties");
-            };
-        }
-        if (!exceptions.ArrayExpression) {
-            nodes.ArrayExpression = function(node) {
-                validateComma(node, "elements");
-            };
-        }
-        if (!exceptions.ArrayPattern) {
-            nodes.ArrayPattern = function(node) {
-                validateComma(node, "elements");
-            };
-        }
-        if (!exceptions.FunctionDeclaration) {
-            nodes.FunctionDeclaration = function(node) {
-                validateComma(node, "params");
-            };
-        }
-        if (!exceptions.FunctionExpression) {
-            nodes.FunctionExpression = function(node) {
-                validateComma(node, "params");
-            };
-        }
-        if (!exceptions.ArrowFunctionExpression) {
-            nodes.ArrowFunctionExpression = function(node) {
-                validateComma(node, "params");
-            };
-        }
-        if (!exceptions.CallExpression) {
-            nodes.CallExpression = function(node) {
-                validateComma(node, "arguments");
-            };
-        }
-        if (!exceptions.ImportDeclaration) {
-            nodes.ImportDeclaration = function(node) {
-                validateComma(node, "specifiers");
-            };
-        }
-
-        return nodes;
-    }
-};
Index: node_modules/eslint/lib/rules/key-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/key-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/key-spacing.js	(revision )
@@ -1,639 +0,0 @@
-/**
- * @fileoverview Rule to specify spacing of object literal keys and values
- * @author Brandon Mills
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether a string contains a line terminator as defined in
- * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3
- * @param {string} str String to test.
- * @returns {boolean} True if str contains a line terminator.
- */
-function containsLineTerminator(str) {
-    return astUtils.LINEBREAK_MATCHER.test(str);
-}
-
-/**
- * Gets the last element of an array.
- * @param {Array} arr An array.
- * @returns {any} Last element of arr.
- */
-function last(arr) {
-    return arr[arr.length - 1];
-}
-
-/**
- * Checks whether a node is contained on a single line.
- * @param {ASTNode} node AST Node being evaluated.
- * @returns {boolean} True if the node is a single line.
- */
-function isSingleLine(node) {
-    return (node.loc.end.line === node.loc.start.line);
-}
-
-/**
- * Initializes a single option property from the configuration with defaults for undefined values
- * @param {Object} toOptions Object to be initialized
- * @param {Object} fromOptions Object to be initialized from
- * @returns {Object} The object with correctly initialized options and values
- */
-function initOptionProperty(toOptions, fromOptions) {
-    toOptions.mode = fromOptions.mode || "strict";
-
-    // Set value of beforeColon
-    if (typeof fromOptions.beforeColon !== "undefined") {
-        toOptions.beforeColon = +fromOptions.beforeColon;
-    } else {
-        toOptions.beforeColon = 0;
-    }
-
-    // Set value of afterColon
-    if (typeof fromOptions.afterColon !== "undefined") {
-        toOptions.afterColon = +fromOptions.afterColon;
-    } else {
-        toOptions.afterColon = 1;
-    }
-
-    // Set align if exists
-    if (typeof fromOptions.align !== "undefined") {
-        if (typeof fromOptions.align === "object") {
-            toOptions.align = fromOptions.align;
-        } else { // "string"
-            toOptions.align = {
-                on: fromOptions.align,
-                mode: toOptions.mode,
-                beforeColon: toOptions.beforeColon,
-                afterColon: toOptions.afterColon
-            };
-        }
-    }
-
-    return toOptions;
-}
-
-/**
- * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values
- * @param {Object} toOptions Object to be initialized
- * @param {Object} fromOptions Object to be initialized from
- * @returns {Object} The object with correctly initialized options and values
- */
-function initOptions(toOptions, fromOptions) {
-    if (typeof fromOptions.align === "object") {
-
-        // Initialize the alignment configuration
-        toOptions.align = initOptionProperty({}, fromOptions.align);
-        toOptions.align.on = fromOptions.align.on || "colon";
-        toOptions.align.mode = fromOptions.align.mode || "strict";
-
-        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));
-        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));
-
-    } else { // string or undefined
-        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));
-        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));
-
-        // If alignment options are defined in multiLine, pull them out into the general align configuration
-        if (toOptions.multiLine.align) {
-            toOptions.align = {
-                on: toOptions.multiLine.align.on,
-                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
-                beforeColon: toOptions.multiLine.align.beforeColon,
-                afterColon: toOptions.multiLine.align.afterColon
-            };
-        }
-    }
-
-    return toOptions;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const messages = {
-    key: "{{error}} space after {{computed}}key '{{key}}'.",
-    value: "{{error}} space before value for {{computed}}key '{{key}}'."
-};
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing between keys and values in object literal properties",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [{
-            anyOf: [
-                {
-                    type: "object",
-                    properties: {
-                        align: {
-                            anyOf: [
-                                {
-                                    enum: ["colon", "value"]
-                                },
-                                {
-                                    type: "object",
-                                    properties: {
-                                        mode: {
-                                            enum: ["strict", "minimum"]
-                                        },
-                                        on: {
-                                            enum: ["colon", "value"]
-                                        },
-                                        beforeColon: {
-                                            type: "boolean"
-                                        },
-                                        afterColon: {
-                                            type: "boolean"
-                                        }
-                                    },
-                                    additionalProperties: false
-                                }
-                            ]
-                        },
-                        mode: {
-                            enum: ["strict", "minimum"]
-                        },
-                        beforeColon: {
-                            type: "boolean"
-                        },
-                        afterColon: {
-                            type: "boolean"
-                        }
-                    },
-                    additionalProperties: false
-                },
-                {
-                    type: "object",
-                    properties: {
-                        singleLine: {
-                            type: "object",
-                            properties: {
-                                mode: {
-                                    enum: ["strict", "minimum"]
-                                },
-                                beforeColon: {
-                                    type: "boolean"
-                                },
-                                afterColon: {
-                                    type: "boolean"
-                                }
-                            },
-                            additionalProperties: false
-                        },
-                        multiLine: {
-                            type: "object",
-                            properties: {
-                                align: {
-                                    anyOf: [
-                                        {
-                                            enum: ["colon", "value"]
-                                        },
-                                        {
-                                            type: "object",
-                                            properties: {
-                                                mode: {
-                                                    enum: ["strict", "minimum"]
-                                                },
-                                                on: {
-                                                    enum: ["colon", "value"]
-                                                },
-                                                beforeColon: {
-                                                    type: "boolean"
-                                                },
-                                                afterColon: {
-                                                    type: "boolean"
-                                                }
-                                            },
-                                            additionalProperties: false
-                                        }
-                                    ]
-                                },
-                                mode: {
-                                    enum: ["strict", "minimum"]
-                                },
-                                beforeColon: {
-                                    type: "boolean"
-                                },
-                                afterColon: {
-                                    type: "boolean"
-                                }
-                            },
-                            additionalProperties: false
-                        }
-                    },
-                    additionalProperties: false
-                },
-                {
-                    type: "object",
-                    properties: {
-                        singleLine: {
-                            type: "object",
-                            properties: {
-                                mode: {
-                                    enum: ["strict", "minimum"]
-                                },
-                                beforeColon: {
-                                    type: "boolean"
-                                },
-                                afterColon: {
-                                    type: "boolean"
-                                }
-                            },
-                            additionalProperties: false
-                        },
-                        multiLine: {
-                            type: "object",
-                            properties: {
-                                mode: {
-                                    enum: ["strict", "minimum"]
-                                },
-                                beforeColon: {
-                                    type: "boolean"
-                                },
-                                afterColon: {
-                                    type: "boolean"
-                                }
-                            },
-                            additionalProperties: false
-                        },
-                        align: {
-                            type: "object",
-                            properties: {
-                                mode: {
-                                    enum: ["strict", "minimum"]
-                                },
-                                on: {
-                                    enum: ["colon", "value"]
-                                },
-                                beforeColon: {
-                                    type: "boolean"
-                                },
-                                afterColon: {
-                                    type: "boolean"
-                                }
-                            },
-                            additionalProperties: false
-                        }
-                    },
-                    additionalProperties: false
-                }
-            ]
-        }]
-    },
-
-    create(context) {
-
-        /**
-         * OPTIONS
-         * "key-spacing": [2, {
-         *     beforeColon: false,
-         *     afterColon: true,
-         *     align: "colon" // Optional, or "value"
-         * }
-         */
-        const options = context.options[0] || {},
-            ruleOptions = initOptions({}, options),
-            multiLineOptions = ruleOptions.multiLine,
-            singleLineOptions = ruleOptions.singleLine,
-            alignmentOptions = ruleOptions.align || null;
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Checks whether a property is a member of the property group it follows.
-         * @param {ASTNode} lastMember The last Property known to be in the group.
-         * @param {ASTNode} candidate The next Property that might be in the group.
-         * @returns {boolean} True if the candidate property is part of the group.
-         */
-        function continuesPropertyGroup(lastMember, candidate) {
-            const groupEndLine = lastMember.loc.start.line,
-                candidateStartLine = candidate.loc.start.line;
-
-            if (candidateStartLine - groupEndLine <= 1) {
-                return true;
-            }
-
-            // Check that the first comment is adjacent to the end of the group, the
-            // last comment is adjacent to the candidate property, and that successive
-            // comments are adjacent to each other.
-            const leadingComments = sourceCode.getCommentsBefore(candidate);
-
-            if (
-                leadingComments.length &&
-                leadingComments[0].loc.start.line - groupEndLine <= 1 &&
-                candidateStartLine - last(leadingComments).loc.end.line <= 1
-            ) {
-                for (let i = 1; i < leadingComments.length; i++) {
-                    if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-
-            return false;
-        }
-
-        /**
-         * Determines if the given property is key-value property.
-         * @param {ASTNode} property Property node to check.
-         * @returns {boolean} Whether the property is a key-value property.
-         */
-        function isKeyValueProperty(property) {
-            return !(
-                (property.method ||
-                property.shorthand ||
-                property.kind !== "init" || property.type !== "Property") // Could be "ExperimentalSpreadProperty" or "SpreadProperty"
-            );
-        }
-
-        /**
-         * Starting from the given a node (a property.key node here) looks forward
-         * until it finds the last token before a colon punctuator and returns it.
-         * @param {ASTNode} node The node to start looking from.
-         * @returns {ASTNode} The last token before a colon punctuator.
-         */
-        function getLastTokenBeforeColon(node) {
-            const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);
-
-            return sourceCode.getTokenBefore(colonToken);
-        }
-
-        /**
-         * Starting from the given a node (a property.key node here) looks forward
-         * until it finds the colon punctuator and returns it.
-         * @param {ASTNode} node The node to start looking from.
-         * @returns {ASTNode} The colon punctuator.
-         */
-        function getNextColon(node) {
-            return sourceCode.getTokenAfter(node, astUtils.isColonToken);
-        }
-
-        /**
-         * Gets an object literal property's key as the identifier name or string value.
-         * @param {ASTNode} property Property node whose key to retrieve.
-         * @returns {string} The property's key.
-         */
-        function getKey(property) {
-            const key = property.key;
-
-            if (property.computed) {
-                return sourceCode.getText().slice(key.range[0], key.range[1]);
-            }
-
-            return property.key.name || property.key.value;
-        }
-
-        /**
-         * Reports an appropriately-formatted error if spacing is incorrect on one
-         * side of the colon.
-         * @param {ASTNode} property Key-value pair in an object literal.
-         * @param {string} side Side being verified - either "key" or "value".
-         * @param {string} whitespace Actual whitespace string.
-         * @param {int} expected Expected whitespace length.
-         * @param {string} mode Value of the mode as "strict" or "minimum"
-         * @returns {void}
-         */
-        function report(property, side, whitespace, expected, mode) {
-            const diff = whitespace.length - expected,
-                nextColon = getNextColon(property.key),
-                tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),
-                tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),
-                isKeySide = side === "key",
-                locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,
-                isExtra = diff > 0,
-                diffAbs = Math.abs(diff),
-                spaces = Array(diffAbs + 1).join(" ");
-
-            if ((
-                diff && mode === "strict" ||
-                diff < 0 && mode === "minimum" ||
-                diff > 0 && !expected && mode === "minimum") &&
-                !(expected && containsLineTerminator(whitespace))
-            ) {
-                let fix;
-
-                if (isExtra) {
-                    let range;
-
-                    // Remove whitespace
-                    if (isKeySide) {
-                        range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
-                    } else {
-                        range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
-                    }
-                    fix = function(fixer) {
-                        return fixer.removeRange(range);
-                    };
-                } else {
-
-                    // Add whitespace
-                    if (isKeySide) {
-                        fix = function(fixer) {
-                            return fixer.insertTextAfter(tokenBeforeColon, spaces);
-                        };
-                    } else {
-                        fix = function(fixer) {
-                            return fixer.insertTextBefore(tokenAfterColon, spaces);
-                        };
-                    }
-                }
-
-                context.report({
-                    node: property[side],
-                    loc: locStart,
-                    message: messages[side],
-                    data: {
-                        error: isExtra ? "Extra" : "Missing",
-                        computed: property.computed ? "computed " : "",
-                        key: getKey(property)
-                    },
-                    fix
-                });
-            }
-        }
-
-        /**
-         * Gets the number of characters in a key, including quotes around string
-         * keys and braces around computed property keys.
-         * @param {ASTNode} property Property of on object literal.
-         * @returns {int} Width of the key.
-         */
-        function getKeyWidth(property) {
-            const startToken = sourceCode.getFirstToken(property);
-            const endToken = getLastTokenBeforeColon(property.key);
-
-            return endToken.range[1] - startToken.range[0];
-        }
-
-        /**
-         * Gets the whitespace around the colon in an object literal property.
-         * @param {ASTNode} property Property node from an object literal.
-         * @returns {Object} Whitespace before and after the property's colon.
-         */
-        function getPropertyWhitespace(property) {
-            const whitespace = /(\s*):(\s*)/.exec(sourceCode.getText().slice(
-                property.key.range[1], property.value.range[0]
-            ));
-
-            if (whitespace) {
-                return {
-                    beforeColon: whitespace[1],
-                    afterColon: whitespace[2]
-                };
-            }
-            return null;
-        }
-
-        /**
-         * Creates groups of properties.
-         * @param  {ASTNode} node ObjectExpression node being evaluated.
-         * @returns {Array.<ASTNode[]>} Groups of property AST node lists.
-         */
-        function createGroups(node) {
-            if (node.properties.length === 1) {
-                return [node.properties];
-            }
-
-            return node.properties.reduce((groups, property) => {
-                const currentGroup = last(groups),
-                    prev = last(currentGroup);
-
-                if (!prev || continuesPropertyGroup(prev, property)) {
-                    currentGroup.push(property);
-                } else {
-                    groups.push([property]);
-                }
-
-                return groups;
-            }, [
-                []
-            ]);
-        }
-
-        /**
-         * Verifies correct vertical alignment of a group of properties.
-         * @param {ASTNode[]} properties List of Property AST nodes.
-         * @returns {void}
-         */
-        function verifyGroupAlignment(properties) {
-            const length = properties.length,
-                widths = properties.map(getKeyWidth), // Width of keys, including quotes
-                align = alignmentOptions.on; // "value" or "colon"
-            let targetWidth = Math.max.apply(null, widths),
-                beforeColon, afterColon, mode;
-
-            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.
-                beforeColon = alignmentOptions.beforeColon;
-                afterColon = alignmentOptions.afterColon;
-                mode = alignmentOptions.mode;
-            } else {
-                beforeColon = multiLineOptions.beforeColon;
-                afterColon = multiLineOptions.afterColon;
-                mode = alignmentOptions.mode;
-            }
-
-            // Conditionally include one space before or after colon
-            targetWidth += (align === "colon" ? beforeColon : afterColon);
-
-            for (let i = 0; i < length; i++) {
-                const property = properties[i];
-                const whitespace = getPropertyWhitespace(property);
-
-                if (whitespace) { // Object literal getters/setters lack a colon
-                    const width = widths[i];
-
-                    if (align === "value") {
-                        report(property, "key", whitespace.beforeColon, beforeColon, mode);
-                        report(property, "value", whitespace.afterColon, targetWidth - width, mode);
-                    } else { // align = "colon"
-                        report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
-                        report(property, "value", whitespace.afterColon, afterColon, mode);
-                    }
-                }
-            }
-        }
-
-        /**
-         * Verifies vertical alignment, taking into account groups of properties.
-         * @param  {ASTNode} node ObjectExpression node being evaluated.
-         * @returns {void}
-         */
-        function verifyAlignment(node) {
-            createGroups(node).forEach(group => {
-                verifyGroupAlignment(group.filter(isKeyValueProperty));
-            });
-        }
-
-        /**
-         * Verifies spacing of property conforms to specified options.
-         * @param  {ASTNode} node Property node being evaluated.
-         * @param {Object} lineOptions Configured singleLine or multiLine options
-         * @returns {void}
-         */
-        function verifySpacing(node, lineOptions) {
-            const actual = getPropertyWhitespace(node);
-
-            if (actual) { // Object literal getters/setters lack colons
-                report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
-                report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
-            }
-        }
-
-        /**
-         * Verifies spacing of each property in a list.
-         * @param  {ASTNode[]} properties List of Property AST nodes.
-         * @returns {void}
-         */
-        function verifyListSpacing(properties) {
-            const length = properties.length;
-
-            for (let i = 0; i < length; i++) {
-                verifySpacing(properties[i], singleLineOptions);
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        if (alignmentOptions) { // Verify vertical alignment
-
-            return {
-                ObjectExpression(node) {
-                    if (isSingleLine(node)) {
-                        verifyListSpacing(node.properties.filter(isKeyValueProperty));
-                    } else {
-                        verifyAlignment(node);
-                    }
-                }
-            };
-
-        }
-
-        // Obey beforeColon and afterColon in each property as configured
-        return {
-            Property(node) {
-                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
-            }
-        };
-
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-continue.js
===================================================================
--- node_modules/eslint/lib/rules/no-continue.js	(revision )
+++ node_modules/eslint/lib/rules/no-continue.js	(revision )
@@ -1,32 +0,0 @@
-/**
- * @fileoverview Rule to flag use of continue statement
- * @author Borislav Zhivkov
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `continue` statements",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-            ContinueStatement(node) {
-                context.report({ node, message: "Unexpected use of continue statement." });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-debugger.js
===================================================================
--- node_modules/eslint/lib/rules/no-debugger.js	(revision )
+++ node_modules/eslint/lib/rules/no-debugger.js	(revision )
@@ -1,43 +0,0 @@
-/**
- * @fileoverview Rule to flag use of a debugger statement
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of `debugger`",
-            category: "Possible Errors",
-            recommended: true
-        },
-        fixable: "code",
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-            DebuggerStatement(node) {
-                context.report({
-                    node,
-                    message: "Unexpected 'debugger' statement.",
-                    fix(fixer) {
-                        if (astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
-                            return fixer.remove(node);
-                        }
-                        return null;
-                    }
-                });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-iterator.js
===================================================================
--- node_modules/eslint/lib/rules/no-iterator.js	(revision )
+++ node_modules/eslint/lib/rules/no-iterator.js	(revision )
@@ -1,38 +0,0 @@
-/**
- * @fileoverview Rule to flag usage of __iterator__ property
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of the `__iterator__` property",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            MemberExpression(node) {
-
-                if (node.property &&
-                        (node.property.type === "Identifier" && node.property.name === "__iterator__" && !node.computed) ||
-                        (node.property.type === "Literal" && node.property.value === "__iterator__")) {
-                    context.report({ node, message: "Reserved name '__iterator__'." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-new-func.js
===================================================================
--- node_modules/eslint/lib/rules/no-new-func.js	(revision )
+++ node_modules/eslint/lib/rules/no-new-func.js	(revision )
@@ -1,45 +0,0 @@
-/**
- * @fileoverview Rule to flag when using new Function
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `new` operators with the `Function` object",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Reports a node.
-         * @param {ASTNode} node The node to report
-         * @returns {void}
-         * @private
-         */
-        function report(node) {
-            context.report({ node, message: "The Function constructor is eval." });
-        }
-
-        return {
-            "NewExpression[callee.name = 'Function']": report,
-            "CallExpression[callee.name = 'Function']": report
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-plusplus.js
===================================================================
--- node_modules/eslint/lib/rules/no-plusplus.js	(revision )
+++ node_modules/eslint/lib/rules/no-plusplus.js	(revision )
@@ -1,61 +0,0 @@
-/**
- * @fileoverview Rule to flag use of unary increment and decrement operators.
- * @author Ian Christian Myers
- * @author Brody McKee (github.com/mrmckeb)
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the unary operators `++` and `--`",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allowForLoopAfterthoughts: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const config = context.options[0];
-        let allowInForAfterthought = false;
-
-        if (typeof config === "object") {
-            allowInForAfterthought = config.allowForLoopAfterthoughts === true;
-        }
-
-        return {
-
-            UpdateExpression(node) {
-                if (allowInForAfterthought && node.parent.type === "ForStatement") {
-                    return;
-                }
-                context.report({
-                    node,
-                    message: "Unary operator '{{operator}}' used.",
-                    data: {
-                        operator: node.operator
-                    }
-                });
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/quote-props.js
===================================================================
--- node_modules/eslint/lib/rules/quote-props.js	(revision )
+++ node_modules/eslint/lib/rules/quote-props.js	(revision )
@@ -1,298 +0,0 @@
-/**
- * @fileoverview Rule to flag non-quoted property names in object literals.
- * @author Mathias Bynens <http://mathiasbynens.be/>
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const espree = require("espree"),
-    keywords = require("../util/keywords");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require quotes around object literal property names",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: {
-            anyOf: [
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 1
-                },
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
-                        },
-                        {
-                            type: "object",
-                            properties: {
-                                keywords: {
-                                    type: "boolean"
-                                },
-                                unnecessary: {
-                                    type: "boolean"
-                                },
-                                numbers: {
-                                    type: "boolean"
-                                }
-                            },
-                            additionalProperties: false
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 2
-                }
-            ]
-        },
-
-        fixable: "code"
-    },
-
-    create(context) {
-
-        const MODE = context.options[0],
-            KEYWORDS = context.options[1] && context.options[1].keywords,
-            CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,
-            NUMBERS = context.options[1] && context.options[1].numbers,
-
-            MESSAGE_UNNECESSARY = "Unnecessarily quoted property '{{property}}' found.",
-            MESSAGE_UNQUOTED = "Unquoted property '{{property}}' found.",
-            MESSAGE_NUMERIC = "Unquoted number literal '{{property}}' used as key.",
-            MESSAGE_RESERVED = "Unquoted reserved word '{{property}}' used as key.",
-            sourceCode = context.getSourceCode();
-
-
-        /**
-         * Checks whether a certain string constitutes an ES3 token
-         * @param   {string} tokenStr - The string to be checked.
-         * @returns {boolean} `true` if it is an ES3 token.
-         */
-        function isKeyword(tokenStr) {
-            return keywords.indexOf(tokenStr) >= 0;
-        }
-
-        /**
-         * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)
-         * @param   {string} rawKey The raw key value from the source
-         * @param   {espreeTokens} tokens The espree-tokenized node key
-         * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked
-         * @returns {boolean} Whether or not a key has redundant quotes.
-         * @private
-         */
-        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {
-            return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length &&
-                (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 ||
-                (tokens[0].type === "Numeric" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value));
-        }
-
-        /**
-        * Returns a string representation of a property node with quotes removed
-        * @param {ASTNode} key Key AST Node, which may or may not be quoted
-        * @returns {string} A replacement string for this property
-        */
-        function getUnquotedKey(key) {
-            return key.type === "Identifier" ? key.name : key.value;
-        }
-
-        /**
-        * Returns a string representation of a property node with quotes added
-        * @param {ASTNode} key Key AST Node, which may or may not be quoted
-        * @returns {string} A replacement string for this property
-        */
-        function getQuotedKey(key) {
-            if (key.type === "Literal" && typeof key.value === "string") {
-
-                // If the key is already a string literal, don't replace the quotes with double quotes.
-                return sourceCode.getText(key);
-            }
-
-            // Otherwise, the key is either an identifier or a number literal.
-            return `"${key.type === "Identifier" ? key.name : key.value}"`;
-        }
-
-        /**
-         * Ensures that a property's key is quoted only when necessary
-         * @param   {ASTNode} node Property AST node
-         * @returns {void}
-         */
-        function checkUnnecessaryQuotes(node) {
-            const key = node.key;
-
-            if (node.method || node.computed || node.shorthand) {
-                return;
-            }
-
-            if (key.type === "Literal" && typeof key.value === "string") {
-                let tokens;
-
-                try {
-                    tokens = espree.tokenize(key.value);
-                } catch (e) {
-                    return;
-                }
-
-                if (tokens.length !== 1) {
-                    return;
-                }
-
-                const isKeywordToken = isKeyword(tokens[0].value);
-
-                if (isKeywordToken && KEYWORDS) {
-                    return;
-                }
-
-                if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {
-                    context.report({
-                        node,
-                        message: MESSAGE_UNNECESSARY,
-                        data: { property: key.value },
-                        fix: fixer => fixer.replaceText(key, getUnquotedKey(key))
-                    });
-                }
-            } else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
-                context.report({
-                    node,
-                    message: MESSAGE_RESERVED,
-                    data: { property: key.name },
-                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))
-                });
-            } else if (NUMBERS && key.type === "Literal" && typeof key.value === "number") {
-                context.report({
-                    node,
-                    message: MESSAGE_NUMERIC,
-                    data: { property: key.value },
-                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))
-                });
-            }
-        }
-
-        /**
-         * Ensures that a property's key is quoted
-         * @param   {ASTNode} node Property AST node
-         * @returns {void}
-         */
-        function checkOmittedQuotes(node) {
-            const key = node.key;
-
-            if (!node.method && !node.computed && !node.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
-                context.report({
-                    node,
-                    message: MESSAGE_UNQUOTED,
-                    data: { property: key.name || key.value },
-                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))
-                });
-            }
-        }
-
-        /**
-         * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes
-         * @param   {ASTNode} node Property AST node
-         * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy
-         * @returns {void}
-         */
-        function checkConsistency(node, checkQuotesRedundancy) {
-            const quotedProps = [],
-                unquotedProps = [];
-            let keywordKeyName = null,
-                necessaryQuotes = false;
-
-            node.properties.forEach(property => {
-                const key = property.key;
-
-                if (!key || property.method || property.computed || property.shorthand) {
-                    return;
-                }
-
-                if (key.type === "Literal" && typeof key.value === "string") {
-
-                    quotedProps.push(property);
-
-                    if (checkQuotesRedundancy) {
-                        let tokens;
-
-                        try {
-                            tokens = espree.tokenize(key.value);
-                        } catch (e) {
-                            necessaryQuotes = true;
-                            return;
-                        }
-
-                        necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);
-                    }
-                } else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
-                    unquotedProps.push(property);
-                    necessaryQuotes = true;
-                    keywordKeyName = key.name;
-                } else {
-                    unquotedProps.push(property);
-                }
-            });
-
-            if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {
-                quotedProps.forEach(property => {
-                    context.report({
-                        node: property,
-                        message: "Properties shouldn't be quoted as all quotes are redundant.",
-                        fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))
-                    });
-                });
-            } else if (unquotedProps.length && keywordKeyName) {
-                unquotedProps.forEach(property => {
-                    context.report({
-                        node: property,
-                        message: "Properties should be quoted as '{{property}}' is a reserved word.",
-                        data: { property: keywordKeyName },
-                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))
-                    });
-                });
-            } else if (quotedProps.length && unquotedProps.length) {
-                unquotedProps.forEach(property => {
-                    context.report({
-                        node: property,
-                        message: "Inconsistently quoted property '{{key}}' found.",
-                        data: { key: property.key.name || property.key.value },
-                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))
-                    });
-                });
-            }
-        }
-
-        return {
-            Property(node) {
-                if (MODE === "always" || !MODE) {
-                    checkOmittedQuotes(node);
-                }
-                if (MODE === "as-needed") {
-                    checkUnnecessaryQuotes(node);
-                }
-            },
-            ObjectExpression(node) {
-                if (MODE === "consistent") {
-                    checkConsistency(node, false);
-                }
-                if (MODE === "consistent-as-needed") {
-                    checkConsistency(node, true);
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/unicode-bom.js
===================================================================
--- node_modules/eslint/lib/rules/unicode-bom.js	(revision )
+++ node_modules/eslint/lib/rules/unicode-bom.js	(revision )
@@ -1,66 +0,0 @@
-/**
- * @fileoverview Require or disallow Unicode BOM
- * @author Andrew Johnston <https://github.com/ehjay>
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow Unicode byte order mark (BOM)",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                enum: ["always", "never"]
-            }
-        ]
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-
-            Program: function checkUnicodeBOM(node) {
-
-                const sourceCode = context.getSourceCode(),
-                    location = { column: 0, line: 1 },
-                    requireBOM = context.options[0] || "never";
-
-                if (!sourceCode.hasBOM && (requireBOM === "always")) {
-                    context.report({
-                        node,
-                        loc: location,
-                        message: "Expected Unicode BOM (Byte Order Mark).",
-                        fix(fixer) {
-                            return fixer.insertTextBeforeRange([0, 1], "\uFEFF");
-                        }
-                    });
-                } else if (sourceCode.hasBOM && (requireBOM === "never")) {
-                    context.report({
-                        node,
-                        loc: location,
-                        message: "Unexpected Unicode BOM (Byte Order Mark).",
-                        fix(fixer) {
-                            return fixer.removeRange([-1, 0]);
-                        }
-                    });
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/valid-jsdoc.js
===================================================================
--- node_modules/eslint/lib/rules/valid-jsdoc.js	(revision )
+++ node_modules/eslint/lib/rules/valid-jsdoc.js	(revision )
@@ -1,417 +0,0 @@
-/**
- * @fileoverview Validates JSDoc comments are syntactically correct
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const doctrine = require("doctrine");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce valid JSDoc comments",
-            category: "Possible Errors",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    prefer: {
-                        type: "object",
-                        additionalProperties: {
-                            type: "string"
-                        }
-                    },
-                    preferType: {
-                        type: "object",
-                        additionalProperties: {
-                            type: "string"
-                        }
-                    },
-                    requireReturn: {
-                        type: "boolean"
-                    },
-                    requireParamDescription: {
-                        type: "boolean"
-                    },
-                    requireReturnDescription: {
-                        type: "boolean"
-                    },
-                    matchDescription: {
-                        type: "string"
-                    },
-                    requireReturnType: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const options = context.options[0] || {},
-            prefer = options.prefer || {},
-            sourceCode = context.getSourceCode(),
-
-            // these both default to true, so you have to explicitly make them false
-            requireReturn = options.requireReturn !== false,
-            requireParamDescription = options.requireParamDescription !== false,
-            requireReturnDescription = options.requireReturnDescription !== false,
-            requireReturnType = options.requireReturnType !== false,
-            preferType = options.preferType || {},
-            checkPreferType = Object.keys(preferType).length !== 0;
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        // Using a stack to store if a function returns or not (handling nested functions)
-        const fns = [];
-
-        /**
-         * Check if node type is a Class
-         * @param {ASTNode} node node to check.
-         * @returns {boolean} True is its a class
-         * @private
-         */
-        function isTypeClass(node) {
-            return node.type === "ClassExpression" || node.type === "ClassDeclaration";
-        }
-
-        /**
-         * When parsing a new function, store it in our function stack.
-         * @param {ASTNode} node A function node to check.
-         * @returns {void}
-         * @private
-         */
-        function startFunction(node) {
-            fns.push({
-                returnPresent: (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") ||
-                    isTypeClass(node)
-            });
-        }
-
-        /**
-         * Indicate that return has been found in the current function.
-         * @param {ASTNode} node The return node.
-         * @returns {void}
-         * @private
-         */
-        function addReturn(node) {
-            const functionState = fns[fns.length - 1];
-
-            if (functionState && node.argument !== null) {
-                functionState.returnPresent = true;
-            }
-        }
-
-        /**
-         * Check if return tag type is void or undefined
-         * @param {Object} tag JSDoc tag
-         * @returns {boolean} True if its of type void or undefined
-         * @private
-         */
-        function isValidReturnType(tag) {
-            return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
-        }
-
-        /**
-         * Check if type should be validated based on some exceptions
-         * @param {Object} type JSDoc tag
-         * @returns {boolean} True if it can be validated
-         * @private
-         */
-        function canTypeBeValidated(type) {
-            return type !== "UndefinedLiteral" && // {undefined} as there is no name property available.
-                   type !== "NullLiteral" && // {null}
-                   type !== "NullableLiteral" && // {?}
-                   type !== "FunctionType" && // {function(a)}
-                   type !== "AllLiteral"; // {*}
-        }
-
-        /**
-         * Extract the current and expected type based on the input type object
-         * @param {Object} type JSDoc tag
-         * @returns {Object} current and expected type object
-         * @private
-         */
-        function getCurrentExpectedTypes(type) {
-            let currentType;
-
-            if (type.name) {
-                currentType = type.name;
-            } else if (type.expression) {
-                currentType = type.expression.name;
-            }
-
-            const expectedType = currentType && preferType[currentType];
-
-            return {
-                currentType,
-                expectedType
-            };
-        }
-
-        /**
-         * Validate type for a given JSDoc node
-         * @param {Object} jsdocNode JSDoc node
-         * @param {Object} type JSDoc tag
-         * @returns {void}
-         * @private
-         */
-        function validateType(jsdocNode, type) {
-            if (!type || !canTypeBeValidated(type.type)) {
-                return;
-            }
-
-            const typesToCheck = [];
-            let elements = [];
-
-            switch (type.type) {
-                case "TypeApplication": // {Array.<String>}
-                    elements = type.applications[0].type === "UnionType" ? type.applications[0].elements : type.applications;
-                    typesToCheck.push(getCurrentExpectedTypes(type));
-                    break;
-                case "RecordType": // {{20:String}}
-                    elements = type.fields;
-                    break;
-                case "UnionType": // {String|number|Test}
-                case "ArrayType": // {[String, number, Test]}
-                    elements = type.elements;
-                    break;
-                case "FieldType": // Array.<{count: number, votes: number}>
-                    if (type.value) {
-                        typesToCheck.push(getCurrentExpectedTypes(type.value));
-                    }
-                    break;
-                default:
-                    typesToCheck.push(getCurrentExpectedTypes(type));
-            }
-
-            elements.forEach(validateType.bind(null, jsdocNode));
-
-            typesToCheck.forEach(typeToCheck => {
-                if (typeToCheck.expectedType &&
-                    typeToCheck.expectedType !== typeToCheck.currentType) {
-                    context.report({
-                        node: jsdocNode,
-                        message: "Use '{{expectedType}}' instead of '{{currentType}}'.",
-                        data: {
-                            currentType: typeToCheck.currentType,
-                            expectedType: typeToCheck.expectedType
-                        }
-                    });
-                }
-            });
-        }
-
-        /**
-         * Validate the JSDoc node and output warnings if anything is wrong.
-         * @param {ASTNode} node The AST node to check.
-         * @returns {void}
-         * @private
-         */
-        function checkJSDoc(node) {
-            const jsdocNode = sourceCode.getJSDocComment(node),
-                functionData = fns.pop(),
-                params = Object.create(null);
-            let hasReturns = false,
-                hasConstructor = false,
-                isInterface = false,
-                isOverride = false,
-                isAbstract = false;
-
-            // make sure only to validate JSDoc comments
-            if (jsdocNode) {
-                let jsdoc;
-
-                try {
-                    jsdoc = doctrine.parse(jsdocNode.value, {
-                        strict: true,
-                        unwrap: true,
-                        sloppy: true
-                    });
-                } catch (ex) {
-
-                    if (/braces/i.test(ex.message)) {
-                        context.report({ node: jsdocNode, message: "JSDoc type missing brace." });
-                    } else {
-                        context.report({ node: jsdocNode, message: "JSDoc syntax error." });
-                    }
-
-                    return;
-                }
-
-                jsdoc.tags.forEach(tag => {
-
-                    switch (tag.title.toLowerCase()) {
-
-                        case "param":
-                        case "arg":
-                        case "argument":
-                            if (!tag.type) {
-                                context.report({ node: jsdocNode, message: "Missing JSDoc parameter type for '{{name}}'.", data: { name: tag.name } });
-                            }
-
-                            if (!tag.description && requireParamDescription) {
-                                context.report({ node: jsdocNode, message: "Missing JSDoc parameter description for '{{name}}'.", data: { name: tag.name } });
-                            }
-
-                            if (params[tag.name]) {
-                                context.report({ node: jsdocNode, message: "Duplicate JSDoc parameter '{{name}}'.", data: { name: tag.name } });
-                            } else if (tag.name.indexOf(".") === -1) {
-                                params[tag.name] = 1;
-                            }
-                            break;
-
-                        case "return":
-                        case "returns":
-                            hasReturns = true;
-
-                            if (!requireReturn && !functionData.returnPresent && (tag.type === null || !isValidReturnType(tag)) && !isAbstract) {
-                                context.report({
-                                    node: jsdocNode,
-                                    message: "Unexpected @{{title}} tag; function has no return statement.",
-                                    data: {
-                                        title: tag.title
-                                    }
-                                });
-                            } else {
-                                if (requireReturnType && !tag.type) {
-                                    context.report({ node: jsdocNode, message: "Missing JSDoc return type." });
-                                }
-
-                                if (!isValidReturnType(tag) && !tag.description && requireReturnDescription) {
-                                    context.report({ node: jsdocNode, message: "Missing JSDoc return description." });
-                                }
-                            }
-
-                            break;
-
-                        case "constructor":
-                        case "class":
-                            hasConstructor = true;
-                            break;
-
-                        case "override":
-                        case "inheritdoc":
-                            isOverride = true;
-                            break;
-
-                        case "abstract":
-                        case "virtual":
-                            isAbstract = true;
-                            break;
-
-                        case "interface":
-                            isInterface = true;
-                            break;
-
-                        // no default
-                    }
-
-                    // check tag preferences
-                    if (prefer.hasOwnProperty(tag.title) && tag.title !== prefer[tag.title]) {
-                        context.report({ node: jsdocNode, message: "Use @{{name}} instead.", data: { name: prefer[tag.title] } });
-                    }
-
-                    // validate the types
-                    if (checkPreferType && tag.type) {
-                        validateType(jsdocNode, tag.type);
-                    }
-                });
-
-                // check for functions missing @returns
-                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&
-                    node.parent.kind !== "get" && node.parent.kind !== "constructor" &&
-                    node.parent.kind !== "set" && !isTypeClass(node)) {
-                    if (requireReturn || functionData.returnPresent) {
-                        context.report({
-                            node: jsdocNode,
-                            message: "Missing JSDoc @{{returns}} for function.",
-                            data: {
-                                returns: prefer.returns || "returns"
-                            }
-                        });
-                    }
-                }
-
-                // check the parameters
-                const jsdocParams = Object.keys(params);
-
-                if (node.params) {
-                    node.params.forEach((param, i) => {
-                        if (param.type === "AssignmentPattern") {
-                            param = param.left;
-                        }
-
-                        const name = param.name;
-
-                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params
-                        if (param.type === "Identifier") {
-                            if (jsdocParams[i] && (name !== jsdocParams[i])) {
-                                context.report({
-                                    node: jsdocNode,
-                                    message: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",
-                                    data: {
-                                        name,
-                                        jsdocName: jsdocParams[i]
-                                    }
-                                });
-                            } else if (!params[name] && !isOverride) {
-                                context.report({
-                                    node: jsdocNode,
-                                    message: "Missing JSDoc for parameter '{{name}}'.",
-                                    data: {
-                                        name
-                                    }
-                                });
-                            }
-                        }
-                    });
-                }
-
-                if (options.matchDescription) {
-                    const regex = new RegExp(options.matchDescription);
-
-                    if (!regex.test(jsdoc.description)) {
-                        context.report({ node: jsdocNode, message: "JSDoc description does not satisfy the regex pattern." });
-                    }
-                }
-
-            }
-
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            ArrowFunctionExpression: startFunction,
-            FunctionExpression: startFunction,
-            FunctionDeclaration: startFunction,
-            ClassExpression: startFunction,
-            ClassDeclaration: startFunction,
-            "ArrowFunctionExpression:exit": checkJSDoc,
-            "FunctionExpression:exit": checkJSDoc,
-            "FunctionDeclaration:exit": checkJSDoc,
-            "ClassExpression:exit": checkJSDoc,
-            "ClassDeclaration:exit": checkJSDoc,
-            ReturnStatement: addReturn
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/vars-on-top.js
===================================================================
--- node_modules/eslint/lib/rules/vars-on-top.js	(revision )
+++ node_modules/eslint/lib/rules/vars-on-top.js	(revision )
@@ -1,149 +0,0 @@
-/**
- * @fileoverview Rule to enforce var declarations are only at the top of a function.
- * @author Danny Fritz
- * @author Gyandeep Singh
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require `var` declarations be placed at the top of their containing scope",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const errorMessage = "All 'var' declarations must be at the top of the function scope.";
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * @param {ASTNode} node - any node
-         * @returns {boolean} whether the given node structurally represents a directive
-         */
-        function looksLikeDirective(node) {
-            return node.type === "ExpressionStatement" &&
-                node.expression.type === "Literal" && typeof node.expression.value === "string";
-        }
-
-        /**
-         * Check to see if its a ES6 import declaration
-         * @param {ASTNode} node - any node
-         * @returns {boolean} whether the given node represents a import declaration
-         */
-        function looksLikeImport(node) {
-            return node.type === "ImportDeclaration" || node.type === "ImportSpecifier" ||
-                node.type === "ImportDefaultSpecifier" || node.type === "ImportNamespaceSpecifier";
-        }
-
-        /**
-         * Checks whether a given node is a variable declaration or not.
-         *
-         * @param {ASTNode} node - any node
-         * @returns {boolean} `true` if the node is a variable declaration.
-         */
-        function isVariableDeclaration(node) {
-            return (
-                node.type === "VariableDeclaration" ||
-                (
-                    node.type === "ExportNamedDeclaration" &&
-                    node.declaration &&
-                    node.declaration.type === "VariableDeclaration"
-                )
-            );
-        }
-
-        /**
-         * Checks whether this variable is on top of the block body
-         * @param {ASTNode} node - The node to check
-         * @param {ASTNode[]} statements - collection of ASTNodes for the parent node block
-         * @returns {boolean} True if var is on top otherwise false
-         */
-        function isVarOnTop(node, statements) {
-            const l = statements.length;
-            let i = 0;
-
-            // skip over directives
-            for (; i < l; ++i) {
-                if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {
-                    break;
-                }
-            }
-
-            for (; i < l; ++i) {
-                if (!isVariableDeclaration(statements[i])) {
-                    return false;
-                }
-                if (statements[i] === node) {
-                    return true;
-                }
-            }
-
-            return false;
-        }
-
-        /**
-         * Checks whether variable is on top at the global level
-         * @param {ASTNode} node - The node to check
-         * @param {ASTNode} parent - Parent of the node
-         * @returns {void}
-         */
-        function globalVarCheck(node, parent) {
-            if (!isVarOnTop(node, parent.body)) {
-                context.report({ node, message: errorMessage });
-            }
-        }
-
-        /**
-         * Checks whether variable is on top at functional block scope level
-         * @param {ASTNode} node - The node to check
-         * @param {ASTNode} parent - Parent of the node
-         * @param {ASTNode} grandParent - Parent of the node's parent
-         * @returns {void}
-         */
-        function blockScopeVarCheck(node, parent, grandParent) {
-            if (!(/Function/.test(grandParent.type) &&
-                    parent.type === "BlockStatement" &&
-                    isVarOnTop(node, parent.body))) {
-                context.report({ node, message: errorMessage });
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            VariableDeclaration(node) {
-                const ancestors = context.getAncestors();
-                let parent = ancestors.pop();
-                let grandParent = ancestors.pop();
-
-                if (node.kind === "var") { // check variable is `var` type and not `let` or `const`
-                    if (parent.type === "ExportNamedDeclaration") {
-                        node = parent;
-                        parent = grandParent;
-                        grandParent = ancestors.pop();
-                    }
-
-                    if (parent.type === "Program") { // That means its a global variable
-                        globalVarCheck(node, parent);
-                    } else {
-                        blockScopeVarCheck(node, parent, grandParent);
-                    }
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/arrow-parens.js
===================================================================
--- node_modules/eslint/lib/rules/arrow-parens.js	(revision )
+++ node_modules/eslint/lib/rules/arrow-parens.js	(revision )
@@ -1,154 +0,0 @@
-/**
- * @fileoverview Rule to require parens in arrow function arguments.
- * @author Jxck
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require parentheses around arrow function arguments",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        fixable: "code",
-
-        schema: [
-            {
-                enum: ["always", "as-needed"]
-            },
-            {
-                type: "object",
-                properties: {
-                    requireForBlockBody: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const message = "Expected parentheses around arrow function argument.";
-        const asNeededMessage = "Unexpected parentheses around single function argument.";
-        const asNeeded = context.options[0] === "as-needed";
-        const requireForBlockBodyMessage = "Unexpected parentheses around single function argument having a body with no curly braces";
-        const requireForBlockBodyNoParensMessage = "Expected parentheses around arrow function argument having a body with curly braces.";
-        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Determines whether a arrow function argument end with `)`
-         * @param {ASTNode} node The arrow function node.
-         * @returns {void}
-         */
-        function parens(node) {
-            const isAsync = node.async;
-            const firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0);
-
-            /**
-             * Remove the parenthesis around a parameter
-             * @param {Fixer} fixer Fixer
-             * @returns {string} fixed parameter
-             */
-            function fixParamsWithParenthesis(fixer) {
-                const paramToken = sourceCode.getTokenAfter(firstTokenOfParam);
-
-                // ES8 allows Trailing commas in function parameter lists and calls
-                // https://github.com/eslint/eslint/issues/8834
-                const closingParenToken = sourceCode.getTokenAfter(paramToken, astUtils.isClosingParenToken);
-                const asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;
-                const shouldAddSpaceForAsync = asyncToken && (asyncToken.range[1] === firstTokenOfParam.range[0]);
-
-                return fixer.replaceTextRange([
-                    firstTokenOfParam.range[0],
-                    closingParenToken.range[1]
-                ], `${shouldAddSpaceForAsync ? " " : ""}${paramToken.value}`);
-            }
-
-            // "as-needed", { "requireForBlockBody": true }: x => x
-            if (
-                requireForBlockBody &&
-                node.params.length === 1 &&
-                node.params[0].type === "Identifier" &&
-                !node.params[0].typeAnnotation &&
-                node.body.type !== "BlockStatement" &&
-                !node.returnType
-            ) {
-                if (astUtils.isOpeningParenToken(firstTokenOfParam)) {
-                    context.report({
-                        node,
-                        message: requireForBlockBodyMessage,
-                        fix: fixParamsWithParenthesis
-                    });
-                }
-                return;
-            }
-
-            if (
-                requireForBlockBody &&
-                node.body.type === "BlockStatement"
-            ) {
-                if (!astUtils.isOpeningParenToken(firstTokenOfParam)) {
-                    context.report({
-                        node,
-                        message: requireForBlockBodyNoParensMessage,
-                        fix(fixer) {
-                            return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);
-                        }
-                    });
-                }
-                return;
-            }
-
-            // "as-needed": x => x
-            if (asNeeded &&
-                node.params.length === 1 &&
-                node.params[0].type === "Identifier" &&
-                !node.params[0].typeAnnotation &&
-                !node.returnType
-            ) {
-                if (astUtils.isOpeningParenToken(firstTokenOfParam)) {
-                    context.report({
-                        node,
-                        message: asNeededMessage,
-                        fix: fixParamsWithParenthesis
-                    });
-                }
-                return;
-            }
-
-            if (firstTokenOfParam.type === "Identifier") {
-                const after = sourceCode.getTokenAfter(firstTokenOfParam);
-
-                // (x) => x
-                if (after.value !== ")") {
-                    context.report({
-                        node,
-                        message,
-                        fix(fixer) {
-                            return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);
-                        }
-                    });
-                }
-            }
-        }
-
-        return {
-            ArrowFunctionExpression: parens
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/comma-dangle.js
===================================================================
--- node_modules/eslint/lib/rules/comma-dangle.js	(revision )
+++ node_modules/eslint/lib/rules/comma-dangle.js	(revision )
@@ -1,337 +0,0 @@
-/**
- * @fileoverview Rule to forbid or enforce dangling commas.
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const DEFAULT_OPTIONS = Object.freeze({
-    arrays: "never",
-    objects: "never",
-    imports: "never",
-    exports: "never",
-    functions: "ignore"
-});
-
-/**
- * Checks whether or not a trailing comma is allowed in a given node.
- * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.
- *
- * @param {ASTNode} lastItem - The node of the last element in the given node.
- * @returns {boolean} `true` if a trailing comma is allowed.
- */
-function isTrailingCommaAllowed(lastItem) {
-    return !(
-        lastItem.type === "RestElement" ||
-        lastItem.type === "RestProperty" ||
-        lastItem.type === "ExperimentalRestProperty"
-    );
-}
-
-/**
- * Normalize option value.
- *
- * @param {string|Object|undefined} optionValue - The 1st option value to normalize.
- * @returns {Object} The normalized option value.
- */
-function normalizeOptions(optionValue) {
-    if (typeof optionValue === "string") {
-        return {
-            arrays: optionValue,
-            objects: optionValue,
-            imports: optionValue,
-            exports: optionValue,
-
-            // For backward compatibility, always ignore functions.
-            functions: "ignore"
-        };
-    }
-    if (typeof optionValue === "object" && optionValue !== null) {
-        return {
-            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,
-            objects: optionValue.objects || DEFAULT_OPTIONS.objects,
-            imports: optionValue.imports || DEFAULT_OPTIONS.imports,
-            exports: optionValue.exports || DEFAULT_OPTIONS.exports,
-            functions: optionValue.functions || DEFAULT_OPTIONS.functions
-        };
-    }
-
-    return DEFAULT_OPTIONS;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow trailing commas",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "code",
-        schema: {
-            definitions: {
-                value: {
-                    enum: [
-                        "always-multiline",
-                        "always",
-                        "never",
-                        "only-multiline"
-                    ]
-                },
-                valueWithIgnore: {
-                    enum: [
-                        "always-multiline",
-                        "always",
-                        "ignore",
-                        "never",
-                        "only-multiline"
-                    ]
-                }
-            },
-            type: "array",
-            items: [
-                {
-                    oneOf: [
-                        {
-                            $ref: "#/definitions/value"
-                        },
-                        {
-                            type: "object",
-                            properties: {
-                                arrays: { $ref: "#/definitions/valueWithIgnore" },
-                                objects: { $ref: "#/definitions/valueWithIgnore" },
-                                imports: { $ref: "#/definitions/valueWithIgnore" },
-                                exports: { $ref: "#/definitions/valueWithIgnore" },
-                                functions: { $ref: "#/definitions/valueWithIgnore" }
-                            },
-                            additionalProperties: false
-                        }
-                    ]
-                }
-            ]
-        }
-    },
-
-    create(context) {
-        const options = normalizeOptions(context.options[0]);
-        const sourceCode = context.getSourceCode();
-        const UNEXPECTED_MESSAGE = "Unexpected trailing comma.";
-        const MISSING_MESSAGE = "Missing trailing comma.";
-
-        /**
-         * Gets the last item of the given node.
-         * @param {ASTNode} node - The node to get.
-         * @returns {ASTNode|null} The last node or null.
-         */
-        function getLastItem(node) {
-            switch (node.type) {
-                case "ObjectExpression":
-                case "ObjectPattern":
-                    return lodash.last(node.properties);
-                case "ArrayExpression":
-                case "ArrayPattern":
-                    return lodash.last(node.elements);
-                case "ImportDeclaration":
-                case "ExportNamedDeclaration":
-                    return lodash.last(node.specifiers);
-                case "FunctionDeclaration":
-                case "FunctionExpression":
-                case "ArrowFunctionExpression":
-                    return lodash.last(node.params);
-                case "CallExpression":
-                case "NewExpression":
-                    return lodash.last(node.arguments);
-                default:
-                    return null;
-            }
-        }
-
-        /**
-         * Gets the trailing comma token of the given node.
-         * If the trailing comma does not exist, this returns the token which is
-         * the insertion point of the trailing comma token.
-         *
-         * @param {ASTNode} node - The node to get.
-         * @param {ASTNode} lastItem - The last item of the node.
-         * @returns {Token} The trailing comma token or the insertion point.
-         */
-        function getTrailingToken(node, lastItem) {
-            switch (node.type) {
-                case "ObjectExpression":
-                case "ArrayExpression":
-                case "CallExpression":
-                case "NewExpression":
-                    return sourceCode.getLastToken(node, 1);
-                default: {
-                    const nextToken = sourceCode.getTokenAfter(lastItem);
-
-                    if (astUtils.isCommaToken(nextToken)) {
-                        return nextToken;
-                    }
-                    return sourceCode.getLastToken(lastItem);
-                }
-            }
-        }
-
-        /**
-         * Checks whether or not a given node is multiline.
-         * This rule handles a given node as multiline when the closing parenthesis
-         * and the last element are not on the same line.
-         *
-         * @param {ASTNode} node - A node to check.
-         * @returns {boolean} `true` if the node is multiline.
-         */
-        function isMultiline(node) {
-            const lastItem = getLastItem(node);
-
-            if (!lastItem) {
-                return false;
-            }
-
-            const penultimateToken = getTrailingToken(node, lastItem);
-            const lastToken = sourceCode.getTokenAfter(penultimateToken);
-
-            return lastToken.loc.end.line !== penultimateToken.loc.end.line;
-        }
-
-        /**
-         * Reports a trailing comma if it exists.
-         *
-         * @param {ASTNode} node - A node to check. Its type is one of
-         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
-         *   ImportDeclaration, and ExportNamedDeclaration.
-         * @returns {void}
-         */
-        function forbidTrailingComma(node) {
-            const lastItem = getLastItem(node);
-
-            if (!lastItem || (node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier")) {
-                return;
-            }
-
-            const trailingToken = getTrailingToken(node, lastItem);
-
-            if (astUtils.isCommaToken(trailingToken)) {
-                context.report({
-                    node: lastItem,
-                    loc: trailingToken.loc.start,
-                    message: UNEXPECTED_MESSAGE,
-                    fix(fixer) {
-                        return fixer.remove(trailingToken);
-                    }
-                });
-            }
-        }
-
-        /**
-         * Reports the last element of a given node if it does not have a trailing
-         * comma.
-         *
-         * If a given node is `ArrayPattern` which has `RestElement`, the trailing
-         * comma is disallowed, so report if it exists.
-         *
-         * @param {ASTNode} node - A node to check. Its type is one of
-         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
-         *   ImportDeclaration, and ExportNamedDeclaration.
-         * @returns {void}
-         */
-        function forceTrailingComma(node) {
-            const lastItem = getLastItem(node);
-
-            if (!lastItem || (node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier")) {
-                return;
-            }
-            if (!isTrailingCommaAllowed(lastItem)) {
-                forbidTrailingComma(node);
-                return;
-            }
-
-            const trailingToken = getTrailingToken(node, lastItem);
-
-            if (trailingToken.value !== ",") {
-                context.report({
-                    node: lastItem,
-                    loc: trailingToken.loc.end,
-                    message: MISSING_MESSAGE,
-                    fix(fixer) {
-                        return fixer.insertTextAfter(trailingToken, ",");
-                    }
-                });
-            }
-        }
-
-        /**
-         * If a given node is multiline, reports the last element of a given node
-         * when it does not have a trailing comma.
-         * Otherwise, reports a trailing comma if it exists.
-         *
-         * @param {ASTNode} node - A node to check. Its type is one of
-         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
-         *   ImportDeclaration, and ExportNamedDeclaration.
-         * @returns {void}
-         */
-        function forceTrailingCommaIfMultiline(node) {
-            if (isMultiline(node)) {
-                forceTrailingComma(node);
-            } else {
-                forbidTrailingComma(node);
-            }
-        }
-
-        /**
-         * Only if a given node is not multiline, reports the last element of a given node
-         * when it does not have a trailing comma.
-         * Otherwise, reports a trailing comma if it exists.
-         *
-         * @param {ASTNode} node - A node to check. Its type is one of
-         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
-         *   ImportDeclaration, and ExportNamedDeclaration.
-         * @returns {void}
-         */
-        function allowTrailingCommaIfMultiline(node) {
-            if (!isMultiline(node)) {
-                forbidTrailingComma(node);
-            }
-        }
-
-        const predicate = {
-            always: forceTrailingComma,
-            "always-multiline": forceTrailingCommaIfMultiline,
-            "only-multiline": allowTrailingCommaIfMultiline,
-            never: forbidTrailingComma,
-            ignore: lodash.noop
-        };
-
-        return {
-            ObjectExpression: predicate[options.objects],
-            ObjectPattern: predicate[options.objects],
-
-            ArrayExpression: predicate[options.arrays],
-            ArrayPattern: predicate[options.arrays],
-
-            ImportDeclaration: predicate[options.imports],
-
-            ExportNamedDeclaration: predicate[options.exports],
-
-            FunctionDeclaration: predicate[options.functions],
-            FunctionExpression: predicate[options.functions],
-            ArrowFunctionExpression: predicate[options.functions],
-            CallExpression: predicate[options.functions],
-            NewExpression: predicate[options.functions]
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/default-case.js
===================================================================
--- node_modules/eslint/lib/rules/default-case.js	(revision )
+++ node_modules/eslint/lib/rules/default-case.js	(revision )
@@ -1,90 +0,0 @@
-/**
- * @fileoverview require default case in switch statements
- * @author Aliaksei Shytkin
- */
-"use strict";
-
-const DEFAULT_COMMENT_PATTERN = /^no default$/i;
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require `default` cases in `switch` statements",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [{
-            type: "object",
-            properties: {
-                commentPattern: {
-                    type: "string"
-                }
-            },
-            additionalProperties: false
-        }]
-    },
-
-    create(context) {
-        const options = context.options[0] || {};
-        const commentPattern = options.commentPattern
-            ? new RegExp(options.commentPattern)
-            : DEFAULT_COMMENT_PATTERN;
-
-        const sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Shortcut to get last element of array
-         * @param  {*[]} collection Array
-         * @returns {*} Last element
-         */
-        function last(collection) {
-            return collection[collection.length - 1];
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-
-            SwitchStatement(node) {
-
-                if (!node.cases.length) {
-
-                    /*
-                     * skip check of empty switch because there is no easy way
-                     * to extract comments inside it now
-                     */
-                    return;
-                }
-
-                const hasDefault = node.cases.some(v => v.test === null);
-
-                if (!hasDefault) {
-
-                    let comment;
-
-                    const lastCase = last(node.cases);
-                    const comments = sourceCode.getCommentsAfter(lastCase);
-
-                    if (comments.length) {
-                        comment = last(comments);
-                    }
-
-                    if (!comment || !commentPattern.test(comment.value.trim())) {
-                        context.report({ node, message: "Expected a default case." });
-                    }
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/dot-location.js
===================================================================
--- node_modules/eslint/lib/rules/dot-location.js	(revision )
+++ node_modules/eslint/lib/rules/dot-location.js	(revision )
@@ -1,88 +0,0 @@
-/**
- * @fileoverview Validates newlines before and after dots
- * @author Greg Cochard
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent newlines before and after dots",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["object", "property"]
-            }
-        ],
-
-        fixable: "code"
-    },
-
-    create(context) {
-
-        const config = context.options[0];
-
-        // default to onObject if no preference is passed
-        const onObject = config === "object" || !config;
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Reports if the dot between object and property is on the correct loccation.
-         * @param {ASTNode} obj The object owning the property.
-         * @param {ASTNode} prop The property of the object.
-         * @param {ASTNode} node The corresponding node of the token.
-         * @returns {void}
-         */
-        function checkDotLocation(obj, prop, node) {
-            const dot = sourceCode.getTokenBefore(prop);
-            const textBeforeDot = sourceCode.getText().slice(obj.range[1], dot.range[0]);
-            const textAfterDot = sourceCode.getText().slice(dot.range[1], prop.range[0]);
-
-            if (dot.type === "Punctuator" && dot.value === ".") {
-                if (onObject) {
-                    if (!astUtils.isTokenOnSameLine(obj, dot)) {
-                        const neededTextAfterObj = astUtils.isDecimalInteger(obj) ? " " : "";
-
-                        context.report({
-                            node,
-                            loc: dot.loc.start,
-                            message: "Expected dot to be on same line as object.",
-                            fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${neededTextAfterObj}.${textBeforeDot}${textAfterDot}`)
-                        });
-                    }
-                } else if (!astUtils.isTokenOnSameLine(dot, prop)) {
-                    context.report({
-                        node,
-                        loc: dot.loc.start,
-                        message: "Expected dot to be on same line as property.",
-                        fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${textBeforeDot}${textAfterDot}.`)
-                    });
-                }
-            }
-        }
-
-        /**
-         * Checks the spacing of the dot within a member expression.
-         * @param {ASTNode} node The node to check.
-         * @returns {void}
-         */
-        function checkNode(node) {
-            checkDotLocation(node.object, node.property, node);
-        }
-
-        return {
-            MemberExpression: checkNode
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/dot-notation.js
===================================================================
--- node_modules/eslint/lib/rules/dot-notation.js	(revision )
+++ node_modules/eslint/lib/rules/dot-notation.js	(revision )
@@ -1,138 +0,0 @@
-/**
- * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.
- * @author Josh Perez
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
-const keywords = require("../util/keywords");
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce dot notation whenever possible",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allowKeywords: {
-                        type: "boolean"
-                    },
-                    allowPattern: {
-                        type: "string"
-                    }
-                },
-                additionalProperties: false
-            }
-        ],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const options = context.options[0] || {};
-        const allowKeywords = options.allowKeywords === void 0 || !!options.allowKeywords;
-        const sourceCode = context.getSourceCode();
-
-        let allowPattern;
-
-        if (options.allowPattern) {
-            allowPattern = new RegExp(options.allowPattern);
-        }
-
-        return {
-            MemberExpression(node) {
-                if (
-                    node.computed &&
-                    node.property.type === "Literal" &&
-                    validIdentifier.test(node.property.value) &&
-                    (allowKeywords || keywords.indexOf(String(node.property.value)) === -1)
-                ) {
-                    if (!(allowPattern && allowPattern.test(node.property.value))) {
-                        context.report({
-                            node: node.property,
-                            message: "[{{propertyValue}}] is better written in dot notation.",
-                            data: {
-                                propertyValue: JSON.stringify(node.property.value)
-                            },
-                            fix(fixer) {
-                                const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);
-                                const rightBracket = sourceCode.getLastToken(node);
-
-                                if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, { includeComments: true, filter: astUtils.isCommentToken })) {
-
-                                    // Don't perform any fixes if there are comments inside the brackets.
-                                    return null;
-                                }
-
-                                const tokenAfterProperty = sourceCode.getTokenAfter(rightBracket);
-                                const needsSpaceAfterProperty = tokenAfterProperty &&
-                                    rightBracket.range[1] === tokenAfterProperty.range[0] &&
-                                    !astUtils.canTokensBeAdjacent(String(node.property.value), tokenAfterProperty);
-
-                                const textBeforeDot = astUtils.isDecimalInteger(node.object) ? " " : "";
-                                const textAfterProperty = needsSpaceAfterProperty ? " " : "";
-
-                                return fixer.replaceTextRange(
-                                    [leftBracket.range[0], rightBracket.range[1]],
-                                    `${textBeforeDot}.${node.property.value}${textAfterProperty}`
-                                );
-                            }
-                        });
-                    }
-                }
-                if (
-                    !allowKeywords &&
-                    !node.computed &&
-                    keywords.indexOf(String(node.property.name)) !== -1
-                ) {
-                    context.report({
-                        node: node.property,
-                        message: ".{{propertyName}} is a syntax error.",
-                        data: {
-                            propertyName: node.property.name
-                        },
-                        fix(fixer) {
-                            const dot = sourceCode.getTokenBefore(node.property);
-                            const textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);
-
-                            if (textAfterDot.trim()) {
-
-                                // Don't perform any fixes if there are comments between the dot and the property name.
-                                return null;
-                            }
-
-                            if (node.object.type === "Identifier" && node.object.name === "let") {
-
-                                /*
-                                 * A statement that starts with `let[` is parsed as a destructuring variable declaration, not
-                                 * a MemberExpression.
-                                 */
-                                return null;
-                            }
-
-                            return fixer.replaceTextRange(
-                                [dot.range[0], node.property.range[1]],
-                                `[${textAfterDot}"${node.property.name}"]`
-                            );
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/guard-for-in.js
===================================================================
--- node_modules/eslint/lib/rules/guard-for-in.js	(revision )
+++ node_modules/eslint/lib/rules/guard-for-in.js	(revision )
@@ -1,42 +0,0 @@
-/**
- * @fileoverview Rule to flag for-in loops without if statements inside
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require `for-in` loops to include an `if` statement",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            ForInStatement(node) {
-
-                /*
-                 * If the for-in statement has {}, then the real body is the body
-                 * of the BlockStatement. Otherwise, just use body as provided.
-                 */
-                const body = node.body.type === "BlockStatement" ? node.body.body[0] : node.body;
-
-                if (body && body.type !== "IfStatement") {
-                    context.report({ node, message: "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/id-blacklist.js
===================================================================
--- node_modules/eslint/lib/rules/id-blacklist.js	(revision )
+++ node_modules/eslint/lib/rules/id-blacklist.js	(revision )
@@ -1,121 +0,0 @@
-/**
- * @fileoverview Rule that warns when identifier names that are
- * blacklisted in the configuration are used.
- * @author Keith Cirkel (http://keithcirkel.co.uk)
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow specified identifiers",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: {
-            type: "array",
-            items: {
-                type: "string"
-            },
-            uniqueItems: true
-        }
-    },
-
-    create(context) {
-
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        const blacklist = context.options;
-
-
-        /**
-         * Checks if a string matches the provided pattern
-         * @param {string} name The string to check.
-         * @returns {boolean} if the string is a match
-         * @private
-         */
-        function isInvalid(name) {
-            return blacklist.indexOf(name) !== -1;
-        }
-
-        /**
-         * Verifies if we should report an error or not based on the effective
-         * parent node and the identifier name.
-         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported
-         * @param {string} name The identifier name of the identifier node
-         * @returns {boolean} whether an error should be reported or not
-         */
-        function shouldReport(effectiveParent, name) {
-            return effectiveParent.type !== "CallExpression" &&
-                effectiveParent.type !== "NewExpression" &&
-                isInvalid(name);
-        }
-
-        /**
-         * Reports an AST node as a rule violation.
-         * @param {ASTNode} node The node to report.
-         * @returns {void}
-         * @private
-         */
-        function report(node) {
-            context.report({
-                node,
-                message: "Identifier '{{name}}' is blacklisted.",
-                data: {
-                    name: node.name
-                }
-            });
-        }
-
-        return {
-
-            Identifier(node) {
-                const name = node.name,
-                    effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;
-
-                // MemberExpressions get special rules
-                if (node.parent.type === "MemberExpression") {
-
-                    // Always check object names
-                    if (node.parent.object.type === "Identifier" &&
-                        node.parent.object.name === node.name) {
-                        if (isInvalid(name)) {
-                            report(node);
-                        }
-
-                        // Report AssignmentExpressions only if they are the left side of the assignment
-                    } else if (effectiveParent.type === "AssignmentExpression" &&
-                        (effectiveParent.right.type !== "MemberExpression" ||
-                        effectiveParent.left.type === "MemberExpression" &&
-                        effectiveParent.left.property.name === node.name)) {
-                        if (isInvalid(name)) {
-                            report(node);
-                        }
-                    }
-
-                // Properties have their own rules
-                } else if (node.parent.type === "Property") {
-
-                    if (shouldReport(effectiveParent, name)) {
-                        report(node);
-                    }
-
-                // Report anything that is a match and not a CallExpression
-                } else if (shouldReport(effectiveParent, name)) {
-                    report(node);
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-div-regex.js
===================================================================
--- node_modules/eslint/lib/rules/no-div-regex.js	(revision )
+++ node_modules/eslint/lib/rules/no-div-regex.js	(revision )
@@ -1,38 +0,0 @@
-/**
- * @fileoverview Rule to check for ambiguous div operator in regexes
- * @author Matt DuVall <http://www.mattduvall.com>
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow division operators explicitly at the beginning of regular expressions",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-
-            Literal(node) {
-                const token = sourceCode.getFirstToken(node);
-
-                if (token.type === "RegularExpression" && token.value[1] === "=") {
-                    context.report({ node, message: "A regular expression literal can be confused with '/='." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-dupe-args.js
===================================================================
--- node_modules/eslint/lib/rules/no-dupe-args.js	(revision )
+++ node_modules/eslint/lib/rules/no-dupe-args.js	(revision )
@@ -1,73 +0,0 @@
-/**
- * @fileoverview Rule to flag duplicate arguments
- * @author Jamund Ferguson
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow duplicate arguments in `function` definitions",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Checks whether or not a given definition is a parameter's.
-         * @param {eslint-scope.DefEntry} def - A definition to check.
-         * @returns {boolean} `true` if the definition is a parameter's.
-         */
-        function isParameter(def) {
-            return def.type === "Parameter";
-        }
-
-        /**
-         * Determines if a given node has duplicate parameters.
-         * @param {ASTNode} node The node to check.
-         * @returns {void}
-         * @private
-         */
-        function checkParams(node) {
-            const variables = context.getDeclaredVariables(node);
-
-            for (let i = 0; i < variables.length; ++i) {
-                const variable = variables[i];
-
-                // Checks and reports duplications.
-                const defs = variable.defs.filter(isParameter);
-
-                if (defs.length >= 2) {
-                    context.report({
-                        node,
-                        message: "Duplicate param '{{name}}'.",
-                        data: { name: variable.name }
-                    });
-                }
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            FunctionDeclaration: checkParams,
-            FunctionExpression: checkParams
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-dupe-keys.js
===================================================================
--- node_modules/eslint/lib/rules/no-dupe-keys.js	(revision )
+++ node_modules/eslint/lib/rules/no-dupe-keys.js	(revision )
@@ -1,135 +0,0 @@
-/**
- * @fileoverview Rule to flag use of duplicate keys in an object.
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const GET_KIND = /^(?:init|get)$/;
-const SET_KIND = /^(?:init|set)$/;
-
-/**
- * The class which stores properties' information of an object.
- */
-class ObjectInfo {
-
-    /**
-     * @param {ObjectInfo|null} upper - The information of the outer object.
-     * @param {ASTNode} node - The ObjectExpression node of this information.
-     */
-    constructor(upper, node) {
-        this.upper = upper;
-        this.node = node;
-        this.properties = new Map();
-    }
-
-    /**
-     * Gets the information of the given Property node.
-     * @param {ASTNode} node - The Property node to get.
-     * @returns {{get: boolean, set: boolean}} The information of the property.
-     */
-    getPropertyInfo(node) {
-        const name = astUtils.getStaticPropertyName(node);
-
-        if (!this.properties.has(name)) {
-            this.properties.set(name, { get: false, set: false });
-        }
-        return this.properties.get(name);
-    }
-
-    /**
-     * Checks whether the given property has been defined already or not.
-     * @param {ASTNode} node - The Property node to check.
-     * @returns {boolean} `true` if the property has been defined.
-     */
-    isPropertyDefined(node) {
-        const entry = this.getPropertyInfo(node);
-
-        return (
-            (GET_KIND.test(node.kind) && entry.get) ||
-            (SET_KIND.test(node.kind) && entry.set)
-        );
-    }
-
-    /**
-     * Defines the given property.
-     * @param {ASTNode} node - The Property node to define.
-     * @returns {void}
-     */
-    defineProperty(node) {
-        const entry = this.getPropertyInfo(node);
-
-        if (GET_KIND.test(node.kind)) {
-            entry.get = true;
-        }
-        if (SET_KIND.test(node.kind)) {
-            entry.set = true;
-        }
-    }
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow duplicate keys in object literals",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        let info = null;
-
-        return {
-            ObjectExpression(node) {
-                info = new ObjectInfo(info, node);
-            },
-            "ObjectExpression:exit"() {
-                info = info.upper;
-            },
-
-            Property(node) {
-                const name = astUtils.getStaticPropertyName(node);
-
-                // Skip destructuring.
-                if (node.parent.type !== "ObjectExpression") {
-                    return;
-                }
-
-                // Skip if the name is not static.
-                if (!name) {
-                    return;
-                }
-
-                // Reports if the name is defined already.
-                if (info.isPropertyDefined(node)) {
-                    context.report({
-                        node: info.node,
-                        loc: node.key.loc,
-                        message: "Duplicate key '{{name}}'.",
-                        data: { name }
-                    });
-                }
-
-                // Update info.
-                info.defineProperty(node);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-ex-assign.js
===================================================================
--- node_modules/eslint/lib/rules/no-ex-assign.js	(revision )
+++ node_modules/eslint/lib/rules/no-ex-assign.js	(revision )
@@ -1,45 +0,0 @@
-/**
- * @fileoverview Rule to flag assignment of the exception parameter
- * @author Stephen Murray <spmurrayzzz>
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow reassigning exceptions in `catch` clauses",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Finds and reports references that are non initializer and writable.
-         * @param {Variable} variable - A variable to check.
-         * @returns {void}
-         */
-        function checkVariable(variable) {
-            astUtils.getModifyingReferences(variable.references).forEach(reference => {
-                context.report({ node: reference.identifier, message: "Do not assign to the exception parameter." });
-            });
-        }
-
-        return {
-            CatchClause(node) {
-                context.getDeclaredVariables(node).forEach(checkVariable);
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-label-var.js
===================================================================
--- node_modules/eslint/lib/rules/no-label-var.js	(revision )
+++ node_modules/eslint/lib/rules/no-label-var.js	(revision )
@@ -1,67 +0,0 @@
-/**
- * @fileoverview Rule to flag labels that are the same as an identifier
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow labels that share a name with a variable",
-            category: "Variables",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Check if the identifier is present inside current scope
-         * @param {Object} scope current scope
-         * @param {string} name To evaluate
-         * @returns {boolean} True if its present
-         * @private
-         */
-        function findIdentifier(scope, name) {
-            return astUtils.getVariableByName(scope, name) !== null;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-
-            LabeledStatement(node) {
-
-                // Fetch the innermost scope.
-                const scope = context.getScope();
-
-                // Recursively find the identifier walking up the scope, starting
-                // with the innermost scope.
-                if (findIdentifier(scope, node.label.name)) {
-                    context.report({ node, message: "Found identifier with same name as label." });
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-lonely-if.js
===================================================================
--- node_modules/eslint/lib/rules/no-lonely-if.js	(revision )
+++ node_modules/eslint/lib/rules/no-lonely-if.js	(revision )
@@ -1,82 +0,0 @@
-/**
- * @fileoverview Rule to disallow if as the only statmenet in an else block
- * @author Brandon Mills
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `if` statements as the only statement in `else` blocks",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-            IfStatement(node) {
-                const ancestors = context.getAncestors(),
-                    parent = ancestors.pop(),
-                    grandparent = ancestors.pop();
-
-                if (parent && parent.type === "BlockStatement" &&
-                        parent.body.length === 1 && grandparent &&
-                        grandparent.type === "IfStatement" &&
-                        parent === grandparent.alternate) {
-                    context.report({
-                        node,
-                        message: "Unexpected if as the only statement in an else block.",
-                        fix(fixer) {
-                            const openingElseCurly = sourceCode.getFirstToken(parent);
-                            const closingElseCurly = sourceCode.getLastToken(parent);
-                            const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);
-                            const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);
-                            const lastIfToken = sourceCode.getLastToken(node.consequent);
-                            const sourceText = sourceCode.getText();
-
-                            if (sourceText.slice(openingElseCurly.range[1], node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {
-
-                                // Don't fix if there are any non-whitespace characters interfering (e.g. comments)
-                                return null;
-                            }
-
-                            if (
-                                node.consequent.type !== "BlockStatement" && lastIfToken.value !== ";" && tokenAfterElseBlock &&
-                                (
-                                    node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line ||
-                                    /^[([/+`-]/.test(tokenAfterElseBlock.value) ||
-                                    lastIfToken.value === "++" ||
-                                    lastIfToken.value === "--"
-                                )
-                            ) {
-
-                                /*
-                                 * If the `if` statement has no block, and is not followed by a semicolon, make sure that fixing
-                                 * the issue would not change semantics due to ASI. If this would happen, don't do a fix.
-                                 */
-                                return null;
-                            }
-
-                            return fixer.replaceTextRange(
-                                [openingElseCurly.range[0], closingElseCurly.range[1]],
-                                (elseKeyword.range[1] === openingElseCurly.range[0] ? " " : "") + sourceCode.getText(node)
-                            );
-                        }
-                    });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-loop-func.js
===================================================================
--- node_modules/eslint/lib/rules/no-loop-func.js	(revision )
+++ node_modules/eslint/lib/rules/no-loop-func.js	(revision )
@@ -1,198 +0,0 @@
-/**
- * @fileoverview Rule to flag creation of function inside a loop
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Gets the containing loop node of a specified node.
- *
- * We don't need to check nested functions, so this ignores those.
- * `Scope.through` contains references of nested functions.
- *
- * @param {ASTNode} node - An AST node to get.
- * @returns {ASTNode|null} The containing loop node of the specified node, or
- *      `null`.
- */
-function getContainingLoopNode(node) {
-    let parent = node.parent;
-
-    while (parent) {
-        switch (parent.type) {
-            case "WhileStatement":
-            case "DoWhileStatement":
-                return parent;
-
-            case "ForStatement":
-
-                // `init` is outside of the loop.
-                if (parent.init !== node) {
-                    return parent;
-                }
-                break;
-
-            case "ForInStatement":
-            case "ForOfStatement":
-
-                // `right` is outside of the loop.
-                if (parent.right !== node) {
-                    return parent;
-                }
-                break;
-
-            case "ArrowFunctionExpression":
-            case "FunctionExpression":
-            case "FunctionDeclaration":
-
-                // We don't need to check nested functions.
-                return null;
-
-            default:
-                break;
-        }
-
-        node = parent;
-        parent = node.parent;
-    }
-
-    return null;
-}
-
-/**
- * Gets the containing loop node of a given node.
- * If the loop was nested, this returns the most outer loop.
- *
- * @param {ASTNode} node - A node to get. This is a loop node.
- * @param {ASTNode|null} excludedNode - A node that the result node should not
- *      include.
- * @returns {ASTNode} The most outer loop node.
- */
-function getTopLoopNode(node, excludedNode) {
-    let retv = node;
-    const border = excludedNode ? excludedNode.range[1] : 0;
-
-    while (node && node.range[0] >= border) {
-        retv = node;
-        node = getContainingLoopNode(node);
-    }
-
-    return retv;
-}
-
-/**
- * Checks whether a given reference which refers to an upper scope's variable is
- * safe or not.
- *
- * @param {ASTNode} funcNode - A target function node.
- * @param {ASTNode} loopNode - A containing loop node.
- * @param {eslint-scope.Reference} reference - A reference to check.
- * @returns {boolean} `true` if the reference is safe or not.
- */
-function isSafe(funcNode, loopNode, reference) {
-    const variable = reference.resolved;
-    const definition = variable && variable.defs[0];
-    const declaration = definition && definition.parent;
-    const kind = (declaration && declaration.type === "VariableDeclaration")
-        ? declaration.kind
-        : "";
-
-    // Variables which are declared by `const` is safe.
-    if (kind === "const") {
-        return true;
-    }
-
-    // Variables which are declared by `let` in the loop is safe.
-    // It's a different instance from the next loop step's.
-    if (kind === "let" &&
-        declaration.range[0] > loopNode.range[0] &&
-        declaration.range[1] < loopNode.range[1]
-    ) {
-        return true;
-    }
-
-    // WriteReferences which exist after this border are unsafe because those
-    // can modify the variable.
-    const border = getTopLoopNode(
-        loopNode,
-        (kind === "let") ? declaration : null
-    ).range[0];
-
-    /**
-     * Checks whether a given reference is safe or not.
-     * The reference is every reference of the upper scope's variable we are
-     * looking now.
-     *
-     * It's safeafe if the reference matches one of the following condition.
-     * - is readonly.
-     * - doesn't exist inside a local function and after the border.
-     *
-     * @param {eslint-scope.Reference} upperRef - A reference to check.
-     * @returns {boolean} `true` if the reference is safe.
-     */
-    function isSafeReference(upperRef) {
-        const id = upperRef.identifier;
-
-        return (
-            !upperRef.isWrite() ||
-            variable.scope.variableScope === upperRef.from.variableScope &&
-            id.range[0] < border
-        );
-    }
-
-    return Boolean(variable) && variable.references.every(isSafeReference);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `function` declarations and expressions inside loop statements",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Reports functions which match the following condition:
-         *
-         * - has a loop node in ancestors.
-         * - has any references which refers to an unsafe variable.
-         *
-         * @param {ASTNode} node The AST node to check.
-         * @returns {boolean} Whether or not the node is within a loop.
-         */
-        function checkForLoops(node) {
-            const loopNode = getContainingLoopNode(node);
-
-            if (!loopNode) {
-                return;
-            }
-
-            const references = context.getScope().through;
-
-            if (references.length > 0 &&
-                !references.every(isSafe.bind(null, node, loopNode))
-            ) {
-                context.report({ node, message: "Don't make functions within a loop." });
-            }
-        }
-
-        return {
-            ArrowFunctionExpression: checkForLoops,
-            FunctionExpression: checkForLoops,
-            FunctionDeclaration: checkForLoops
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-multi-str.js
===================================================================
--- node_modules/eslint/lib/rules/no-multi-str.js	(revision )
+++ node_modules/eslint/lib/rules/no-multi-str.js	(revision )
@@ -1,55 +0,0 @@
-/**
- * @fileoverview Rule to flag when using multiline strings
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow multiline strings",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Determines if a given node is part of JSX syntax.
-         * @param {ASTNode} node The node to check.
-         * @returns {boolean} True if the node is a JSX node, false if not.
-         * @private
-         */
-        function isJSXElement(node) {
-            return node.type.indexOf("JSX") === 0;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-
-            Literal(node) {
-                if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {
-                    context.report({ node, message: "Multiline support is limited to browsers supporting ES5 only." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-obj-calls.js
===================================================================
--- node_modules/eslint/lib/rules/no-obj-calls.js	(revision )
+++ node_modules/eslint/lib/rules/no-obj-calls.js	(revision )
@@ -1,39 +0,0 @@
-/**
- * @fileoverview Rule to flag use of an object property of the global object (Math and JSON) as a function
- * @author James Allardice
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow calling global object properties as functions",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-            CallExpression(node) {
-
-                if (node.callee.type === "Identifier") {
-                    const name = node.callee.name;
-
-                    if (name === "Math" || name === "JSON" || name === "Reflect") {
-                        context.report({ node, message: "'{{name}}' is not a function.", data: { name } });
-                    }
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-redeclare.js
===================================================================
--- node_modules/eslint/lib/rules/no-redeclare.js	(revision )
+++ node_modules/eslint/lib/rules/no-redeclare.js	(revision )
@@ -1,101 +0,0 @@
-/**
- * @fileoverview Rule to flag when the same variable is declared more then once.
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow variable redeclaration",
-            category: "Best Practices",
-            recommended: true
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    builtinGlobals: { type: "boolean" }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = {
-            builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals)
-        };
-
-        /**
-         * Find variables in a given scope and flag redeclared ones.
-         * @param {Scope} scope - An eslint-scope scope object.
-         * @returns {void}
-         * @private
-         */
-        function findVariablesInScope(scope) {
-            scope.variables.forEach(variable => {
-                const hasBuiltin = options.builtinGlobals && "writeable" in variable;
-                const count = (hasBuiltin ? 1 : 0) + variable.identifiers.length;
-
-                if (count >= 2) {
-                    variable.identifiers.sort((a, b) => a.range[1] - b.range[1]);
-
-                    for (let i = (hasBuiltin ? 0 : 1), l = variable.identifiers.length; i < l; i++) {
-                        context.report({ node: variable.identifiers[i], message: "'{{a}}' is already defined.", data: { a: variable.name } });
-                    }
-                }
-            });
-
-        }
-
-        /**
-         * Find variables in the current scope.
-         * @param {ASTNode} node - The Program node.
-         * @returns {void}
-         * @private
-         */
-        function checkForGlobal(node) {
-            const scope = context.getScope(),
-                parserOptions = context.parserOptions,
-                ecmaFeatures = parserOptions.ecmaFeatures || {};
-
-            // Nodejs env or modules has a special scope.
-            if (ecmaFeatures.globalReturn || node.sourceType === "module") {
-                findVariablesInScope(scope.childScopes[0]);
-            } else {
-                findVariablesInScope(scope);
-            }
-        }
-
-        /**
-         * Find variables in the current scope.
-         * @returns {void}
-         * @private
-         */
-        function checkForBlock() {
-            findVariablesInScope(context.getScope());
-        }
-
-        if (context.parserOptions.ecmaVersion >= 6) {
-            return {
-                Program: checkForGlobal,
-                BlockStatement: checkForBlock,
-                SwitchStatement: checkForBlock
-            };
-        }
-        return {
-            Program: checkForGlobal,
-            FunctionDeclaration: checkForBlock,
-            FunctionExpression: checkForBlock,
-            ArrowFunctionExpression: checkForBlock
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-sequences.js
===================================================================
--- node_modules/eslint/lib/rules/no-sequences.js	(revision )
+++ node_modules/eslint/lib/rules/no-sequences.js	(revision )
@@ -1,110 +0,0 @@
-/**
- * @fileoverview Rule to flag use of comma operator
- * @author Brandon Mills
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow comma operators",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Parts of the grammar that are required to have parens.
-         */
-        const parenthesized = {
-            DoWhileStatement: "test",
-            IfStatement: "test",
-            SwitchStatement: "discriminant",
-            WhileStatement: "test",
-            WithStatement: "object",
-            ArrowFunctionExpression: "body"
-
-            // Omitting CallExpression - commas are parsed as argument separators
-            // Omitting NewExpression - commas are parsed as argument separators
-            // Omitting ForInStatement - parts aren't individually parenthesised
-            // Omitting ForStatement - parts aren't individually parenthesised
-        };
-
-        /**
-         * Determines whether a node is required by the grammar to be wrapped in
-         * parens, e.g. the test of an if statement.
-         * @param {ASTNode} node - The AST node
-         * @returns {boolean} True if parens around node belong to parent node.
-         */
-        function requiresExtraParens(node) {
-            return node.parent && parenthesized[node.parent.type] &&
-                    node === node.parent[parenthesized[node.parent.type]];
-        }
-
-        /**
-         * Check if a node is wrapped in parens.
-         * @param {ASTNode} node - The AST node
-         * @returns {boolean} True if the node has a paren on each side.
-         */
-        function isParenthesised(node) {
-            return astUtils.isParenthesised(sourceCode, node);
-        }
-
-        /**
-         * Check if a node is wrapped in two levels of parens.
-         * @param {ASTNode} node - The AST node
-         * @returns {boolean} True if two parens surround the node on each side.
-         */
-        function isParenthesisedTwice(node) {
-            const previousToken = sourceCode.getTokenBefore(node, 1),
-                nextToken = sourceCode.getTokenAfter(node, 1);
-
-            return isParenthesised(node) && previousToken && nextToken &&
-                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&
-                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
-        }
-
-        return {
-            SequenceExpression(node) {
-
-                // Always allow sequences in for statement update
-                if (node.parent.type === "ForStatement" &&
-                        (node === node.parent.init || node === node.parent.update)) {
-                    return;
-                }
-
-                // Wrapping a sequence in extra parens indicates intent
-                if (requiresExtraParens(node)) {
-                    if (isParenthesisedTwice(node)) {
-                        return;
-                    }
-                } else {
-                    if (isParenthesised(node)) {
-                        return;
-                    }
-                }
-
-                const child = sourceCode.getTokenAfter(node.expressions[0]);
-
-                context.report({ node, loc: child.loc.start, message: "Unexpected use of comma operator." });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-undefined.js
===================================================================
--- node_modules/eslint/lib/rules/no-undefined.js	(revision )
+++ node_modules/eslint/lib/rules/no-undefined.js	(revision )
@@ -1,77 +0,0 @@
-/**
- * @fileoverview Rule to flag references to the undefined variable.
- * @author Michael Ficarra
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of `undefined` as an identifier",
-            category: "Variables",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Report an invalid "undefined" identifier node.
-         * @param {ASTNode} node The node to report.
-         * @returns {void}
-         */
-        function report(node) {
-            context.report({
-                node,
-                message: "Unexpected use of undefined."
-            });
-        }
-
-        /**
-         * Checks the given scope for references to `undefined` and reports
-         * all references found.
-         * @param {eslint-scope.Scope} scope The scope to check.
-         * @returns {void}
-         */
-        function checkScope(scope) {
-            const undefinedVar = scope.set.get("undefined");
-
-            if (!undefinedVar) {
-                return;
-            }
-
-            const references = undefinedVar.references;
-
-            const defs = undefinedVar.defs;
-
-            // Report non-initializing references (those are covered in defs below)
-            references
-                .filter(ref => !ref.init)
-                .forEach(ref => report(ref.identifier));
-
-            defs.forEach(def => report(def.name));
-        }
-
-        return {
-            "Program:exit"() {
-                const globalScope = context.getScope();
-
-                const stack = [globalScope];
-
-                while (stack.length) {
-                    const scope = stack.pop();
-
-                    stack.push.apply(stack, scope.childScopes);
-                    checkScope(scope);
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/prefer-const.js
===================================================================
--- node_modules/eslint/lib/rules/prefer-const.js	(revision )
+++ node_modules/eslint/lib/rules/prefer-const.js	(revision )
@@ -1,313 +0,0 @@
-/**
- * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/;
-const DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/;
-const DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/;
-
-/**
- * Adds multiple items to the tail of an array.
- *
- * @param {any[]} array - A destination to add.
- * @param {any[]} values - Items to be added.
- * @returns {void}
- */
-const pushAll = Function.apply.bind(Array.prototype.push);
-
-/**
- * Checks whether a given node is located at `ForStatement.init` or not.
- *
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} `true` if the node is located at `ForStatement.init`.
- */
-function isInitOfForStatement(node) {
-    return node.parent.type === "ForStatement" && node.parent.init === node;
-}
-
-/**
- * Checks whether a given Identifier node becomes a VariableDeclaration or not.
- *
- * @param {ASTNode} identifier - An Identifier node to check.
- * @returns {boolean} `true` if the node can become a VariableDeclaration.
- */
-function canBecomeVariableDeclaration(identifier) {
-    let node = identifier.parent;
-
-    while (PATTERN_TYPE.test(node.type)) {
-        node = node.parent;
-    }
-
-    return (
-        node.type === "VariableDeclarator" ||
-        (
-            node.type === "AssignmentExpression" &&
-            node.parent.type === "ExpressionStatement" &&
-            DECLARATION_HOST_TYPE.test(node.parent.parent.type)
-        )
-    );
-}
-
-/**
- * Gets an identifier node of a given variable.
- *
- * If the initialization exists or one or more reading references exist before
- * the first assignment, the identifier node is the node of the declaration.
- * Otherwise, the identifier node is the node of the first assignment.
- *
- * If the variable should not change to const, this function returns null.
- * - If the variable is reassigned.
- * - If the variable is never initialized nor assigned.
- * - If the variable is initialized in a different scope from the declaration.
- * - If the unique assignment of the variable cannot change to a declaration.
- *   e.g. `if (a) b = 1` / `return (b = 1)`
- * - If the variable is declared in the global scope and `eslintUsed` is `true`.
- *   `/*exported foo` directive comment makes such variables. This rule does not
- *   warn such variables because this rule cannot distinguish whether the
- *   exported variables are reassigned or not.
- *
- * @param {eslint-scope.Variable} variable - A variable to get.
- * @param {boolean} ignoreReadBeforeAssign -
- *      The value of `ignoreReadBeforeAssign` option.
- * @returns {ASTNode|null}
- *      An Identifier node if the variable should change to const.
- *      Otherwise, null.
- */
-function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {
-    if (variable.eslintUsed && variable.scope.type === "global") {
-        return null;
-    }
-
-    // Finds the unique WriteReference.
-    let writer = null;
-    let isReadBeforeInit = false;
-    const references = variable.references;
-
-    for (let i = 0; i < references.length; ++i) {
-        const reference = references[i];
-
-        if (reference.isWrite()) {
-            const isReassigned = (
-                writer !== null &&
-                writer.identifier !== reference.identifier
-            );
-
-            if (isReassigned) {
-                return null;
-            }
-            writer = reference;
-
-        } else if (reference.isRead() && writer === null) {
-            if (ignoreReadBeforeAssign) {
-                return null;
-            }
-            isReadBeforeInit = true;
-        }
-    }
-
-    // If the assignment is from a different scope, ignore it.
-    // If the assignment cannot change to a declaration, ignore it.
-    const shouldBeConst = (
-        writer !== null &&
-        writer.from === variable.scope &&
-        canBecomeVariableDeclaration(writer.identifier)
-    );
-
-    if (!shouldBeConst) {
-        return null;
-    }
-    if (isReadBeforeInit) {
-        return variable.defs[0].name;
-    }
-    return writer.identifier;
-}
-
-/**
- * Gets the VariableDeclarator/AssignmentExpression node that a given reference
- * belongs to.
- * This is used to detect a mix of reassigned and never reassigned in a
- * destructuring.
- *
- * @param {eslint-scope.Reference} reference - A reference to get.
- * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or
- *      null.
- */
-function getDestructuringHost(reference) {
-    if (!reference.isWrite()) {
-        return null;
-    }
-    let node = reference.identifier.parent;
-
-    while (PATTERN_TYPE.test(node.type)) {
-        node = node.parent;
-    }
-
-    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {
-        return null;
-    }
-    return node;
-}
-
-/**
- * Groups by the VariableDeclarator/AssignmentExpression node that each
- * reference of given variables belongs to.
- * This is used to detect a mix of reassigned and never reassigned in a
- * destructuring.
- *
- * @param {eslint-scope.Variable[]} variables - Variables to group by destructuring.
- * @param {boolean} ignoreReadBeforeAssign -
- *      The value of `ignoreReadBeforeAssign` option.
- * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.
- */
-function groupByDestructuring(variables, ignoreReadBeforeAssign) {
-    const identifierMap = new Map();
-
-    for (let i = 0; i < variables.length; ++i) {
-        const variable = variables[i];
-        const references = variable.references;
-        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);
-        let prevId = null;
-
-        for (let j = 0; j < references.length; ++j) {
-            const reference = references[j];
-            const id = reference.identifier;
-
-            // Avoid counting a reference twice or more for default values of
-            // destructuring.
-            if (id === prevId) {
-                continue;
-            }
-            prevId = id;
-
-            // Add the identifier node into the destructuring group.
-            const group = getDestructuringHost(reference);
-
-            if (group) {
-                if (identifierMap.has(group)) {
-                    identifierMap.get(group).push(identifier);
-                } else {
-                    identifierMap.set(group, [identifier]);
-                }
-            }
-        }
-    }
-
-    return identifierMap;
-}
-
-/**
- * Finds the nearest parent of node with a given type.
- *
- * @param {ASTNode} node – The node to search from.
- * @param {string} type – The type field of the parent node.
- * @param {Function} shouldStop – a predicate that returns true if the traversal should stop, and false otherwise.
- * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.
- */
-function findUp(node, type, shouldStop) {
-    if (!node || shouldStop(node)) {
-        return null;
-    }
-    if (node.type === type) {
-        return node;
-    }
-    return findUp(node.parent, type, shouldStop);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require `const` declarations for variables that are never reassigned after declared",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        fixable: "code",
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    destructuring: { enum: ["any", "all"] },
-                    ignoreReadBeforeAssign: { type: "boolean" }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0] || {};
-        const sourceCode = context.getSourceCode();
-        const checkingMixedDestructuring = options.destructuring !== "all";
-        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;
-        const variables = [];
-
-        /**
-         * Reports given identifier nodes if all of the nodes should be declared
-         * as const.
-         *
-         * The argument 'nodes' is an array of Identifier nodes.
-         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's
-         * nullable. In simple declaration or assignment cases, the length of
-         * the array is 1. In destructuring cases, the length of the array can
-         * be 2 or more.
-         *
-         * @param {(eslint-scope.Reference|null)[]} nodes -
-         *      References which are grouped by destructuring to report.
-         * @returns {void}
-         */
-        function checkGroup(nodes) {
-            const nodesToReport = nodes.filter(Boolean);
-
-            if (nodes.length && (checkingMixedDestructuring || nodesToReport.length === nodes.length)) {
-                const varDeclParent = findUp(nodes[0], "VariableDeclaration", parentNode => parentNode.type.endsWith("Statement"));
-                const shouldFix = varDeclParent &&
-
-                    // If there are multiple variable declarations, like {let a = 1, b = 2}, then
-                    // do not attempt to fix if one of the declarations should be `const`. It's
-                    // too hard to know how the developer would want to automatically resolve the issue.
-                    varDeclParent.declarations.length === 1 &&
-
-                    // Don't do a fix unless the variable is initialized (or it's in a for-in or for-of loop)
-                    (varDeclParent.parent.type === "ForInStatement" || varDeclParent.parent.type === "ForOfStatement" || varDeclParent.declarations[0].init) &&
-
-                    // If options.destucturing is "all", then this warning will not occur unless
-                    // every assignment in the destructuring should be const. In that case, it's safe
-                    // to apply the fix.
-                    nodesToReport.length === nodes.length;
-
-                nodesToReport.forEach(node => {
-                    context.report({
-                        node,
-                        message: "'{{name}}' is never reassigned. Use 'const' instead.",
-                        data: node,
-                        fix: shouldFix ? fixer => fixer.replaceText(sourceCode.getFirstToken(varDeclParent), "const") : null
-                    });
-                });
-            }
-        }
-
-        return {
-            "Program:exit"() {
-                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);
-            },
-
-            VariableDeclaration(node) {
-                if (node.kind === "let" && !isInitOfForStatement(node)) {
-                    pushAll(variables, context.getDeclaredVariables(node));
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/semi-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/semi-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/semi-spacing.js	(revision )
@@ -1,211 +0,0 @@
-/**
- * @fileoverview Validates spacing before and after semicolon
- * @author Mathias Schreck
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing before and after semicolons",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    before: {
-                        type: "boolean"
-                    },
-                    after: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const config = context.options[0],
-            sourceCode = context.getSourceCode();
-        let requireSpaceBefore = false,
-            requireSpaceAfter = true;
-
-        if (typeof config === "object") {
-            if (config.hasOwnProperty("before")) {
-                requireSpaceBefore = config.before;
-            }
-            if (config.hasOwnProperty("after")) {
-                requireSpaceAfter = config.after;
-            }
-        }
-
-        /**
-         * Checks if a given token has leading whitespace.
-         * @param {Object} token The token to check.
-         * @returns {boolean} True if the given token has leading space, false if not.
-         */
-        function hasLeadingSpace(token) {
-            const tokenBefore = sourceCode.getTokenBefore(token);
-
-            return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
-        }
-
-        /**
-         * Checks if a given token has trailing whitespace.
-         * @param {Object} token The token to check.
-         * @returns {boolean} True if the given token has trailing space, false if not.
-         */
-        function hasTrailingSpace(token) {
-            const tokenAfter = sourceCode.getTokenAfter(token);
-
-            return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
-        }
-
-        /**
-         * Checks if the given token is the last token in its line.
-         * @param {Token} token The token to check.
-         * @returns {boolean} Whether or not the token is the last in its line.
-         */
-        function isLastTokenInCurrentLine(token) {
-            const tokenAfter = sourceCode.getTokenAfter(token);
-
-            return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
-        }
-
-        /**
-         * Checks if the given token is the first token in its line
-         * @param {Token} token The token to check.
-         * @returns {boolean} Whether or not the token is the first in its line.
-         */
-        function isFirstTokenInCurrentLine(token) {
-            const tokenBefore = sourceCode.getTokenBefore(token);
-
-            return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
-        }
-
-        /**
-         * Checks if the next token of a given token is a closing parenthesis.
-         * @param {Token} token The token to check.
-         * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.
-         */
-        function isBeforeClosingParen(token) {
-            const nextToken = sourceCode.getTokenAfter(token);
-
-            return (nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken));
-        }
-
-        /**
-         * Reports if the given token has invalid spacing.
-         * @param {Token} token The semicolon token to check.
-         * @param {ASTNode} node The corresponding node of the token.
-         * @returns {void}
-         */
-        function checkSemicolonSpacing(token, node) {
-            if (astUtils.isSemicolonToken(token)) {
-                const location = token.loc.start;
-
-                if (hasLeadingSpace(token)) {
-                    if (!requireSpaceBefore) {
-                        context.report({
-                            node,
-                            loc: location,
-                            message: "Unexpected whitespace before semicolon.",
-                            fix(fixer) {
-                                const tokenBefore = sourceCode.getTokenBefore(token);
-
-                                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
-                            }
-                        });
-                    }
-                } else {
-                    if (requireSpaceBefore) {
-                        context.report({
-                            node,
-                            loc: location,
-                            message: "Missing whitespace before semicolon.",
-                            fix(fixer) {
-                                return fixer.insertTextBefore(token, " ");
-                            }
-                        });
-                    }
-                }
-
-                if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
-                    if (hasTrailingSpace(token)) {
-                        if (!requireSpaceAfter) {
-                            context.report({
-                                node,
-                                loc: location,
-                                message: "Unexpected whitespace after semicolon.",
-                                fix(fixer) {
-                                    const tokenAfter = sourceCode.getTokenAfter(token);
-
-                                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
-                                }
-                            });
-                        }
-                    } else {
-                        if (requireSpaceAfter) {
-                            context.report({
-                                node,
-                                loc: location,
-                                message: "Missing whitespace after semicolon.",
-                                fix(fixer) {
-                                    return fixer.insertTextAfter(token, " ");
-                                }
-                            });
-                        }
-                    }
-                }
-            }
-        }
-
-        /**
-         * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.
-         * @param {ASTNode} node The node to check.
-         * @returns {void}
-         */
-        function checkNode(node) {
-            const token = sourceCode.getLastToken(node);
-
-            checkSemicolonSpacing(token, node);
-        }
-
-        return {
-            VariableDeclaration: checkNode,
-            ExpressionStatement: checkNode,
-            BreakStatement: checkNode,
-            ContinueStatement: checkNode,
-            DebuggerStatement: checkNode,
-            ReturnStatement: checkNode,
-            ThrowStatement: checkNode,
-            ImportDeclaration: checkNode,
-            ExportNamedDeclaration: checkNode,
-            ExportAllDeclaration: checkNode,
-            ExportDefaultDeclaration: checkNode,
-            ForStatement(node) {
-                if (node.init) {
-                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);
-                }
-
-                if (node.test) {
-                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/sort-imports.js
===================================================================
--- node_modules/eslint/lib/rules/sort-imports.js	(revision )
+++ node_modules/eslint/lib/rules/sort-imports.js	(revision )
@@ -1,191 +0,0 @@
-/**
- * @fileoverview Rule to require sorting of import declarations
- * @author Christian Schuller
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce sorted import declarations within modules",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    ignoreCase: {
-                        type: "boolean"
-                    },
-                    memberSyntaxSortOrder: {
-                        type: "array",
-                        items: {
-                            enum: ["none", "all", "multiple", "single"]
-                        },
-                        uniqueItems: true,
-                        minItems: 4,
-                        maxItems: 4
-                    },
-                    ignoreMemberSort: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ],
-
-        fixable: "code"
-    },
-
-    create(context) {
-
-        const configuration = context.options[0] || {},
-            ignoreCase = configuration.ignoreCase || false,
-            ignoreMemberSort = configuration.ignoreMemberSort || false,
-            memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || ["none", "all", "multiple", "single"],
-            sourceCode = context.getSourceCode();
-        let previousDeclaration = null;
-
-        /**
-         * Gets the used member syntax style.
-         *
-         * import "my-module.js" --> none
-         * import * as myModule from "my-module.js" --> all
-         * import {myMember} from "my-module.js" --> single
-         * import {foo, bar} from  "my-module.js" --> multiple
-         *
-         * @param {ASTNode} node - the ImportDeclaration node.
-         * @returns {string} used member parameter style, ["all", "multiple", "single"]
-         */
-        function usedMemberSyntax(node) {
-            if (node.specifiers.length === 0) {
-                return "none";
-            } else if (node.specifiers[0].type === "ImportNamespaceSpecifier") {
-                return "all";
-            } else if (node.specifiers.length === 1) {
-                return "single";
-            }
-            return "multiple";
-
-        }
-
-        /**
-         * Gets the group by member parameter index for given declaration.
-         * @param {ASTNode} node - the ImportDeclaration node.
-         * @returns {number} the declaration group by member index.
-         */
-        function getMemberParameterGroupIndex(node) {
-            return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));
-        }
-
-        /**
-         * Gets the local name of the first imported module.
-         * @param {ASTNode} node - the ImportDeclaration node.
-         * @returns {?string} the local name of the first imported module.
-         */
-        function getFirstLocalMemberName(node) {
-            if (node.specifiers[0]) {
-                return node.specifiers[0].local.name;
-            }
-            return null;
-
-        }
-
-        return {
-            ImportDeclaration(node) {
-                if (previousDeclaration) {
-                    const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),
-                        previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);
-                    let currentLocalMemberName = getFirstLocalMemberName(node),
-                        previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);
-
-                    if (ignoreCase) {
-                        previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();
-                        currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();
-                    }
-
-                    // When the current declaration uses a different member syntax,
-                    // then check if the ordering is correct.
-                    // Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.
-                    if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {
-                        if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {
-                            context.report({
-                                node,
-                                message: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.",
-                                data: {
-                                    syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],
-                                    syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]
-                                }
-                            });
-                        }
-                    } else {
-                        if (previousLocalMemberName &&
-                            currentLocalMemberName &&
-                            currentLocalMemberName < previousLocalMemberName
-                        ) {
-                            context.report({
-                                node,
-                                message: "Imports should be sorted alphabetically."
-                            });
-                        }
-                    }
-                }
-
-                if (!ignoreMemberSort) {
-                    const importSpecifiers = node.specifiers.filter(specifier => specifier.type === "ImportSpecifier");
-                    const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;
-                    const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);
-
-                    if (firstUnsortedIndex !== -1) {
-                        context.report({
-                            node: importSpecifiers[firstUnsortedIndex],
-                            message: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
-                            data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },
-                            fix(fixer) {
-                                if (importSpecifiers.some(specifier => sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {
-
-                                    // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.
-                                    return null;
-                                }
-
-                                return fixer.replaceTextRange(
-                                    [importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]],
-                                    importSpecifiers
-
-                                        // Clone the importSpecifiers array to avoid mutating it
-                                        .slice()
-
-                                        // Sort the array into the desired order
-                                        .sort((specifierA, specifierB) => {
-                                            const aName = getSortableName(specifierA);
-                                            const bName = getSortableName(specifierB);
-
-                                            return aName > bName ? 1 : -1;
-                                        })
-
-                                        // Build a string out of the sorted list of import specifiers and the text between the originals
-                                        .reduce((sourceText, specifier, index) => {
-                                            const textAfterSpecifier = index === importSpecifiers.length - 1
-                                                ? ""
-                                                : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);
-
-                                            return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;
-                                        }, "")
-                                );
-                            }
-                        });
-                    }
-                }
-
-                previousDeclaration = node;
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/valid-typeof.js
===================================================================
--- node_modules/eslint/lib/rules/valid-typeof.js	(revision )
+++ node_modules/eslint/lib/rules/valid-typeof.js	(revision )
@@ -1,77 +0,0 @@
-/**
- * @fileoverview Ensures that the results of typeof are compared against a valid string
- * @author Ian Christian Myers
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce comparing `typeof` expressions against valid strings",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    requireStringLiterals: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const VALID_TYPES = ["symbol", "undefined", "object", "boolean", "number", "string", "function"],
-            OPERATORS = ["==", "===", "!=", "!=="];
-
-        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;
-
-        /**
-        * Determines whether a node is a typeof expression.
-        * @param {ASTNode} node The node
-        * @returns {boolean} `true` if the node is a typeof expression
-        */
-        function isTypeofExpression(node) {
-            return node.type === "UnaryExpression" && node.operator === "typeof";
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-
-            UnaryExpression(node) {
-                if (isTypeofExpression(node)) {
-                    const parent = context.getAncestors().pop();
-
-                    if (parent.type === "BinaryExpression" && OPERATORS.indexOf(parent.operator) !== -1) {
-                        const sibling = parent.left === node ? parent.right : parent.left;
-
-                        if (sibling.type === "Literal" || sibling.type === "TemplateLiteral" && !sibling.expressions.length) {
-                            const value = sibling.type === "Literal" ? sibling.value : sibling.quasis[0].value.cooked;
-
-                            if (VALID_TYPES.indexOf(value) === -1) {
-                                context.report({ node: sibling, message: "Invalid typeof comparison value." });
-                            }
-                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {
-                            context.report({ node: sibling, message: "Typeof comparisons should be to string literals." });
-                        }
-                    }
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/arrow-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/arrow-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/arrow-spacing.js	(revision )
@@ -1,149 +0,0 @@
-/**
- * @fileoverview Rule to define spacing before/after arrow function's arrow.
- * @author Jxck
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing before and after the arrow in arrow functions",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    before: {
-                        type: "boolean"
-                    },
-                    after: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        // merge rules with default
-        const rule = { before: true, after: true },
-            option = context.options[0] || {};
-
-        rule.before = option.before !== false;
-        rule.after = option.after !== false;
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Get tokens of arrow(`=>`) and before/after arrow.
-         * @param {ASTNode} node The arrow function node.
-         * @returns {Object} Tokens of arrow and before/after arrow.
-         */
-        function getTokens(node) {
-            const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);
-
-            return {
-                before: sourceCode.getTokenBefore(arrow),
-                arrow,
-                after: sourceCode.getTokenAfter(arrow)
-            };
-        }
-
-        /**
-         * Count spaces before/after arrow(`=>`) token.
-         * @param {Object} tokens Tokens before/after arrow.
-         * @returns {Object} count of space before/after arrow.
-         */
-        function countSpaces(tokens) {
-            const before = tokens.arrow.range[0] - tokens.before.range[1];
-            const after = tokens.after.range[0] - tokens.arrow.range[1];
-
-            return { before, after };
-        }
-
-        /**
-         * Determines whether space(s) before after arrow(`=>`) is satisfy rule.
-         * if before/after value is `true`, there should be space(s).
-         * if before/after value is `false`, there should be no space.
-         * @param {ASTNode} node The arrow function node.
-         * @returns {void}
-         */
-        function spaces(node) {
-            const tokens = getTokens(node);
-            const countSpace = countSpaces(tokens);
-
-            if (rule.before) {
-
-                // should be space(s) before arrow
-                if (countSpace.before === 0) {
-                    context.report({
-                        node: tokens.before,
-                        message: "Missing space before =>.",
-                        fix(fixer) {
-                            return fixer.insertTextBefore(tokens.arrow, " ");
-                        }
-                    });
-                }
-            } else {
-
-                // should be no space before arrow
-                if (countSpace.before > 0) {
-                    context.report({
-                        node: tokens.before,
-                        message: "Unexpected space before =>.",
-                        fix(fixer) {
-                            return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);
-                        }
-                    });
-                }
-            }
-
-            if (rule.after) {
-
-                // should be space(s) after arrow
-                if (countSpace.after === 0) {
-                    context.report({
-                        node: tokens.after,
-                        message: "Missing space after =>.",
-                        fix(fixer) {
-                            return fixer.insertTextAfter(tokens.arrow, " ");
-                        }
-                    });
-                }
-            } else {
-
-                // should be no space after arrow
-                if (countSpace.after > 0) {
-                    context.report({
-                        node: tokens.after,
-                        message: "Unexpected space after =>.",
-                        fix(fixer) {
-                            return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);
-                        }
-                    });
-                }
-            }
-        }
-
-        return {
-            ArrowFunctionExpression: spaces
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/block-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/block-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/block-spacing.js	(revision )
@@ -1,137 +0,0 @@
-/**
- * @fileoverview A rule to disallow or enforce spaces inside of single line blocks.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-const util = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing inside single-line blocks",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            { enum: ["always", "never"] }
-        ]
-    },
-
-    create(context) {
-        const always = (context.options[0] !== "never"),
-            message = always ? "Requires a space" : "Unexpected space(s)",
-            sourceCode = context.getSourceCode();
-
-        /**
-         * Gets the open brace token from a given node.
-         * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.
-         * @returns {Token} The token of the open brace.
-         */
-        function getOpenBrace(node) {
-            if (node.type === "SwitchStatement") {
-                if (node.cases.length > 0) {
-                    return sourceCode.getTokenBefore(node.cases[0]);
-                }
-                return sourceCode.getLastToken(node, 1);
-            }
-            return sourceCode.getFirstToken(node);
-        }
-
-        /**
-         * Checks whether or not:
-         *   - given tokens are on same line.
-         *   - there is/isn't a space between given tokens.
-         * @param {Token} left - A token to check.
-         * @param {Token} right - The token which is next to `left`.
-         * @returns {boolean}
-         *    When the option is `"always"`, `true` if there are one or more spaces between given tokens.
-         *    When the option is `"never"`, `true` if there are not any spaces between given tokens.
-         *    If given tokens are not on same line, it's always `true`.
-         */
-        function isValid(left, right) {
-            return (
-                !util.isTokenOnSameLine(left, right) ||
-                sourceCode.isSpaceBetweenTokens(left, right) === always
-            );
-        }
-
-        /**
-         * Reports invalid spacing style inside braces.
-         * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.
-         * @returns {void}
-         */
-        function checkSpacingInsideBraces(node) {
-
-            // Gets braces and the first/last token of content.
-            const openBrace = getOpenBrace(node);
-            const closeBrace = sourceCode.getLastToken(node);
-            const firstToken = sourceCode.getTokenAfter(openBrace, { includeComments: true });
-            const lastToken = sourceCode.getTokenBefore(closeBrace, { includeComments: true });
-
-            // Skip if the node is invalid or empty.
-            if (openBrace.type !== "Punctuator" ||
-                openBrace.value !== "{" ||
-                closeBrace.type !== "Punctuator" ||
-                closeBrace.value !== "}" ||
-                firstToken === closeBrace
-            ) {
-                return;
-            }
-
-            // Skip line comments for option never
-            if (!always && firstToken.type === "Line") {
-                return;
-            }
-
-            // Check.
-            if (!isValid(openBrace, firstToken)) {
-                context.report({
-                    node,
-                    loc: openBrace.loc.start,
-                    message: "{{message}} after '{'.",
-                    data: {
-                        message
-                    },
-                    fix(fixer) {
-                        if (always) {
-                            return fixer.insertTextBefore(firstToken, " ");
-                        }
-
-                        return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
-                    }
-                });
-            }
-            if (!isValid(lastToken, closeBrace)) {
-                context.report({
-                    node,
-                    loc: closeBrace.loc.start,
-                    message: "{{message}} before '}'.",
-                    data: {
-                        message
-                    },
-                    fix(fixer) {
-                        if (always) {
-                            return fixer.insertTextAfter(lastToken, " ");
-                        }
-
-                        return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
-                    }
-                });
-            }
-        }
-
-        return {
-            BlockStatement: checkSpacingInsideBraces,
-            SwitchStatement: checkSpacingInsideBraces
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/comma-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/comma-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/comma-spacing.js	(revision )
@@ -1,183 +0,0 @@
-/**
- * @fileoverview Comma spacing - validates spacing before and after comma
- * @author Vignesh Anand aka vegetableman.
- */
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing before and after commas",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    before: {
-                        type: "boolean"
-                    },
-                    after: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const sourceCode = context.getSourceCode();
-        const tokensAndComments = sourceCode.tokensAndComments;
-
-        const options = {
-            before: context.options[0] ? !!context.options[0].before : false,
-            after: context.options[0] ? !!context.options[0].after : true
-        };
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        // list of comma tokens to ignore for the check of leading whitespace
-        const commaTokensToIgnore = [];
-
-        /**
-         * Reports a spacing error with an appropriate message.
-         * @param {ASTNode} node The binary expression node to report.
-         * @param {string} dir Is the error "before" or "after" the comma?
-         * @param {ASTNode} otherNode The node at the left or right of `node`
-         * @returns {void}
-         * @private
-         */
-        function report(node, dir, otherNode) {
-            context.report({
-                node,
-                fix(fixer) {
-                    if (options[dir]) {
-                        if (dir === "before") {
-                            return fixer.insertTextBefore(node, " ");
-                        }
-                        return fixer.insertTextAfter(node, " ");
-
-                    }
-                    let start, end;
-                    const newText = "";
-
-                    if (dir === "before") {
-                        start = otherNode.range[1];
-                        end = node.range[0];
-                    } else {
-                        start = node.range[1];
-                        end = otherNode.range[0];
-                    }
-
-                    return fixer.replaceTextRange([start, end], newText);
-
-                },
-                message: options[dir]
-                    ? "A space is required {{dir}} ','."
-                    : "There should be no space {{dir}} ','.",
-                data: {
-                    dir
-                }
-            });
-        }
-
-        /**
-         * Validates the spacing around a comma token.
-         * @param {Object} tokens - The tokens to be validated.
-         * @param {Token} tokens.comma The token representing the comma.
-         * @param {Token} [tokens.left] The last token before the comma.
-         * @param {Token} [tokens.right] The first token after the comma.
-         * @param {Token|ASTNode} reportItem The item to use when reporting an error.
-         * @returns {void}
-         * @private
-         */
-        function validateCommaItemSpacing(tokens, reportItem) {
-            if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) &&
-                    (options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma))
-            ) {
-                report(reportItem, "before", tokens.left);
-            }
-
-            if (tokens.right && !options.after && tokens.right.type === "Line") {
-                return;
-            }
-
-            if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) &&
-                    (options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right))
-            ) {
-                report(reportItem, "after", tokens.right);
-            }
-        }
-
-        /**
-         * Adds null elements of the given ArrayExpression or ArrayPattern node to the ignore list.
-         * @param {ASTNode} node An ArrayExpression or ArrayPattern node.
-         * @returns {void}
-         */
-        function addNullElementsToIgnoreList(node) {
-            let previousToken = sourceCode.getFirstToken(node);
-
-            node.elements.forEach(element => {
-                let token;
-
-                if (element === null) {
-                    token = sourceCode.getTokenAfter(previousToken);
-
-                    if (astUtils.isCommaToken(token)) {
-                        commaTokensToIgnore.push(token);
-                    }
-                } else {
-                    token = sourceCode.getTokenAfter(element);
-                }
-
-                previousToken = token;
-            });
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            "Program:exit"() {
-                tokensAndComments.forEach((token, i) => {
-
-                    if (!astUtils.isCommaToken(token)) {
-                        return;
-                    }
-
-                    if (token && token.type === "JSXText") {
-                        return;
-                    }
-
-                    const previousToken = tokensAndComments[i - 1];
-                    const nextToken = tokensAndComments[i + 1];
-
-                    validateCommaItemSpacing({
-                        comma: token,
-                        left: astUtils.isCommaToken(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,
-                        right: astUtils.isCommaToken(nextToken) ? null : nextToken
-                    }, token);
-                });
-            },
-            ArrayExpression: addNullElementsToIgnoreList,
-            ArrayPattern: addNullElementsToIgnoreList
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/for-direction.js
===================================================================
--- node_modules/eslint/lib/rules/for-direction.js	(revision )
+++ node_modules/eslint/lib/rules/for-direction.js	(revision )
@@ -1,105 +0,0 @@
-/**
- * @fileoverview enforce "for" loop update clause moving the counter in the right direction.(for-direction)
- * @author Aladdin-ADD<hh_2013@foxmail.com>
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce \"for\" loop update clause moving the counter in the right direction.",
-            category: "Possible Errors",
-            recommended: false
-        },
-        fixable: null,
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * report an error.
-         * @param {ASTNode} node the node to report.
-         * @returns {void}
-         */
-        function report(node) {
-            context.report({
-                node,
-                message: "The update clause in this loop moves the variable in the wrong direction."
-            });
-        }
-
-        /**
-         * check UpdateExpression add/sub the counter
-         * @param {ASTNode} update UpdateExpression to check
-         * @param {string} counter variable name to check
-         * @returns {int} if add return 1, if sub return -1, if nochange, return 0
-         */
-        function getUpdateDirection(update, counter) {
-            if (update.argument.type === "Identifier" && update.argument.name === counter) {
-                if (update.operator === "++") {
-                    return 1;
-                }
-                if (update.operator === "--") {
-                    return -1;
-                }
-            }
-            return 0;
-        }
-
-        /**
-         * check AssignmentExpression add/sub the counter
-         * @param {ASTNode} update AssignmentExpression to check
-         * @param {string} counter variable name to check
-         * @returns {int} if add return 1, if sub return -1, if nochange, return 0
-         */
-        function getAssignmentDirection(update, counter) {
-            if (update.left.name === counter) {
-                if (update.operator === "+=") {
-                    return 1;
-                }
-                if (update.operator === "-=") {
-                    return -1;
-                }
-            }
-            return 0;
-        }
-        return {
-            ForStatement(node) {
-
-                if (node.test && node.test.type === "BinaryExpression" && node.test.left.type === "Identifier" && node.update) {
-                    const counter = node.test.left.name;
-                    const operator = node.test.operator;
-                    const update = node.update;
-
-                    if (operator === "<" || operator === "<=") {
-
-                        // report error if update sub the counter (--, -=)
-                        if (update.type === "UpdateExpression" && getUpdateDirection(update, counter) < 0) {
-                            report(node);
-                        }
-
-                        if (update.type === "AssignmentExpression" && getAssignmentDirection(update, counter) < 0) {
-                            report(node);
-                        }
-                    } else if (operator === ">" || operator === ">=") {
-
-                        // report error if update add the counter (++, +=)
-                        if (update.type === "UpdateExpression" && getUpdateDirection(update, counter) > 0) {
-                            report(node);
-                        }
-
-                        if (update.type === "AssignmentExpression" && getAssignmentDirection(update, counter) > 0) {
-                            report(node);
-                        }
-                    }
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/getter-return.js
===================================================================
--- node_modules/eslint/lib/rules/getter-return.js	(revision )
+++ node_modules/eslint/lib/rules/getter-return.js	(revision )
@@ -1,176 +0,0 @@
-/**
- * @fileoverview Enforces that a return statement is present in property getters.
- * @author Aladdin-ADD(hh_2013@foxmail.com)
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-const TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;
-
-/**
- * Checks a given code path segment is reachable.
- *
- * @param {CodePathSegment} segment - A segment to check.
- * @returns {boolean} `true` if the segment is reachable.
- */
-function isReachable(segment) {
-    return segment.reachable;
-}
-
-/**
- * Gets a readable location.
- *
- * - FunctionExpression -> the function name or `function` keyword.
- *
- * @param {ASTNode} node - A function node to get.
- * @returns {ASTNode|Token} The node or the token of a location.
- */
-function getId(node) {
-    return node.id || node;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce `return` statements in getters",
-            category: "Possible Errors",
-            recommended: false
-        },
-        fixable: null,
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allowImplicit: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const options = context.options[0] || { allowImplicit: false };
-
-        let funcInfo = {
-            upper: null,
-            codePath: null,
-            hasReturn: false,
-            shouldCheck: false,
-            node: null
-        };
-
-        /**
-         * Checks whether or not the last code path segment is reachable.
-         * Then reports this function if the segment is reachable.
-         *
-         * If the last code path segment is reachable, there are paths which are not
-         * returned or thrown.
-         *
-         * @param {ASTNode} node - A node to check.
-         * @returns {void}
-         */
-        function checkLastSegment(node) {
-            if (funcInfo.shouldCheck &&
-                funcInfo.codePath.currentSegments.some(isReachable)
-            ) {
-                context.report({
-                    node,
-                    loc: getId(node).loc.start,
-                    message: funcInfo.hasReturn
-                        ? "Expected {{name}} to always return a value."
-                        : "Expected to return a value in {{name}}.",
-                    data: {
-                        name: astUtils.getFunctionNameWithKind(funcInfo.node)
-                    }
-                });
-            }
-        }
-
-        /** Checks whether a node means a getter function.
-         * @param {ASTNode} node - a node to check.
-         * @returns {boolean} if node means a getter, return true; else return false.
-         */
-        function isGetter(node) {
-            const parent = node.parent;
-
-            if (TARGET_NODE_TYPE.test(node.type) && node.body.type === "BlockStatement") {
-                if (parent.kind === "get") {
-                    return true;
-                }
-                if (parent.type === "Property" && astUtils.getStaticPropertyName(parent) === "get" && parent.parent.type === "ObjectExpression") {
-
-                    // Object.defineProperty()
-                    if (parent.parent.parent.type === "CallExpression" &&
-                        astUtils.getStaticPropertyName(parent.parent.parent.callee) === "defineProperty") {
-                        return true;
-                    }
-
-                    // Object.defineProperties()
-                    if (parent.parent.parent.type === "Property" &&
-                        parent.parent.parent.parent.type === "ObjectExpression" &&
-                        parent.parent.parent.parent.parent.type === "CallExpression" &&
-                        astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === "defineProperties") {
-                        return true;
-                    }
-                }
-            }
-            return false;
-        }
-        return {
-
-            // Stacks this function's information.
-            onCodePathStart(codePath, node) {
-                funcInfo = {
-                    upper: funcInfo,
-                    codePath,
-                    hasReturn: false,
-                    shouldCheck: isGetter(node),
-                    node
-                };
-            },
-
-            // Pops this function's information.
-            onCodePathEnd() {
-                funcInfo = funcInfo.upper;
-            },
-
-            // Checks the return statement is valid.
-            ReturnStatement(node) {
-                if (funcInfo.shouldCheck) {
-                    funcInfo.hasReturn = true;
-
-                    // if allowImplicit: false, should also check node.argument
-                    if (!options.allowImplicit && !node.argument) {
-                        context.report({
-                            node,
-                            message: "Expected to return a value in {{name}}.",
-                            data: {
-                                name: astUtils.getFunctionNameWithKind(funcInfo.node)
-                            }
-                        });
-                    }
-                }
-            },
-
-            // Reports a given function if the last path is reachable.
-            "FunctionExpression:exit": checkLastSegment,
-            "ArrowFunctionExpression:exit": checkLastSegment
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/indent-legacy.js
===================================================================
--- node_modules/eslint/lib/rules/indent-legacy.js	(revision )
+++ node_modules/eslint/lib/rules/indent-legacy.js	(revision )
@@ -1,1126 +0,0 @@
-/**
- * @fileoverview This option sets a specific tab width for your code
- *
- * This rule has been ported and modified from nodeca.
- * @author Vitaly Puzrin
- * @author Gyandeep Singh
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent indentation",
-            category: "Stylistic Issues",
-            recommended: false,
-            replacedBy: ["indent"]
-        },
-
-        deprecated: true,
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["tab"]
-                    },
-                    {
-                        type: "integer",
-                        minimum: 0
-                    }
-                ]
-            },
-            {
-                type: "object",
-                properties: {
-                    SwitchCase: {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    VariableDeclarator: {
-                        oneOf: [
-                            {
-                                type: "integer",
-                                minimum: 0
-                            },
-                            {
-                                type: "object",
-                                properties: {
-                                    var: {
-                                        type: "integer",
-                                        minimum: 0
-                                    },
-                                    let: {
-                                        type: "integer",
-                                        minimum: 0
-                                    },
-                                    const: {
-                                        type: "integer",
-                                        minimum: 0
-                                    }
-                                }
-                            }
-                        ]
-                    },
-                    outerIIFEBody: {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    MemberExpression: {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    FunctionDeclaration: {
-                        type: "object",
-                        properties: {
-                            parameters: {
-                                oneOf: [
-                                    {
-                                        type: "integer",
-                                        minimum: 0
-                                    },
-                                    {
-                                        enum: ["first"]
-                                    }
-                                ]
-                            },
-                            body: {
-                                type: "integer",
-                                minimum: 0
-                            }
-                        }
-                    },
-                    FunctionExpression: {
-                        type: "object",
-                        properties: {
-                            parameters: {
-                                oneOf: [
-                                    {
-                                        type: "integer",
-                                        minimum: 0
-                                    },
-                                    {
-                                        enum: ["first"]
-                                    }
-                                ]
-                            },
-                            body: {
-                                type: "integer",
-                                minimum: 0
-                            }
-                        }
-                    },
-                    CallExpression: {
-                        type: "object",
-                        properties: {
-                            parameters: {
-                                oneOf: [
-                                    {
-                                        type: "integer",
-                                        minimum: 0
-                                    },
-                                    {
-                                        enum: ["first"]
-                                    }
-                                ]
-                            }
-                        }
-                    },
-                    ArrayExpression: {
-                        oneOf: [
-                            {
-                                type: "integer",
-                                minimum: 0
-                            },
-                            {
-                                enum: ["first"]
-                            }
-                        ]
-                    },
-                    ObjectExpression: {
-                        oneOf: [
-                            {
-                                type: "integer",
-                                minimum: 0
-                            },
-                            {
-                                enum: ["first"]
-                            }
-                        ]
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const DEFAULT_VARIABLE_INDENT = 1;
-        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config
-        const DEFAULT_FUNCTION_BODY_INDENT = 1;
-
-        let indentType = "space";
-        let indentSize = 4;
-        const options = {
-            SwitchCase: 0,
-            VariableDeclarator: {
-                var: DEFAULT_VARIABLE_INDENT,
-                let: DEFAULT_VARIABLE_INDENT,
-                const: DEFAULT_VARIABLE_INDENT
-            },
-            outerIIFEBody: null,
-            FunctionDeclaration: {
-                parameters: DEFAULT_PARAMETER_INDENT,
-                body: DEFAULT_FUNCTION_BODY_INDENT
-            },
-            FunctionExpression: {
-                parameters: DEFAULT_PARAMETER_INDENT,
-                body: DEFAULT_FUNCTION_BODY_INDENT
-            },
-            CallExpression: {
-                arguments: DEFAULT_PARAMETER_INDENT
-            },
-            ArrayExpression: 1,
-            ObjectExpression: 1
-        };
-
-        const sourceCode = context.getSourceCode();
-
-        if (context.options.length) {
-            if (context.options[0] === "tab") {
-                indentSize = 1;
-                indentType = "tab";
-            } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === "number") {
-                indentSize = context.options[0];
-                indentType = "space";
-            }
-
-            if (context.options[1]) {
-                const opts = context.options[1];
-
-                options.SwitchCase = opts.SwitchCase || 0;
-                const variableDeclaratorRules = opts.VariableDeclarator;
-
-                if (typeof variableDeclaratorRules === "number") {
-                    options.VariableDeclarator = {
-                        var: variableDeclaratorRules,
-                        let: variableDeclaratorRules,
-                        const: variableDeclaratorRules
-                    };
-                } else if (typeof variableDeclaratorRules === "object") {
-                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);
-                }
-
-                if (typeof opts.outerIIFEBody === "number") {
-                    options.outerIIFEBody = opts.outerIIFEBody;
-                }
-
-                if (typeof opts.MemberExpression === "number") {
-                    options.MemberExpression = opts.MemberExpression;
-                }
-
-                if (typeof opts.FunctionDeclaration === "object") {
-                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);
-                }
-
-                if (typeof opts.FunctionExpression === "object") {
-                    Object.assign(options.FunctionExpression, opts.FunctionExpression);
-                }
-
-                if (typeof opts.CallExpression === "object") {
-                    Object.assign(options.CallExpression, opts.CallExpression);
-                }
-
-                if (typeof opts.ArrayExpression === "number" || typeof opts.ArrayExpression === "string") {
-                    options.ArrayExpression = opts.ArrayExpression;
-                }
-
-                if (typeof opts.ObjectExpression === "number" || typeof opts.ObjectExpression === "string") {
-                    options.ObjectExpression = opts.ObjectExpression;
-                }
-            }
-        }
-
-        const caseIndentStore = {};
-
-        /**
-         * Creates an error message for a line, given the expected/actual indentation.
-         * @param {int} expectedAmount The expected amount of indentation characters for this line
-         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line
-         * @param {int} actualTabs The actual number of indentation tabs that were found on this line
-         * @returns {string} An error message for this line
-         */
-        function createErrorMessage(expectedAmount, actualSpaces, actualTabs) {
-            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`; // e.g. "2 tabs"
-            const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`; // e.g. "space"
-            const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`; // e.g. "tabs"
-            let foundStatement;
-
-            if (actualSpaces > 0 && actualTabs > 0) {
-                foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. "1 space and 2 tabs"
-            } else if (actualSpaces > 0) {
-
-                // Abbreviate the message if the expected indentation is also spaces.
-                // e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'
-                foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
-            } else if (actualTabs > 0) {
-                foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
-            } else {
-                foundStatement = "0";
-            }
-
-            return `Expected indentation of ${expectedStatement} but found ${foundStatement}.`;
-        }
-
-        /**
-         * Reports a given indent violation
-         * @param {ASTNode} node Node violating the indent rule
-         * @param {int} needed Expected indentation character count
-         * @param {int} gottenSpaces Indentation space count in the actual node/code
-         * @param {int} gottenTabs Indentation tab count in the actual node/code
-         * @param {Object=} loc Error line and column location
-         * @param {boolean} isLastNodeCheck Is the error for last node check
-         * @param {int} lastNodeCheckEndOffset Number of charecters to skip from the end
-         * @returns {void}
-         */
-        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {
-            if (gottenSpaces && gottenTabs) {
-
-                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.
-                return;
-            }
-
-            const desiredIndent = (indentType === "space" ? " " : "\t").repeat(needed);
-
-            const textRange = isLastNodeCheck
-                ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs]
-                : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];
-
-            context.report({
-                node,
-                loc,
-                message: createErrorMessage(needed, gottenSpaces, gottenTabs),
-                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)
-            });
-        }
-
-        /**
-         * Get the actual indent of node
-         * @param {ASTNode|Token} node Node to examine
-         * @param {boolean} [byLastLine=false] get indent of node's last line
-         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also
-         contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and
-         `badChar` is the amount of the other indentation character.
-         */
-        function getNodeIndent(node, byLastLine) {
-            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);
-            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split("");
-            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== " " && char !== "\t"));
-            const spaces = indentChars.filter(char => char === " ").length;
-            const tabs = indentChars.filter(char => char === "\t").length;
-
-            return {
-                space: spaces,
-                tab: tabs,
-                goodChar: indentType === "space" ? spaces : tabs,
-                badChar: indentType === "space" ? tabs : spaces
-            };
-        }
-
-        /**
-         * Checks node is the first in its own start line. By default it looks by start line.
-         * @param {ASTNode} node The node to check
-         * @param {boolean} [byEndLocation=false] Lookup based on start position or end
-         * @returns {boolean} true if its the first in the its start line
-         */
-        function isNodeFirstInLine(node, byEndLocation) {
-            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),
-                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,
-                endLine = firstToken ? firstToken.loc.end.line : -1;
-
-            return startLine !== endLine;
-        }
-
-        /**
-         * Check indent for node
-         * @param {ASTNode} node Node to check
-         * @param {int} neededIndent needed indent
-         * @param {boolean} [excludeCommas=false] skip comma on start of line
-         * @returns {void}
-         */
-        function checkNodeIndent(node, neededIndent) {
-            const actualIndent = getNodeIndent(node, false);
-
-            if (
-                node.type !== "ArrayExpression" &&
-                node.type !== "ObjectExpression" &&
-                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&
-                isNodeFirstInLine(node)
-            ) {
-                report(node, neededIndent, actualIndent.space, actualIndent.tab);
-            }
-
-            if (node.type === "IfStatement" && node.alternate) {
-                const elseToken = sourceCode.getTokenBefore(node.alternate);
-
-                checkNodeIndent(elseToken, neededIndent);
-
-                if (!isNodeFirstInLine(node.alternate)) {
-                    checkNodeIndent(node.alternate, neededIndent);
-                }
-            }
-
-            if (node.type === "TryStatement" && node.handler) {
-                const catchToken = sourceCode.getFirstToken(node.handler);
-
-                checkNodeIndent(catchToken, neededIndent);
-            }
-
-            if (node.type === "TryStatement" && node.finalizer) {
-                const finallyToken = sourceCode.getTokenBefore(node.finalizer);
-
-                checkNodeIndent(finallyToken, neededIndent);
-            }
-
-            if (node.type === "DoWhileStatement") {
-                const whileToken = sourceCode.getTokenAfter(node.body);
-
-                checkNodeIndent(whileToken, neededIndent);
-            }
-        }
-
-        /**
-         * Check indent for nodes list
-         * @param {ASTNode[]} nodes list of node objects
-         * @param {int} indent needed indent
-         * @param {boolean} [excludeCommas=false] skip comma on start of line
-         * @returns {void}
-         */
-        function checkNodesIndent(nodes, indent) {
-            nodes.forEach(node => checkNodeIndent(node, indent));
-        }
-
-        /**
-         * Check last node line indent this detects, that block closed correctly
-         * @param {ASTNode} node Node to examine
-         * @param {int} lastLineIndent needed indent
-         * @returns {void}
-         */
-        function checkLastNodeLineIndent(node, lastLineIndent) {
-            const lastToken = sourceCode.getLastToken(node);
-            const endIndent = getNodeIndent(lastToken, true);
-
-            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {
-                report(
-                    node,
-                    lastLineIndent,
-                    endIndent.space,
-                    endIndent.tab,
-                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },
-                    true
-                );
-            }
-        }
-
-        /**
-         * Check last node line indent this detects, that block closed correctly
-         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'
-         * @param {ASTNode} node Node to examine
-         * @param {int} firstLineIndent first line needed indent
-         * @returns {void}
-         */
-        function checkLastReturnStatementLineIndent(node, firstLineIndent) {
-
-            // in case if return statement ends with ');' we have traverse back to ')'
-            // otherwise we'll measure indent for ';' and replace ')'
-            const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);
-            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);
-
-            if (textBeforeClosingParenthesis.trim()) {
-
-                // There are tokens before the closing paren, don't report this case
-                return;
-            }
-
-            const endIndent = getNodeIndent(lastToken, true);
-
-            if (endIndent.goodChar !== firstLineIndent) {
-                report(
-                    node,
-                    firstLineIndent,
-                    endIndent.space,
-                    endIndent.tab,
-                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },
-                    true
-                );
-            }
-        }
-
-        /**
-         * Check first node line indent is correct
-         * @param {ASTNode} node Node to examine
-         * @param {int} firstLineIndent needed indent
-         * @returns {void}
-         */
-        function checkFirstNodeLineIndent(node, firstLineIndent) {
-            const startIndent = getNodeIndent(node, false);
-
-            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {
-                report(
-                    node,
-                    firstLineIndent,
-                    startIndent.space,
-                    startIndent.tab,
-                    { line: node.loc.start.line, column: node.loc.start.column }
-                );
-            }
-        }
-
-        /**
-         * Returns a parent node of given node based on a specified type
-         * if not present then return null
-         * @param {ASTNode} node node to examine
-         * @param {string} type type that is being looked for
-         * @param {string} stopAtList end points for the evaluating code
-         * @returns {ASTNode|void} if found then node otherwise null
-         */
-        function getParentNodeByType(node, type, stopAtList) {
-            let parent = node.parent;
-
-            if (!stopAtList) {
-                stopAtList = ["Program"];
-            }
-
-            while (parent.type !== type && stopAtList.indexOf(parent.type) === -1 && parent.type !== "Program") {
-                parent = parent.parent;
-            }
-
-            return parent.type === type ? parent : null;
-        }
-
-        /**
-         * Returns the VariableDeclarator based on the current node
-         * if not present then return null
-         * @param {ASTNode} node node to examine
-         * @returns {ASTNode|void} if found then node otherwise null
-         */
-        function getVariableDeclaratorNode(node) {
-            return getParentNodeByType(node, "VariableDeclarator");
-        }
-
-        /**
-         * Check to see if the node is part of the multi-line variable declaration.
-         * Also if its on the same line as the varNode
-         * @param {ASTNode} node node to check
-         * @param {ASTNode} varNode variable declaration node to check against
-         * @returns {boolean} True if all the above condition satisfy
-         */
-        function isNodeInVarOnTop(node, varNode) {
-            return varNode &&
-                varNode.parent.loc.start.line === node.loc.start.line &&
-                varNode.parent.declarations.length > 1;
-        }
-
-        /**
-         * Check to see if the argument before the callee node is multi-line and
-         * there should only be 1 argument before the callee node
-         * @param {ASTNode} node node to check
-         * @returns {boolean} True if arguments are multi-line
-         */
-        function isArgBeforeCalleeNodeMultiline(node) {
-            const parent = node.parent;
-
-            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {
-                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
-            }
-
-            return false;
-        }
-
-        /**
-         * Check to see if the node is a file level IIFE
-         * @param {ASTNode} node The function node to check.
-         * @returns {boolean} True if the node is the outer IIFE
-         */
-        function isOuterIIFE(node) {
-            const parent = node.parent;
-            let stmt = parent.parent;
-
-            /*
-             * Verify that the node is an IIEF
-             */
-            if (
-                parent.type !== "CallExpression" ||
-                parent.callee !== node) {
-
-                return false;
-            }
-
-            /*
-             * Navigate legal ancestors to determine whether this IIEF is outer
-             */
-            while (
-                stmt.type === "UnaryExpression" && (
-                    stmt.operator === "!" ||
-                    stmt.operator === "~" ||
-                    stmt.operator === "+" ||
-                    stmt.operator === "-") ||
-                stmt.type === "AssignmentExpression" ||
-                stmt.type === "LogicalExpression" ||
-                stmt.type === "SequenceExpression" ||
-                stmt.type === "VariableDeclarator") {
-
-                stmt = stmt.parent;
-            }
-
-            return ((
-                stmt.type === "ExpressionStatement" ||
-                stmt.type === "VariableDeclaration") &&
-                stmt.parent && stmt.parent.type === "Program"
-            );
-        }
-
-        /**
-         * Check indent for function block content
-         * @param {ASTNode} node A BlockStatement node that is inside of a function.
-         * @returns {void}
-         */
-        function checkIndentInFunctionBlock(node) {
-
-            /*
-             * Search first caller in chain.
-             * Ex.:
-             *
-             * Models <- Identifier
-             *   .User
-             *   .find()
-             *   .exec(function() {
-             *   // function body
-             * });
-             *
-             * Looks for 'Models'
-             */
-            const calleeNode = node.parent; // FunctionExpression
-            let indent;
-
-            if (calleeNode.parent &&
-                (calleeNode.parent.type === "Property" ||
-                calleeNode.parent.type === "ArrayExpression")) {
-
-                // If function is part of array or object, comma can be put at left
-                indent = getNodeIndent(calleeNode, false).goodChar;
-            } else {
-
-                // If function is standalone, simple calculate indent
-                indent = getNodeIndent(calleeNode).goodChar;
-            }
-
-            if (calleeNode.parent.type === "CallExpression") {
-                const calleeParent = calleeNode.parent;
-
-                if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
-                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {
-                        indent = getNodeIndent(calleeParent).goodChar;
-                    }
-                } else {
-                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&
-                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&
-                        !isNodeFirstInLine(calleeNode)) {
-                        indent = getNodeIndent(calleeParent).goodChar;
-                    }
-                }
-            }
-
-            // function body indent should be indent + indent size, unless this
-            // is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.
-            let functionOffset = indentSize;
-
-            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {
-                functionOffset = options.outerIIFEBody * indentSize;
-            } else if (calleeNode.type === "FunctionExpression") {
-                functionOffset = options.FunctionExpression.body * indentSize;
-            } else if (calleeNode.type === "FunctionDeclaration") {
-                functionOffset = options.FunctionDeclaration.body * indentSize;
-            }
-            indent += functionOffset;
-
-            // check if the node is inside a variable
-            const parentVarNode = getVariableDeclaratorNode(node);
-
-            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {
-                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
-            }
-
-            if (node.body.length > 0) {
-                checkNodesIndent(node.body, indent);
-            }
-
-            checkLastNodeLineIndent(node, indent - functionOffset);
-        }
-
-
-        /**
-         * Checks if the given node starts and ends on the same line
-         * @param {ASTNode} node The node to check
-         * @returns {boolean} Whether or not the block starts and ends on the same line.
-         */
-        function isSingleLineNode(node) {
-            const lastToken = sourceCode.getLastToken(node),
-                startLine = node.loc.start.line,
-                endLine = lastToken.loc.end.line;
-
-            return startLine === endLine;
-        }
-
-        /**
-         * Check to see if the first element inside an array is an object and on the same line as the node
-         * If the node is not an array then it will return false.
-         * @param {ASTNode} node node to check
-         * @returns {boolean} success/failure
-         */
-        function isFirstArrayElementOnSameLine(node) {
-            if (node.type === "ArrayExpression" && node.elements[0]) {
-                return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === "ObjectExpression";
-            }
-            return false;
-
-        }
-
-        /**
-         * Check indent for array block content or object block content
-         * @param {ASTNode} node node to examine
-         * @returns {void}
-         */
-        function checkIndentInArrayOrObjectBlock(node) {
-
-            // Skip inline
-            if (isSingleLineNode(node)) {
-                return;
-            }
-
-            let elements = (node.type === "ArrayExpression") ? node.elements : node.properties;
-
-            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null
-            elements = elements.filter(elem => elem !== null);
-
-            let nodeIndent;
-            let elementsIndent;
-            const parentVarNode = getVariableDeclaratorNode(node);
-
-            // TODO - come up with a better strategy in future
-            if (isNodeFirstInLine(node)) {
-                const parent = node.parent;
-
-                nodeIndent = getNodeIndent(parent).goodChar;
-                if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {
-                    if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
-                        if (parent.type === "VariableDeclarator" && parentVarNode.loc.start.line === parent.loc.start.line) {
-                            nodeIndent += (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);
-                        } else if (parent.type === "ObjectExpression" || parent.type === "ArrayExpression") {
-                            const parentElements = node.parent.type === "ObjectExpression" ? node.parent.properties : node.parent.elements;
-
-                            if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {
-
-                                /*
-                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.
-                                 * e.g. [{
-                                 *        foo: 1
-                                 *      },
-                                 *      {
-                                 *        bar: 1
-                                 *      }]
-                                 * the second object is not indented.
-                                 */
-                            } else if (typeof options[parent.type] === "number") {
-                                nodeIndent += options[parent.type] * indentSize;
-                            } else {
-                                nodeIndent = parentElements[0].loc.start.column;
-                            }
-                        } else if (parent.type === "CallExpression" || parent.type === "NewExpression") {
-                            if (typeof options.CallExpression.arguments === "number") {
-                                nodeIndent += options.CallExpression.arguments * indentSize;
-                            } else if (options.CallExpression.arguments === "first") {
-                                if (parent.arguments.indexOf(node) !== -1) {
-                                    nodeIndent = parent.arguments[0].loc.start.column;
-                                }
-                            } else {
-                                nodeIndent += indentSize;
-                            }
-                        } else if (parent.type === "LogicalExpression" || parent.type === "ArrowFunctionExpression") {
-                            nodeIndent += indentSize;
-                        }
-                    }
-                } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && parent.type !== "MemberExpression" && parent.type !== "ExpressionStatement" && parent.type !== "AssignmentExpression" && parent.type !== "Property") {
-                    nodeIndent += indentSize;
-                }
-
-                checkFirstNodeLineIndent(node, nodeIndent);
-            } else {
-                nodeIndent = getNodeIndent(node).goodChar;
-            }
-
-            if (options[node.type] === "first") {
-                elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.
-            } else {
-                elementsIndent = nodeIndent + indentSize * options[node.type];
-            }
-
-            /*
-             * Check if the node is a multiple variable declaration; if so, then
-             * make sure indentation takes that into account.
-             */
-            if (isNodeInVarOnTop(node, parentVarNode)) {
-                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
-            }
-
-            checkNodesIndent(elements, elementsIndent);
-
-            if (elements.length > 0) {
-
-                // Skip last block line check if last item in same line
-                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
-                    return;
-                }
-            }
-
-            checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));
-        }
-
-        /**
-         * Check if the node or node body is a BlockStatement or not
-         * @param {ASTNode} node node to test
-         * @returns {boolean} True if it or its body is a block statement
-         */
-        function isNodeBodyBlock(node) {
-            return node.type === "BlockStatement" || node.type === "ClassBody" || (node.body && node.body.type === "BlockStatement") ||
-                (node.consequent && node.consequent.type === "BlockStatement");
-        }
-
-        /**
-         * Check indentation for blocks
-         * @param {ASTNode} node node to check
-         * @returns {void}
-         */
-        function blockIndentationCheck(node) {
-
-            // Skip inline blocks
-            if (isSingleLineNode(node)) {
-                return;
-            }
-
-            if (node.parent && (
-                node.parent.type === "FunctionExpression" ||
-                node.parent.type === "FunctionDeclaration" ||
-                node.parent.type === "ArrowFunctionExpression")
-            ) {
-                checkIndentInFunctionBlock(node);
-                return;
-            }
-
-            let indent;
-            let nodesToCheck = [];
-
-            /*
-             * For this statements we should check indent from statement beginning,
-             * not from the beginning of the block.
-             */
-            const statementsWithProperties = [
-                "IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement", "ClassDeclaration", "TryStatement"
-            ];
-
-            if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {
-                indent = getNodeIndent(node.parent).goodChar;
-            } else if (node.parent && node.parent.type === "CatchClause") {
-                indent = getNodeIndent(node.parent.parent).goodChar;
-            } else {
-                indent = getNodeIndent(node).goodChar;
-            }
-
-            if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
-                nodesToCheck = [node.consequent];
-            } else if (Array.isArray(node.body)) {
-                nodesToCheck = node.body;
-            } else {
-                nodesToCheck = [node.body];
-            }
-
-            if (nodesToCheck.length > 0) {
-                checkNodesIndent(nodesToCheck, indent + indentSize);
-            }
-
-            if (node.type === "BlockStatement") {
-                checkLastNodeLineIndent(node, indent);
-            }
-        }
-
-        /**
-         * Filter out the elements which are on the same line of each other or the node.
-         * basically have only 1 elements from each line except the variable declaration line.
-         * @param {ASTNode} node Variable declaration node
-         * @returns {ASTNode[]} Filtered elements
-         */
-        function filterOutSameLineVars(node) {
-            return node.declarations.reduce((finalCollection, elem) => {
-                const lastElem = finalCollection[finalCollection.length - 1];
-
-                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||
-                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {
-                    finalCollection.push(elem);
-                }
-
-                return finalCollection;
-            }, []);
-        }
-
-        /**
-         * Check indentation for variable declarations
-         * @param {ASTNode} node node to examine
-         * @returns {void}
-         */
-        function checkIndentInVariableDeclarations(node) {
-            const elements = filterOutSameLineVars(node);
-            const nodeIndent = getNodeIndent(node).goodChar;
-            const lastElement = elements[elements.length - 1];
-
-            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];
-
-            checkNodesIndent(elements, elementsIndent);
-
-            // Only check the last line if there is any token after the last item
-            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {
-                return;
-            }
-
-            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);
-
-            if (tokenBeforeLastElement.value === ",") {
-
-                // Special case for comma-first syntax where the semicolon is indented
-                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);
-            } else {
-                checkLastNodeLineIndent(node, elementsIndent - indentSize);
-            }
-        }
-
-        /**
-         * Check and decide whether to check for indentation for blockless nodes
-         * Scenarios are for or while statements without braces around them
-         * @param {ASTNode} node node to examine
-         * @returns {void}
-         */
-        function blockLessNodes(node) {
-            if (node.body.type !== "BlockStatement") {
-                blockIndentationCheck(node);
-            }
-        }
-
-        /**
-         * Returns the expected indentation for the case statement
-         * @param {ASTNode} node node to examine
-         * @param {int} [switchIndent] indent for switch statement
-         * @returns {int} indent size
-         */
-        function expectedCaseIndent(node, switchIndent) {
-            const switchNode = (node.type === "SwitchStatement") ? node : node.parent;
-            let caseIndent;
-
-            if (caseIndentStore[switchNode.loc.start.line]) {
-                return caseIndentStore[switchNode.loc.start.line];
-            }
-            if (typeof switchIndent === "undefined") {
-                switchIndent = getNodeIndent(switchNode).goodChar;
-            }
-
-            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
-                caseIndent = switchIndent;
-            } else {
-                caseIndent = switchIndent + (indentSize * options.SwitchCase);
-            }
-
-            caseIndentStore[switchNode.loc.start.line] = caseIndent;
-            return caseIndent;
-
-        }
-
-        /**
-         * Checks wether a return statement is wrapped in ()
-         * @param {ASTNode} node node to examine
-         * @returns {boolean} the result
-         */
-        function isWrappedInParenthesis(node) {
-            const regex = /^return\s*?\(\s*?\);*?/;
-
-            const statementWithoutArgument = sourceCode.getText(node).replace(
-                sourceCode.getText(node.argument), ""
-            );
-
-            return regex.test(statementWithoutArgument);
-        }
-
-        return {
-            Program(node) {
-                if (node.body.length > 0) {
-
-                    // Root nodes should have no indent
-                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);
-                }
-            },
-
-            ClassBody: blockIndentationCheck,
-
-            BlockStatement: blockIndentationCheck,
-
-            WhileStatement: blockLessNodes,
-
-            ForStatement: blockLessNodes,
-
-            ForInStatement: blockLessNodes,
-
-            ForOfStatement: blockLessNodes,
-
-            DoWhileStatement: blockLessNodes,
-
-            IfStatement(node) {
-                if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
-                    blockIndentationCheck(node);
-                }
-            },
-
-            VariableDeclaration(node) {
-                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
-                    checkIndentInVariableDeclarations(node);
-                }
-            },
-
-            ObjectExpression(node) {
-                checkIndentInArrayOrObjectBlock(node);
-            },
-
-            ArrayExpression(node) {
-                checkIndentInArrayOrObjectBlock(node);
-            },
-
-            MemberExpression(node) {
-
-                if (typeof options.MemberExpression === "undefined") {
-                    return;
-                }
-
-                if (isSingleLineNode(node)) {
-                    return;
-                }
-
-                // The typical layout of variable declarations and assignments
-                // alter the expectation of correct indentation. Skip them.
-                // TODO: Add appropriate configuration options for variable
-                // declarations and assignments.
-                if (getParentNodeByType(node, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"])) {
-                    return;
-                }
-
-                if (getParentNodeByType(node, "AssignmentExpression", ["FunctionExpression"])) {
-                    return;
-                }
-
-                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;
-
-                const checkNodes = [node.property];
-
-                const dot = sourceCode.getTokenBefore(node.property);
-
-                if (dot.type === "Punctuator" && dot.value === ".") {
-                    checkNodes.push(dot);
-                }
-
-                checkNodesIndent(checkNodes, propertyIndent);
-            },
-
-            SwitchStatement(node) {
-
-                // Switch is not a 'BlockStatement'
-                const switchIndent = getNodeIndent(node).goodChar;
-                const caseIndent = expectedCaseIndent(node, switchIndent);
-
-                checkNodesIndent(node.cases, caseIndent);
-
-
-                checkLastNodeLineIndent(node, switchIndent);
-            },
-
-            SwitchCase(node) {
-
-                // Skip inline cases
-                if (isSingleLineNode(node)) {
-                    return;
-                }
-                const caseIndent = expectedCaseIndent(node);
-
-                checkNodesIndent(node.consequent, caseIndent + indentSize);
-            },
-
-            FunctionDeclaration(node) {
-                if (isSingleLineNode(node)) {
-                    return;
-                }
-                if (options.FunctionDeclaration.parameters === "first" && node.params.length) {
-                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
-                } else if (options.FunctionDeclaration.parameters !== null) {
-                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);
-                }
-            },
-
-            FunctionExpression(node) {
-                if (isSingleLineNode(node)) {
-                    return;
-                }
-                if (options.FunctionExpression.parameters === "first" && node.params.length) {
-                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
-                } else if (options.FunctionExpression.parameters !== null) {
-                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);
-                }
-            },
-
-            ReturnStatement(node) {
-                if (isSingleLineNode(node)) {
-                    return;
-                }
-
-                const firstLineIndent = getNodeIndent(node).goodChar;
-
-                // in case if return statement is wrapped in parenthesis
-                if (isWrappedInParenthesis(node)) {
-                    checkLastReturnStatementLineIndent(node, firstLineIndent);
-                } else {
-                    checkNodeIndent(node, firstLineIndent);
-                }
-            },
-
-            CallExpression(node) {
-                if (isSingleLineNode(node)) {
-                    return;
-                }
-                if (options.CallExpression.arguments === "first" && node.arguments.length) {
-                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);
-                } else if (options.CallExpression.arguments !== null) {
-                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-delete-var.js
===================================================================
--- node_modules/eslint/lib/rules/no-delete-var.js	(revision )
+++ node_modules/eslint/lib/rules/no-delete-var.js	(revision )
@@ -1,35 +0,0 @@
-/**
- * @fileoverview Rule to flag when deleting variables
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow deleting variables",
-            category: "Variables",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            UnaryExpression(node) {
-                if (node.operator === "delete" && node.argument.type === "Identifier") {
-                    context.report({ node, message: "Variables should not be deleted." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-extra-bind.js
===================================================================
--- node_modules/eslint/lib/rules/no-extra-bind.js	(revision )
+++ node_modules/eslint/lib/rules/no-extra-bind.js	(revision )
@@ -1,145 +0,0 @@
-/**
- * @fileoverview Rule to flag unnecessary bind calls
- * @author Bence Dányi <bence@danyi.me>
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary calls to `.bind()`",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        let scopeInfo = null;
-
-        /**
-         * Reports a given function node.
-         *
-         * @param {ASTNode} node - A node to report. This is a FunctionExpression or
-         *      an ArrowFunctionExpression.
-         * @returns {void}
-         */
-        function report(node) {
-            context.report({
-                node: node.parent.parent,
-                message: "The function binding is unnecessary.",
-                loc: node.parent.property.loc.start,
-                fix(fixer) {
-                    const firstTokenToRemove = context.getSourceCode()
-                        .getFirstTokenBetween(node.parent.object, node.parent.property, astUtils.isNotClosingParenToken);
-
-                    return fixer.removeRange([firstTokenToRemove.range[0], node.parent.parent.range[1]]);
-                }
-            });
-        }
-
-        /**
-         * Checks whether or not a given function node is the callee of `.bind()`
-         * method.
-         *
-         * e.g. `(function() {}.bind(foo))`
-         *
-         * @param {ASTNode} node - A node to report. This is a FunctionExpression or
-         *      an ArrowFunctionExpression.
-         * @returns {boolean} `true` if the node is the callee of `.bind()` method.
-         */
-        function isCalleeOfBindMethod(node) {
-            const parent = node.parent;
-            const grandparent = parent.parent;
-
-            return (
-                grandparent &&
-                grandparent.type === "CallExpression" &&
-                grandparent.callee === parent &&
-                grandparent.arguments.length === 1 &&
-                parent.type === "MemberExpression" &&
-                parent.object === node &&
-                astUtils.getStaticPropertyName(parent) === "bind"
-            );
-        }
-
-        /**
-         * Adds a scope information object to the stack.
-         *
-         * @param {ASTNode} node - A node to add. This node is a FunctionExpression
-         *      or a FunctionDeclaration node.
-         * @returns {void}
-         */
-        function enterFunction(node) {
-            scopeInfo = {
-                isBound: isCalleeOfBindMethod(node),
-                thisFound: false,
-                upper: scopeInfo
-            };
-        }
-
-        /**
-         * Removes the scope information object from the top of the stack.
-         * At the same time, this reports the function node if the function has
-         * `.bind()` and the `this` keywords found.
-         *
-         * @param {ASTNode} node - A node to remove. This node is a
-         *      FunctionExpression or a FunctionDeclaration node.
-         * @returns {void}
-         */
-        function exitFunction(node) {
-            if (scopeInfo.isBound && !scopeInfo.thisFound) {
-                report(node);
-            }
-
-            scopeInfo = scopeInfo.upper;
-        }
-
-        /**
-         * Reports a given arrow function if the function is callee of `.bind()`
-         * method.
-         *
-         * @param {ASTNode} node - A node to report. This node is an
-         *      ArrowFunctionExpression.
-         * @returns {void}
-         */
-        function exitArrowFunction(node) {
-            if (isCalleeOfBindMethod(node)) {
-                report(node);
-            }
-        }
-
-        /**
-         * Set the mark as the `this` keyword was found in this scope.
-         *
-         * @returns {void}
-         */
-        function markAsThisFound() {
-            if (scopeInfo) {
-                scopeInfo.thisFound = true;
-            }
-        }
-
-        return {
-            "ArrowFunctionExpression:exit": exitArrowFunction,
-            FunctionDeclaration: enterFunction,
-            "FunctionDeclaration:exit": exitFunction,
-            FunctionExpression: enterFunction,
-            "FunctionExpression:exit": exitFunction,
-            ThisExpression: markAsThisFound
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-extra-semi.js
===================================================================
--- node_modules/eslint/lib/rules/no-extra-semi.js	(revision )
+++ node_modules/eslint/lib/rules/no-extra-semi.js	(revision )
@@ -1,118 +0,0 @@
-/**
- * @fileoverview Rule to flag use of unnecessary semicolons
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const FixTracker = require("../util/fix-tracker");
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary semicolons",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        fixable: "code",
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Reports an unnecessary semicolon error.
-         * @param {Node|Token} nodeOrToken - A node or a token to be reported.
-         * @returns {void}
-         */
-        function report(nodeOrToken) {
-            context.report({
-                node: nodeOrToken,
-                message: "Unnecessary semicolon.",
-                fix(fixer) {
-
-                    // Expand the replacement range to include the surrounding
-                    // tokens to avoid conflicting with semi.
-                    // https://github.com/eslint/eslint/issues/7928
-                    return new FixTracker(fixer, context.getSourceCode())
-                        .retainSurroundingTokens(nodeOrToken)
-                        .remove(nodeOrToken);
-                }
-            });
-        }
-
-        /**
-         * Checks for a part of a class body.
-         * This checks tokens from a specified token to a next MethodDefinition or the end of class body.
-         *
-         * @param {Token} firstToken - The first token to check.
-         * @returns {void}
-         */
-        function checkForPartOfClassBody(firstToken) {
-            for (let token = firstToken;
-                token.type === "Punctuator" && !astUtils.isClosingBraceToken(token);
-                token = sourceCode.getTokenAfter(token)
-            ) {
-                if (astUtils.isSemicolonToken(token)) {
-                    report(token);
-                }
-            }
-        }
-
-        return {
-
-            /**
-             * Reports this empty statement, except if the parent node is a loop.
-             * @param {Node} node - A EmptyStatement node to be reported.
-             * @returns {void}
-             */
-            EmptyStatement(node) {
-                const parent = node.parent,
-                    allowedParentTypes = [
-                        "ForStatement",
-                        "ForInStatement",
-                        "ForOfStatement",
-                        "WhileStatement",
-                        "DoWhileStatement",
-                        "IfStatement",
-                        "LabeledStatement",
-                        "WithStatement"
-                    ];
-
-                if (allowedParentTypes.indexOf(parent.type) === -1) {
-                    report(node);
-                }
-            },
-
-            /**
-             * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.
-             * @param {Node} node - A ClassBody node to check.
-             * @returns {void}
-             */
-            ClassBody(node) {
-                checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.
-            },
-
-            /**
-             * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.
-             * @param {Node} node - A MethodDefinition node of the start point.
-             * @returns {void}
-             */
-            MethodDefinition(node) {
-                checkForPartOfClassBody(sourceCode.getTokenAfter(node));
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-new-object.js
===================================================================
--- node_modules/eslint/lib/rules/no-new-object.js	(revision )
+++ node_modules/eslint/lib/rules/no-new-object.js	(revision )
@@ -1,35 +0,0 @@
-/**
- * @fileoverview A rule to disallow calls to the Object constructor
- * @author Matt DuVall <http://www.mattduvall.com/>
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `Object` constructors",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            NewExpression(node) {
-                if (node.callee.name === "Object") {
-                    context.report({ node, message: "The object literal notation {} is preferrable." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-new-symbol.js
===================================================================
--- node_modules/eslint/lib/rules/no-new-symbol.js	(revision )
+++ node_modules/eslint/lib/rules/no-new-symbol.js	(revision )
@@ -1,43 +0,0 @@
-/**
- * @fileoverview Rule to disallow use of the new operator with the `Symbol` object
- * @author Alberto Rodríguez
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `new` operators with the `Symbol` object",
-            category: "ECMAScript 6",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-            "Program:exit"() {
-                const globalScope = context.getScope();
-                const variable = globalScope.set.get("Symbol");
-
-                if (variable && variable.defs.length === 0) {
-                    variable.references.forEach(ref => {
-                        const node = ref.identifier;
-
-                        if (node.parent && node.parent.type === "NewExpression") {
-                            context.report({ node, message: "`Symbol` cannot be called as a constructor." });
-                        }
-                    });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-script-url.js
===================================================================
--- node_modules/eslint/lib/rules/no-script-url.js	(revision )
+++ node_modules/eslint/lib/rules/no-script-url.js	(revision )
@@ -1,41 +0,0 @@
-/**
- * @fileoverview Rule to flag when using javascript: urls
- * @author Ilya Volodin
- */
-/* jshint scripturl: true */
-/* eslint no-script-url: 0 */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `javascript:` urls",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            Literal(node) {
-                if (node.value && typeof node.value === "string") {
-                    const value = node.value.toLowerCase();
-
-                    if (value.indexOf("javascript:") === 0) {
-                        context.report({ node, message: "Script URL is a form of eval." });
-                    }
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-undef-init.js
===================================================================
--- node_modules/eslint/lib/rules/no-undef-init.js	(revision )
+++ node_modules/eslint/lib/rules/no-undef-init.js	(revision )
@@ -1,63 +0,0 @@
-/**
- * @fileoverview Rule to flag when initializing to undefined
- * @author Ilya Volodin
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow initializing variables to `undefined`",
-            category: "Variables",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-
-        const sourceCode = context.getSourceCode();
-
-        return {
-
-            VariableDeclarator(node) {
-                const name = sourceCode.getText(node.id),
-                    init = node.init && node.init.name,
-                    scope = context.getScope(),
-                    undefinedVar = astUtils.getVariableByName(scope, "undefined"),
-                    shadowed = undefinedVar && undefinedVar.defs.length > 0;
-
-                if (init === "undefined" && node.parent.kind !== "const" && !shadowed) {
-                    context.report({
-                        node,
-                        message: "It's not necessary to initialize '{{name}}' to undefined.",
-                        data: { name },
-                        fix(fixer) {
-                            if (node.parent.kind === "var") {
-                                return null;
-                            }
-
-                            if (node.id.type === "ArrayPattern" || node.id.type === "ObjectPattern") {
-
-                                // Don't fix destructuring assignment to `undefined`.
-                                return null;
-                            }
-                            return fixer.removeRange([node.id.range[1], node.range[1]]);
-                        }
-                    });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/padded-blocks.js
===================================================================
--- node_modules/eslint/lib/rules/padded-blocks.js	(revision )
+++ node_modules/eslint/lib/rules/padded-blocks.js	(revision )
@@ -1,256 +0,0 @@
-/**
- * @fileoverview A rule to ensure blank lines within blocks.
- * @author Mathias Schreck <https://github.com/lo1tuma>
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow padding within blocks",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["always", "never"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            blocks: {
-                                enum: ["always", "never"]
-                            },
-                            switches: {
-                                enum: ["always", "never"]
-                            },
-                            classes: {
-                                enum: ["always", "never"]
-                            }
-                        },
-                        additionalProperties: false,
-                        minProperties: 1
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const options = {};
-        const config = context.options[0] || "always";
-
-        if (typeof config === "string") {
-            const shouldHavePadding = config === "always";
-
-            options.blocks = shouldHavePadding;
-            options.switches = shouldHavePadding;
-            options.classes = shouldHavePadding;
-        } else {
-            if (config.hasOwnProperty("blocks")) {
-                options.blocks = config.blocks === "always";
-            }
-            if (config.hasOwnProperty("switches")) {
-                options.switches = config.switches === "always";
-            }
-            if (config.hasOwnProperty("classes")) {
-                options.classes = config.classes === "always";
-            }
-        }
-
-        const ALWAYS_MESSAGE = "Block must be padded by blank lines.",
-            NEVER_MESSAGE = "Block must not be padded by blank lines.";
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Gets the open brace token from a given node.
-         * @param {ASTNode} node - A BlockStatement or SwitchStatement node from which to get the open brace.
-         * @returns {Token} The token of the open brace.
-         */
-        function getOpenBrace(node) {
-            if (node.type === "SwitchStatement") {
-                return sourceCode.getTokenBefore(node.cases[0]);
-            }
-            return sourceCode.getFirstToken(node);
-        }
-
-        /**
-         * Checks if the given parameter is a comment node
-         * @param {ASTNode|Token} node An AST node or token
-         * @returns {boolean} True if node is a comment
-         */
-        function isComment(node) {
-            return node.type === "Line" || node.type === "Block";
-        }
-
-        /**
-         * Checks if there is padding between two tokens
-         * @param {Token} first The first token
-         * @param {Token} second The second token
-         * @returns {boolean} True if there is at least a line between the tokens
-         */
-        function isPaddingBetweenTokens(first, second) {
-            return second.loc.start.line - first.loc.end.line >= 2;
-        }
-
-
-        /**
-         * Checks if the given token has a blank line after it.
-         * @param {Token} token The token to check.
-         * @returns {boolean} Whether or not the token is followed by a blank line.
-         */
-        function getFirstBlockToken(token) {
-            let prev,
-                first = token;
-
-            do {
-                prev = first;
-                first = sourceCode.getTokenAfter(first, { includeComments: true });
-            } while (isComment(first) && first.loc.start.line === prev.loc.end.line);
-
-            return first;
-        }
-
-        /**
-         * Checks if the given token is preceeded by a blank line.
-         * @param {Token} token The token to check
-         * @returns {boolean} Whether or not the token is preceeded by a blank line
-         */
-        function getLastBlockToken(token) {
-            let last = token,
-                next;
-
-            do {
-                next = last;
-                last = sourceCode.getTokenBefore(last, { includeComments: true });
-            } while (isComment(last) && last.loc.end.line === next.loc.start.line);
-
-            return last;
-        }
-
-        /**
-         * Checks if a node should be padded, according to the rule config.
-         * @param {ASTNode} node The AST node to check.
-         * @returns {boolean} True if the node should be padded, false otherwise.
-         */
-        function requirePaddingFor(node) {
-            switch (node.type) {
-                case "BlockStatement":
-                    return options.blocks;
-                case "SwitchStatement":
-                    return options.switches;
-                case "ClassBody":
-                    return options.classes;
-
-                /* istanbul ignore next */
-                default:
-                    throw new Error("unreachable");
-            }
-        }
-
-        /**
-         * Checks the given BlockStatement node to be padded if the block is not empty.
-         * @param {ASTNode} node The AST node of a BlockStatement.
-         * @returns {void} undefined.
-         */
-        function checkPadding(node) {
-            const openBrace = getOpenBrace(node),
-                firstBlockToken = getFirstBlockToken(openBrace),
-                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),
-                closeBrace = sourceCode.getLastToken(node),
-                lastBlockToken = getLastBlockToken(closeBrace),
-                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),
-                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),
-                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);
-
-            if (requirePaddingFor(node)) {
-                if (!blockHasTopPadding) {
-                    context.report({
-                        node,
-                        loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },
-                        fix(fixer) {
-                            return fixer.insertTextAfter(tokenBeforeFirst, "\n");
-                        },
-                        message: ALWAYS_MESSAGE
-                    });
-                }
-                if (!blockHasBottomPadding) {
-                    context.report({
-                        node,
-                        loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },
-                        fix(fixer) {
-                            return fixer.insertTextBefore(tokenAfterLast, "\n");
-                        },
-                        message: ALWAYS_MESSAGE
-                    });
-                }
-            } else {
-                if (blockHasTopPadding) {
-
-                    context.report({
-                        node,
-                        loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },
-                        fix(fixer) {
-                            return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], "\n");
-                        },
-                        message: NEVER_MESSAGE
-                    });
-                }
-
-                if (blockHasBottomPadding) {
-
-                    context.report({
-                        node,
-                        loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },
-                        message: NEVER_MESSAGE,
-                        fix(fixer) {
-                            return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], "\n");
-                        }
-                    });
-                }
-            }
-        }
-
-        const rule = {};
-
-        if (options.hasOwnProperty("switches")) {
-            rule.SwitchStatement = function(node) {
-                if (node.cases.length === 0) {
-                    return;
-                }
-                checkPadding(node);
-            };
-        }
-
-        if (options.hasOwnProperty("blocks")) {
-            rule.BlockStatement = function(node) {
-                if (node.body.length === 0) {
-                    return;
-                }
-                checkPadding(node);
-            };
-        }
-
-        if (options.hasOwnProperty("classes")) {
-            rule.ClassBody = function(node) {
-                if (node.body.length === 0) {
-                    return;
-                }
-                checkPadding(node);
-            };
-        }
-
-        return rule;
-    }
-};
Index: node_modules/eslint/lib/rules/prefer-spread.js
===================================================================
--- node_modules/eslint/lib/rules/prefer-spread.js	(revision )
+++ node_modules/eslint/lib/rules/prefer-spread.js	(revision )
@@ -1,120 +0,0 @@
-/**
- * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a node is a `.apply()` for variadic.
- * @param {ASTNode} node - A CallExpression node to check.
- * @returns {boolean} Whether or not the node is a `.apply()` for variadic.
- */
-function isVariadicApplyCalling(node) {
-    return (
-        node.callee.type === "MemberExpression" &&
-        node.callee.property.type === "Identifier" &&
-        node.callee.property.name === "apply" &&
-        node.callee.computed === false &&
-        node.arguments.length === 2 &&
-        node.arguments[1].type !== "ArrayExpression" &&
-        node.arguments[1].type !== "SpreadElement"
-    );
-}
-
-/**
- * Checks whether or not the tokens of two given nodes are same.
- * @param {ASTNode} left - A node 1 to compare.
- * @param {ASTNode} right - A node 2 to compare.
- * @param {SourceCode} sourceCode - The ESLint source code object.
- * @returns {boolean} the source code for the given node.
- */
-function equalTokens(left, right, sourceCode) {
-    const tokensL = sourceCode.getTokens(left);
-    const tokensR = sourceCode.getTokens(right);
-
-    if (tokensL.length !== tokensR.length) {
-        return false;
-    }
-    for (let i = 0; i < tokensL.length; ++i) {
-        if (tokensL[i].type !== tokensR[i].type ||
-            tokensL[i].value !== tokensR[i].value
-        ) {
-            return false;
-        }
-    }
-
-    return true;
-}
-
-/**
- * Checks whether or not `thisArg` is not changed by `.apply()`.
- * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.
- * @param {ASTNode} thisArg - The node that is given to the first argument of the `.apply()`.
- * @param {RuleContext} context - The ESLint rule context object.
- * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.
- */
-function isValidThisArg(expectedThis, thisArg, context) {
-    if (!expectedThis) {
-        return astUtils.isNullOrUndefined(thisArg);
-    }
-    return equalTokens(expectedThis, thisArg, context);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require spread operators instead of `.apply()`",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-            CallExpression(node) {
-                if (!isVariadicApplyCalling(node)) {
-                    return;
-                }
-
-                const applied = node.callee.object;
-                const expectedThis = (applied.type === "MemberExpression") ? applied.object : null;
-                const thisArg = node.arguments[0];
-
-                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
-                    context.report({
-                        node,
-                        message: "Use the spread operator instead of '.apply()'.",
-                        fix(fixer) {
-                            if (expectedThis && expectedThis.type !== "Identifier") {
-
-                                // Don't fix cases where the `this` value could be a computed expression.
-                                return null;
-                            }
-
-                            const propertyDot = sourceCode.getFirstTokenBetween(applied, node.callee.property, token => token.value === ".");
-
-                            return fixer.replaceTextRange([propertyDot.range[0], node.range[1]], `(...${sourceCode.getText(node.arguments[1])})`);
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/require-await.js
===================================================================
--- node_modules/eslint/lib/rules/require-await.js	(revision )
+++ node_modules/eslint/lib/rules/require-await.js	(revision )
@@ -1,95 +0,0 @@
-/**
- * @fileoverview Rule to disallow async functions which have no `await` expression.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Capitalize the 1st letter of the given text.
- *
- * @param {string} text - The text to capitalize.
- * @returns {string} The text that the 1st letter was capitalized.
- */
-function capitalizeFirstLetter(text) {
-    return text[0].toUpperCase() + text.slice(1);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow async functions which have no `await` expression",
-            category: "Best Practices",
-            recommended: false
-        },
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        let scopeInfo = null;
-
-        /**
-         * Push the scope info object to the stack.
-         *
-         * @returns {void}
-         */
-        function enterFunction() {
-            scopeInfo = {
-                upper: scopeInfo,
-                hasAwait: false
-            };
-        }
-
-        /**
-         * Pop the top scope info object from the stack.
-         * Also, it reports the function if needed.
-         *
-         * @param {ASTNode} node - The node to report.
-         * @returns {void}
-         */
-        function exitFunction(node) {
-            if (node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {
-                context.report({
-                    node,
-                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),
-                    message: "{{name}} has no 'await' expression.",
-                    data: {
-                        name: capitalizeFirstLetter(
-                            astUtils.getFunctionNameWithKind(node)
-                        )
-                    }
-                });
-            }
-
-            scopeInfo = scopeInfo.upper;
-        }
-
-        return {
-            FunctionDeclaration: enterFunction,
-            FunctionExpression: enterFunction,
-            ArrowFunctionExpression: enterFunction,
-            "FunctionDeclaration:exit": exitFunction,
-            "FunctionExpression:exit": exitFunction,
-            "ArrowFunctionExpression:exit": exitFunction,
-
-            AwaitExpression() {
-                scopeInfo.hasAwait = true;
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/require-jsdoc.js
===================================================================
--- node_modules/eslint/lib/rules/require-jsdoc.js	(revision )
+++ node_modules/eslint/lib/rules/require-jsdoc.js	(revision )
@@ -1,112 +0,0 @@
-/**
- * @fileoverview Rule to check for jsdoc presence.
- * @author Gyandeep Singh
- */
-"use strict";
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require JSDoc comments",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    require: {
-                        type: "object",
-                        properties: {
-                            ClassDeclaration: {
-                                type: "boolean"
-                            },
-                            MethodDefinition: {
-                                type: "boolean"
-                            },
-                            FunctionDeclaration: {
-                                type: "boolean"
-                            },
-                            ArrowFunctionExpression: {
-                                type: "boolean"
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const source = context.getSourceCode();
-        const DEFAULT_OPTIONS = {
-            FunctionDeclaration: true,
-            MethodDefinition: false,
-            ClassDeclaration: false
-        };
-        const options = Object.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require || {});
-
-        /**
-         * Report the error message
-         * @param {ASTNode} node node to report
-         * @returns {void}
-         */
-        function report(node) {
-            context.report({ node, message: "Missing JSDoc comment." });
-        }
-
-        /**
-         * Check if the jsdoc comment is present for class methods
-         * @param {ASTNode} node node to examine
-         * @returns {void}
-         */
-        function checkClassMethodJsDoc(node) {
-            if (node.parent.type === "MethodDefinition") {
-                const jsdocComment = source.getJSDocComment(node);
-
-                if (!jsdocComment) {
-                    report(node);
-                }
-            }
-        }
-
-        /**
-         * Check if the jsdoc comment is present or not.
-         * @param {ASTNode} node node to examine
-         * @returns {void}
-         */
-        function checkJsDoc(node) {
-            const jsdocComment = source.getJSDocComment(node);
-
-            if (!jsdocComment) {
-                report(node);
-            }
-        }
-
-        return {
-            FunctionDeclaration(node) {
-                if (options.FunctionDeclaration) {
-                    checkJsDoc(node);
-                }
-            },
-            FunctionExpression(node) {
-                if (options.MethodDefinition) {
-                    checkClassMethodJsDoc(node);
-                }
-            },
-            ClassDeclaration(node) {
-                if (options.ClassDeclaration) {
-                    checkJsDoc(node);
-                }
-            },
-            ArrowFunctionExpression(node) {
-                if (options.ArrowFunctionExpression && node.parent.type === "VariableDeclarator") {
-                    checkJsDoc(node);
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/require-yield.js
===================================================================
--- node_modules/eslint/lib/rules/require-yield.js	(revision )
+++ node_modules/eslint/lib/rules/require-yield.js	(revision )
@@ -1,71 +0,0 @@
-/**
- * @fileoverview Rule to flag the generator functions that does not have yield.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require generator functions to contain `yield`",
-            category: "ECMAScript 6",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const stack = [];
-
-        /**
-         * If the node is a generator function, start counting `yield` keywords.
-         * @param {Node} node - A function node to check.
-         * @returns {void}
-         */
-        function beginChecking(node) {
-            if (node.generator) {
-                stack.push(0);
-            }
-        }
-
-        /**
-         * If the node is a generator function, end counting `yield` keywords, then
-         * reports result.
-         * @param {Node} node - A function node to check.
-         * @returns {void}
-         */
-        function endChecking(node) {
-            if (!node.generator) {
-                return;
-            }
-
-            const countYield = stack.pop();
-
-            if (countYield === 0 && node.body.body.length > 0) {
-                context.report({ node, message: "This generator function does not have 'yield'." });
-            }
-        }
-
-        return {
-            FunctionDeclaration: beginChecking,
-            "FunctionDeclaration:exit": endChecking,
-            FunctionExpression: beginChecking,
-            "FunctionExpression:exit": endChecking,
-
-            // Increases the count of `yield` keyword.
-            YieldExpression() {
-
-                /* istanbul ignore else */
-                if (stack.length > 0) {
-                    stack[stack.length - 1] += 1;
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/accessor-pairs.js
===================================================================
--- node_modules/eslint/lib/rules/accessor-pairs.js	(revision )
+++ node_modules/eslint/lib/rules/accessor-pairs.js	(revision )
@@ -1,156 +0,0 @@
-/**
- * @fileoverview Rule to flag wrapping non-iife in parens
- * @author Gyandeep Singh
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a given node is an `Identifier` node which was named a given name.
- * @param {ASTNode} node - A node to check.
- * @param {string} name - An expected name of the node.
- * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.
- */
-function isIdentifier(node, name) {
-    return node.type === "Identifier" && node.name === name;
-}
-
-/**
- * Checks whether or not a given node is an argument of a specified method call.
- * @param {ASTNode} node - A node to check.
- * @param {number} index - An expected index of the node in arguments.
- * @param {string} object - An expected name of the object of the method.
- * @param {string} property - An expected name of the method.
- * @returns {boolean} `true` if the node is an argument of the specified method call.
- */
-function isArgumentOfMethodCall(node, index, object, property) {
-    const parent = node.parent;
-
-    return (
-        parent.type === "CallExpression" &&
-        parent.callee.type === "MemberExpression" &&
-        parent.callee.computed === false &&
-        isIdentifier(parent.callee.object, object) &&
-        isIdentifier(parent.callee.property, property) &&
-        parent.arguments[index] === node
-    );
-}
-
-/**
- * Checks whether or not a given node is a property descriptor.
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} `true` if the node is a property descriptor.
- */
-function isPropertyDescriptor(node) {
-
-    // Object.defineProperty(obj, "foo", {set: ...})
-    if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") ||
-        isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")
-    ) {
-        return true;
-    }
-
-    /*
-     * Object.defineProperties(obj, {foo: {set: ...}})
-     * Object.create(proto, {foo: {set: ...}})
-     */
-    node = node.parent.parent;
-
-    return node.type === "ObjectExpression" && (
-        isArgumentOfMethodCall(node, 1, "Object", "create") ||
-        isArgumentOfMethodCall(node, 1, "Object", "defineProperties")
-    );
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce getter and setter pairs in objects",
-            category: "Best Practices",
-            recommended: false
-        },
-        schema: [{
-            type: "object",
-            properties: {
-                getWithoutSet: {
-                    type: "boolean"
-                },
-                setWithoutGet: {
-                    type: "boolean"
-                }
-            },
-            additionalProperties: false
-        }]
-    },
-    create(context) {
-        const config = context.options[0] || {};
-        const checkGetWithoutSet = config.getWithoutSet === true;
-        const checkSetWithoutGet = config.setWithoutGet !== false;
-
-        /**
-         * Checks a object expression to see if it has setter and getter both present or none.
-         * @param {ASTNode} node The node to check.
-         * @returns {void}
-         * @private
-         */
-        function checkLonelySetGet(node) {
-            let isSetPresent = false;
-            let isGetPresent = false;
-            const isDescriptor = isPropertyDescriptor(node);
-
-            for (let i = 0, end = node.properties.length; i < end; i++) {
-                const property = node.properties[i];
-
-                let propToCheck = "";
-
-                if (property.kind === "init") {
-                    if (isDescriptor && !property.computed) {
-                        propToCheck = property.key.name;
-                    }
-                } else {
-                    propToCheck = property.kind;
-                }
-
-                switch (propToCheck) {
-                    case "set":
-                        isSetPresent = true;
-                        break;
-
-                    case "get":
-                        isGetPresent = true;
-                        break;
-
-                    default:
-
-                        // Do nothing
-                }
-
-                if (isSetPresent && isGetPresent) {
-                    break;
-                }
-            }
-
-            if (checkSetWithoutGet && isSetPresent && !isGetPresent) {
-                context.report({ node, message: "Getter is not present." });
-            } else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {
-                context.report({ node, message: "Setter is not present." });
-            }
-        }
-
-        return {
-            ObjectExpression(node) {
-                if (checkSetWithoutGet || checkGetWithoutSet) {
-                    checkLonelySetGet(node);
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/global-require.js
===================================================================
--- node_modules/eslint/lib/rules/global-require.js	(revision )
+++ node_modules/eslint/lib/rules/global-require.js	(revision )
@@ -1,75 +0,0 @@
-/**
- * @fileoverview Rule for disallowing require() outside of the top-level module context
- * @author Jamund Ferguson
- */
-
-"use strict";
-
-const ACCEPTABLE_PARENTS = [
-    "AssignmentExpression",
-    "VariableDeclarator",
-    "MemberExpression",
-    "ExpressionStatement",
-    "CallExpression",
-    "ConditionalExpression",
-    "Program",
-    "VariableDeclaration"
-];
-
-/**
- * Finds the eslint-scope reference in the given scope.
- * @param {Object} scope The scope to search.
- * @param {ASTNode} node The identifier node.
- * @returns {Reference|null} Returns the found reference or null if none were found.
- */
-function findReference(scope, node) {
-    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&
-            reference.identifier.range[1] === node.range[1]);
-
-    /* istanbul ignore else: correctly returns null */
-    if (references.length === 1) {
-        return references[0];
-    }
-    return null;
-
-}
-
-/**
- * Checks if the given identifier node is shadowed in the given scope.
- * @param {Object} scope The current scope.
- * @param {ASTNode} node The identifier node to check.
- * @returns {boolean} Whether or not the name is shadowed.
- */
-function isShadowed(scope, node) {
-    const reference = findReference(scope, node);
-
-    return reference && reference.resolved && reference.resolved.defs.length > 0;
-}
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require `require()` calls to be placed at top-level module scope",
-            category: "Node.js and CommonJS",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        return {
-            CallExpression(node) {
-                const currentScope = context.getScope();
-
-                if (node.callee.name === "require" && !isShadowed(currentScope, node.callee)) {
-                    const isGoodRequire = context.getAncestors().every(parent => ACCEPTABLE_PARENTS.indexOf(parent.type) > -1);
-
-                    if (!isGoodRequire) {
-                        context.report({ node, message: "Unexpected require()." });
-                    }
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/max-statements.js
===================================================================
--- node_modules/eslint/lib/rules/max-statements.js	(revision )
+++ node_modules/eslint/lib/rules/max-statements.js	(revision )
@@ -1,170 +0,0 @@
-/**
- * @fileoverview A rule to set the maximum number of statements in a function.
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce a maximum number of statements allowed in function blocks",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            maximum: {
-                                type: "integer",
-                                minimum: 0
-                            },
-                            max: {
-                                type: "integer",
-                                minimum: 0
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            },
-            {
-                type: "object",
-                properties: {
-                    ignoreTopLevelFunctions: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        const functionStack = [],
-            option = context.options[0],
-            ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,
-            topLevelFunctions = [];
-        let maxStatements = 10;
-
-        if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
-            maxStatements = option.maximum;
-        }
-        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
-            maxStatements = option.max;
-        }
-        if (typeof option === "number") {
-            maxStatements = option;
-        }
-
-        /**
-         * Reports a node if it has too many statements
-         * @param {ASTNode} node node to evaluate
-         * @param {int} count Number of statements in node
-         * @param {int} max Maximum number of statements allowed
-         * @returns {void}
-         * @private
-         */
-        function reportIfTooManyStatements(node, count, max) {
-            if (count > max) {
-                const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));
-
-                context.report({
-                    node,
-                    message: "{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}.",
-                    data: { name, count, max }
-                });
-            }
-        }
-
-        /**
-         * When parsing a new function, store it in our function stack
-         * @returns {void}
-         * @private
-         */
-        function startFunction() {
-            functionStack.push(0);
-        }
-
-        /**
-         * Evaluate the node at the end of function
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function endFunction(node) {
-            const count = functionStack.pop();
-
-            if (ignoreTopLevelFunctions && functionStack.length === 0) {
-                topLevelFunctions.push({ node, count });
-            } else {
-                reportIfTooManyStatements(node, count, maxStatements);
-            }
-        }
-
-        /**
-         * Increment the count of the functions
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function countStatements(node) {
-            functionStack[functionStack.length - 1] += node.body.length;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            FunctionDeclaration: startFunction,
-            FunctionExpression: startFunction,
-            ArrowFunctionExpression: startFunction,
-
-            BlockStatement: countStatements,
-
-            "FunctionDeclaration:exit": endFunction,
-            "FunctionExpression:exit": endFunction,
-            "ArrowFunctionExpression:exit": endFunction,
-
-            "Program:exit"() {
-                if (topLevelFunctions.length === 1) {
-                    return;
-                }
-
-                topLevelFunctions.forEach(element => {
-                    const count = element.count;
-                    const node = element.node;
-
-                    reportIfTooManyStatements(node, count, maxStatements);
-                });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-cond-assign.js
===================================================================
--- node_modules/eslint/lib/rules/no-cond-assign.js	(revision )
+++ node_modules/eslint/lib/rules/no-cond-assign.js	(revision )
@@ -1,139 +0,0 @@
-/**
- * @fileoverview Rule to flag assignment in a conditional statement's test expression
- * @author Stephen Murray <spmurrayzzz>
- */
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-const NODE_DESCRIPTIONS = {
-    DoWhileStatement: "a 'do...while' statement",
-    ForStatement: "a 'for' statement",
-    IfStatement: "an 'if' statement",
-    WhileStatement: "a 'while' statement"
-};
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow assignment operators in conditional expressions",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: [
-            {
-                enum: ["except-parens", "always"]
-            }
-        ]
-    },
-
-    create(context) {
-
-        const prohibitAssign = (context.options[0] || "except-parens");
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Check whether an AST node is the test expression for a conditional statement.
-         * @param {!Object} node The node to test.
-         * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.
-         */
-        function isConditionalTestExpression(node) {
-            return node.parent &&
-                node.parent.test &&
-                node === node.parent.test;
-        }
-
-        /**
-         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.
-         * @param {!Object} node The node to use at the start of the search.
-         * @returns {?Object} The closest ancestor node that represents a conditional statement.
-         */
-        function findConditionalAncestor(node) {
-            let currentAncestor = node;
-
-            do {
-                if (isConditionalTestExpression(currentAncestor)) {
-                    return currentAncestor.parent;
-                }
-            } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));
-
-            return null;
-        }
-
-        /**
-         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.
-         * @param {!Object} node The node to test.
-         * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.
-         */
-        function isParenthesisedTwice(node) {
-            const previousToken = sourceCode.getTokenBefore(node, 1),
-                nextToken = sourceCode.getTokenAfter(node, 1);
-
-            return astUtils.isParenthesised(sourceCode, node) &&
-                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&
-                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
-        }
-
-        /**
-         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.
-         * @param {!Object} node The node for the conditional statement.
-         * @returns {void}
-         */
-        function testForAssign(node) {
-            if (node.test &&
-                (node.test.type === "AssignmentExpression") &&
-                (node.type === "ForStatement"
-                    ? !astUtils.isParenthesised(sourceCode, node.test)
-                    : !isParenthesisedTwice(node.test)
-                )
-            ) {
-
-                // must match JSHint's error message
-                context.report({
-                    node,
-                    loc: node.test.loc.start,
-                    message: "Expected a conditional expression and instead saw an assignment."
-                });
-            }
-        }
-
-        /**
-         * Check whether an assignment expression is descended from a conditional statement's test expression.
-         * @param {!Object} node The node for the assignment expression.
-         * @returns {void}
-         */
-        function testForConditionalAncestor(node) {
-            const ancestor = findConditionalAncestor(node);
-
-            if (ancestor) {
-                context.report({
-                    node: ancestor,
-                    message: "Unexpected assignment within {{type}}.",
-                    data: {
-                        type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
-                    }
-                });
-            }
-        }
-
-        if (prohibitAssign === "always") {
-            return {
-                AssignmentExpression: testForConditionalAncestor
-            };
-        }
-
-        return {
-            DoWhileStatement: testForAssign,
-            ForStatement: testForAssign,
-            IfStatement: testForAssign,
-            WhileStatement: testForAssign
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-else-return.js
===================================================================
--- node_modules/eslint/lib/rules/no-else-return.js	(revision )
+++ node_modules/eslint/lib/rules/no-else-return.js	(revision )
@@ -1,235 +0,0 @@
-/**
- * @fileoverview Rule to flag `else` after a `return` in `if`
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-const FixTracker = require("../util/fix-tracker");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `else` blocks after `return` statements in `if` statements",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Display the context report if rule is violated
-         *
-         * @param {Node} node The 'else' node
-         * @returns {void}
-         */
-        function displayReport(node) {
-            context.report({
-                node,
-                message: "Unnecessary 'else' after 'return'.",
-                fix: fixer => {
-                    const sourceCode = context.getSourceCode();
-                    const startToken = sourceCode.getFirstToken(node);
-                    const elseToken = sourceCode.getTokenBefore(startToken);
-                    const source = sourceCode.getText(node);
-                    const lastIfToken = sourceCode.getTokenBefore(elseToken);
-                    let fixedSource, firstTokenOfElseBlock;
-
-                    if (startToken.type === "Punctuator" && startToken.value === "{") {
-                        firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);
-                    } else {
-                        firstTokenOfElseBlock = startToken;
-                    }
-
-                    // If the if block does not have curly braces and does not end in a semicolon
-                    // and the else block starts with (, [, /, +, ` or -, then it is not
-                    // safe to remove the else keyword, because ASI will not add a semicolon
-                    // after the if block
-                    const ifBlockMaybeUnsafe = node.parent.consequent.type !== "BlockStatement" && lastIfToken.value !== ";";
-                    const elseBlockUnsafe = /^[([/+`-]/.test(firstTokenOfElseBlock.value);
-
-                    if (ifBlockMaybeUnsafe && elseBlockUnsafe) {
-                        return null;
-                    }
-
-                    const endToken = sourceCode.getLastToken(node);
-                    const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);
-
-                    if (lastTokenOfElseBlock.value !== ";") {
-                        const nextToken = sourceCode.getTokenAfter(endToken);
-
-                        const nextTokenUnsafe = nextToken && /^[([/+`-]/.test(nextToken.value);
-                        const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;
-
-                        // If the else block contents does not end in a semicolon,
-                        // and the else block starts with (, [, /, +, ` or -, then it is not
-                        // safe to remove the else block, because ASI will not add a semicolon
-                        // after the remaining else block contents
-                        if (nextTokenUnsafe || (nextTokenOnSameLine && nextToken.value !== "}")) {
-                            return null;
-                        }
-                    }
-
-                    if (startToken.type === "Punctuator" && startToken.value === "{") {
-                        fixedSource = source.slice(1, -1);
-                    } else {
-                        fixedSource = source;
-                    }
-
-                    // Extend the replacement range to include the entire
-                    // function to avoid conflicting with no-useless-return.
-                    // https://github.com/eslint/eslint/issues/8026
-                    return new FixTracker(fixer, sourceCode)
-                        .retainEnclosingFunction(node)
-                        .replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);
-                }
-            });
-        }
-
-        /**
-         * Check to see if the node is a ReturnStatement
-         *
-         * @param {Node} node The node being evaluated
-         * @returns {boolean} True if node is a return
-         */
-        function checkForReturn(node) {
-            return node.type === "ReturnStatement";
-        }
-
-        /**
-         * Naive return checking, does not iterate through the whole
-         * BlockStatement because we make the assumption that the ReturnStatement
-         * will be the last node in the body of the BlockStatement.
-         *
-         * @param {Node} node The consequent/alternate node
-         * @returns {boolean} True if it has a return
-         */
-        function naiveHasReturn(node) {
-            if (node.type === "BlockStatement") {
-                const body = node.body,
-                    lastChildNode = body[body.length - 1];
-
-                return lastChildNode && checkForReturn(lastChildNode);
-            }
-            return checkForReturn(node);
-        }
-
-        /**
-         * Check to see if the node is valid for evaluation,
-         * meaning it has an else and not an else-if
-         *
-         * @param {Node} node The node being evaluated
-         * @returns {boolean} True if the node is valid
-         */
-        function hasElse(node) {
-            return node.alternate && node.consequent && node.alternate.type !== "IfStatement";
-        }
-
-        /**
-         * If the consequent is an IfStatement, check to see if it has an else
-         * and both its consequent and alternate path return, meaning this is
-         * a nested case of rule violation.  If-Else not considered currently.
-         *
-         * @param {Node} node The consequent node
-         * @returns {boolean} True if this is a nested rule violation
-         */
-        function checkForIf(node) {
-            return node.type === "IfStatement" && hasElse(node) &&
-                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
-        }
-
-        /**
-         * Check the consequent/body node to make sure it is not
-         * a ReturnStatement or an IfStatement that returns on both
-         * code paths.
-         *
-         * @param {Node} node The consequent or body node
-         * @param {Node} alternate The alternate node
-         * @returns {boolean} `true` if it is a Return/If node that always returns.
-         */
-        function checkForReturnOrIf(node) {
-            return checkForReturn(node) || checkForIf(node);
-        }
-
-
-        /**
-         * Check whether a node returns in every codepath.
-         * @param {Node} node The node to be checked
-         * @returns {boolean} `true` if it returns on every codepath.
-         */
-        function alwaysReturns(node) {
-            if (node.type === "BlockStatement") {
-
-                // If we have a BlockStatement, check each consequent body node.
-                return node.body.some(checkForReturnOrIf);
-            }
-
-            /*
-             * If not a block statement, make sure the consequent isn't a
-             * ReturnStatement or an IfStatement with returns on both paths.
-             */
-            return checkForReturnOrIf(node);
-        }
-
-        /**
-         * Check the if statement
-         * @returns {void}
-         * @param {Node} node The node for the if statement to check
-         * @private
-         */
-        function IfStatement(node) {
-            const parent = context.getAncestors().pop();
-            let consequents,
-                alternate;
-
-            /*
-             * Fixing this would require splitting one statement into two, so no error should
-             * be reported if this node is in a position where only one statement is allowed.
-             */
-            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
-                return;
-            }
-
-            for (consequents = []; node.type === "IfStatement"; node = node.alternate) {
-                if (!node.alternate) {
-                    return;
-                }
-                consequents.push(node.consequent);
-                alternate = node.alternate;
-            }
-
-            if (consequents.every(alwaysReturns)) {
-                displayReport(alternate);
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-
-            "IfStatement:exit": IfStatement
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-extra-label.js
===================================================================
--- node_modules/eslint/lib/rules/no-extra-label.js	(revision )
+++ node_modules/eslint/lib/rules/no-extra-label.js	(revision )
@@ -1,140 +0,0 @@
-/**
- * @fileoverview Rule to disallow unnecessary labels
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary labels",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        let scopeInfo = null;
-
-        /**
-         * Creates a new scope with a breakable statement.
-         *
-         * @param {ASTNode} node - A node to create. This is a BreakableStatement.
-         * @returns {void}
-         */
-        function enterBreakableStatement(node) {
-            scopeInfo = {
-                label: node.parent.type === "LabeledStatement" ? node.parent.label : null,
-                breakable: true,
-                upper: scopeInfo
-            };
-        }
-
-        /**
-         * Removes the top scope of the stack.
-         *
-         * @returns {void}
-         */
-        function exitBreakableStatement() {
-            scopeInfo = scopeInfo.upper;
-        }
-
-        /**
-         * Creates a new scope with a labeled statement.
-         *
-         * This ignores it if the body is a breakable statement.
-         * In this case it's handled in the `enterBreakableStatement` function.
-         *
-         * @param {ASTNode} node - A node to create. This is a LabeledStatement.
-         * @returns {void}
-         */
-        function enterLabeledStatement(node) {
-            if (!astUtils.isBreakableStatement(node.body)) {
-                scopeInfo = {
-                    label: node.label,
-                    breakable: false,
-                    upper: scopeInfo
-                };
-            }
-        }
-
-        /**
-         * Removes the top scope of the stack.
-         *
-         * This ignores it if the body is a breakable statement.
-         * In this case it's handled in the `exitBreakableStatement` function.
-         *
-         * @param {ASTNode} node - A node. This is a LabeledStatement.
-         * @returns {void}
-         */
-        function exitLabeledStatement(node) {
-            if (!astUtils.isBreakableStatement(node.body)) {
-                scopeInfo = scopeInfo.upper;
-            }
-        }
-
-        /**
-         * Reports a given control node if it's unnecessary.
-         *
-         * @param {ASTNode} node - A node. This is a BreakStatement or a
-         *      ContinueStatement.
-         * @returns {void}
-         */
-        function reportIfUnnecessary(node) {
-            if (!node.label) {
-                return;
-            }
-
-            const labelNode = node.label;
-
-            for (let info = scopeInfo; info !== null; info = info.upper) {
-                if (info.breakable || info.label && info.label.name === labelNode.name) {
-                    if (info.breakable && info.label && info.label.name === labelNode.name) {
-                        context.report({
-                            node: labelNode,
-                            message: "This label '{{name}}' is unnecessary.",
-                            data: labelNode,
-                            fix: fixer => fixer.removeRange([sourceCode.getFirstToken(node).range[1], labelNode.range[1]])
-                        });
-                    }
-                    return;
-                }
-            }
-        }
-
-        return {
-            WhileStatement: enterBreakableStatement,
-            "WhileStatement:exit": exitBreakableStatement,
-            DoWhileStatement: enterBreakableStatement,
-            "DoWhileStatement:exit": exitBreakableStatement,
-            ForStatement: enterBreakableStatement,
-            "ForStatement:exit": exitBreakableStatement,
-            ForInStatement: enterBreakableStatement,
-            "ForInStatement:exit": exitBreakableStatement,
-            ForOfStatement: enterBreakableStatement,
-            "ForOfStatement:exit": exitBreakableStatement,
-            SwitchStatement: enterBreakableStatement,
-            "SwitchStatement:exit": exitBreakableStatement,
-            LabeledStatement: enterLabeledStatement,
-            "LabeledStatement:exit": exitLabeledStatement,
-            BreakStatement: reportIfUnnecessary,
-            ContinueStatement: reportIfUnnecessary
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-fallthrough.js
===================================================================
--- node_modules/eslint/lib/rules/no-fallthrough.js	(revision )
+++ node_modules/eslint/lib/rules/no-fallthrough.js	(revision )
@@ -1,135 +0,0 @@
-/**
- * @fileoverview Rule to flag fall-through cases in switch statements.
- * @author Matt DuVall <http://mattduvall.com/>
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/i;
-
-/**
- * Checks whether or not a given node has a fallthrough comment.
- * @param {ASTNode} node - A SwitchCase node to get comments.
- * @param {RuleContext} context - A rule context which stores comments.
- * @param {RegExp} fallthroughCommentPattern - A pattern to match comment to.
- * @returns {boolean} `true` if the node has a valid fallthrough comment.
- */
-function hasFallthroughComment(node, context, fallthroughCommentPattern) {
-    const sourceCode = context.getSourceCode();
-    const comment = lodash.last(sourceCode.getCommentsBefore(node));
-
-    return Boolean(comment && fallthroughCommentPattern.test(comment.value));
-}
-
-/**
- * Checks whether or not a given code path segment is reachable.
- * @param {CodePathSegment} segment - A CodePathSegment to check.
- * @returns {boolean} `true` if the segment is reachable.
- */
-function isReachable(segment) {
-    return segment.reachable;
-}
-
-/**
- * Checks whether a node and a token are separated by blank lines
- * @param {ASTNode} node - The node to check
- * @param {Token} token - The token to compare against
- * @returns {boolean} `true` if there are blank lines between node and token
- */
-function hasBlankLinesBetween(node, token) {
-    return token.loc.start.line > node.loc.end.line + 1;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow fallthrough of `case` statements",
-            category: "Best Practices",
-            recommended: true
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    commentPattern: {
-                        type: "string"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0] || {};
-        let currentCodePath = null;
-        const sourceCode = context.getSourceCode();
-
-        /*
-         * We need to use leading comments of the next SwitchCase node because
-         * trailing comments is wrong if semicolons are omitted.
-         */
-        let fallthroughCase = null;
-        let fallthroughCommentPattern = null;
-
-        if (options.commentPattern) {
-            fallthroughCommentPattern = new RegExp(options.commentPattern);
-        } else {
-            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
-        }
-
-        return {
-            onCodePathStart(codePath) {
-                currentCodePath = codePath;
-            },
-            onCodePathEnd() {
-                currentCodePath = currentCodePath.upper;
-            },
-
-            SwitchCase(node) {
-
-                /*
-                 * Checks whether or not there is a fallthrough comment.
-                 * And reports the previous fallthrough node if that does not exist.
-                 */
-                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {
-                    context.report({
-                        message: "Expected a 'break' statement before '{{type}}'.",
-                        data: { type: node.test ? "case" : "default" },
-                        node
-                    });
-                }
-                fallthroughCase = null;
-            },
-
-            "SwitchCase:exit"(node) {
-                const nextToken = sourceCode.getTokenAfter(node);
-
-                /*
-                 * `reachable` meant fall through because statements preceded by
-                 * `break`, `return`, or `throw` are unreachable.
-                 * And allows empty cases and the last case.
-                 */
-                if (currentCodePath.currentSegments.some(isReachable) &&
-                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&
-                    lodash.last(node.parent.cases) !== node) {
-                    fallthroughCase = node;
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-func-assign.js
===================================================================
--- node_modules/eslint/lib/rules/no-func-assign.js	(revision )
+++ node_modules/eslint/lib/rules/no-func-assign.js	(revision )
@@ -1,63 +0,0 @@
-/**
- * @fileoverview Rule to flag use of function declaration identifiers as variables.
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow reassigning `function` declarations",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Reports a reference if is non initializer and writable.
-         * @param {References} references - Collection of reference to check.
-         * @returns {void}
-         */
-        function checkReference(references) {
-            astUtils.getModifyingReferences(references).forEach(reference => {
-                context.report({ node: reference.identifier, message: "'{{name}}' is a function.", data: { name: reference.identifier.name } });
-            });
-        }
-
-        /**
-         * Finds and reports references that are non initializer and writable.
-         * @param {Variable} variable - A variable to check.
-         * @returns {void}
-         */
-        function checkVariable(variable) {
-            if (variable.defs[0].type === "FunctionName") {
-                checkReference(variable.references);
-            }
-        }
-
-        /**
-         * Checks parameters of a given function node.
-         * @param {ASTNode} node - A function node to check.
-         * @returns {void}
-         */
-        function checkForFunction(node) {
-            context.getDeclaredVariables(node).forEach(checkVariable);
-        }
-
-        return {
-            FunctionDeclaration: checkForFunction,
-            FunctionExpression: checkForFunction
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-lone-blocks.js
===================================================================
--- node_modules/eslint/lib/rules/no-lone-blocks.js	(revision )
+++ node_modules/eslint/lib/rules/no-lone-blocks.js	(revision )
@@ -1,112 +0,0 @@
-/**
- * @fileoverview Rule to flag blocks with no reason to exist
- * @author Brandon Mills
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary nested blocks",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        // A stack of lone blocks to be checked for block-level bindings
-        const loneBlocks = [];
-        let ruleDef;
-
-        /**
-         * Reports a node as invalid.
-         * @param {ASTNode} node - The node to be reported.
-         * @returns {void}
-        */
-        function report(node) {
-            const message = node.parent.type === "BlockStatement" ? "Nested block is redundant." : "Block is redundant.";
-
-            context.report({ node, message });
-        }
-
-        /**
-         * Checks for any ocurrence of a BlockStatement in a place where lists of statements can appear
-         * @param {ASTNode} node The node to check
-         * @returns {boolean} True if the node is a lone block.
-        */
-        function isLoneBlock(node) {
-            return node.parent.type === "BlockStatement" ||
-                node.parent.type === "Program" ||
-
-                // Don't report blocks in switch cases if the block is the only statement of the case.
-                node.parent.type === "SwitchCase" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);
-        }
-
-        /**
-         * Checks the enclosing block of the current node for block-level bindings,
-         * and "marks it" as valid if any.
-         * @returns {void}
-        */
-        function markLoneBlock() {
-            if (loneBlocks.length === 0) {
-                return;
-            }
-
-            const block = context.getAncestors().pop();
-
-            if (loneBlocks[loneBlocks.length - 1] === block) {
-                loneBlocks.pop();
-            }
-        }
-
-        // Default rule definition: report all lone blocks
-        ruleDef = {
-            BlockStatement(node) {
-                if (isLoneBlock(node)) {
-                    report(node);
-                }
-            }
-        };
-
-        // ES6: report blocks without block-level bindings
-        if (context.parserOptions.ecmaVersion >= 6) {
-            ruleDef = {
-                BlockStatement(node) {
-                    if (isLoneBlock(node)) {
-                        loneBlocks.push(node);
-                    }
-                },
-                "BlockStatement:exit"(node) {
-                    if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {
-                        loneBlocks.pop();
-                        report(node);
-                    }
-                }
-            };
-
-            ruleDef.VariableDeclaration = function(node) {
-                if (node.kind === "let" || node.kind === "const") {
-                    markLoneBlock();
-                }
-            };
-
-            ruleDef.FunctionDeclaration = function() {
-                if (context.getScope().isStrict) {
-                    markLoneBlock();
-                }
-            };
-
-            ruleDef.ClassDeclaration = markLoneBlock;
-        }
-
-        return ruleDef;
-    }
-};
Index: node_modules/eslint/lib/rules/no-new-require.js
===================================================================
--- node_modules/eslint/lib/rules/no-new-require.js	(revision )
+++ node_modules/eslint/lib/rules/no-new-require.js	(revision )
@@ -1,35 +0,0 @@
-/**
- * @fileoverview Rule to disallow use of new operator with the `require` function
- * @author Wil Moore III
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `new` operators with calls to `require`",
-            category: "Node.js and CommonJS",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            NewExpression(node) {
-                if (node.callee.type === "Identifier" && node.callee.name === "require") {
-                    context.report({ node, message: "Unexpected use of new with require." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-path-concat.js
===================================================================
--- node_modules/eslint/lib/rules/no-path-concat.js	(revision )
+++ node_modules/eslint/lib/rules/no-path-concat.js	(revision )
@@ -1,49 +0,0 @@
-/**
- * @fileoverview Disallow string concatenation when using __dirname and __filename
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow string concatenation with `__dirname` and `__filename`",
-            category: "Node.js and CommonJS",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        const MATCHER = /^__(?:dir|file)name$/;
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-
-            BinaryExpression(node) {
-
-                const left = node.left,
-                    right = node.right;
-
-                if (node.operator === "+" &&
-                        ((left.type === "Identifier" && MATCHER.test(left.name)) ||
-                        (right.type === "Identifier" && MATCHER.test(right.name)))
-                ) {
-
-                    context.report({ node, message: "Use path.join() or path.resolve() instead of + to create paths." });
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-process-env.js
===================================================================
--- node_modules/eslint/lib/rules/no-process-env.js	(revision )
+++ node_modules/eslint/lib/rules/no-process-env.js	(revision )
@@ -1,39 +0,0 @@
-/**
- * @fileoverview Disallow the use of process.env()
- * @author Vignesh Anand
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of `process.env`",
-            category: "Node.js and CommonJS",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            MemberExpression(node) {
-                const objectName = node.object.name,
-                    propertyName = node.property.name;
-
-                if (objectName === "process" && !node.computed && propertyName && propertyName === "env") {
-                    context.report({ node, message: "Unexpected use of process.env." });
-                }
-
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-self-assign.js
===================================================================
--- node_modules/eslint/lib/rules/no-self-assign.js	(revision )
+++ node_modules/eslint/lib/rules/no-self-assign.js	(revision )
@@ -1,212 +0,0 @@
-/**
- * @fileoverview Rule to disallow assignments where both sides are exactly the same
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const SPACES = /\s+/g;
-
-/**
- * Checks whether the property of 2 given member expression nodes are the same
- * property or not.
- *
- * @param {ASTNode} left - A member expression node to check.
- * @param {ASTNode} right - Another member expression node to check.
- * @returns {boolean} `true` if the member expressions have the same property.
- */
-function isSameProperty(left, right) {
-    if (left.property.type === "Identifier" &&
-        left.property.type === right.property.type &&
-        left.property.name === right.property.name &&
-        left.computed === right.computed
-    ) {
-        return true;
-    }
-
-    const lname = astUtils.getStaticPropertyName(left);
-    const rname = astUtils.getStaticPropertyName(right);
-
-    return lname !== null && lname === rname;
-}
-
-/**
- * Checks whether 2 given member expression nodes are the reference to the same
- * property or not.
- *
- * @param {ASTNode} left - A member expression node to check.
- * @param {ASTNode} right - Another member expression node to check.
- * @returns {boolean} `true` if the member expressions are the reference to the
- *  same property or not.
- */
-function isSameMember(left, right) {
-    if (!isSameProperty(left, right)) {
-        return false;
-    }
-
-    const lobj = left.object;
-    const robj = right.object;
-
-    if (lobj.type !== robj.type) {
-        return false;
-    }
-    if (lobj.type === "MemberExpression") {
-        return isSameMember(lobj, robj);
-    }
-    return lobj.type === "Identifier" && lobj.name === robj.name;
-}
-
-/**
- * Traverses 2 Pattern nodes in parallel, then reports self-assignments.
- *
- * @param {ASTNode|null} left - A left node to traverse. This is a Pattern or
- *      a Property.
- * @param {ASTNode|null} right - A right node to traverse. This is a Pattern or
- *      a Property.
- * @param {boolean} props - The flag to check member expressions as well.
- * @param {Function} report - A callback function to report.
- * @returns {void}
- */
-function eachSelfAssignment(left, right, props, report) {
-    if (!left || !right) {
-
-        // do nothing
-    } else if (
-        left.type === "Identifier" &&
-        right.type === "Identifier" &&
-        left.name === right.name
-    ) {
-        report(right);
-    } else if (
-        left.type === "ArrayPattern" &&
-        right.type === "ArrayExpression"
-    ) {
-        const end = Math.min(left.elements.length, right.elements.length);
-
-        for (let i = 0; i < end; ++i) {
-            const rightElement = right.elements[i];
-
-            eachSelfAssignment(left.elements[i], rightElement, props, report);
-
-            // After a spread element, those indices are unknown.
-            if (rightElement && rightElement.type === "SpreadElement") {
-                break;
-            }
-        }
-    } else if (
-        left.type === "RestElement" &&
-        right.type === "SpreadElement"
-    ) {
-        eachSelfAssignment(left.argument, right.argument, props, report);
-    } else if (
-        left.type === "ObjectPattern" &&
-        right.type === "ObjectExpression" &&
-        right.properties.length >= 1
-    ) {
-
-        // Gets the index of the last spread property.
-        // It's possible to overwrite properties followed by it.
-        let startJ = 0;
-
-        for (let i = right.properties.length - 1; i >= 0; --i) {
-            if (right.properties[i].type === "ExperimentalSpreadProperty") {
-                startJ = i + 1;
-                break;
-            }
-        }
-
-        for (let i = 0; i < left.properties.length; ++i) {
-            for (let j = startJ; j < right.properties.length; ++j) {
-                eachSelfAssignment(
-                    left.properties[i],
-                    right.properties[j],
-                    props,
-                    report
-                );
-            }
-        }
-    } else if (
-        left.type === "Property" &&
-        right.type === "Property" &&
-        !left.computed &&
-        !right.computed &&
-        right.kind === "init" &&
-        !right.method &&
-        left.key.name === right.key.name
-    ) {
-        eachSelfAssignment(left.value, right.value, props, report);
-    } else if (
-        props &&
-        left.type === "MemberExpression" &&
-        right.type === "MemberExpression" &&
-        isSameMember(left, right)
-    ) {
-        report(right);
-    }
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow assignments where both sides are exactly the same",
-            category: "Best Practices",
-            recommended: true
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    props: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const options = context.options[0];
-        const props = Boolean(options && options.props);
-
-        /**
-         * Reports a given node as self assignments.
-         *
-         * @param {ASTNode} node - A node to report. This is an Identifier node.
-         * @returns {void}
-         */
-        function report(node) {
-            context.report({
-                node,
-                message: "'{{name}}' is assigned to itself.",
-                data: {
-                    name: sourceCode.getText(node).replace(SPACES, "")
-                }
-            });
-        }
-
-        return {
-            AssignmentExpression(node) {
-                if (node.operator === "=") {
-                    eachSelfAssignment(node.left, node.right, props, report);
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-spaced-func.js
===================================================================
--- node_modules/eslint/lib/rules/no-spaced-func.js	(revision )
+++ node_modules/eslint/lib/rules/no-spaced-func.js	(revision )
@@ -1,75 +0,0 @@
-/**
- * @fileoverview Rule to check that spaced function application
- * @author Matt DuVall <http://www.mattduvall.com>
- * @deprecated in ESLint v3.3.0
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow spacing between function identifiers and their applications (deprecated)",
-            category: "Stylistic Issues",
-            recommended: false,
-            replacedBy: ["func-call-spacing"]
-        },
-
-        deprecated: true,
-
-        fixable: "whitespace",
-        schema: []
-    },
-
-    create(context) {
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Check if open space is present in a function name
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function detectOpenSpaces(node) {
-            const lastCalleeToken = sourceCode.getLastToken(node.callee);
-            let prevToken = lastCalleeToken,
-                parenToken = sourceCode.getTokenAfter(lastCalleeToken);
-
-            // advances to an open parenthesis.
-            while (
-                parenToken &&
-                parenToken.range[1] < node.range[1] &&
-                parenToken.value !== "("
-            ) {
-                prevToken = parenToken;
-                parenToken = sourceCode.getTokenAfter(parenToken);
-            }
-
-            // look for a space between the callee and the open paren
-            if (parenToken &&
-                parenToken.range[1] < node.range[1] &&
-                sourceCode.isSpaceBetweenTokens(prevToken, parenToken)
-            ) {
-                context.report({
-                    node,
-                    loc: lastCalleeToken.loc.start,
-                    message: "Unexpected space between function name and paren.",
-                    fix(fixer) {
-                        return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
-                    }
-                });
-            }
-        }
-
-        return {
-            CallExpression: detectOpenSpaces,
-            NewExpression: detectOpenSpaces
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-unreachable.js
===================================================================
--- node_modules/eslint/lib/rules/no-unreachable.js	(revision )
+++ node_modules/eslint/lib/rules/no-unreachable.js	(revision )
@@ -1,210 +0,0 @@
-/**
- * @fileoverview Checks for unreachable code due to return, throws, break, and continue.
- * @author Joel Feenstra
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a given variable declarator has the initializer.
- * @param {ASTNode} node - A VariableDeclarator node to check.
- * @returns {boolean} `true` if the node has the initializer.
- */
-function isInitialized(node) {
-    return Boolean(node.init);
-}
-
-/**
- * Checks whether or not a given code path segment is unreachable.
- * @param {CodePathSegment} segment - A CodePathSegment to check.
- * @returns {boolean} `true` if the segment is unreachable.
- */
-function isUnreachable(segment) {
-    return !segment.reachable;
-}
-
-/**
- * The class to distinguish consecutive unreachable statements.
- */
-class ConsecutiveRange {
-    constructor(sourceCode) {
-        this.sourceCode = sourceCode;
-        this.startNode = null;
-        this.endNode = null;
-    }
-
-    /**
-     * The location object of this range.
-     * @type {Object}
-     */
-    get location() {
-        return {
-            start: this.startNode.loc.start,
-            end: this.endNode.loc.end
-        };
-    }
-
-    /**
-     * `true` if this range is empty.
-     * @type {boolean}
-     */
-    get isEmpty() {
-        return !(this.startNode && this.endNode);
-    }
-
-    /**
-     * Checks whether the given node is inside of this range.
-     * @param {ASTNode|Token} node - The node to check.
-     * @returns {boolean} `true` if the node is inside of this range.
-     */
-    contains(node) {
-        return (
-            node.range[0] >= this.startNode.range[0] &&
-            node.range[1] <= this.endNode.range[1]
-        );
-    }
-
-    /**
-     * Checks whether the given node is consecutive to this range.
-     * @param {ASTNode} node - The node to check.
-     * @returns {boolean} `true` if the node is consecutive to this range.
-     */
-    isConsecutive(node) {
-        return this.contains(this.sourceCode.getTokenBefore(node));
-    }
-
-    /**
-     * Merges the given node to this range.
-     * @param {ASTNode} node - The node to merge.
-     * @returns {void}
-     */
-    merge(node) {
-        this.endNode = node;
-    }
-
-    /**
-     * Resets this range by the given node or null.
-     * @param {ASTNode|null} node - The node to reset, or null.
-     * @returns {void}
-     */
-    reset(node) {
-        this.startNode = this.endNode = node;
-    }
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        let currentCodePath = null;
-
-        const range = new ConsecutiveRange(context.getSourceCode());
-
-        /**
-         * Reports a given node if it's unreachable.
-         * @param {ASTNode} node - A statement node to report.
-         * @returns {void}
-         */
-        function reportIfUnreachable(node) {
-            let nextNode = null;
-
-            if (node && currentCodePath.currentSegments.every(isUnreachable)) {
-
-                // Store this statement to distinguish consecutive statements.
-                if (range.isEmpty) {
-                    range.reset(node);
-                    return;
-                }
-
-                // Skip if this statement is inside of the current range.
-                if (range.contains(node)) {
-                    return;
-                }
-
-                // Merge if this statement is consecutive to the current range.
-                if (range.isConsecutive(node)) {
-                    range.merge(node);
-                    return;
-                }
-
-                nextNode = node;
-            }
-
-            // Report the current range since this statement is reachable or is
-            // not consecutive to the current range.
-            if (!range.isEmpty) {
-                context.report({
-                    message: "Unreachable code.",
-                    loc: range.location,
-                    node: range.startNode
-                });
-            }
-
-            // Update the current range.
-            range.reset(nextNode);
-        }
-
-        return {
-
-            // Manages the current code path.
-            onCodePathStart(codePath) {
-                currentCodePath = codePath;
-            },
-
-            onCodePathEnd() {
-                currentCodePath = currentCodePath.upper;
-            },
-
-            // Registers for all statement nodes (excludes FunctionDeclaration).
-            BlockStatement: reportIfUnreachable,
-            BreakStatement: reportIfUnreachable,
-            ClassDeclaration: reportIfUnreachable,
-            ContinueStatement: reportIfUnreachable,
-            DebuggerStatement: reportIfUnreachable,
-            DoWhileStatement: reportIfUnreachable,
-            EmptyStatement: reportIfUnreachable,
-            ExpressionStatement: reportIfUnreachable,
-            ForInStatement: reportIfUnreachable,
-            ForOfStatement: reportIfUnreachable,
-            ForStatement: reportIfUnreachable,
-            IfStatement: reportIfUnreachable,
-            ImportDeclaration: reportIfUnreachable,
-            LabeledStatement: reportIfUnreachable,
-            ReturnStatement: reportIfUnreachable,
-            SwitchStatement: reportIfUnreachable,
-            ThrowStatement: reportIfUnreachable,
-            TryStatement: reportIfUnreachable,
-
-            VariableDeclaration(node) {
-                if (node.kind !== "var" || node.declarations.some(isInitialized)) {
-                    reportIfUnreachable(node);
-                }
-            },
-
-            WhileStatement: reportIfUnreachable,
-            WithStatement: reportIfUnreachable,
-            ExportNamedDeclaration: reportIfUnreachable,
-            ExportDefaultDeclaration: reportIfUnreachable,
-            ExportAllDeclaration: reportIfUnreachable,
-
-            "Program:exit"() {
-                reportIfUnreachable();
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-unused-vars.js
===================================================================
--- node_modules/eslint/lib/rules/no-unused-vars.js	(revision )
+++ node_modules/eslint/lib/rules/no-unused-vars.js	(revision )
@@ -1,647 +0,0 @@
-/**
- * @fileoverview Rule to flag declared but unused variables
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unused variables",
-            category: "Variables",
-            recommended: true
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["all", "local"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            vars: {
-                                enum: ["all", "local"]
-                            },
-                            varsIgnorePattern: {
-                                type: "string"
-                            },
-                            args: {
-                                enum: ["all", "after-used", "none"]
-                            },
-                            ignoreRestSiblings: {
-                                type: "boolean"
-                            },
-                            argsIgnorePattern: {
-                                type: "string"
-                            },
-                            caughtErrors: {
-                                enum: ["all", "none"]
-                            },
-                            caughtErrorsIgnorePattern: {
-                                type: "string"
-                            }
-                        }
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        const REST_PROPERTY_TYPE = /^(?:Experimental)?RestProperty$/;
-
-        const config = {
-            vars: "all",
-            args: "after-used",
-            ignoreRestSiblings: false,
-            caughtErrors: "none"
-        };
-
-        const firstOption = context.options[0];
-
-        if (firstOption) {
-            if (typeof firstOption === "string") {
-                config.vars = firstOption;
-            } else {
-                config.vars = firstOption.vars || config.vars;
-                config.args = firstOption.args || config.args;
-                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;
-                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;
-
-                if (firstOption.varsIgnorePattern) {
-                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern);
-                }
-
-                if (firstOption.argsIgnorePattern) {
-                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern);
-                }
-
-                if (firstOption.caughtErrorsIgnorePattern) {
-                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern);
-                }
-            }
-        }
-
-        /**
-         * Generate the warning message about the variable being
-         * defined and unused, including the ignore pattern if configured.
-         * @param {Variable} unusedVar - eslint-scope variable object.
-         * @returns {string} The warning message to be used with this unused variable.
-         */
-        function getDefinedMessage(unusedVar) {
-            let type;
-            let pattern;
-
-            if (config.varsIgnorePattern) {
-                type = "vars";
-                pattern = config.varsIgnorePattern.toString();
-            }
-
-            if (unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type) {
-                const defType = unusedVar.defs[0].type;
-
-                if (defType === "CatchClause" && config.caughtErrorsIgnorePattern) {
-                    type = "args";
-                    pattern = config.caughtErrorsIgnorePattern.toString();
-                } else if (defType === "Parameter" && config.argsIgnorePattern) {
-                    type = "args";
-                    pattern = config.argsIgnorePattern.toString();
-                }
-            }
-
-            const additional = type ? ` Allowed unused ${type} must match ${pattern}.` : "";
-
-            return `'{{name}}' is defined but never used.${additional}`;
-        }
-
-        /**
-         * Generate the warning message about the variable being
-         * assigned and unused, including the ignore pattern if configured.
-         * @returns {string} The warning message to be used with this unused variable.
-         */
-        function getAssignedMessage() {
-            const additional = config.varsIgnorePattern ? ` Allowed unused vars must match ${config.varsIgnorePattern.toString()}.` : "";
-
-            return `'{{name}}' is assigned a value but never used.${additional}`;
-        }
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        const STATEMENT_TYPE = /(?:Statement|Declaration)$/;
-
-        /**
-         * Determines if a given variable is being exported from a module.
-         * @param {Variable} variable - eslint-scope variable object.
-         * @returns {boolean} True if the variable is exported, false if not.
-         * @private
-         */
-        function isExported(variable) {
-
-            const definition = variable.defs[0];
-
-            if (definition) {
-
-                let node = definition.node;
-
-                if (node.type === "VariableDeclarator") {
-                    node = node.parent;
-                } else if (definition.type === "Parameter") {
-                    return false;
-                }
-
-                return node.parent.type.indexOf("Export") === 0;
-            }
-            return false;
-
-        }
-
-        /**
-         * Determines if a variable has a sibling rest property
-         * @param {Variable} variable - eslint-scope variable object.
-         * @returns {boolean} True if the variable is exported, false if not.
-         * @private
-         */
-        function hasRestSpreadSibling(variable) {
-            if (config.ignoreRestSiblings) {
-                return variable.defs.some(def => {
-                    const propertyNode = def.name.parent;
-                    const patternNode = propertyNode.parent;
-
-                    return (
-                        propertyNode.type === "Property" &&
-                        patternNode.type === "ObjectPattern" &&
-                        REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type)
-                    );
-                });
-            }
-
-            return false;
-        }
-
-        /**
-         * Determines if a reference is a read operation.
-         * @param {Reference} ref - An eslint-scope Reference
-         * @returns {boolean} whether the given reference represents a read operation
-         * @private
-         */
-        function isReadRef(ref) {
-            return ref.isRead();
-        }
-
-        /**
-         * Determine if an identifier is referencing an enclosing function name.
-         * @param {Reference} ref - The reference to check.
-         * @param {ASTNode[]} nodes - The candidate function nodes.
-         * @returns {boolean} True if it's a self-reference, false if not.
-         * @private
-         */
-        function isSelfReference(ref, nodes) {
-            let scope = ref.from;
-
-            while (scope) {
-                if (nodes.indexOf(scope.block) >= 0) {
-                    return true;
-                }
-
-                scope = scope.upper;
-            }
-
-            return false;
-        }
-
-        /**
-         * Checks the position of given nodes.
-         *
-         * @param {ASTNode} inner - A node which is expected as inside.
-         * @param {ASTNode} outer - A node which is expected as outside.
-         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.
-         * @private
-         */
-        function isInside(inner, outer) {
-            return (
-                inner.range[0] >= outer.range[0] &&
-                inner.range[1] <= outer.range[1]
-            );
-        }
-
-        /**
-         * If a given reference is left-hand side of an assignment, this gets
-         * the right-hand side node of the assignment.
-         *
-         * In the following cases, this returns null.
-         *
-         * - The reference is not the LHS of an assignment expression.
-         * - The reference is inside of a loop.
-         * - The reference is inside of a function scope which is different from
-         *   the declaration.
-         *
-         * @param {eslint-scope.Reference} ref - A reference to check.
-         * @param {ASTNode} prevRhsNode - The previous RHS node.
-         * @returns {ASTNode|null} The RHS node or null.
-         * @private
-         */
-        function getRhsNode(ref, prevRhsNode) {
-            const id = ref.identifier;
-            const parent = id.parent;
-            const granpa = parent.parent;
-            const refScope = ref.from.variableScope;
-            const varScope = ref.resolved.scope.variableScope;
-            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);
-
-            /*
-             * Inherits the previous node if this reference is in the node.
-             * This is for `a = a + a`-like code.
-             */
-            if (prevRhsNode && isInside(id, prevRhsNode)) {
-                return prevRhsNode;
-            }
-
-            if (parent.type === "AssignmentExpression" &&
-                granpa.type === "ExpressionStatement" &&
-                id === parent.left &&
-                !canBeUsedLater
-            ) {
-                return parent.right;
-            }
-            return null;
-        }
-
-        /**
-         * Checks whether a given function node is stored to somewhere or not.
-         * If the function node is stored, the function can be used later.
-         *
-         * @param {ASTNode} funcNode - A function node to check.
-         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
-         * @returns {boolean} `true` if under the following conditions:
-         *      - the funcNode is assigned to a variable.
-         *      - the funcNode is bound as an argument of a function call.
-         *      - the function is bound to a property and the object satisfies above conditions.
-         * @private
-         */
-        function isStorableFunction(funcNode, rhsNode) {
-            let node = funcNode;
-            let parent = funcNode.parent;
-
-            while (parent && isInside(parent, rhsNode)) {
-                switch (parent.type) {
-                    case "SequenceExpression":
-                        if (parent.expressions[parent.expressions.length - 1] !== node) {
-                            return false;
-                        }
-                        break;
-
-                    case "CallExpression":
-                    case "NewExpression":
-                        return parent.callee !== node;
-
-                    case "AssignmentExpression":
-                    case "TaggedTemplateExpression":
-                    case "YieldExpression":
-                        return true;
-
-                    default:
-                        if (STATEMENT_TYPE.test(parent.type)) {
-
-                            /*
-                             * If it encountered statements, this is a complex pattern.
-                             * Since analyzeing complex patterns is hard, this returns `true` to avoid false positive.
-                             */
-                            return true;
-                        }
-                }
-
-                node = parent;
-                parent = parent.parent;
-            }
-
-            return false;
-        }
-
-        /**
-         * Checks whether a given Identifier node exists inside of a function node which can be used later.
-         *
-         * "can be used later" means:
-         * - the function is assigned to a variable.
-         * - the function is bound to a property and the object can be used later.
-         * - the function is bound as an argument of a function call.
-         *
-         * If a reference exists in a function which can be used later, the reference is read when the function is called.
-         *
-         * @param {ASTNode} id - An Identifier node to check.
-         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
-         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.
-         * @private
-         */
-        function isInsideOfStorableFunction(id, rhsNode) {
-            const funcNode = astUtils.getUpperFunction(id);
-
-            return (
-                funcNode &&
-                isInside(funcNode, rhsNode) &&
-                isStorableFunction(funcNode, rhsNode)
-            );
-        }
-
-        /**
-         * Checks whether a given reference is a read to update itself or not.
-         *
-         * @param {eslint-scope.Reference} ref - A reference to check.
-         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
-         * @returns {boolean} The reference is a read to update itself.
-         * @private
-         */
-        function isReadForItself(ref, rhsNode) {
-            const id = ref.identifier;
-            const parent = id.parent;
-            const granpa = parent.parent;
-
-            return ref.isRead() && (
-
-                // self update. e.g. `a += 1`, `a++`
-                (
-                    parent.type === "AssignmentExpression" &&
-                    granpa.type === "ExpressionStatement" &&
-                    parent.left === id
-                ) ||
-                (
-                    parent.type === "UpdateExpression" &&
-                    granpa.type === "ExpressionStatement"
-                ) ||
-
-                // in RHS of an assignment for itself. e.g. `a = a + 1`
-                (
-                    rhsNode &&
-                    isInside(id, rhsNode) &&
-                    !isInsideOfStorableFunction(id, rhsNode)
-                )
-            );
-        }
-
-        /**
-         * Determine if an identifier is used either in for-in loops.
-         *
-         * @param {Reference} ref - The reference to check.
-         * @returns {boolean} whether reference is used in the for-in loops
-         * @private
-         */
-        function isForInRef(ref) {
-            let target = ref.identifier.parent;
-
-
-            // "for (var ...) { return; }"
-            if (target.type === "VariableDeclarator") {
-                target = target.parent.parent;
-            }
-
-            if (target.type !== "ForInStatement") {
-                return false;
-            }
-
-            // "for (...) { return; }"
-            if (target.body.type === "BlockStatement") {
-                target = target.body.body[0];
-
-            // "for (...) return;"
-            } else {
-                target = target.body;
-            }
-
-            // For empty loop body
-            if (!target) {
-                return false;
-            }
-
-            return target.type === "ReturnStatement";
-        }
-
-        /**
-         * Determines if the variable is used.
-         * @param {Variable} variable - The variable to check.
-         * @returns {boolean} True if the variable is used
-         * @private
-         */
-        function isUsedVariable(variable) {
-            const functionNodes = variable.defs.filter(def => def.type === "FunctionName").map(def => def.node),
-                isFunctionDefinition = functionNodes.length > 0;
-            let rhsNode = null;
-
-            return variable.references.some(ref => {
-                if (isForInRef(ref)) {
-                    return true;
-                }
-
-                const forItself = isReadForItself(ref, rhsNode);
-
-                rhsNode = getRhsNode(ref, rhsNode);
-
-                return (
-                    isReadRef(ref) &&
-                    !forItself &&
-                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))
-                );
-            });
-        }
-
-        /**
-         * Checks whether the given variable is the last parameter in the non-ignored parameters.
-         *
-         * @param {eslint-scope.Variable} variable - The variable to check.
-         * @returns {boolean} `true` if the variable is the last.
-         */
-        function isLastInNonIgnoredParameters(variable) {
-            const def = variable.defs[0];
-
-            // This is the last.
-            if (def.index === def.node.params.length - 1) {
-                return true;
-            }
-
-            // if all parameters preceded by this variable are ignored and unused, this is the last.
-            if (config.argsIgnorePattern) {
-                const params = context.getDeclaredVariables(def.node);
-                const posteriorParams = params.slice(params.indexOf(variable) + 1);
-
-                if (posteriorParams.every(v => v.references.length === 0 && config.argsIgnorePattern.test(v.name))) {
-                    return true;
-                }
-            }
-
-            return false;
-        }
-
-        /**
-         * Gets an array of variables without read references.
-         * @param {Scope} scope - an eslint-scope Scope object.
-         * @param {Variable[]} unusedVars - an array that saving result.
-         * @returns {Variable[]} unused variables of the scope and descendant scopes.
-         * @private
-         */
-        function collectUnusedVariables(scope, unusedVars) {
-            const variables = scope.variables;
-            const childScopes = scope.childScopes;
-            let i, l;
-
-            if (scope.type !== "TDZ" && (scope.type !== "global" || config.vars === "all")) {
-                for (i = 0, l = variables.length; i < l; ++i) {
-                    const variable = variables[i];
-
-                    // skip a variable of class itself name in the class scope
-                    if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
-                        continue;
-                    }
-
-                    // skip function expression names and variables marked with markVariableAsUsed()
-                    if (scope.functionExpressionScope || variable.eslintUsed) {
-                        continue;
-                    }
-
-                    // skip implicit "arguments" variable
-                    if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
-                        continue;
-                    }
-
-                    // explicit global variables don't have definitions.
-                    const def = variable.defs[0];
-
-                    if (def) {
-                        const type = def.type;
-
-                        // skip catch variables
-                        if (type === "CatchClause") {
-                            if (config.caughtErrors === "none") {
-                                continue;
-                            }
-
-                            // skip ignored parameters
-                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {
-                                continue;
-                            }
-                        }
-
-                        if (type === "Parameter") {
-
-                            // skip any setter argument
-                            if ((def.node.parent.type === "Property" || def.node.parent.type === "MethodDefinition") && def.node.parent.kind === "set") {
-                                continue;
-                            }
-
-                            // if "args" option is "none", skip any parameter
-                            if (config.args === "none") {
-                                continue;
-                            }
-
-                            // skip ignored parameters
-                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {
-                                continue;
-                            }
-
-                            // if "args" option is "after-used", skip all but the last parameter
-                            if (config.args === "after-used" && astUtils.isFunction(def.name.parent) && !isLastInNonIgnoredParameters(variable)) {
-                                continue;
-                            }
-                        } else {
-
-                            // skip ignored variables
-                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {
-                                continue;
-                            }
-                        }
-                    }
-
-                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {
-                        unusedVars.push(variable);
-                    }
-                }
-            }
-
-            for (i = 0, l = childScopes.length; i < l; ++i) {
-                collectUnusedVariables(childScopes[i], unusedVars);
-            }
-
-            return unusedVars;
-        }
-
-        /**
-         * Gets the index of a given variable name in a given comment.
-         * @param {eslint-scope.Variable} variable - A variable to get.
-         * @param {ASTNode} comment - A comment node which includes the variable name.
-         * @returns {number} The index of the variable name's location.
-         * @private
-         */
-        function getColumnInComment(variable, comment) {
-            const namePattern = new RegExp(`[\\s,]${lodash.escapeRegExp(variable.name)}(?:$|[\\s,:])`, "g");
-
-            // To ignore the first text "global".
-            namePattern.lastIndex = comment.value.indexOf("global") + 6;
-
-            // Search a given variable name.
-            const match = namePattern.exec(comment.value);
-
-            return match ? match.index + 1 : 0;
-        }
-
-        /**
-         * Creates the correct location of a given variables.
-         * The location is at its name string in a `/*global` comment.
-         *
-         * @param {eslint-scope.Variable} variable - A variable to get its location.
-         * @returns {{line: number, column: number}} The location object for the variable.
-         * @private
-         */
-        function getLocation(variable) {
-            const comment = variable.eslintExplicitGlobalComment;
-
-            return sourceCode.getLocFromIndex(comment.range[0] + 2 + getColumnInComment(variable, comment));
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            "Program:exit"(programNode) {
-                const unusedVars = collectUnusedVariables(context.getScope(), []);
-
-                for (let i = 0, l = unusedVars.length; i < l; ++i) {
-                    const unusedVar = unusedVars[i];
-
-                    if (unusedVar.eslintExplicitGlobal) {
-                        context.report({
-                            node: programNode,
-                            loc: getLocation(unusedVar),
-                            message: getDefinedMessage(unusedVar),
-                            data: unusedVar
-                        });
-                    } else if (unusedVar.defs.length > 0) {
-                        context.report({
-                            node: unusedVar.identifiers[0],
-                            message: unusedVar.references.some(ref => ref.isWrite())
-                                ? getAssignedMessage()
-                                : getDefinedMessage(unusedVar),
-                            data: unusedVar
-                        });
-                    }
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/prefer-reflect.js
===================================================================
--- node_modules/eslint/lib/rules/prefer-reflect.js	(revision )
+++ node_modules/eslint/lib/rules/prefer-reflect.js	(revision )
@@ -1,119 +0,0 @@
-/**
- * @fileoverview Rule to suggest using "Reflect" api over Function/Object methods
- * @author Keith Cirkel <http://keithcirkel.co.uk>
- * @deprecated in ESLint v3.9.0
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require `Reflect` methods where applicable",
-            category: "ECMAScript 6",
-            recommended: false,
-            replacedBy: []
-        },
-
-        deprecated: true,
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    exceptions: {
-                        type: "array",
-                        items: {
-                            enum: [
-                                "apply",
-                                "call",
-                                "delete",
-                                "defineProperty",
-                                "getOwnPropertyDescriptor",
-                                "getPrototypeOf",
-                                "setPrototypeOf",
-                                "isExtensible",
-                                "getOwnPropertyNames",
-                                "preventExtensions"
-                            ]
-                        },
-                        uniqueItems: true
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const existingNames = {
-            apply: "Function.prototype.apply",
-            call: "Function.prototype.call",
-            defineProperty: "Object.defineProperty",
-            getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
-            getPrototypeOf: "Object.getPrototypeOf",
-            setPrototypeOf: "Object.setPrototypeOf",
-            isExtensible: "Object.isExtensible",
-            getOwnPropertyNames: "Object.getOwnPropertyNames",
-            preventExtensions: "Object.preventExtensions"
-        };
-
-        const reflectSubsitutes = {
-            apply: "Reflect.apply",
-            call: "Reflect.apply",
-            defineProperty: "Reflect.defineProperty",
-            getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
-            getPrototypeOf: "Reflect.getPrototypeOf",
-            setPrototypeOf: "Reflect.setPrototypeOf",
-            isExtensible: "Reflect.isExtensible",
-            getOwnPropertyNames: "Reflect.getOwnPropertyNames",
-            preventExtensions: "Reflect.preventExtensions"
-        };
-
-        const exceptions = (context.options[0] || {}).exceptions || [];
-
-        /**
-         * Reports the Reflect violation based on the `existing` and `substitute`
-         * @param {Object} node The node that violates the rule.
-         * @param {string} existing The existing method name that has been used.
-         * @param {string} substitute The Reflect substitute that should be used.
-         * @returns {void}
-         */
-        function report(node, existing, substitute) {
-            context.report({
-                node,
-                message: "Avoid using {{existing}}, instead use {{substitute}}.",
-                data: {
-                    existing,
-                    substitute
-                }
-            });
-        }
-
-        return {
-            CallExpression(node) {
-                const methodName = (node.callee.property || {}).name;
-                const isReflectCall = (node.callee.object || {}).name === "Reflect";
-                const hasReflectSubsitute = reflectSubsitutes.hasOwnProperty(methodName);
-                const userConfiguredException = exceptions.indexOf(methodName) !== -1;
-
-                if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {
-                    report(node, existingNames[methodName], reflectSubsitutes[methodName]);
-                }
-            },
-            UnaryExpression(node) {
-                const isDeleteOperator = node.operator === "delete";
-                const targetsIdentifier = node.argument.type === "Identifier";
-                const userConfiguredException = exceptions.indexOf("delete") !== -1;
-
-                if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
-                    report(node, "the delete keyword", "Reflect.deleteProperty");
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/spaced-comment.js
===================================================================
--- node_modules/eslint/lib/rules/spaced-comment.js	(revision )
+++ node_modules/eslint/lib/rules/spaced-comment.js	(revision )
@@ -1,375 +0,0 @@
-/**
- * @fileoverview Source code for spaced-comments rule
- * @author Gyandeep Singh
- */
-"use strict";
-
-const lodash = require("lodash");
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Escapes the control characters of a given string.
- * @param {string} s - A string to escape.
- * @returns {string} An escaped string.
- */
-function escape(s) {
-    const isOneChar = s.length === 1;
-
-    s = lodash.escapeRegExp(s);
-    return isOneChar ? s : `(?:${s})`;
-}
-
-/**
- * Escapes the control characters of a given string.
- * And adds a repeat flag.
- * @param {string} s - A string to escape.
- * @returns {string} An escaped string.
- */
-function escapeAndRepeat(s) {
-    return `${escape(s)}+`;
-}
-
-/**
- * Parses `markers` option.
- * If markers don't include `"*"`, this adds `"*"` to allow JSDoc comments.
- * @param {string[]} [markers] - A marker list.
- * @returns {string[]} A marker list.
- */
-function parseMarkersOption(markers) {
-    markers = markers ? markers.slice(0) : [];
-
-    // `*` is a marker for JSDoc comments.
-    if (markers.indexOf("*") === -1) {
-        markers.push("*");
-    }
-
-    return markers;
-}
-
-/**
- * Creates string pattern for exceptions.
- * Generated pattern:
- *
- * 1. A space or an exception pattern sequence.
- *
- * @param {string[]} exceptions - An exception pattern list.
- * @returns {string} A regular expression string for exceptions.
- */
-function createExceptionsPattern(exceptions) {
-    let pattern = "";
-
-    /*
-     * A space or an exception pattern sequence.
-     * []                 ==> "\s"
-     * ["-"]              ==> "(?:\s|\-+$)"
-     * ["-", "="]         ==> "(?:\s|(?:\-+|=+)$)"
-     * ["-", "=", "--=="] ==> "(?:\s|(?:\-+|=+|(?:\-\-==)+)$)" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)
-     */
-    if (exceptions.length === 0) {
-
-        // a space.
-        pattern += "\\s";
-    } else {
-
-        // a space or...
-        pattern += "(?:\\s|";
-
-        if (exceptions.length === 1) {
-
-            // a sequence of the exception pattern.
-            pattern += escapeAndRepeat(exceptions[0]);
-        } else {
-
-            // a sequence of one of the exception patterns.
-            pattern += "(?:";
-            pattern += exceptions.map(escapeAndRepeat).join("|");
-            pattern += ")";
-        }
-        pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join("")}]))`;
-    }
-
-    return pattern;
-}
-
-/**
- * Creates RegExp object for `always` mode.
- * Generated pattern for beginning of comment:
- *
- * 1. First, a marker or nothing.
- * 2. Next, a space or an exception pattern sequence.
- *
- * @param {string[]} markers - A marker list.
- * @param {string[]} exceptions - An exception pattern list.
- * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.
- */
-function createAlwaysStylePattern(markers, exceptions) {
-    let pattern = "^";
-
-    /*
-     * A marker or nothing.
-     * ["*"]            ==> "\*?"
-     * ["*", "!"]       ==> "(?:\*|!)?"
-     * ["*", "/", "!<"] ==> "(?:\*|\/|(?:!<))?" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F
-     */
-    if (markers.length === 1) {
-
-        // the marker.
-        pattern += escape(markers[0]);
-    } else {
-
-        // one of markers.
-        pattern += "(?:";
-        pattern += markers.map(escape).join("|");
-        pattern += ")";
-    }
-
-    pattern += "?"; // or nothing.
-    pattern += createExceptionsPattern(exceptions);
-
-    return new RegExp(pattern);
-}
-
-/**
- * Creates RegExp object for `never` mode.
- * Generated pattern for beginning of comment:
- *
- * 1. First, a marker or nothing (captured).
- * 2. Next, a space or a tab.
- *
- * @param {string[]} markers - A marker list.
- * @returns {RegExp} A RegExp object for `never` mode.
- */
-function createNeverStylePattern(markers) {
-    const pattern = `^(${markers.map(escape).join("|")})?[ \t]+`;
-
-    return new RegExp(pattern);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing after the `//` or `/*` in a comment",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                enum: ["always", "never"]
-            },
-            {
-                type: "object",
-                properties: {
-                    exceptions: {
-                        type: "array",
-                        items: {
-                            type: "string"
-                        }
-                    },
-                    markers: {
-                        type: "array",
-                        items: {
-                            type: "string"
-                        }
-                    },
-                    line: {
-                        type: "object",
-                        properties: {
-                            exceptions: {
-                                type: "array",
-                                items: {
-                                    type: "string"
-                                }
-                            },
-                            markers: {
-                                type: "array",
-                                items: {
-                                    type: "string"
-                                }
-                            }
-                        },
-                        additionalProperties: false
-                    },
-                    block: {
-                        type: "object",
-                        properties: {
-                            exceptions: {
-                                type: "array",
-                                items: {
-                                    type: "string"
-                                }
-                            },
-                            markers: {
-                                type: "array",
-                                items: {
-                                    type: "string"
-                                }
-                            },
-                            balanced: {
-                                type: "boolean"
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const sourceCode = context.getSourceCode();
-
-        // Unless the first option is never, require a space
-        const requireSpace = context.options[0] !== "never";
-
-        /*
-         * Parse the second options.
-         * If markers don't include `"*"`, it's added automatically for JSDoc
-         * comments.
-         */
-        const config = context.options[1] || {};
-        const balanced = config.block && config.block.balanced;
-
-        const styleRules = ["block", "line"].reduce((rule, type) => {
-            const markers = parseMarkersOption(config[type] && config[type].markers || config.markers);
-            const exceptions = config[type] && config[type].exceptions || config.exceptions || [];
-            const endNeverPattern = "[ \t]+$";
-
-            // Create RegExp object for valid patterns.
-            rule[type] = {
-                beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
-                endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`) : new RegExp(endNeverPattern),
-                hasExceptions: exceptions.length > 0,
-                markers: new RegExp(`^(${markers.map(escape).join("|")})`)
-            };
-
-            return rule;
-        }, {});
-
-        /**
-         * Reports a beginning spacing error with an appropriate message.
-         * @param {ASTNode} node - A comment node to check.
-         * @param {string} message - An error message to report.
-         * @param {Array} match - An array of match results for markers.
-         * @param {string} refChar - Character used for reference in the error message.
-         * @returns {void}
-         */
-        function reportBegin(node, message, match, refChar) {
-            const type = node.type.toLowerCase(),
-                commentIdentifier = type === "block" ? "/*" : "//";
-
-            context.report({
-                node,
-                fix(fixer) {
-                    const start = node.range[0];
-                    let end = start + 2;
-
-                    if (requireSpace) {
-                        if (match) {
-                            end += match[0].length;
-                        }
-                        return fixer.insertTextAfterRange([start, end], " ");
-                    }
-                    end += match[0].length;
-                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : ""));
-
-                },
-                message,
-                data: { refChar }
-            });
-        }
-
-        /**
-         * Reports an ending spacing error with an appropriate message.
-         * @param {ASTNode} node - A comment node to check.
-         * @param {string} message - An error message to report.
-         * @param {string} match - An array of the matched whitespace characters.
-         * @returns {void}
-         */
-        function reportEnd(node, message, match) {
-            context.report({
-                node,
-                fix(fixer) {
-                    if (requireSpace) {
-                        return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], " ");
-                    }
-                    const end = node.range[1] - 2,
-                        start = end - match[0].length;
-
-                    return fixer.replaceTextRange([start, end], "");
-
-                },
-                message
-            });
-        }
-
-        /**
-         * Reports a given comment if it's invalid.
-         * @param {ASTNode} node - a comment node to check.
-         * @returns {void}
-         */
-        function checkCommentForSpace(node) {
-            const type = node.type.toLowerCase(),
-                rule = styleRules[type],
-                commentIdentifier = type === "block" ? "/*" : "//";
-
-            // Ignores empty comments.
-            if (node.value.length === 0) {
-                return;
-            }
-
-            const beginMatch = rule.beginRegex.exec(node.value);
-            const endMatch = rule.endRegex.exec(node.value);
-
-            // Checks.
-            if (requireSpace) {
-                if (!beginMatch) {
-                    const hasMarker = rule.markers.exec(node.value);
-                    const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;
-
-                    if (rule.hasExceptions) {
-                        reportBegin(node, "Expected exception block, space or tab after '{{refChar}}' in comment.", hasMarker, marker);
-                    } else {
-                        reportBegin(node, "Expected space or tab after '{{refChar}}' in comment.", hasMarker, marker);
-                    }
-                }
-
-                if (balanced && type === "block" && !endMatch) {
-                    reportEnd(node, "Expected space or tab before '*/' in comment.");
-                }
-            } else {
-                if (beginMatch) {
-                    if (!beginMatch[1]) {
-                        reportBegin(node, "Unexpected space or tab after '{{refChar}}' in comment.", beginMatch, commentIdentifier);
-                    } else {
-                        reportBegin(node, "Unexpected space or tab after marker ({{refChar}}) in comment.", beginMatch, beginMatch[1]);
-                    }
-                }
-
-                if (balanced && type === "block" && endMatch) {
-                    reportEnd(node, "Unexpected space or tab before '*/' in comment.", endMatch);
-                }
-            }
-        }
-
-        return {
-            Program() {
-                const comments = sourceCode.getAllComments();
-
-                comments.filter(token => token.type !== "Shebang").forEach(checkCommentForSpace);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/callback-return.js
===================================================================
--- node_modules/eslint/lib/rules/callback-return.js	(revision )
+++ node_modules/eslint/lib/rules/callback-return.js	(revision )
@@ -1,174 +0,0 @@
-/**
- * @fileoverview Enforce return after a callback.
- * @author Jamund Ferguson
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require `return` statements after callbacks",
-            category: "Node.js and CommonJS",
-            recommended: false
-        },
-
-        schema: [{
-            type: "array",
-            items: { type: "string" }
-        }]
-    },
-
-    create(context) {
-
-        const callbacks = context.options[0] || ["callback", "cb", "next"],
-            sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Find the closest parent matching a list of types.
-         * @param {ASTNode} node The node whose parents we are searching
-         * @param {Array} types The node types to match
-         * @returns {ASTNode} The matched node or undefined.
-         */
-        function findClosestParentOfType(node, types) {
-            if (!node.parent) {
-                return null;
-            }
-            if (types.indexOf(node.parent.type) === -1) {
-                return findClosestParentOfType(node.parent, types);
-            }
-            return node.parent;
-        }
-
-        /**
-         * Check to see if a node contains only identifers
-         * @param {ASTNode} node The node to check
-         * @returns {boolean} Whether or not the node contains only identifers
-         */
-        function containsOnlyIdentifiers(node) {
-            if (node.type === "Identifier") {
-                return true;
-            }
-
-            if (node.type === "MemberExpression") {
-                if (node.object.type === "Identifier") {
-                    return true;
-                } else if (node.object.type === "MemberExpression") {
-                    return containsOnlyIdentifiers(node.object);
-                }
-            }
-
-            return false;
-        }
-
-        /**
-         * Check to see if a CallExpression is in our callback list.
-         * @param {ASTNode} node The node to check against our callback names list.
-         * @returns {boolean} Whether or not this function matches our callback name.
-         */
-        function isCallback(node) {
-            return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;
-        }
-
-        /**
-         * Determines whether or not the callback is part of a callback expression.
-         * @param {ASTNode} node The callback node
-         * @param {ASTNode} parentNode The expression node
-         * @returns {boolean} Whether or not this is part of a callback expression
-         */
-        function isCallbackExpression(node, parentNode) {
-
-            // ensure the parent node exists and is an expression
-            if (!parentNode || parentNode.type !== "ExpressionStatement") {
-                return false;
-            }
-
-            // cb()
-            if (parentNode.expression === node) {
-                return true;
-            }
-
-            // special case for cb && cb() and similar
-            if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
-                if (parentNode.expression.right === node) {
-                    return true;
-                }
-            }
-
-            return false;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            CallExpression(node) {
-
-                // if we're not a callback we can return
-                if (!isCallback(node)) {
-                    return;
-                }
-
-                // find the closest block, return or loop
-                const closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {};
-
-                // if our parent is a return we know we're ok
-                if (closestBlock.type === "ReturnStatement") {
-                    return;
-                }
-
-                // arrow functions don't always have blocks and implicitly return
-                if (closestBlock.type === "ArrowFunctionExpression") {
-                    return;
-                }
-
-                // block statements are part of functions and most if statements
-                if (closestBlock.type === "BlockStatement") {
-
-                    // find the last item in the block
-                    const lastItem = closestBlock.body[closestBlock.body.length - 1];
-
-                    // if the callback is the last thing in a block that might be ok
-                    if (isCallbackExpression(node, lastItem)) {
-
-                        const parentType = closestBlock.parent.type;
-
-                        // but only if the block is part of a function
-                        if (parentType === "FunctionExpression" ||
-                            parentType === "FunctionDeclaration" ||
-                            parentType === "ArrowFunctionExpression"
-                        ) {
-                            return;
-                        }
-
-                    }
-
-                    // ending a block with a return is also ok
-                    if (lastItem.type === "ReturnStatement") {
-
-                        // but only if the callback is immediately before
-                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {
-                            return;
-                        }
-                    }
-
-                }
-
-                // as long as you're the child of a function at this point you should be asked to return
-                if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) {
-                    context.report({ node, message: "Expected return with your callback function." });
-                }
-
-            }
-
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/consistent-this.js
===================================================================
--- node_modules/eslint/lib/rules/consistent-this.js	(revision )
+++ node_modules/eslint/lib/rules/consistent-this.js	(revision )
@@ -1,141 +0,0 @@
-/**
- * @fileoverview Rule to enforce consistent naming of "this" context variables
- * @author Raphael Pigulla
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent naming when capturing the current execution context",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: {
-            type: "array",
-            items: {
-                type: "string",
-                minLength: 1
-            },
-            uniqueItems: true
-        }
-    },
-
-    create(context) {
-        let aliases = [];
-
-        if (context.options.length === 0) {
-            aliases.push("that");
-        } else {
-            aliases = context.options;
-        }
-
-        /**
-         * Reports that a variable declarator or assignment expression is assigning
-         * a non-'this' value to the specified alias.
-         * @param {ASTNode} node - The assigning node.
-         * @param {string} alias - the name of the alias that was incorrectly used.
-         * @returns {void}
-         */
-        function reportBadAssignment(node, alias) {
-            context.report({ node, message: "Designated alias '{{alias}}' is not assigned to 'this'.", data: { alias } });
-        }
-
-        /**
-         * Checks that an assignment to an identifier only assigns 'this' to the
-         * appropriate alias, and the alias is only assigned to 'this'.
-         * @param {ASTNode} node - The assigning node.
-         * @param {Identifier} name - The name of the variable assigned to.
-         * @param {Expression} value - The value of the assignment.
-         * @returns {void}
-         */
-        function checkAssignment(node, name, value) {
-            const isThis = value.type === "ThisExpression";
-
-            if (aliases.indexOf(name) !== -1) {
-                if (!isThis || node.operator && node.operator !== "=") {
-                    reportBadAssignment(node, name);
-                }
-            } else if (isThis) {
-                context.report({ node, message: "Unexpected alias '{{name}}' for 'this'.", data: { name } });
-            }
-        }
-
-        /**
-         * Ensures that a variable declaration of the alias in a program or function
-         * is assigned to the correct value.
-         * @param {string} alias alias the check the assignment of.
-         * @param {Object} scope scope of the current code we are checking.
-         * @private
-         * @returns {void}
-         */
-        function checkWasAssigned(alias, scope) {
-            const variable = scope.set.get(alias);
-
-            if (!variable) {
-                return;
-            }
-
-            if (variable.defs.some(def => def.node.type === "VariableDeclarator" &&
-                def.node.init !== null)) {
-                return;
-            }
-
-            // The alias has been declared and not assigned: check it was
-            // assigned later in the same scope.
-            if (!variable.references.some(reference => {
-                const write = reference.writeExpr;
-
-                return (
-                    reference.from === scope &&
-                    write && write.type === "ThisExpression" &&
-                    write.parent.operator === "="
-                );
-            })) {
-                variable.defs.map(def => def.node).forEach(node => {
-                    reportBadAssignment(node, alias);
-                });
-            }
-        }
-
-        /**
-         * Check each alias to ensure that is was assinged to the correct value.
-         * @returns {void}
-         */
-        function ensureWasAssigned() {
-            const scope = context.getScope();
-
-            aliases.forEach(alias => {
-                checkWasAssigned(alias, scope);
-            });
-        }
-
-        return {
-            "Program:exit": ensureWasAssigned,
-            "FunctionExpression:exit": ensureWasAssigned,
-            "FunctionDeclaration:exit": ensureWasAssigned,
-
-            VariableDeclarator(node) {
-                const id = node.id;
-                const isDestructuring =
-                    id.type === "ArrayPattern" || id.type === "ObjectPattern";
-
-                if (node.init !== null && !isDestructuring) {
-                    checkAssignment(node, id.name, node.init);
-                }
-            },
-
-            AssignmentExpression(node) {
-                if (node.left.type === "Identifier") {
-                    checkAssignment(node, node.left.name, node.right);
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/keyword-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/keyword-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/keyword-spacing.js	(revision )
@@ -1,584 +0,0 @@
-/**
- * @fileoverview Rule to enforce spacing before and after keywords.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils"),
-    keywords = require("../util/keywords");
-
-//------------------------------------------------------------------------------
-// Constants
-//------------------------------------------------------------------------------
-
-const PREV_TOKEN = /^[)\]}>]$/;
-const NEXT_TOKEN = /^(?:[([{<~!]|\+\+?|--?)$/;
-const PREV_TOKEN_M = /^[)\]}>*]$/;
-const NEXT_TOKEN_M = /^[{*]$/;
-const TEMPLATE_OPEN_PAREN = /\$\{$/;
-const TEMPLATE_CLOSE_PAREN = /^\}/;
-const CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/;
-const KEYS = keywords.concat(["as", "async", "await", "from", "get", "let", "of", "set", "yield"]);
-
-// check duplications.
-(function() {
-    KEYS.sort();
-    for (let i = 1; i < KEYS.length; ++i) {
-        if (KEYS[i] === KEYS[i - 1]) {
-            throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);
-        }
-    }
-}());
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a given token is a "Template" token ends with "${".
- *
- * @param {Token} token - A token to check.
- * @returns {boolean} `true` if the token is a "Template" token ends with "${".
- */
-function isOpenParenOfTemplate(token) {
-    return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
-}
-
-/**
- * Checks whether or not a given token is a "Template" token starts with "}".
- *
- * @param {Token} token - A token to check.
- * @returns {boolean} `true` if the token is a "Template" token starts with "}".
- */
-function isCloseParenOfTemplate(token) {
-    return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing before and after keywords",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    before: { type: "boolean" },
-                    after: { type: "boolean" },
-                    overrides: {
-                        type: "object",
-                        properties: KEYS.reduce((retv, key) => {
-                            retv[key] = {
-                                type: "object",
-                                properties: {
-                                    before: { type: "boolean" },
-                                    after: { type: "boolean" }
-                                },
-                                additionalProperties: false
-                            };
-                            return retv;
-                        }, {}),
-                        additionalProperties: false
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Reports a given token if there are not space(s) before the token.
-         *
-         * @param {Token} token - A token to report.
-         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous
-         *      token to check.
-         * @returns {void}
-         */
-        function expectSpaceBefore(token, pattern) {
-            pattern = pattern || PREV_TOKEN;
-
-            const prevToken = sourceCode.getTokenBefore(token);
-
-            if (prevToken &&
-                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&
-                !isOpenParenOfTemplate(prevToken) &&
-                astUtils.isTokenOnSameLine(prevToken, token) &&
-                !sourceCode.isSpaceBetweenTokens(prevToken, token)
-            ) {
-                context.report({
-                    loc: token.loc.start,
-                    message: "Expected space(s) before \"{{value}}\".",
-                    data: token,
-                    fix(fixer) {
-                        return fixer.insertTextBefore(token, " ");
-                    }
-                });
-            }
-        }
-
-        /**
-         * Reports a given token if there are space(s) before the token.
-         *
-         * @param {Token} token - A token to report.
-         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous
-         *      token to check.
-         * @returns {void}
-         */
-        function unexpectSpaceBefore(token, pattern) {
-            pattern = pattern || PREV_TOKEN;
-
-            const prevToken = sourceCode.getTokenBefore(token);
-
-            if (prevToken &&
-                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&
-                !isOpenParenOfTemplate(prevToken) &&
-                astUtils.isTokenOnSameLine(prevToken, token) &&
-                sourceCode.isSpaceBetweenTokens(prevToken, token)
-            ) {
-                context.report({
-                    loc: token.loc.start,
-                    message: "Unexpected space(s) before \"{{value}}\".",
-                    data: token,
-                    fix(fixer) {
-                        return fixer.removeRange([prevToken.range[1], token.range[0]]);
-                    }
-                });
-            }
-        }
-
-        /**
-         * Reports a given token if there are not space(s) after the token.
-         *
-         * @param {Token} token - A token to report.
-         * @param {RegExp|undefined} pattern - Optional. A pattern of the next
-         *      token to check.
-         * @returns {void}
-         */
-        function expectSpaceAfter(token, pattern) {
-            pattern = pattern || NEXT_TOKEN;
-
-            const nextToken = sourceCode.getTokenAfter(token);
-
-            if (nextToken &&
-                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&
-                !isCloseParenOfTemplate(nextToken) &&
-                astUtils.isTokenOnSameLine(token, nextToken) &&
-                !sourceCode.isSpaceBetweenTokens(token, nextToken)
-            ) {
-                context.report({
-                    loc: token.loc.start,
-                    message: "Expected space(s) after \"{{value}}\".",
-                    data: token,
-                    fix(fixer) {
-                        return fixer.insertTextAfter(token, " ");
-                    }
-                });
-            }
-        }
-
-        /**
-         * Reports a given token if there are space(s) after the token.
-         *
-         * @param {Token} token - A token to report.
-         * @param {RegExp|undefined} pattern - Optional. A pattern of the next
-         *      token to check.
-         * @returns {void}
-         */
-        function unexpectSpaceAfter(token, pattern) {
-            pattern = pattern || NEXT_TOKEN;
-
-            const nextToken = sourceCode.getTokenAfter(token);
-
-            if (nextToken &&
-                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&
-                !isCloseParenOfTemplate(nextToken) &&
-                astUtils.isTokenOnSameLine(token, nextToken) &&
-                sourceCode.isSpaceBetweenTokens(token, nextToken)
-            ) {
-                context.report({
-                    loc: token.loc.start,
-                    message: "Unexpected space(s) after \"{{value}}\".",
-                    data: token,
-                    fix(fixer) {
-                        return fixer.removeRange([token.range[1], nextToken.range[0]]);
-                    }
-                });
-            }
-        }
-
-        /**
-         * Parses the option object and determines check methods for each keyword.
-         *
-         * @param {Object|undefined} options - The option object to parse.
-         * @returns {Object} - Normalized option object.
-         *      Keys are keywords (there are for every keyword).
-         *      Values are instances of `{"before": function, "after": function}`.
-         */
-        function parseOptions(options) {
-            const before = !options || options.before !== false;
-            const after = !options || options.after !== false;
-            const defaultValue = {
-                before: before ? expectSpaceBefore : unexpectSpaceBefore,
-                after: after ? expectSpaceAfter : unexpectSpaceAfter
-            };
-            const overrides = (options && options.overrides) || {};
-            const retv = Object.create(null);
-
-            for (let i = 0; i < KEYS.length; ++i) {
-                const key = KEYS[i];
-                const override = overrides[key];
-
-                if (override) {
-                    const thisBefore = ("before" in override) ? override.before : before;
-                    const thisAfter = ("after" in override) ? override.after : after;
-
-                    retv[key] = {
-                        before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
-                        after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
-                    };
-                } else {
-                    retv[key] = defaultValue;
-                }
-            }
-
-            return retv;
-        }
-
-        const checkMethodMap = parseOptions(context.options[0]);
-
-        /**
-         * Reports a given token if usage of spacing followed by the token is
-         * invalid.
-         *
-         * @param {Token} token - A token to report.
-         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous
-         *      token to check.
-         * @returns {void}
-         */
-        function checkSpacingBefore(token, pattern) {
-            checkMethodMap[token.value].before(token, pattern);
-        }
-
-        /**
-         * Reports a given token if usage of spacing preceded by the token is
-         * invalid.
-         *
-         * @param {Token} token - A token to report.
-         * @param {RegExp|undefined} pattern - Optional. A pattern of the next
-         *      token to check.
-         * @returns {void}
-         */
-        function checkSpacingAfter(token, pattern) {
-            checkMethodMap[token.value].after(token, pattern);
-        }
-
-        /**
-         * Reports a given token if usage of spacing around the token is invalid.
-         *
-         * @param {Token} token - A token to report.
-         * @returns {void}
-         */
-        function checkSpacingAround(token) {
-            checkSpacingBefore(token);
-            checkSpacingAfter(token);
-        }
-
-        /**
-         * Reports the first token of a given node if the first token is a keyword
-         * and usage of spacing around the token is invalid.
-         *
-         * @param {ASTNode|null} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingAroundFirstToken(node) {
-            const firstToken = node && sourceCode.getFirstToken(node);
-
-            if (firstToken && firstToken.type === "Keyword") {
-                checkSpacingAround(firstToken);
-            }
-        }
-
-        /**
-         * Reports the first token of a given node if the first token is a keyword
-         * and usage of spacing followed by the token is invalid.
-         *
-         * This is used for unary operators (e.g. `typeof`), `function`, and `super`.
-         * Other rules are handling usage of spacing preceded by those keywords.
-         *
-         * @param {ASTNode|null} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingBeforeFirstToken(node) {
-            const firstToken = node && sourceCode.getFirstToken(node);
-
-            if (firstToken && firstToken.type === "Keyword") {
-                checkSpacingBefore(firstToken);
-            }
-        }
-
-        /**
-         * Reports the previous token of a given node if the token is a keyword and
-         * usage of spacing around the token is invalid.
-         *
-         * @param {ASTNode|null} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingAroundTokenBefore(node) {
-            if (node) {
-                const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);
-
-                checkSpacingAround(token);
-            }
-        }
-
-        /**
-         * Reports `async` or `function` keywords of a given node if usage of
-         * spacing around those keywords is invalid.
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingForFunction(node) {
-            const firstToken = node && sourceCode.getFirstToken(node);
-
-            if (firstToken &&
-                ((firstToken.type === "Keyword" && firstToken.value === "function") ||
-                firstToken.value === "async")
-            ) {
-                checkSpacingBefore(firstToken);
-            }
-        }
-
-        /**
-         * Reports `class` and `extends` keywords of a given node if usage of
-         * spacing around those keywords is invalid.
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingForClass(node) {
-            checkSpacingAroundFirstToken(node);
-            checkSpacingAroundTokenBefore(node.superClass);
-        }
-
-        /**
-         * Reports `if` and `else` keywords of a given node if usage of spacing
-         * around those keywords is invalid.
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingForIfStatement(node) {
-            checkSpacingAroundFirstToken(node);
-            checkSpacingAroundTokenBefore(node.alternate);
-        }
-
-        /**
-         * Reports `try`, `catch`, and `finally` keywords of a given node if usage
-         * of spacing around those keywords is invalid.
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingForTryStatement(node) {
-            checkSpacingAroundFirstToken(node);
-            checkSpacingAroundFirstToken(node.handler);
-            checkSpacingAroundTokenBefore(node.finalizer);
-        }
-
-        /**
-         * Reports `do` and `while` keywords of a given node if usage of spacing
-         * around those keywords is invalid.
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingForDoWhileStatement(node) {
-            checkSpacingAroundFirstToken(node);
-            checkSpacingAroundTokenBefore(node.test);
-        }
-
-        /**
-         * Reports `for` and `in` keywords of a given node if usage of spacing
-         * around those keywords is invalid.
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingForForInStatement(node) {
-            checkSpacingAroundFirstToken(node);
-            checkSpacingAroundTokenBefore(node.right);
-        }
-
-        /**
-         * Reports `for` and `of` keywords of a given node if usage of spacing
-         * around those keywords is invalid.
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingForForOfStatement(node) {
-            checkSpacingAroundFirstToken(node);
-            checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));
-        }
-
-        /**
-         * Reports `import`, `export`, `as`, and `from` keywords of a given node if
-         * usage of spacing around those keywords is invalid.
-         *
-         * This rule handles the `*` token in module declarations.
-         *
-         *     import*as A from "./a"; /*error Expected space(s) after "import".
-         *                               error Expected space(s) before "as".
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingForModuleDeclaration(node) {
-            const firstToken = sourceCode.getFirstToken(node);
-
-            checkSpacingBefore(firstToken, PREV_TOKEN_M);
-            checkSpacingAfter(firstToken, NEXT_TOKEN_M);
-
-            if (node.source) {
-                const fromToken = sourceCode.getTokenBefore(node.source);
-
-                checkSpacingBefore(fromToken, PREV_TOKEN_M);
-                checkSpacingAfter(fromToken, NEXT_TOKEN_M);
-            }
-        }
-
-        /**
-         * Reports `as` keyword of a given node if usage of spacing around this
-         * keyword is invalid.
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingForImportNamespaceSpecifier(node) {
-            const asToken = sourceCode.getFirstToken(node, 1);
-
-            checkSpacingBefore(asToken, PREV_TOKEN_M);
-        }
-
-        /**
-         * Reports `static`, `get`, and `set` keywords of a given node if usage of
-         * spacing around those keywords is invalid.
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingForProperty(node) {
-            if (node.static) {
-                checkSpacingAroundFirstToken(node);
-            }
-            if (node.kind === "get" ||
-                node.kind === "set" ||
-                (
-                    (node.method || node.type === "MethodDefinition") &&
-                    node.value.async
-                )
-            ) {
-                const token = sourceCode.getTokenBefore(
-                    node.key,
-                    tok => {
-                        switch (tok.value) {
-                            case "get":
-                            case "set":
-                            case "async":
-                                return true;
-                            default:
-                                return false;
-                        }
-                    }
-                );
-
-                if (!token) {
-                    throw new Error("Failed to find token get, set, or async beside method name");
-                }
-
-
-                checkSpacingAround(token);
-            }
-        }
-
-        /**
-         * Reports `await` keyword of a given node if usage of spacing before
-         * this keyword is invalid.
-         *
-         * @param {ASTNode} node - A node to report.
-         * @returns {void}
-         */
-        function checkSpacingForAwaitExpression(node) {
-            checkSpacingBefore(sourceCode.getFirstToken(node));
-        }
-
-        return {
-
-            // Statements
-            DebuggerStatement: checkSpacingAroundFirstToken,
-            WithStatement: checkSpacingAroundFirstToken,
-
-            // Statements - Control flow
-            BreakStatement: checkSpacingAroundFirstToken,
-            ContinueStatement: checkSpacingAroundFirstToken,
-            ReturnStatement: checkSpacingAroundFirstToken,
-            ThrowStatement: checkSpacingAroundFirstToken,
-            TryStatement: checkSpacingForTryStatement,
-
-            // Statements - Choice
-            IfStatement: checkSpacingForIfStatement,
-            SwitchStatement: checkSpacingAroundFirstToken,
-            SwitchCase: checkSpacingAroundFirstToken,
-
-            // Statements - Loops
-            DoWhileStatement: checkSpacingForDoWhileStatement,
-            ForInStatement: checkSpacingForForInStatement,
-            ForOfStatement: checkSpacingForForOfStatement,
-            ForStatement: checkSpacingAroundFirstToken,
-            WhileStatement: checkSpacingAroundFirstToken,
-
-            // Statements - Declarations
-            ClassDeclaration: checkSpacingForClass,
-            ExportNamedDeclaration: checkSpacingForModuleDeclaration,
-            ExportDefaultDeclaration: checkSpacingAroundFirstToken,
-            ExportAllDeclaration: checkSpacingForModuleDeclaration,
-            FunctionDeclaration: checkSpacingForFunction,
-            ImportDeclaration: checkSpacingForModuleDeclaration,
-            VariableDeclaration: checkSpacingAroundFirstToken,
-
-            // Expressions
-            ArrowFunctionExpression: checkSpacingForFunction,
-            AwaitExpression: checkSpacingForAwaitExpression,
-            ClassExpression: checkSpacingForClass,
-            FunctionExpression: checkSpacingForFunction,
-            NewExpression: checkSpacingBeforeFirstToken,
-            Super: checkSpacingBeforeFirstToken,
-            ThisExpression: checkSpacingBeforeFirstToken,
-            UnaryExpression: checkSpacingBeforeFirstToken,
-            YieldExpression: checkSpacingBeforeFirstToken,
-
-            // Others
-            ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,
-            MethodDefinition: checkSpacingForProperty,
-            Property: checkSpacingForProperty
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/linebreak-style.js
===================================================================
--- node_modules/eslint/lib/rules/linebreak-style.js	(revision )
+++ node_modules/eslint/lib/rules/linebreak-style.js	(revision )
@@ -1,96 +0,0 @@
-/**
- * @fileoverview Rule to enforce a single linebreak style.
- * @author Erik Mueller
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent linebreak style",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                enum: ["unix", "windows"]
-            }
-        ]
-    },
-
-    create(context) {
-
-        const EXPECTED_LF_MSG = "Expected linebreaks to be 'LF' but found 'CRLF'.",
-            EXPECTED_CRLF_MSG = "Expected linebreaks to be 'CRLF' but found 'LF'.";
-
-        const sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Builds a fix function that replaces text at the specified range in the source text.
-         * @param {int[]} range The range to replace
-         * @param {string} text The text to insert.
-         * @returns {Function} Fixer function
-         * @private
-         */
-        function createFix(range, text) {
-            return function(fixer) {
-                return fixer.replaceTextRange(range, text);
-            };
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            Program: function checkForlinebreakStyle(node) {
-                const linebreakStyle = context.options[0] || "unix",
-                    expectedLF = linebreakStyle === "unix",
-                    expectedLFChars = expectedLF ? "\n" : "\r\n",
-                    source = sourceCode.getText(),
-                    pattern = astUtils.createGlobalLinebreakMatcher();
-                let match;
-
-                let i = 0;
-
-                while ((match = pattern.exec(source)) !== null) {
-                    i++;
-                    if (match[0] === expectedLFChars) {
-                        continue;
-                    }
-
-                    const index = match.index;
-                    const range = [index, index + match[0].length];
-
-                    context.report({
-                        node,
-                        loc: {
-                            line: i,
-                            column: sourceCode.lines[i - 1].length
-                        },
-                        message: expectedLF ? EXPECTED_LF_MSG : EXPECTED_CRLF_MSG,
-                        fix: createFix(range, expectedLFChars)
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-catch-shadow.js
===================================================================
--- node_modules/eslint/lib/rules/no-catch-shadow.js	(revision )
+++ node_modules/eslint/lib/rules/no-catch-shadow.js	(revision )
@@ -1,67 +0,0 @@
-/**
- * @fileoverview Rule to flag variable leak in CatchClauses in IE 8 and earlier
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `catch` clause parameters from shadowing variables in the outer scope",
-            category: "Variables",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Check if the parameters are been shadowed
-         * @param {Object} scope current scope
-         * @param {string} name parameter name
-         * @returns {boolean} True is its been shadowed
-         */
-        function paramIsShadowing(scope, name) {
-            return astUtils.getVariableByName(scope, name) !== null;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-
-            CatchClause(node) {
-                let scope = context.getScope();
-
-                // When blockBindings is enabled, CatchClause creates its own scope
-                // so start from one upper scope to exclude the current node
-                if (scope.block === node) {
-                    scope = scope.upper;
-                }
-
-                if (paramIsShadowing(scope, node.param.name)) {
-                    context.report({ node, message: "Value of '{{name}}' may be overwritten in IE 8 and earlier.", data: { name: node.param.name } });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-class-assign.js
===================================================================
--- node_modules/eslint/lib/rules/no-class-assign.js	(revision )
+++ node_modules/eslint/lib/rules/no-class-assign.js	(revision )
@@ -1,54 +0,0 @@
-/**
- * @fileoverview A rule to disallow modifying variables of class declarations
- * @author Toru Nagashima
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow reassigning class members",
-            category: "ECMAScript 6",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Finds and reports references that are non initializer and writable.
-         * @param {Variable} variable - A variable to check.
-         * @returns {void}
-         */
-        function checkVariable(variable) {
-            astUtils.getModifyingReferences(variable.references).forEach(reference => {
-                context.report({ node: reference.identifier, message: "'{{name}}' is a class.", data: { name: reference.identifier.name } });
-
-            });
-        }
-
-        /**
-         * Finds and reports references that are non initializer and writable.
-         * @param {ASTNode} node - A ClassDeclaration/ClassExpression node to check.
-         * @returns {void}
-         */
-        function checkForClass(node) {
-            context.getDeclaredVariables(node).forEach(checkVariable);
-        }
-
-        return {
-            ClassDeclaration: checkForClass,
-            ClassExpression: checkForClass
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-const-assign.js
===================================================================
--- node_modules/eslint/lib/rules/no-const-assign.js	(revision )
+++ node_modules/eslint/lib/rules/no-const-assign.js	(revision )
@@ -1,47 +0,0 @@
-/**
- * @fileoverview A rule to disallow modifying variables that are declared using `const`
- * @author Toru Nagashima
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow reassigning `const` variables",
-            category: "ECMAScript 6",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Finds and reports references that are non initializer and writable.
-         * @param {Variable} variable - A variable to check.
-         * @returns {void}
-         */
-        function checkVariable(variable) {
-            astUtils.getModifyingReferences(variable.references).forEach(reference => {
-                context.report({ node: reference.identifier, message: "'{{name}}' is constant.", data: { name: reference.identifier.name } });
-            });
-        }
-
-        return {
-            VariableDeclaration(node) {
-                if (node.kind === "const") {
-                    context.getDeclaredVariables(node).forEach(checkVariable);
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-extra-parens.js
===================================================================
--- node_modules/eslint/lib/rules/no-extra-parens.js	(revision )
+++ node_modules/eslint/lib/rules/no-extra-parens.js	(revision )
@@ -1,734 +0,0 @@
-/**
- * @fileoverview Disallow parenthesising higher precedence subexpressions.
- * @author Michael Ficarra
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils.js");
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary parentheses",
-            category: "Possible Errors",
-            recommended: false
-        },
-
-        fixable: "code",
-
-        schema: {
-            anyOf: [
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["functions"]
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 1
-                },
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["all"]
-                        },
-                        {
-                            type: "object",
-                            properties: {
-                                conditionalAssign: { type: "boolean" },
-                                nestedBinaryExpressions: { type: "boolean" },
-                                returnAssign: { type: "boolean" },
-                                ignoreJSX: { enum: ["none", "all", "single-line", "multi-line"] },
-                                enforceForArrowConditionals: { type: "boolean" }
-                            },
-                            additionalProperties: false
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 2
-                }
-            ]
-        }
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        const tokensToIgnore = new WeakSet();
-        const isParenthesised = astUtils.isParenthesised.bind(astUtils, sourceCode);
-        const precedence = astUtils.getPrecedence;
-        const ALL_NODES = context.options[0] !== "functions";
-        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;
-        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;
-        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;
-        const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;
-        const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] &&
-            context.options[1].enforceForArrowConditionals === false;
-
-        const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: "AssignmentExpression" });
-        const PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: "UpdateExpression" });
-
-        /**
-         * Determines if this rule should be enforced for a node given the current configuration.
-         * @param {ASTNode} node - The node to be checked.
-         * @returns {boolean} True if the rule should be enforced for this node.
-         * @private
-         */
-        function ruleApplies(node) {
-            if (node.type === "JSXElement") {
-                const isSingleLine = node.loc.start.line === node.loc.end.line;
-
-                switch (IGNORE_JSX) {
-
-                    // Exclude this JSX element from linting
-                    case "all":
-                        return false;
-
-                    // Exclude this JSX element if it is multi-line element
-                    case "multi-line":
-                        return isSingleLine;
-
-                    // Exclude this JSX element if it is single-line element
-                    case "single-line":
-                        return !isSingleLine;
-
-                    // Nothing special to be done for JSX elements
-                    case "none":
-                        break;
-
-                    // no default
-                }
-            }
-
-            return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
-        }
-
-        /**
-         * Determines if a node is surrounded by parentheses twice.
-         * @param {ASTNode} node - The node to be checked.
-         * @returns {boolean} True if the node is doubly parenthesised.
-         * @private
-         */
-        function isParenthesisedTwice(node) {
-            const previousToken = sourceCode.getTokenBefore(node, 1),
-                nextToken = sourceCode.getTokenAfter(node, 1);
-
-            return isParenthesised(node) && previousToken && nextToken &&
-                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&
-                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
-        }
-
-        /**
-         * Determines if a node is surrounded by (potentially) invalid parentheses.
-         * @param {ASTNode} node - The node to be checked.
-         * @returns {boolean} True if the node is incorrectly parenthesised.
-         * @private
-         */
-        function hasExcessParens(node) {
-            return ruleApplies(node) && isParenthesised(node);
-        }
-
-        /**
-         * Determines if a node that is expected to be parenthesised is surrounded by
-         * (potentially) invalid extra parentheses.
-         * @param {ASTNode} node - The node to be checked.
-         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.
-         * @private
-         */
-        function hasDoubleExcessParens(node) {
-            return ruleApplies(node) && isParenthesisedTwice(node);
-        }
-
-        /**
-         * Determines if a node test expression is allowed to have a parenthesised assignment
-         * @param {ASTNode} node - The node to be checked.
-         * @returns {boolean} True if the assignment can be parenthesised.
-         * @private
-         */
-        function isCondAssignException(node) {
-            return EXCEPT_COND_ASSIGN && node.test.type === "AssignmentExpression";
-        }
-
-        /**
-         * Determines if a node is in a return statement
-         * @param {ASTNode} node - The node to be checked.
-         * @returns {boolean} True if the node is in a return statement.
-         * @private
-         */
-        function isInReturnStatement(node) {
-            while (node) {
-                if (node.type === "ReturnStatement" ||
-                        (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement")) {
-                    return true;
-                }
-                node = node.parent;
-            }
-
-            return false;
-        }
-
-        /**
-         * Determines if a constructor function is newed-up with parens
-         * @param {ASTNode} newExpression - The NewExpression node to be checked.
-         * @returns {boolean} True if the constructor is called with parens.
-         * @private
-         */
-        function isNewExpressionWithParens(newExpression) {
-            const lastToken = sourceCode.getLastToken(newExpression);
-            const penultimateToken = sourceCode.getTokenBefore(lastToken);
-
-            return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken);
-        }
-
-        /**
-         * Determines if a node is or contains an assignment expression
-         * @param {ASTNode} node - The node to be checked.
-         * @returns {boolean} True if the node is or contains an assignment expression.
-         * @private
-         */
-        function containsAssignment(node) {
-            if (node.type === "AssignmentExpression") {
-                return true;
-            } else if (node.type === "ConditionalExpression" &&
-                    (node.consequent.type === "AssignmentExpression" || node.alternate.type === "AssignmentExpression")) {
-                return true;
-            } else if ((node.left && node.left.type === "AssignmentExpression") ||
-                    (node.right && node.right.type === "AssignmentExpression")) {
-                return true;
-            }
-
-            return false;
-        }
-
-        /**
-         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment
-         * @param {ASTNode} node - The node to be checked.
-         * @returns {boolean} True if the assignment can be parenthesised.
-         * @private
-         */
-        function isReturnAssignException(node) {
-            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {
-                return false;
-            }
-
-            if (node.type === "ReturnStatement") {
-                return node.argument && containsAssignment(node.argument);
-            } else if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {
-                return containsAssignment(node.body);
-            }
-            return containsAssignment(node);
-
-        }
-
-        /**
-         * Determines if a node following a [no LineTerminator here] restriction is
-         * surrounded by (potentially) invalid extra parentheses.
-         * @param {Token} token - The token preceding the [no LineTerminator here] restriction.
-         * @param {ASTNode} node - The node to be checked.
-         * @returns {boolean} True if the node is incorrectly parenthesised.
-         * @private
-         */
-        function hasExcessParensNoLineTerminator(token, node) {
-            if (token.loc.end.line === node.loc.start.line) {
-                return hasExcessParens(node);
-            }
-
-            return hasDoubleExcessParens(node);
-        }
-
-        /**
-         * Determines whether a node should be preceded by an additional space when removing parens
-         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses
-         * @returns {boolean} `true` if a space should be inserted before the node
-         * @private
-         */
-        function requiresLeadingSpace(node) {
-            const leftParenToken = sourceCode.getTokenBefore(node);
-            const tokenBeforeLeftParen = sourceCode.getTokenBefore(node, 1);
-            const firstToken = sourceCode.getFirstToken(node);
-
-            return tokenBeforeLeftParen &&
-                tokenBeforeLeftParen.range[1] === leftParenToken.range[0] &&
-                leftParenToken.range[1] === firstToken.range[0] &&
-                !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, firstToken);
-        }
-
-        /**
-         * Determines whether a node should be followed by an additional space when removing parens
-         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses
-         * @returns {boolean} `true` if a space should be inserted after the node
-         * @private
-         */
-        function requiresTrailingSpace(node) {
-            const nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });
-            const rightParenToken = nextTwoTokens[0];
-            const tokenAfterRightParen = nextTwoTokens[1];
-            const tokenBeforeRightParen = sourceCode.getLastToken(node);
-
-            return rightParenToken && tokenAfterRightParen &&
-                !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) &&
-                !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);
-        }
-
-        /**
-         * Determines if a given expression node is an IIFE
-         * @param {ASTNode} node The node to check
-         * @returns {boolean} `true` if the given node is an IIFE
-         */
-        function isIIFE(node) {
-            return node.type === "CallExpression" && node.callee.type === "FunctionExpression";
-        }
-
-        /**
-         * Report the node
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function report(node) {
-            const leftParenToken = sourceCode.getTokenBefore(node);
-            const rightParenToken = sourceCode.getTokenAfter(node);
-
-            if (!isParenthesisedTwice(node)) {
-                if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {
-                    return;
-                }
-
-                if (isIIFE(node) && !isParenthesised(node.callee)) {
-                    return;
-                }
-            }
-
-            context.report({
-                node,
-                loc: leftParenToken.loc.start,
-                message: "Gratuitous parentheses around expression.",
-                fix(fixer) {
-                    const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);
-
-                    return fixer.replaceTextRange([
-                        leftParenToken.range[0],
-                        rightParenToken.range[1]
-                    ], (requiresLeadingSpace(node) ? " " : "") + parenthesizedSource + (requiresTrailingSpace(node) ? " " : ""));
-                }
-            });
-        }
-
-        /**
-         * Evaluate Unary update
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkUnaryUpdate(node) {
-            if (node.type === "UnaryExpression" && node.argument.type === "BinaryExpression" && node.argument.operator === "**") {
-                return;
-            }
-
-            if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {
-                report(node.argument);
-            }
-        }
-
-        /**
-         * Check if a member expression contains a call expression
-         * @param {ASTNode} node MemberExpression node to evaluate
-         * @returns {boolean} true if found, false if not
-         */
-        function doesMemberExpressionContainCallExpression(node) {
-            let currentNode = node.object;
-            let currentNodeType = node.object.type;
-
-            while (currentNodeType === "MemberExpression") {
-                currentNode = currentNode.object;
-                currentNodeType = currentNode.type;
-            }
-
-            return currentNodeType === "CallExpression";
-        }
-
-        /**
-         * Evaluate a new call
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkCallNew(node) {
-            const callee = node.callee;
-
-            if (hasExcessParens(callee) && precedence(callee) >= precedence(node)) {
-                const hasNewParensException = callee.type === "NewExpression" && !isNewExpressionWithParens(callee);
-
-                if (
-                    hasDoubleExcessParens(callee) ||
-                    !isIIFE(node) && !hasNewParensException && !(
-
-                        // Allow extra parens around a new expression if
-                        // there are intervening parentheses.
-                        callee.type === "MemberExpression" &&
-                        doesMemberExpressionContainCallExpression(callee)
-                    )
-                ) {
-                    report(node.callee);
-                }
-            }
-            if (node.arguments.length === 1) {
-                if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
-                    report(node.arguments[0]);
-                }
-            } else {
-                node.arguments
-                    .filter(arg => hasExcessParens(arg) && precedence(arg) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)
-                    .forEach(report);
-            }
-        }
-
-        /**
-         * Evaluate binary logicals
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkBinaryLogical(node) {
-            const prec = precedence(node);
-            const leftPrecedence = precedence(node.left);
-            const rightPrecedence = precedence(node.right);
-            const isExponentiation = node.operator === "**";
-            const shouldSkipLeft = (NESTED_BINARY && (node.left.type === "BinaryExpression" || node.left.type === "LogicalExpression")) ||
-              node.left.type === "UnaryExpression" && isExponentiation;
-            const shouldSkipRight = NESTED_BINARY && (node.right.type === "BinaryExpression" || node.right.type === "LogicalExpression");
-
-            if (!shouldSkipLeft && hasExcessParens(node.left) && (leftPrecedence > prec || (leftPrecedence === prec && !isExponentiation))) {
-                report(node.left);
-            }
-            if (!shouldSkipRight && hasExcessParens(node.right) && (rightPrecedence > prec || (rightPrecedence === prec && isExponentiation))) {
-                report(node.right);
-            }
-        }
-
-        /**
-         * Check the parentheses around the super class of the given class definition.
-         * @param {ASTNode} node The node of class declarations to check.
-         * @returns {void}
-         */
-        function checkClass(node) {
-            if (!node.superClass) {
-                return;
-            }
-
-            // If `node.superClass` is a LeftHandSideExpression, parentheses are extra.
-            // Otherwise, parentheses are needed.
-            const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR
-                ? hasExcessParens(node.superClass)
-                : hasDoubleExcessParens(node.superClass);
-
-            if (hasExtraParens) {
-                report(node.superClass);
-            }
-        }
-
-        /**
-         * Check the parentheses around the argument of the given spread operator.
-         * @param {ASTNode} node The node of spread elements/properties to check.
-         * @returns {void}
-         */
-        function checkSpreadOperator(node) {
-            const hasExtraParens = precedence(node.argument) >= PRECEDENCE_OF_ASSIGNMENT_EXPR
-                ? hasExcessParens(node.argument)
-                : hasDoubleExcessParens(node.argument);
-
-            if (hasExtraParens) {
-                report(node.argument);
-            }
-        }
-
-        /**
-         * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration
-         * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node
-         * @returns {void}
-         */
-        function checkExpressionOrExportStatement(node) {
-            const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);
-            const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);
-            const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;
-
-            if (
-                astUtils.isOpeningParenToken(firstToken) &&
-                (
-                    astUtils.isOpeningBraceToken(secondToken) ||
-                    secondToken.type === "Keyword" && (
-                        secondToken.value === "function" ||
-                        secondToken.value === "class" ||
-                        secondToken.value === "let" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken))
-                    ) ||
-                    secondToken && secondToken.type === "Identifier" && secondToken.value === "async" && thirdToken && thirdToken.type === "Keyword" && thirdToken.value === "function"
-                )
-            ) {
-                tokensToIgnore.add(secondToken);
-            }
-
-            if (hasExcessParens(node)) {
-                report(node);
-            }
-        }
-
-        return {
-            ArrayExpression(node) {
-                node.elements
-                    .filter(e => e && hasExcessParens(e) && precedence(e) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)
-                    .forEach(report);
-            },
-
-            ArrowFunctionExpression(node) {
-                if (isReturnAssignException(node)) {
-                    return;
-                }
-
-                if (node.body.type === "ConditionalExpression" &&
-                    IGNORE_ARROW_CONDITIONALS &&
-                    !isParenthesisedTwice(node.body)
-                ) {
-                    return;
-                }
-
-                if (node.body.type !== "BlockStatement") {
-                    const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);
-                    const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);
-
-                    if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {
-                        tokensToIgnore.add(firstBodyToken);
-                    }
-                    if (hasExcessParens(node.body) && precedence(node.body) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
-                        report(node.body);
-                    }
-                }
-            },
-
-            AssignmentExpression(node) {
-                if (isReturnAssignException(node)) {
-                    return;
-                }
-
-                if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {
-                    report(node.right);
-                }
-            },
-
-            BinaryExpression: checkBinaryLogical,
-            CallExpression: checkCallNew,
-
-            ConditionalExpression(node) {
-                if (isReturnAssignException(node)) {
-                    return;
-                }
-
-                if (hasExcessParens(node.test) && precedence(node.test) >= precedence({ type: "LogicalExpression", operator: "||" })) {
-                    report(node.test);
-                }
-
-                if (hasExcessParens(node.consequent) && precedence(node.consequent) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
-                    report(node.consequent);
-                }
-
-                if (hasExcessParens(node.alternate) && precedence(node.alternate) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
-                    report(node.alternate);
-                }
-            },
-
-            DoWhileStatement(node) {
-                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
-                    report(node.test);
-                }
-            },
-
-            ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),
-            ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),
-
-            "ForInStatement, ForOfStatement"(node) {
-                if (node.left.type !== "VariableDeclarator") {
-                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);
-
-                    if (
-                        firstLeftToken.value === "let" && (
-
-                            // If `let` is the only thing on the left side of the loop, it's the loop variable: `for ((let) of foo);`
-                            // Removing it will cause a syntax error, because it will be parsed as the start of a VariableDeclarator.
-                            firstLeftToken.range[1] === node.left.range[1] ||
-
-                            // If `let` is followed by a `[` token, it's a property access on the `let` value: `for ((let[foo]) of bar);`
-                            // Removing it will cause the property access to be parsed as a destructuring declaration of `foo` instead.
-                            astUtils.isOpeningBracketToken(
-                                sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)
-                            )
-                        )
-                    ) {
-                        tokensToIgnore.add(firstLeftToken);
-                    }
-                }
-                if (hasExcessParens(node.right)) {
-                    report(node.right);
-                }
-                if (hasExcessParens(node.left)) {
-                    report(node.left);
-                }
-            },
-
-            ForStatement(node) {
-                if (node.init && hasExcessParens(node.init)) {
-                    report(node.init);
-                }
-
-                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {
-                    report(node.test);
-                }
-
-                if (node.update && hasExcessParens(node.update)) {
-                    report(node.update);
-                }
-            },
-
-            IfStatement(node) {
-                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
-                    report(node.test);
-                }
-            },
-
-            LogicalExpression: checkBinaryLogical,
-
-            MemberExpression(node) {
-                const nodeObjHasExcessParens = hasExcessParens(node.object);
-
-                if (
-                    nodeObjHasExcessParens &&
-                    precedence(node.object) >= precedence(node) &&
-                    (
-                        node.computed ||
-                        !(
-                            astUtils.isDecimalInteger(node.object) ||
-
-                            // RegExp literal is allowed to have parens (#1589)
-                            (node.object.type === "Literal" && node.object.regex)
-                        )
-                    )
-                ) {
-                    report(node.object);
-                }
-
-                if (nodeObjHasExcessParens &&
-                  node.object.type === "CallExpression" &&
-                  node.parent.type !== "NewExpression") {
-                    report(node.object);
-                }
-
-                if (node.computed && hasExcessParens(node.property)) {
-                    report(node.property);
-                }
-            },
-
-            NewExpression: checkCallNew,
-
-            ObjectExpression(node) {
-                node.properties
-                    .filter(property => {
-                        const value = property.value;
-
-                        return value && hasExcessParens(value) && precedence(value) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;
-                    }).forEach(property => report(property.value));
-            },
-
-            ReturnStatement(node) {
-                const returnToken = sourceCode.getFirstToken(node);
-
-                if (isReturnAssignException(node)) {
-                    return;
-                }
-
-                if (node.argument &&
-                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&
-
-                        // RegExp literal is allowed to have parens (#1589)
-                        !(node.argument.type === "Literal" && node.argument.regex)) {
-                    report(node.argument);
-                }
-            },
-
-            SequenceExpression(node) {
-                node.expressions
-                    .filter(e => hasExcessParens(e) && precedence(e) >= precedence(node))
-                    .forEach(report);
-            },
-
-            SwitchCase(node) {
-                if (node.test && hasExcessParens(node.test)) {
-                    report(node.test);
-                }
-            },
-
-            SwitchStatement(node) {
-                if (hasDoubleExcessParens(node.discriminant)) {
-                    report(node.discriminant);
-                }
-            },
-
-            ThrowStatement(node) {
-                const throwToken = sourceCode.getFirstToken(node);
-
-                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {
-                    report(node.argument);
-                }
-            },
-
-            UnaryExpression: checkUnaryUpdate,
-            UpdateExpression: checkUnaryUpdate,
-            AwaitExpression: checkUnaryUpdate,
-
-            VariableDeclarator(node) {
-                if (node.init && hasExcessParens(node.init) &&
-                        precedence(node.init) >= PRECEDENCE_OF_ASSIGNMENT_EXPR &&
-
-                        // RegExp literal is allowed to have parens (#1589)
-                        !(node.init.type === "Literal" && node.init.regex)) {
-                    report(node.init);
-                }
-            },
-
-            WhileStatement(node) {
-                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
-                    report(node.test);
-                }
-            },
-
-            WithStatement(node) {
-                if (hasDoubleExcessParens(node.object)) {
-                    report(node.object);
-                }
-            },
-
-            YieldExpression(node) {
-                if (node.argument) {
-                    const yieldToken = sourceCode.getFirstToken(node);
-
-                    if ((precedence(node.argument) >= precedence(node) &&
-                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||
-                            hasDoubleExcessParens(node.argument)) {
-                        report(node.argument);
-                    }
-                }
-            },
-
-            ClassDeclaration: checkClass,
-            ClassExpression: checkClass,
-
-            SpreadElement: checkSpreadOperator,
-            SpreadProperty: checkSpreadOperator,
-            ExperimentalSpreadProperty: checkSpreadOperator
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-implied-eval.js
===================================================================
--- node_modules/eslint/lib/rules/no-implied-eval.js	(revision )
+++ node_modules/eslint/lib/rules/no-implied-eval.js	(revision )
@@ -1,160 +0,0 @@
-/**
- * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval
- * @author James Allardice
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of `eval()`-like methods",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const CALLEE_RE = /^(setTimeout|setInterval|execScript)$/;
-
-        /*
-         * Figures out if we should inspect a given binary expression. Is a stack
-         * of stacks, where the first element in each substack is a CallExpression.
-         */
-        const impliedEvalAncestorsStack = [];
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Get the last element of an array, without modifying arr, like pop(), but non-destructive.
-         * @param {array} arr What to inspect
-         * @returns {*} The last element of arr
-         * @private
-         */
-        function last(arr) {
-            return arr ? arr[arr.length - 1] : null;
-        }
-
-        /**
-         * Checks if the given MemberExpression node is a potentially implied eval identifier on window.
-         * @param {ASTNode} node The MemberExpression node to check.
-         * @returns {boolean} Whether or not the given node is potentially an implied eval.
-         * @private
-         */
-        function isImpliedEvalMemberExpression(node) {
-            const object = node.object,
-                property = node.property,
-                hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);
-
-            return object.name === "window" && hasImpliedEvalName;
-        }
-
-        /**
-         * Determines if a node represents a call to a potentially implied eval.
-         *
-         * This checks the callee name and that there's an argument, but not the type of the argument.
-         *
-         * @param {ASTNode} node The CallExpression to check.
-         * @returns {boolean} True if the node matches, false if not.
-         * @private
-         */
-        function isImpliedEvalCallExpression(node) {
-            const isMemberExpression = (node.callee.type === "MemberExpression"),
-                isIdentifier = (node.callee.type === "Identifier"),
-                isImpliedEvalCallee =
-                    (isIdentifier && CALLEE_RE.test(node.callee.name)) ||
-                    (isMemberExpression && isImpliedEvalMemberExpression(node.callee));
-
-            return isImpliedEvalCallee && node.arguments.length;
-        }
-
-        /**
-         * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.
-         * @param {ASTNode} node The node to inspect the parent of.
-         * @returns {boolean} Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?
-         * @private
-         */
-        function hasImpliedEvalParent(node) {
-
-            // make sure our parent is marked
-            return node.parent === last(last(impliedEvalAncestorsStack)) &&
-
-                // if our parent is a CallExpression, make sure we're the first argument
-                (node.parent.type !== "CallExpression" || node === node.parent.arguments[0]);
-        }
-
-        /**
-         * Checks if our parent is marked as part of an implied eval argument. If
-         * so, collapses the top of impliedEvalAncestorsStack and reports on the
-         * original CallExpression.
-         * @param {ASTNode} node The CallExpression to check.
-         * @returns {boolean} True if the node matches, false if not.
-         * @private
-         */
-        function checkString(node) {
-            if (hasImpliedEvalParent(node)) {
-
-                // remove the entire substack, to avoid duplicate reports
-                const substack = impliedEvalAncestorsStack.pop();
-
-                context.report({ node: substack[0], message: "Implied eval. Consider passing a function instead of a string." });
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            CallExpression(node) {
-                if (isImpliedEvalCallExpression(node)) {
-
-                    // call expressions create a new substack
-                    impliedEvalAncestorsStack.push([node]);
-                }
-            },
-
-            "CallExpression:exit"(node) {
-                if (node === last(last(impliedEvalAncestorsStack))) {
-
-                    /* Destroys the entire sub-stack, rather than just using
-                     * last(impliedEvalAncestorsStack).pop(), as a CallExpression is
-                     * always the bottom of a impliedEvalAncestorsStack substack.
-                     */
-                    impliedEvalAncestorsStack.pop();
-                }
-            },
-
-            BinaryExpression(node) {
-                if (node.operator === "+" && hasImpliedEvalParent(node)) {
-                    last(impliedEvalAncestorsStack).push(node);
-                }
-            },
-
-            "BinaryExpression:exit"(node) {
-                if (node === last(last(impliedEvalAncestorsStack))) {
-                    last(impliedEvalAncestorsStack).pop();
-                }
-            },
-
-            Literal(node) {
-                if (typeof node.value === "string") {
-                    checkString(node);
-                }
-            },
-
-            TemplateLiteral(node) {
-                checkString(node);
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-invalid-this.js
===================================================================
--- node_modules/eslint/lib/rules/no-invalid-this.js	(revision )
+++ node_modules/eslint/lib/rules/no-invalid-this.js	(revision )
@@ -1,123 +0,0 @@
-/**
- * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `this` keywords outside of classes or class-like objects",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const stack = [],
-            sourceCode = context.getSourceCode();
-
-        /**
-         * Gets the current checking context.
-         *
-         * The return value has a flag that whether or not `this` keyword is valid.
-         * The flag is initialized when got at the first time.
-         *
-         * @returns {{valid: boolean}}
-         *   an object which has a flag that whether or not `this` keyword is valid.
-         */
-        stack.getCurrent = function() {
-            const current = this[this.length - 1];
-
-            if (!current.init) {
-                current.init = true;
-                current.valid = !astUtils.isDefaultThisBinding(
-                    current.node,
-                    sourceCode
-                );
-            }
-            return current;
-        };
-
-        /**
-         * Pushs new checking context into the stack.
-         *
-         * The checking context is not initialized yet.
-         * Because most functions don't have `this` keyword.
-         * When `this` keyword was found, the checking context is initialized.
-         *
-         * @param {ASTNode} node - A function node that was entered.
-         * @returns {void}
-         */
-        function enterFunction(node) {
-
-            // `this` can be invalid only under strict mode.
-            stack.push({
-                init: !context.getScope().isStrict,
-                node,
-                valid: true
-            });
-        }
-
-        /**
-         * Pops the current checking context from the stack.
-         * @returns {void}
-         */
-        function exitFunction() {
-            stack.pop();
-        }
-
-        return {
-
-            /*
-             * `this` is invalid only under strict mode.
-             * Modules is always strict mode.
-             */
-            Program(node) {
-                const scope = context.getScope(),
-                    features = context.parserOptions.ecmaFeatures || {};
-
-                stack.push({
-                    init: true,
-                    node,
-                    valid: !(
-                        scope.isStrict ||
-                        node.sourceType === "module" ||
-                        (features.globalReturn && scope.childScopes[0].isStrict)
-                    )
-                });
-            },
-
-            "Program:exit"() {
-                stack.pop();
-            },
-
-            FunctionDeclaration: enterFunction,
-            "FunctionDeclaration:exit": exitFunction,
-            FunctionExpression: enterFunction,
-            "FunctionExpression:exit": exitFunction,
-
-            // Reports if `this` of the current context is invalid.
-            ThisExpression(node) {
-                const current = stack.getCurrent();
-
-                if (current && !current.valid) {
-                    context.report({ node, message: "Unexpected 'this'." });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-multi-assign.js
===================================================================
--- node_modules/eslint/lib/rules/no-multi-assign.js	(revision )
+++ node_modules/eslint/lib/rules/no-multi-assign.js	(revision )
@@ -1,41 +0,0 @@
-/**
- * @fileoverview Rule to check use of chained assignment expressions
- * @author Stewart Rand
- */
-
-"use strict";
-
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow use of chained assignment expressions",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        schema: []
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            AssignmentExpression(node) {
-                if (["AssignmentExpression", "VariableDeclarator"].indexOf(node.parent.type) !== -1) {
-                    context.report({
-                        node,
-                        message: "Unexpected chained assignment."
-                    });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-multi-spaces.js
===================================================================
--- node_modules/eslint/lib/rules/no-multi-spaces.js	(revision )
+++ node_modules/eslint/lib/rules/no-multi-spaces.js	(revision )
@@ -1,130 +0,0 @@
-/**
- * @fileoverview Disallow use of multiple spaces.
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow multiple spaces",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    exceptions: {
-                        type: "object",
-                        patternProperties: {
-                            "^([A-Z][a-z]*)+$": {
-                                type: "boolean"
-                            }
-                        },
-                        additionalProperties: false
-                    },
-                    ignoreEOLComments: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const options = context.options[0] || {};
-        const ignoreEOLComments = options.ignoreEOLComments;
-        const exceptions = Object.assign({ Property: true }, options.exceptions);
-        const hasExceptions = Object.keys(exceptions).filter(key => exceptions[key]).length > 0;
-
-        /**
-         * Formats value of given comment token for error message by truncating its length.
-         * @param {Token} token comment token
-         * @returns {string} formatted value
-         * @private
-         */
-        function formatReportedCommentValue(token) {
-            const valueLines = token.value.split("\n");
-            const value = valueLines[0];
-            const formattedValue = `${value.slice(0, 12)}...`;
-
-            return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            Program() {
-                sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {
-                    if (leftIndex === tokensAndComments.length - 1) {
-                        return;
-                    }
-                    const rightToken = tokensAndComments[leftIndex + 1];
-
-                    // Ignore tokens that don't have 2 spaces between them or are on different lines
-                    if (
-                        !sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes("  ") ||
-                        leftToken.loc.end.line < rightToken.loc.start.line
-                    ) {
-                        return;
-                    }
-
-                    // Ignore comments that are the last token on their line if `ignoreEOLComments` is active.
-                    if (
-                        ignoreEOLComments &&
-                        astUtils.isCommentToken(rightToken) &&
-                        (
-                            leftIndex === tokensAndComments.length - 2 ||
-                            rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line
-                        )
-                    ) {
-                        return;
-                    }
-
-                    // Ignore tokens that are in a node in the "exceptions" object
-                    if (hasExceptions) {
-                        const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);
-
-                        if (parentNode && exceptions[parentNode.type]) {
-                            return;
-                        }
-                    }
-
-                    let displayValue;
-
-                    if (rightToken.type === "Block") {
-                        displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;
-                    } else if (rightToken.type === "Line") {
-                        displayValue = `//${formatReportedCommentValue(rightToken)}`;
-                    } else {
-                        displayValue = rightToken.value;
-                    }
-
-                    context.report({
-                        node: rightToken,
-                        loc: rightToken.loc.start,
-                        message: "Multiple spaces found before '{{displayValue}}'.",
-                        data: { displayValue },
-                        fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], " ")
-                    });
-                });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-new-wrappers.js
===================================================================
--- node_modules/eslint/lib/rules/no-new-wrappers.js	(revision )
+++ node_modules/eslint/lib/rules/no-new-wrappers.js	(revision )
@@ -1,37 +0,0 @@
-/**
- * @fileoverview Rule to flag when using constructor for wrapper objects
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `new` operators with the `String`, `Number`, and `Boolean` objects",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            NewExpression(node) {
-                const wrapperObjects = ["String", "Number", "Boolean", "Math", "JSON"];
-
-                if (wrapperObjects.indexOf(node.callee.name) > -1) {
-                    context.report({ node, message: "Do not use {{fn}} as a constructor.", data: { fn: node.callee.name } });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-octal-escape.js
===================================================================
--- node_modules/eslint/lib/rules/no-octal-escape.js	(revision )
+++ node_modules/eslint/lib/rules/no-octal-escape.js	(revision )
@@ -1,47 +0,0 @@
-/**
- * @fileoverview Rule to flag octal escape sequences in string literals.
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow octal escape sequences in string literals",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            Literal(node) {
-                if (typeof node.value !== "string") {
-                    return;
-                }
-
-                const match = node.raw.match(/^([^\\]|\\[^0-7])*\\([0-3][0-7]{1,2}|[4-7][0-7]|[0-7])/);
-
-                if (match) {
-                    const octalDigit = match[2];
-
-                    // \0 is actually not considered an octal
-                    if (match[2] !== "0" || typeof match[3] !== "undefined") {
-                        context.report({ node, message: "Don't use octal: '\\{{octalDigit}}'. Use '\\u....' instead.", data: { octalDigit } });
-                    }
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-process-exit.js
===================================================================
--- node_modules/eslint/lib/rules/no-process-exit.js	(revision )
+++ node_modules/eslint/lib/rules/no-process-exit.js	(revision )
@@ -1,35 +0,0 @@
-/**
- * @fileoverview Disallow the use of process.exit()
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of `process.exit()`",
-            category: "Node.js and CommonJS",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            "CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']"(node) {
-                context.report({ node: node.parent, message: "Don't use process.exit(); throw an error instead." });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-regex-spaces.js
===================================================================
--- node_modules/eslint/lib/rules/no-regex-spaces.js	(revision )
+++ node_modules/eslint/lib/rules/no-regex-spaces.js	(revision )
@@ -1,114 +0,0 @@
-/**
- * @fileoverview Rule to count multiple spaces in regular expressions
- * @author Matt DuVall <http://www.mattduvall.com/>
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow multiple spaces in regular expressions",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Validate regular expressions
-         * @param {ASTNode} node node to validate
-         * @param {string} value regular expression to validate
-         * @param {number} valueStart The start location of the regex/string literal. It will always be the case that
-         `sourceCode.getText().slice(valueStart, valueStart + value.length) === value`
-         * @returns {void}
-         * @private
-         */
-        function checkRegex(node, value, valueStart) {
-            const multipleSpacesRegex = /( {2,})( [+*{?]|[^+*{?]|$)/,
-                regexResults = multipleSpacesRegex.exec(value);
-
-            if (regexResults !== null) {
-                const count = regexResults[1].length;
-
-                context.report({
-                    node,
-                    message: "Spaces are hard to count. Use {{{count}}}.",
-                    data: { count },
-                    fix(fixer) {
-                        return fixer.replaceTextRange(
-                            [valueStart + regexResults.index, valueStart + regexResults.index + count],
-                            ` {${count}}`
-                        );
-                    }
-                });
-
-                /*
-                 * TODO: (platinumazure) Fix message to use rule message
-                 * substitution when api.report is fixed in lib/eslint.js.
-                 */
-            }
-        }
-
-        /**
-         * Validate regular expression literals
-         * @param {ASTNode} node node to validate
-         * @returns {void}
-         * @private
-         */
-        function checkLiteral(node) {
-            const token = sourceCode.getFirstToken(node),
-                nodeType = token.type,
-                nodeValue = token.value;
-
-            if (nodeType === "RegularExpression") {
-                checkRegex(node, nodeValue, token.range[0]);
-            }
-        }
-
-        /**
-         * Check if node is a string
-         * @param {ASTNode} node node to evaluate
-         * @returns {boolean} True if its a string
-         * @private
-         */
-        function isString(node) {
-            return node && node.type === "Literal" && typeof node.value === "string";
-        }
-
-        /**
-         * Validate strings passed to the RegExp constructor
-         * @param {ASTNode} node node to validate
-         * @returns {void}
-         * @private
-         */
-        function checkFunction(node) {
-            const scope = context.getScope();
-            const regExpVar = astUtils.getVariableByName(scope, "RegExp");
-            const shadowed = regExpVar && regExpVar.defs.length > 0;
-
-            if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0]) && !shadowed) {
-                checkRegex(node, node.arguments[0].value, node.arguments[0].range[0] + 1);
-            }
-        }
-
-        return {
-            Literal: checkLiteral,
-            CallExpression: checkFunction,
-            NewExpression: checkFunction
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-return-await.js
===================================================================
--- node_modules/eslint/lib/rules/no-return-await.js	(revision )
+++ node_modules/eslint/lib/rules/no-return-await.js	(revision )
@@ -1,94 +0,0 @@
-/**
- * @fileoverview Disallows unnecessary `return await`
- * @author Jordan Harband
- */
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const message = "Redundant use of `await` on a return value.";
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary `return await`",
-            category: "Best Practices",
-            recommended: false // TODO: set to true
-        },
-        fixable: null,
-        schema: [
-        ]
-    },
-
-    create(context) {
-
-        /**
-         * Reports a found unnecessary `await` expression.
-         * @param {ASTNode} node The node representing the `await` expression to report
-         * @returns {void}
-         */
-        function reportUnnecessaryAwait(node) {
-            context.report({
-                node: context.getSourceCode().getFirstToken(node),
-                loc: node.loc,
-                message
-            });
-        }
-
-        /**
-        * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting
-        * this function. For example, a statement in a `try` block will always have an error handler. A statement in
-        * a `catch` block will only have an error handler if there is also a `finally` block.
-        * @param {ASTNode} node A node representing a location where an could be thrown
-        * @returns {boolean} `true` if a thrown error will be caught/handled in this function
-        */
-        function hasErrorHandler(node) {
-            let ancestor = node;
-
-            while (!astUtils.isFunction(ancestor) && ancestor.type !== "Program") {
-                if (ancestor.parent.type === "TryStatement" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {
-                    return true;
-                }
-                ancestor = ancestor.parent;
-            }
-            return false;
-        }
-
-        /**
-         * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,
-         * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.
-         * @param {ASTNode} node A node representing the `await` expression to check
-         * @returns {boolean} The checking result
-         */
-        function isInTailCallPosition(node) {
-            if (node.parent.type === "ArrowFunctionExpression") {
-                return true;
-            }
-            if (node.parent.type === "ReturnStatement") {
-                return !hasErrorHandler(node.parent);
-            }
-            if (node.parent.type === "ConditionalExpression" && (node === node.parent.consequent || node === node.parent.alternate)) {
-                return isInTailCallPosition(node.parent);
-            }
-            if (node.parent.type === "LogicalExpression" && node === node.parent.right) {
-                return isInTailCallPosition(node.parent);
-            }
-            if (node.parent.type === "SequenceExpression" && node === node.parent.expressions[node.parent.expressions.length - 1]) {
-                return isInTailCallPosition(node.parent);
-            }
-            return false;
-        }
-
-        return {
-            AwaitExpression(node) {
-                if (isInTailCallPosition(node) && !hasErrorHandler(node)) {
-                    reportUnnecessaryAwait(node);
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-self-compare.js
===================================================================
--- node_modules/eslint/lib/rules/no-self-compare.js	(revision )
+++ node_modules/eslint/lib/rules/no-self-compare.js	(revision )
@@ -1,53 +0,0 @@
-/**
- * @fileoverview Rule to flag comparison where left part is the same as the right
- * part.
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow comparisons where both sides are exactly the same",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Determines whether two nodes are composed of the same tokens.
-         * @param {ASTNode} nodeA The first node
-         * @param {ASTNode} nodeB The second node
-         * @returns {boolean} true if the nodes have identical token representations
-         */
-        function hasSameTokens(nodeA, nodeB) {
-            const tokensA = sourceCode.getTokens(nodeA);
-            const tokensB = sourceCode.getTokens(nodeB);
-
-            return tokensA.length === tokensB.length &&
-                tokensA.every((token, index) => token.type === tokensB[index].type && token.value === tokensB[index].value);
-        }
-
-        return {
-
-            BinaryExpression(node) {
-                const operators = new Set(["===", "==", "!==", "!=", ">", "<", ">=", "<="]);
-
-                if (operators.has(node.operator) && hasSameTokens(node.left, node.right)) {
-                    context.report({ node, message: "Comparing to itself is potentially pointless." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-useless-call.js
===================================================================
--- node_modules/eslint/lib/rules/no-useless-call.js	(revision )
+++ node_modules/eslint/lib/rules/no-useless-call.js	(revision )
@@ -1,104 +0,0 @@
-/**
- * @fileoverview A rule to disallow unnecessary `.call()` and `.apply()`.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a node is a `.call()`/`.apply()`.
- * @param {ASTNode} node - A CallExpression node to check.
- * @returns {boolean} Whether or not the node is a `.call()`/`.apply()`.
- */
-function isCallOrNonVariadicApply(node) {
-    return (
-        node.callee.type === "MemberExpression" &&
-        node.callee.property.type === "Identifier" &&
-        node.callee.computed === false &&
-        (
-            (node.callee.property.name === "call" && node.arguments.length >= 1) ||
-            (node.callee.property.name === "apply" && node.arguments.length === 2 && node.arguments[1].type === "ArrayExpression")
-        )
-    );
-}
-
-/**
- * Checks whether or not the tokens of two given nodes are same.
- * @param {ASTNode} left - A node 1 to compare.
- * @param {ASTNode} right - A node 2 to compare.
- * @param {SourceCode} sourceCode - The ESLint source code object.
- * @returns {boolean} the source code for the given node.
- */
-function equalTokens(left, right, sourceCode) {
-    const tokensL = sourceCode.getTokens(left);
-    const tokensR = sourceCode.getTokens(right);
-
-    if (tokensL.length !== tokensR.length) {
-        return false;
-    }
-    for (let i = 0; i < tokensL.length; ++i) {
-        if (tokensL[i].type !== tokensR[i].type ||
-            tokensL[i].value !== tokensR[i].value
-        ) {
-            return false;
-        }
-    }
-
-    return true;
-}
-
-/**
- * Checks whether or not `thisArg` is not changed by `.call()`/`.apply()`.
- * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.
- * @param {ASTNode} thisArg - The node that is given to the first argument of the `.call()`/`.apply()`.
- * @param {SourceCode} sourceCode - The ESLint source code object.
- * @returns {boolean} Whether or not `thisArg` is not changed by `.call()`/`.apply()`.
- */
-function isValidThisArg(expectedThis, thisArg, sourceCode) {
-    if (!expectedThis) {
-        return astUtils.isNullOrUndefined(thisArg);
-    }
-    return equalTokens(expectedThis, thisArg, sourceCode);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary calls to `.call()` and `.apply()`",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-            CallExpression(node) {
-                if (!isCallOrNonVariadicApply(node)) {
-                    return;
-                }
-
-                const applied = node.callee.object;
-                const expectedThis = (applied.type === "MemberExpression") ? applied.object : null;
-                const thisArg = node.arguments[0];
-
-                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
-                    context.report({ node, message: "unnecessary '.{{name}}()'.", data: { name: node.callee.property.name } });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/prefer-template.js
===================================================================
--- node_modules/eslint/lib/rules/prefer-template.js	(revision )
+++ node_modules/eslint/lib/rules/prefer-template.js	(revision )
@@ -1,228 +0,0 @@
-/**
- * @fileoverview A rule to suggest using template literals instead of string concatenation.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a given node is a concatenation.
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} `true` if the node is a concatenation.
- */
-function isConcatenation(node) {
-    return node.type === "BinaryExpression" && node.operator === "+";
-}
-
-/**
- * Gets the top binary expression node for concatenation in parents of a given node.
- * @param {ASTNode} node - A node to get.
- * @returns {ASTNode} the top binary expression node in parents of a given node.
- */
-function getTopConcatBinaryExpression(node) {
-    while (isConcatenation(node.parent)) {
-        node = node.parent;
-    }
-    return node;
-}
-
-/**
-* Checks whether or not a given binary expression has string literals.
-* @param {ASTNode} node - A node to check.
-* @returns {boolean} `true` if the node has string literals.
-*/
-function hasStringLiteral(node) {
-    if (isConcatenation(node)) {
-
-        // `left` is deeper than `right` normally.
-        return hasStringLiteral(node.right) || hasStringLiteral(node.left);
-    }
-    return astUtils.isStringLiteral(node);
-}
-
-/**
- * Checks whether or not a given binary expression has non string literals.
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} `true` if the node has non string literals.
- */
-function hasNonStringLiteral(node) {
-    if (isConcatenation(node)) {
-
-        // `left` is deeper than `right` normally.
-        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
-    }
-    return !astUtils.isStringLiteral(node);
-}
-
-/**
-* Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.
-* @param {ASTNode} node The node that will be fixed to a template literal
-* @returns {boolean} `true` if the node will start with a template curly.
-*/
-function startsWithTemplateCurly(node) {
-    if (node.type === "BinaryExpression") {
-        return startsWithTemplateCurly(node.left);
-    }
-    if (node.type === "TemplateLiteral") {
-        return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];
-    }
-    return node.type !== "Literal" || typeof node.value !== "string";
-}
-
-/**
-* Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.
-* @param {ASTNode} node The node that will be fixed to a template literal
-* @returns {boolean} `true` if the node will end with a template curly.
-*/
-function endsWithTemplateCurly(node) {
-    if (node.type === "BinaryExpression") {
-        return startsWithTemplateCurly(node.right);
-    }
-    if (node.type === "TemplateLiteral") {
-        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];
-    }
-    return node.type !== "Literal" || typeof node.value !== "string";
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require template literals instead of string concatenation",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        let done = Object.create(null);
-
-        /**
-        * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.
-        * @param {ASTNode} node1 The first node
-        * @param {ASTNode} node2 The second node
-        * @returns {string} The text between the nodes, excluding other tokens
-        */
-        function getTextBetween(node1, node2) {
-            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);
-            const sourceText = sourceCode.getText();
-
-            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), "");
-        }
-
-        /**
-        * Returns a template literal form of the given node.
-        * @param {ASTNode} currentNode A node that should be converted to a template literal
-        * @param {string} textBeforeNode Text that should appear before the node
-        * @param {string} textAfterNode Text that should appear after the node
-        * @returns {string} A string form of this node, represented as a template literal
-        */
-        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {
-            if (currentNode.type === "Literal" && typeof currentNode.value === "string") {
-
-                // If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted
-                // as a template placeholder. However, if the code already contains a backslash before the ${ or `
-                // for some reason, don't add another backslash, because that would change the meaning of the code (it would cause
-                // an actual backslash character to appear before the dollar sign).
-                return `\`${currentNode.raw.slice(1, -1).replace(/\\*(\${|`)/g, matched => {
-                    if (matched.lastIndexOf("\\") % 2) {
-                        return `\\${matched}`;
-                    }
-                    return matched;
-
-                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.
-                }).replace(new RegExp(`\\\\${currentNode.raw[0]}`, "g"), currentNode.raw[0])}\``;
-            }
-
-            if (currentNode.type === "TemplateLiteral") {
-                return sourceCode.getText(currentNode);
-            }
-
-            if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {
-                const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === "+");
-                const textBeforePlus = getTextBetween(currentNode.left, plusSign);
-                const textAfterPlus = getTextBetween(plusSign, currentNode.right);
-                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);
-                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);
-
-                if (leftEndsWithCurly) {
-
-                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.
-                    // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`
-                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +
-                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);
-                }
-                if (rightStartsWithCurly) {
-
-                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.
-                    // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`
-                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +
-                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);
-                }
-
-                // Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put
-                // the text between them.
-                return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;
-            }
-
-            return `\`\${${textBeforeNode || ""}${sourceCode.getText(currentNode)}${textAfterNode || ""}}\``;
-        }
-
-        /**
-         * Reports if a given node is string concatenation with non string literals.
-         *
-         * @param {ASTNode} node - A node to check.
-         * @returns {void}
-         */
-        function checkForStringConcat(node) {
-            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {
-                return;
-            }
-
-            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);
-
-            // Checks whether or not this node had been checked already.
-            if (done[topBinaryExpr.range[0]]) {
-                return;
-            }
-            done[topBinaryExpr.range[0]] = true;
-
-            if (hasNonStringLiteral(topBinaryExpr)) {
-                context.report({
-                    node: topBinaryExpr,
-                    message: "Unexpected string concatenation.",
-                    fix(fixer) {
-                        return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));
-                    }
-                });
-            }
-        }
-
-        return {
-            Program() {
-                done = Object.create(null);
-            },
-
-            Literal: checkForStringConcat,
-            TemplateLiteral: checkForStringConcat
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/space-in-parens.js
===================================================================
--- node_modules/eslint/lib/rules/space-in-parens.js	(revision )
+++ node_modules/eslint/lib/rules/space-in-parens.js	(revision )
@@ -1,275 +0,0 @@
-/**
- * @fileoverview Disallows or enforces spaces inside of parentheses.
- * @author Jonathan Rajavuori
- */
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing inside parentheses",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                enum: ["always", "never"]
-            },
-            {
-                type: "object",
-                properties: {
-                    exceptions: {
-                        type: "array",
-                        items: {
-                            enum: ["{}", "[]", "()", "empty"]
-                        },
-                        uniqueItems: true
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const MISSING_SPACE_MESSAGE = "There must be a space inside this paren.",
-            REJECTED_SPACE_MESSAGE = "There should be no spaces inside this paren.",
-            ALWAYS = context.options[0] === "always",
-
-            exceptionsArrayOptions = (context.options.length === 2) ? context.options[1].exceptions : [],
-            options = {};
-        let exceptions;
-
-        if (exceptionsArrayOptions.length) {
-            options.braceException = exceptionsArrayOptions.indexOf("{}") !== -1;
-            options.bracketException = exceptionsArrayOptions.indexOf("[]") !== -1;
-            options.parenException = exceptionsArrayOptions.indexOf("()") !== -1;
-            options.empty = exceptionsArrayOptions.indexOf("empty") !== -1;
-        }
-
-        /**
-         * Produces an object with the opener and closer exception values
-         * @param {Object} opts The exception options
-         * @returns {Object} `openers` and `closers` exception values
-         * @private
-         */
-        function getExceptions() {
-            const openers = [],
-                closers = [];
-
-            if (options.braceException) {
-                openers.push("{");
-                closers.push("}");
-            }
-
-            if (options.bracketException) {
-                openers.push("[");
-                closers.push("]");
-            }
-
-            if (options.parenException) {
-                openers.push("(");
-                closers.push(")");
-            }
-
-            if (options.empty) {
-                openers.push(")");
-                closers.push("(");
-            }
-
-            return {
-                openers,
-                closers
-            };
-        }
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Determines if a token is one of the exceptions for the opener paren
-         * @param {Object} token The token to check
-         * @returns {boolean} True if the token is one of the exceptions for the opener paren
-         */
-        function isOpenerException(token) {
-            return token.type === "Punctuator" && exceptions.openers.indexOf(token.value) >= 0;
-        }
-
-        /**
-         * Determines if a token is one of the exceptions for the closer paren
-         * @param {Object} token The token to check
-         * @returns {boolean} True if the token is one of the exceptions for the closer paren
-         */
-        function isCloserException(token) {
-            return token.type === "Punctuator" && exceptions.closers.indexOf(token.value) >= 0;
-        }
-
-        /**
-         * Determines if an opener paren should have a missing space after it
-         * @param {Object} left The paren token
-         * @param {Object} right The token after it
-         * @returns {boolean} True if the paren should have a space
-         */
-        function shouldOpenerHaveSpace(left, right) {
-            if (sourceCode.isSpaceBetweenTokens(left, right)) {
-                return false;
-            }
-
-            if (ALWAYS) {
-                if (astUtils.isClosingParenToken(right)) {
-                    return false;
-                }
-                return !isOpenerException(right);
-            }
-            return isOpenerException(right);
-
-        }
-
-        /**
-         * Determines if an closer paren should have a missing space after it
-         * @param {Object} left The token before the paren
-         * @param {Object} right The paren token
-         * @returns {boolean} True if the paren should have a space
-         */
-        function shouldCloserHaveSpace(left, right) {
-            if (astUtils.isOpeningParenToken(left)) {
-                return false;
-            }
-
-            if (sourceCode.isSpaceBetweenTokens(left, right)) {
-                return false;
-            }
-
-            if (ALWAYS) {
-                return !isCloserException(left);
-            }
-            return isCloserException(left);
-
-        }
-
-        /**
-         * Determines if an opener paren should not have an existing space after it
-         * @param {Object} left The paren token
-         * @param {Object} right The token after it
-         * @returns {boolean} True if the paren should reject the space
-         */
-        function shouldOpenerRejectSpace(left, right) {
-            if (right.type === "Line") {
-                return false;
-            }
-
-            if (!astUtils.isTokenOnSameLine(left, right)) {
-                return false;
-            }
-
-            if (!sourceCode.isSpaceBetweenTokens(left, right)) {
-                return false;
-            }
-
-            if (ALWAYS) {
-                return isOpenerException(right);
-            }
-            return !isOpenerException(right);
-
-        }
-
-        /**
-         * Determines if an closer paren should not have an existing space after it
-         * @param {Object} left The token before the paren
-         * @param {Object} right The paren token
-         * @returns {boolean} True if the paren should reject the space
-         */
-        function shouldCloserRejectSpace(left, right) {
-            if (astUtils.isOpeningParenToken(left)) {
-                return false;
-            }
-
-            if (!astUtils.isTokenOnSameLine(left, right)) {
-                return false;
-            }
-
-            if (!sourceCode.isSpaceBetweenTokens(left, right)) {
-                return false;
-            }
-
-            if (ALWAYS) {
-                return isCloserException(left);
-            }
-            return !isCloserException(left);
-
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            Program: function checkParenSpaces(node) {
-                exceptions = getExceptions();
-                const tokens = sourceCode.tokensAndComments;
-
-                tokens.forEach((token, i) => {
-                    const prevToken = tokens[i - 1];
-                    const nextToken = tokens[i + 1];
-
-                    if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {
-                        return;
-                    }
-
-                    if (token.value === "(" && shouldOpenerHaveSpace(token, nextToken)) {
-                        context.report({
-                            node,
-                            loc: token.loc.start,
-                            message: MISSING_SPACE_MESSAGE,
-                            fix(fixer) {
-                                return fixer.insertTextAfter(token, " ");
-                            }
-                        });
-                    } else if (token.value === "(" && shouldOpenerRejectSpace(token, nextToken)) {
-                        context.report({
-                            node,
-                            loc: token.loc.start,
-                            message: REJECTED_SPACE_MESSAGE,
-                            fix(fixer) {
-                                return fixer.removeRange([token.range[1], nextToken.range[0]]);
-                            }
-                        });
-                    } else if (token.value === ")" && shouldCloserHaveSpace(prevToken, token)) {
-
-                        // context.report(node, token.loc.start, MISSING_SPACE_MESSAGE);
-                        context.report({
-                            node,
-                            loc: token.loc.start,
-                            message: MISSING_SPACE_MESSAGE,
-                            fix(fixer) {
-                                return fixer.insertTextBefore(token, " ");
-                            }
-                        });
-                    } else if (token.value === ")" && shouldCloserRejectSpace(prevToken, token)) {
-                        context.report({
-                            node,
-                            loc: token.loc.start,
-                            message: REJECTED_SPACE_MESSAGE,
-                            fix(fixer) {
-                                return fixer.removeRange([prevToken.range[1], token.range[0]]);
-                            }
-                        });
-                    }
-                });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/space-infix-ops.js
===================================================================
--- node_modules/eslint/lib/rules/space-infix-ops.js	(revision )
+++ node_modules/eslint/lib/rules/space-infix-ops.js	(revision )
@@ -1,167 +0,0 @@
-/**
- * @fileoverview Require spaces around infix operators
- * @author Michael Ficarra
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require spacing around infix operators",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    int32Hint: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;
-
-        const OPERATORS = [
-            "*", "/", "%", "+", "-", "<<", ">>", ">>>", "<", "<=", ">", ">=", "in",
-            "instanceof", "==", "!=", "===", "!==", "&", "^", "|", "&&", "||", "=",
-            "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "^=", "|=",
-            "?", ":", ",", "**"
-        ];
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Returns the first token which violates the rule
-         * @param {ASTNode} left - The left node of the main node
-         * @param {ASTNode} right - The right node of the main node
-         * @returns {Object} The violator token or null
-         * @private
-         */
-        function getFirstNonSpacedToken(left, right) {
-            const tokens = sourceCode.getTokensBetween(left, right, 1);
-
-            for (let i = 1, l = tokens.length - 1; i < l; ++i) {
-                const op = tokens[i];
-
-                if (
-                    (op.type === "Punctuator" || op.type === "Keyword") &&
-                    OPERATORS.indexOf(op.value) >= 0 &&
-                    (tokens[i - 1].range[1] >= op.range[0] || op.range[1] >= tokens[i + 1].range[0])
-                ) {
-                    return op;
-                }
-            }
-            return null;
-        }
-
-        /**
-         * Reports an AST node as a rule violation
-         * @param {ASTNode} mainNode - The node to report
-         * @param {Object} culpritToken - The token which has a problem
-         * @returns {void}
-         * @private
-         */
-        function report(mainNode, culpritToken) {
-            context.report({
-                node: mainNode,
-                loc: culpritToken.loc.start,
-                message: "Infix operators must be spaced.",
-                fix(fixer) {
-                    const previousToken = sourceCode.getTokenBefore(culpritToken);
-                    const afterToken = sourceCode.getTokenAfter(culpritToken);
-                    let fixString = "";
-
-                    if (culpritToken.range[0] - previousToken.range[1] === 0) {
-                        fixString = " ";
-                    }
-
-                    fixString += culpritToken.value;
-
-                    if (afterToken.range[0] - culpritToken.range[1] === 0) {
-                        fixString += " ";
-                    }
-
-                    return fixer.replaceText(culpritToken, fixString);
-                }
-            });
-        }
-
-        /**
-         * Check if the node is binary then report
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkBinary(node) {
-            const leftNode = (node.left.typeAnnotation) ? node.left.typeAnnotation : node.left;
-            const rightNode = node.right;
-
-            const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode);
-
-            if (nonSpacedNode) {
-                if (!(int32Hint && sourceCode.getText(node).endsWith("|0"))) {
-                    report(node, nonSpacedNode);
-                }
-            }
-        }
-
-        /**
-         * Check if the node is conditional
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkConditional(node) {
-            const nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent);
-            const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate);
-
-            if (nonSpacedConsequesntNode) {
-                report(node, nonSpacedConsequesntNode);
-            } else if (nonSpacedAlternateNode) {
-                report(node, nonSpacedAlternateNode);
-            }
-        }
-
-        /**
-         * Check if the node is a variable
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkVar(node) {
-            const leftNode = (node.id.typeAnnotation) ? node.id.typeAnnotation : node.id;
-            const rightNode = node.init;
-
-            if (rightNode) {
-                const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode);
-
-                if (nonSpacedNode) {
-                    report(node, nonSpacedNode);
-                }
-            }
-        }
-
-        return {
-            AssignmentExpression: checkBinary,
-            AssignmentPattern: checkBinary,
-            BinaryExpression: checkBinary,
-            LogicalExpression: checkBinary,
-            ConditionalExpression: checkConditional,
-            VariableDeclarator: checkVar
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/space-unary-ops.js
===================================================================
--- node_modules/eslint/lib/rules/space-unary-ops.js	(revision )
+++ node_modules/eslint/lib/rules/space-unary-ops.js	(revision )
@@ -1,321 +0,0 @@
-/**
- * @fileoverview This rule shoud require or disallow spaces before or after unary operations.
- * @author Marcin Kumorek
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing before or after unary operators",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    words: {
-                        type: "boolean"
-                    },
-                    nonwords: {
-                        type: "boolean"
-                    },
-                    overrides: {
-                        type: "object",
-                        additionalProperties: {
-                            type: "boolean"
-                        }
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options && Array.isArray(context.options) && context.options[0] || { words: true, nonwords: false };
-
-        const sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-        * Check if the node is the first "!" in a "!!" convert to Boolean expression
-        * @param {ASTnode} node AST node
-        * @returns {boolean} Whether or not the node is first "!" in "!!"
-        */
-        function isFirstBangInBangBangExpression(node) {
-            return node && node.type === "UnaryExpression" && node.argument.operator === "!" &&
-                node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
-        }
-
-        /**
-        * Check if the node's child argument is an "ObjectExpression"
-        * @param {ASTnode} node AST node
-        * @returns {boolean} Whether or not the argument's type is "ObjectExpression"
-        */
-        function isArgumentObjectExpression(node) {
-            return node.argument && node.argument.type && node.argument.type === "ObjectExpression";
-        }
-
-        /**
-        * Checks if an override exists for a given operator.
-        * @param {ASTnode} node AST node
-        * @param {string} operator Operator
-        * @returns {boolean} Whether or not an override has been provided for the operator
-        */
-        function overrideExistsForOperator(node, operator) {
-            return options.overrides && options.overrides.hasOwnProperty(operator);
-        }
-
-        /**
-        * Gets the value that the override was set to for this operator
-        * @param {ASTnode} node AST node
-        * @param {string} operator Operator
-        * @returns {boolean} Whether or not an override enforces a space with this operator
-        */
-        function overrideEnforcesSpaces(node, operator) {
-            return options.overrides[operator];
-        }
-
-        /**
-        * Verify Unary Word Operator has spaces after the word operator
-        * @param {ASTnode} node AST node
-        * @param {Object} firstToken first token from the AST node
-        * @param {Object} secondToken second token from the AST node
-        * @param {string} word The word to be used for reporting
-        * @returns {void}
-        */
-        function verifyWordHasSpaces(node, firstToken, secondToken, word) {
-            if (secondToken.range[0] === firstToken.range[1]) {
-                context.report({
-                    node,
-                    message: "Unary word operator '{{word}}' must be followed by whitespace.",
-                    data: {
-                        word
-                    },
-                    fix(fixer) {
-                        return fixer.insertTextAfter(firstToken, " ");
-                    }
-                });
-            }
-        }
-
-        /**
-        * Verify Unary Word Operator doesn't have spaces after the word operator
-        * @param {ASTnode} node AST node
-        * @param {Object} firstToken first token from the AST node
-        * @param {Object} secondToken second token from the AST node
-        * @param {string} word The word to be used for reporting
-        * @returns {void}
-        */
-        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {
-            if (isArgumentObjectExpression(node)) {
-                if (secondToken.range[0] > firstToken.range[1]) {
-                    context.report({
-                        node,
-                        message: "Unexpected space after unary word operator '{{word}}'.",
-                        data: {
-                            word
-                        },
-                        fix(fixer) {
-                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
-                        }
-                    });
-                }
-            }
-        }
-
-        /**
-        * Check Unary Word Operators for spaces after the word operator
-        * @param {ASTnode} node AST node
-        * @param {Object} firstToken first token from the AST node
-        * @param {Object} secondToken second token from the AST node
-        * @param {string} word The word to be used for reporting
-        * @returns {void}
-        */
-        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
-            word = word || firstToken.value;
-
-            if (overrideExistsForOperator(node, word)) {
-                if (overrideEnforcesSpaces(node, word)) {
-                    verifyWordHasSpaces(node, firstToken, secondToken, word);
-                } else {
-                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
-                }
-            } else if (options.words) {
-                verifyWordHasSpaces(node, firstToken, secondToken, word);
-            } else {
-                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
-            }
-        }
-
-        /**
-        * Verifies YieldExpressions satisfy spacing requirements
-        * @param {ASTnode} node AST node
-        * @returns {void}
-        */
-        function checkForSpacesAfterYield(node) {
-            const tokens = sourceCode.getFirstTokens(node, 3),
-                word = "yield";
-
-            if (!node.argument || node.delegate) {
-                return;
-            }
-
-            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
-        }
-
-        /**
-        * Verifies AwaitExpressions satisfy spacing requirements
-        * @param {ASTNode} node AwaitExpression AST node
-        * @returns {void}
-        */
-        function checkForSpacesAfterAwait(node) {
-            const tokens = sourceCode.getFirstTokens(node, 3);
-
-            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "await");
-        }
-
-        /**
-        * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator
-        * @param {ASTnode} node AST node
-        * @param {Object} firstToken First token in the expression
-        * @param {Object} secondToken Second token in the expression
-        * @returns {void}
-        */
-        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {
-            if (node.prefix) {
-                if (isFirstBangInBangBangExpression(node)) {
-                    return;
-                }
-                if (firstToken.range[1] === secondToken.range[0]) {
-                    context.report({
-                        node,
-                        message: "Unary operator '{{operator}}' must be followed by whitespace.",
-                        data: {
-                            operator: firstToken.value
-                        },
-                        fix(fixer) {
-                            return fixer.insertTextAfter(firstToken, " ");
-                        }
-                    });
-                }
-            } else {
-                if (firstToken.range[1] === secondToken.range[0]) {
-                    context.report({
-                        node,
-                        message: "Space is required before unary expressions '{{token}}'.",
-                        data: {
-                            token: secondToken.value
-                        },
-                        fix(fixer) {
-                            return fixer.insertTextBefore(secondToken, " ");
-                        }
-                    });
-                }
-            }
-        }
-
-        /**
-        * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator
-        * @param {ASTnode} node AST node
-        * @param {Object} firstToken First token in the expression
-        * @param {Object} secondToken Second token in the expression
-        * @returns {void}
-        */
-        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {
-            if (node.prefix) {
-                if (secondToken.range[0] > firstToken.range[1]) {
-                    context.report({
-                        node,
-                        message: "Unexpected space after unary operator '{{operator}}'.",
-                        data: {
-                            operator: firstToken.value
-                        },
-                        fix(fixer) {
-                            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
-                                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
-                            }
-                            return null;
-                        }
-                    });
-                }
-            } else {
-                if (secondToken.range[0] > firstToken.range[1]) {
-                    context.report({
-                        node,
-                        message: "Unexpected space before unary operator '{{operator}}'.",
-                        data: {
-                            operator: secondToken.value
-                        },
-                        fix(fixer) {
-                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
-                        }
-                    });
-                }
-            }
-        }
-
-        /**
-        * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements
-        * @param {ASTnode} node AST node
-        * @returns {void}
-        */
-        function checkForSpaces(node) {
-            const tokens = node.type === "UpdateExpression" && !node.prefix
-                ? sourceCode.getLastTokens(node, 2)
-                : sourceCode.getFirstTokens(node, 2);
-            const firstToken = tokens[0];
-            const secondToken = tokens[1];
-
-            if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
-                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken);
-                return;
-            }
-
-            const operator = node.prefix ? tokens[0].value : tokens[1].value;
-
-            if (overrideExistsForOperator(node, operator)) {
-                if (overrideEnforcesSpaces(node, operator)) {
-                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);
-                } else {
-                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
-                }
-            } else if (options.nonwords) {
-                verifyNonWordsHaveSpaces(node, firstToken, secondToken);
-            } else {
-                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            UnaryExpression: checkForSpaces,
-            UpdateExpression: checkForSpaces,
-            NewExpression: checkForSpaces,
-            YieldExpression: checkForSpacesAfterYield,
-            AwaitExpression: checkForSpacesAfterAwait
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/arrow-body-style.js
===================================================================
--- node_modules/eslint/lib/rules/arrow-body-style.js	(revision )
+++ node_modules/eslint/lib/rules/arrow-body-style.js	(revision )
@@ -1,209 +0,0 @@
-/**
- * @fileoverview Rule to require braces in arrow function body.
- * @author Alberto Rodríguez
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require braces around arrow function bodies",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: {
-            anyOf: [
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["always", "never"]
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 1
-                },
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["as-needed"]
-                        },
-                        {
-                            type: "object",
-                            properties: {
-                                requireReturnForObjectLiteral: { type: "boolean" }
-                            },
-                            additionalProperties: false
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 2
-                }
-            ]
-        },
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const options = context.options;
-        const always = options[0] === "always";
-        const asNeeded = !options[0] || options[0] === "as-needed";
-        const never = options[0] === "never";
-        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Checks whether the given node has ASI problem or not.
-         * @param {Token} token The token to check.
-         * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.
-         */
-        function hasASIProblem(token) {
-            return token && token.type === "Punctuator" && /^[([/`+-]/.test(token.value);
-        }
-
-        /**
-         * Gets the closing parenthesis which is the pair of the given opening parenthesis.
-         * @param {Token} token The opening parenthesis token to get.
-         * @returns {Token} The found closing parenthesis token.
-         */
-        function findClosingParen(token) {
-            let node = sourceCode.getNodeByRangeIndex(token.range[1]);
-
-            while (!astUtils.isParenthesised(sourceCode, node)) {
-                node = node.parent;
-            }
-            return sourceCode.getTokenAfter(node);
-        }
-
-        /**
-         * Determines whether a arrow function body needs braces
-         * @param {ASTNode} node The arrow function node.
-         * @returns {void}
-         */
-        function validate(node) {
-            const arrowBody = node.body;
-
-            if (arrowBody.type === "BlockStatement") {
-                const blockBody = arrowBody.body;
-
-                if (blockBody.length !== 1 && !never) {
-                    return;
-                }
-
-                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === "ReturnStatement" &&
-                    blockBody[0].argument && blockBody[0].argument.type === "ObjectExpression") {
-                    return;
-                }
-
-                if (never || asNeeded && blockBody[0].type === "ReturnStatement") {
-                    context.report({
-                        node,
-                        loc: arrowBody.loc.start,
-                        message: "Unexpected block statement surrounding arrow body.",
-                        fix(fixer) {
-                            const fixes = [];
-
-                            if (blockBody.length !== 1 ||
-                                blockBody[0].type !== "ReturnStatement" ||
-                                !blockBody[0].argument ||
-                                hasASIProblem(sourceCode.getTokenAfter(arrowBody))
-                            ) {
-                                return fixes;
-                            }
-
-                            const openingBrace = sourceCode.getFirstToken(arrowBody);
-                            const closingBrace = sourceCode.getLastToken(arrowBody);
-                            const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);
-                            const lastValueToken = sourceCode.getLastToken(blockBody[0]);
-                            const commentsExist =
-                                sourceCode.commentsExistBetween(openingBrace, firstValueToken) ||
-                                sourceCode.commentsExistBetween(lastValueToken, closingBrace);
-
-                            // Remove tokens around the return value.
-                            // If comments don't exist, remove extra spaces as well.
-                            if (commentsExist) {
-                                fixes.push(
-                                    fixer.remove(openingBrace),
-                                    fixer.remove(closingBrace),
-                                    fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword
-                                );
-                            } else {
-                                fixes.push(
-                                    fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]),
-                                    fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]])
-                                );
-                            }
-
-                            // If the first token of the reutrn value is `{`,
-                            // enclose the return value by parentheses to avoid syntax error.
-                            if (astUtils.isOpeningBraceToken(firstValueToken)) {
-                                fixes.push(
-                                    fixer.insertTextBefore(firstValueToken, "("),
-                                    fixer.insertTextAfter(lastValueToken, ")")
-                                );
-                            }
-
-                            // If the last token of the return statement is semicolon, remove it.
-                            // Non-block arrow body is an expression, not a statement.
-                            if (astUtils.isSemicolonToken(lastValueToken)) {
-                                fixes.push(fixer.remove(lastValueToken));
-                            }
-
-                            return fixes;
-                        }
-                    });
-                }
-            } else {
-                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === "ObjectExpression")) {
-                    context.report({
-                        node,
-                        loc: arrowBody.loc.start,
-                        message: "Expected block statement surrounding arrow body.",
-                        fix(fixer) {
-                            const fixes = [];
-                            const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);
-                            const firstBodyToken = sourceCode.getTokenAfter(arrowToken);
-                            const lastBodyToken = sourceCode.getLastToken(node);
-                            const isParenthesisedObjectLiteral =
-                                astUtils.isOpeningParenToken(firstBodyToken) &&
-                                astUtils.isOpeningBraceToken(sourceCode.getTokenAfter(firstBodyToken));
-
-                            // Wrap the value by a block and a return statement.
-                            fixes.push(
-                                fixer.insertTextBefore(firstBodyToken, "{return "),
-                                fixer.insertTextAfter(lastBodyToken, "}")
-                            );
-
-                            // If the value is object literal, remove parentheses which were forced by syntax.
-                            if (isParenthesisedObjectLiteral) {
-                                fixes.push(
-                                    fixer.remove(firstBodyToken),
-                                    fixer.remove(findClosingParen(firstBodyToken))
-                                );
-                            }
-
-                            return fixes;
-                        }
-                    });
-                }
-            }
-        }
-
-        return {
-            "ArrowFunctionExpression:exit": validate
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/block-scoped-var.js
===================================================================
--- node_modules/eslint/lib/rules/block-scoped-var.js	(revision )
+++ node_modules/eslint/lib/rules/block-scoped-var.js	(revision )
@@ -1,115 +0,0 @@
-/**
- * @fileoverview Rule to check for "block scoped" variables by binding context
- * @author Matt DuVall <http://www.mattduvall.com>
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce the use of variables within the scope they are defined",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        let stack = [];
-
-        /**
-         * Makes a block scope.
-         * @param {ASTNode} node - A node of a scope.
-         * @returns {void}
-         */
-        function enterScope(node) {
-            stack.push(node.range);
-        }
-
-        /**
-         * Pops the last block scope.
-         * @returns {void}
-         */
-        function exitScope() {
-            stack.pop();
-        }
-
-        /**
-         * Reports a given reference.
-         * @param {eslint-scope.Reference} reference - A reference to report.
-         * @returns {void}
-         */
-        function report(reference) {
-            const identifier = reference.identifier;
-
-            context.report({ node: identifier, message: "'{{name}}' used outside of binding context.", data: { name: identifier.name } });
-        }
-
-        /**
-         * Finds and reports references which are outside of valid scopes.
-         * @param {ASTNode} node - A node to get variables.
-         * @returns {void}
-         */
-        function checkForVariables(node) {
-            if (node.kind !== "var") {
-                return;
-            }
-
-            // Defines a predicate to check whether or not a given reference is outside of valid scope.
-            const scopeRange = stack[stack.length - 1];
-
-            /**
-             * Check if a reference is out of scope
-             * @param {ASTNode} reference node to examine
-             * @returns {boolean} True is its outside the scope
-             * @private
-             */
-            function isOutsideOfScope(reference) {
-                const idRange = reference.identifier.range;
-
-                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
-            }
-
-            // Gets declared variables, and checks its references.
-            const variables = context.getDeclaredVariables(node);
-
-            for (let i = 0; i < variables.length; ++i) {
-
-                // Reports.
-                variables[i]
-                    .references
-                    .filter(isOutsideOfScope)
-                    .forEach(report);
-            }
-        }
-
-        return {
-            Program(node) {
-                stack = [node.range];
-            },
-
-            // Manages scopes.
-            BlockStatement: enterScope,
-            "BlockStatement:exit": exitScope,
-            ForStatement: enterScope,
-            "ForStatement:exit": exitScope,
-            ForInStatement: enterScope,
-            "ForInStatement:exit": exitScope,
-            ForOfStatement: enterScope,
-            "ForOfStatement:exit": exitScope,
-            SwitchStatement: enterScope,
-            "SwitchStatement:exit": exitScope,
-            CatchClause: enterScope,
-            "CatchClause:exit": exitScope,
-
-            // Finds and reports references which are outside of valid scope.
-            VariableDeclaration: checkForVariables
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-await-in-loop.js
===================================================================
--- node_modules/eslint/lib/rules/no-await-in-loop.js	(revision )
+++ node_modules/eslint/lib/rules/no-await-in-loop.js	(revision )
@@ -1,75 +0,0 @@
-/**
- * @fileoverview Rule to disallow uses of await inside of loops.
- * @author Nat Mote (nmote)
- */
-"use strict";
-
-// Node types which are considered loops.
-const loopTypes = new Set([
-    "ForStatement",
-    "ForOfStatement",
-    "ForInStatement",
-    "WhileStatement",
-    "DoWhileStatement"
-]);
-
-// Node types at which we should stop looking for loops. For example, it is fine to declare an async
-// function within a loop, and use await inside of that.
-const boundaryTypes = new Set([
-    "FunctionDeclaration",
-    "FunctionExpression",
-    "ArrowFunctionExpression"
-]);
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `await` inside of loops",
-            category: "Possible Errors",
-            recommended: false
-        },
-        schema: []
-    },
-    create(context) {
-        return {
-            AwaitExpression(node) {
-                const ancestors = context.getAncestors();
-
-                // Reverse so that we can traverse from the deepest node upwards.
-                ancestors.reverse();
-
-                // Create a set of all the ancestors plus this node so that we can check
-                // if this use of await appears in the body of the loop as opposed to
-                // the right-hand side of a for...of, for example.
-                const ancestorSet = new Set(ancestors).add(node);
-
-                for (let i = 0; i < ancestors.length; i++) {
-                    const ancestor = ancestors[i];
-
-                    if (boundaryTypes.has(ancestor.type)) {
-
-                        // Short-circuit out if we encounter a boundary type. Loops above
-                        // this do not matter.
-                        return;
-                    }
-                    if (loopTypes.has(ancestor.type)) {
-
-                        // Only report if we are actually in the body or another part that gets executed on
-                        // every iteration.
-                        if (
-                            ancestorSet.has(ancestor.body) ||
-                            ancestorSet.has(ancestor.test) ||
-                            ancestorSet.has(ancestor.update)
-                        ) {
-                            context.report({
-                                node,
-                                message: "Unexpected `await` inside a loop."
-                            });
-                            return;
-                        }
-                    }
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-control-regex.js
===================================================================
--- node_modules/eslint/lib/rules/no-control-regex.js	(revision )
+++ node_modules/eslint/lib/rules/no-control-regex.js	(revision )
@@ -1,126 +0,0 @@
-/**
- * @fileoverview Rule to forbid control charactes from regular expressions.
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow control characters in regular expressions",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Get the regex expression
-         * @param {ASTNode} node node to evaluate
-         * @returns {*} Regex if found else null
-         * @private
-         */
-        function getRegExp(node) {
-            if (node.value instanceof RegExp) {
-                return node.value;
-            } else if (typeof node.value === "string") {
-
-                const parent = context.getAncestors().pop();
-
-                if ((parent.type === "NewExpression" || parent.type === "CallExpression") &&
-                    parent.callee.type === "Identifier" && parent.callee.name === "RegExp"
-                ) {
-
-                    // there could be an invalid regular expression string
-                    try {
-                        return new RegExp(node.value);
-                    } catch (ex) {
-                        return null;
-                    }
-                }
-            }
-
-            return null;
-        }
-
-
-        const controlChar = /[\x00-\x1f]/g; // eslint-disable-line no-control-regex
-        const consecutiveSlashes = /\\+/g;
-        const consecutiveSlashesAtEnd = /\\+$/g;
-        const stringControlChar = /\\x[01][0-9a-f]/ig;
-        const stringControlCharWithoutSlash = /x[01][0-9a-f]/ig;
-
-        /**
-         * Return a list of the control characters in the given regex string
-         * @param {string} regexStr regex as string to check
-         * @returns {array} returns a list of found control characters on given string
-         * @private
-         */
-        function getControlCharacters(regexStr) {
-
-            // check control characters, if RegExp object used
-            const controlChars = regexStr.match(controlChar) || [];
-
-            let stringControlChars = [];
-
-            // check substr, if regex literal used
-            const subStrIndex = regexStr.search(stringControlChar);
-
-            if (subStrIndex > -1) {
-
-                // is it escaped, check backslash count
-                const possibleEscapeCharacters = regexStr.slice(0, subStrIndex).match(consecutiveSlashesAtEnd);
-
-                const hasControlChars = possibleEscapeCharacters === null || !(possibleEscapeCharacters[0].length % 2);
-
-                if (hasControlChars) {
-                    stringControlChars = regexStr.slice(subStrIndex, -1)
-                        .split(consecutiveSlashes)
-                        .filter(Boolean)
-                        .map(x => {
-                            const match = x.match(stringControlCharWithoutSlash) || [x];
-
-                            return `\\${match[0]}`;
-                        });
-                }
-            }
-
-            return controlChars.map(x => {
-                const hexCode = `0${x.charCodeAt(0).toString(16)}`.slice(-2);
-
-                return `\\x${hexCode}`;
-            }).concat(stringControlChars);
-        }
-
-        return {
-            Literal(node) {
-                const regex = getRegExp(node);
-
-                if (regex) {
-                    const computedValue = regex.toString();
-
-                    const controlCharacters = getControlCharacters(computedValue);
-
-                    if (controlCharacters.length > 0) {
-                        context.report({
-                            node,
-                            message: "Unexpected control character(s) in regular expression: {{controlChars}}.",
-                            data: {
-                                controlChars: controlCharacters.join(", ")
-                            }
-                        });
-                    }
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-empty-pattern.js
===================================================================
--- node_modules/eslint/lib/rules/no-empty-pattern.js	(revision )
+++ node_modules/eslint/lib/rules/no-empty-pattern.js	(revision )
@@ -1,36 +0,0 @@
-/**
- * @fileoverview Rule to disallow an empty pattern
- * @author Alberto Rodríguez
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow empty destructuring patterns",
-            category: "Best Practices",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        return {
-            ObjectPattern(node) {
-                if (node.properties.length === 0) {
-                    context.report({ node, message: "Unexpected empty object pattern." });
-                }
-            },
-            ArrayPattern(node) {
-                if (node.elements.length === 0) {
-                    context.report({ node, message: "Unexpected empty array pattern." });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-extend-native.js
===================================================================
--- node_modules/eslint/lib/rules/no-extend-native.js	(revision )
+++ node_modules/eslint/lib/rules/no-extend-native.js	(revision )
@@ -1,174 +0,0 @@
-/**
- * @fileoverview Rule to flag adding properties to native object's prototypes.
- * @author David Nelson
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-const globals = require("globals");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const propertyDefinitionMethods = new Set(["defineProperty", "defineProperties"]);
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow extending native types",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    exceptions: {
-                        type: "array",
-                        items: {
-                            type: "string"
-                        },
-                        uniqueItems: true
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const config = context.options[0] || {};
-        const exceptions = new Set(config.exceptions || []);
-        const modifiedBuiltins = new Set(
-            Object.keys(globals.builtin)
-                .filter(builtin => builtin[0].toUpperCase() === builtin[0])
-                .filter(builtin => !exceptions.has(builtin))
-        );
-
-        /**
-         * Reports a lint error for the given node.
-         * @param {ASTNode} node The node to report.
-         * @param {string} builtin The name of the native builtin being extended.
-         * @returns {void}
-         */
-        function reportNode(node, builtin) {
-            context.report({
-                node,
-                message: "{{builtin}} prototype is read only, properties should not be added.",
-                data: {
-                    builtin
-                }
-            });
-        }
-
-        /**
-         * Check to see if the `prototype` property of the given object
-         * identifier node is being accessed.
-         * @param {ASTNode} identifierNode The Identifier representing the object
-         * to check.
-         * @returns {boolean} True if the identifier is the object of a
-         * MemberExpression and its `prototype` property is being accessed,
-         * false otherwise.
-         */
-        function isPrototypePropertyAccessed(identifierNode) {
-            return Boolean(
-                identifierNode &&
-                identifierNode.parent &&
-                identifierNode.parent.type === "MemberExpression" &&
-                identifierNode.parent.object === identifierNode &&
-                astUtils.getStaticPropertyName(identifierNode.parent) === "prototype"
-            );
-        }
-
-        /**
-         * Checks that an identifier is an object of a prototype whose member
-         * is being assigned in an AssignmentExpression.
-         * Example: Object.prototype.foo = "bar"
-         * @param {ASTNode} identifierNode The identifier to check.
-         * @returns {boolean} True if the identifier's prototype is modified.
-         */
-        function isInPrototypePropertyAssignment(identifierNode) {
-            return Boolean(
-                isPrototypePropertyAccessed(identifierNode) &&
-                identifierNode.parent.parent.type === "MemberExpression" &&
-                identifierNode.parent.parent.parent.type === "AssignmentExpression" &&
-                identifierNode.parent.parent.parent.left === identifierNode.parent.parent
-            );
-        }
-
-        /**
-         * Checks that an identifier is an object of a prototype whose member
-         * is being extended via the Object.defineProperty() or
-         * Object.defineProperties() methods.
-         * Example: Object.defineProperty(Array.prototype, "foo", ...)
-         * Example: Object.defineProperties(Array.prototype, ...)
-         * @param {ASTNode} identifierNode The identifier to check.
-         * @returns {boolean} True if the identifier's prototype is modified.
-         */
-        function isInDefinePropertyCall(identifierNode) {
-            return Boolean(
-                isPrototypePropertyAccessed(identifierNode) &&
-                identifierNode.parent.parent.type === "CallExpression" &&
-                identifierNode.parent.parent.arguments[0] === identifierNode.parent &&
-                identifierNode.parent.parent.callee.type === "MemberExpression" &&
-                identifierNode.parent.parent.callee.object.type === "Identifier" &&
-                identifierNode.parent.parent.callee.object.name === "Object" &&
-                identifierNode.parent.parent.callee.property.type === "Identifier" &&
-                propertyDefinitionMethods.has(identifierNode.parent.parent.callee.property.name)
-            );
-        }
-
-        /**
-         * Check to see if object prototype access is part of a prototype
-         * extension. There are three ways a prototype can be extended:
-         * 1. Assignment to prototype property (Object.prototype.foo = 1)
-         * 2. Object.defineProperty()/Object.defineProperties() on a prototype
-         * If prototype extension is detected, report the AssignmentExpression
-         * or CallExpression node.
-         * @param {ASTNode} identifierNode The Identifier representing the object
-         * which prototype is being accessed and possibly extended.
-         * @returns {void}
-         */
-        function checkAndReportPrototypeExtension(identifierNode) {
-            if (isInPrototypePropertyAssignment(identifierNode)) {
-
-                // Identifier --> MemberExpression --> MemberExpression --> AssignmentExpression
-                reportNode(identifierNode.parent.parent.parent, identifierNode.name);
-            } else if (isInDefinePropertyCall(identifierNode)) {
-
-                // Identifier --> MemberExpression --> CallExpression
-                reportNode(identifierNode.parent.parent, identifierNode.name);
-            }
-        }
-
-        return {
-
-            "Program:exit"() {
-                const globalScope = context.getScope();
-
-                modifiedBuiltins.forEach(builtin => {
-                    const builtinVar = globalScope.set.get(builtin);
-
-                    if (builtinVar && builtinVar.references) {
-                        builtinVar.references
-                            .map(ref => ref.identifier)
-                            .forEach(checkAndReportPrototypeExtension);
-                    }
-                });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-global-assign.js
===================================================================
--- node_modules/eslint/lib/rules/no-global-assign.js	(revision )
+++ node_modules/eslint/lib/rules/no-global-assign.js	(revision )
@@ -1,83 +0,0 @@
-/**
- * @fileoverview Rule to disallow assignments to native objects or read-only global variables
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow assignments to native objects or read-only global variables",
-            category: "Best Practices",
-            recommended: true
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    exceptions: {
-                        type: "array",
-                        items: { type: "string" },
-                        uniqueItems: true
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const config = context.options[0];
-        const exceptions = (config && config.exceptions) || [];
-
-        /**
-         * Reports write references.
-         * @param {Reference} reference - A reference to check.
-         * @param {int} index - The index of the reference in the references.
-         * @param {Reference[]} references - The array that the reference belongs to.
-         * @returns {void}
-         */
-        function checkReference(reference, index, references) {
-            const identifier = reference.identifier;
-
-            if (reference.init === false &&
-                reference.isWrite() &&
-
-                // Destructuring assignments can have multiple default value,
-                // so possibly there are multiple writeable references for the same identifier.
-                (index === 0 || references[index - 1].identifier !== identifier)
-            ) {
-                context.report({
-                    node: identifier,
-                    message: "Read-only global '{{name}}' should not be modified.",
-                    data: identifier
-                });
-            }
-        }
-
-        /**
-         * Reports write references if a given variable is read-only builtin.
-         * @param {Variable} variable - A variable to check.
-         * @returns {void}
-         */
-        function checkVariable(variable) {
-            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
-                variable.references.forEach(checkReference);
-            }
-        }
-
-        return {
-            Program() {
-                const globalScope = context.getScope();
-
-                globalScope.variables.forEach(checkVariable);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-magic-numbers.js
===================================================================
--- node_modules/eslint/lib/rules/no-magic-numbers.js	(revision )
+++ node_modules/eslint/lib/rules/no-magic-numbers.js	(revision )
@@ -1,149 +0,0 @@
-/**
- * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)
- * @author Vincent Lemeunier
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow magic numbers",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [{
-            type: "object",
-            properties: {
-                detectObjects: {
-                    type: "boolean"
-                },
-                enforceConst: {
-                    type: "boolean"
-                },
-                ignore: {
-                    type: "array",
-                    items: {
-                        type: "number"
-                    },
-                    uniqueItems: true
-                },
-                ignoreArrayIndexes: {
-                    type: "boolean"
-                }
-            },
-            additionalProperties: false
-        }]
-    },
-
-    create(context) {
-        const config = context.options[0] || {},
-            detectObjects = !!config.detectObjects,
-            enforceConst = !!config.enforceConst,
-            ignore = config.ignore || [],
-            ignoreArrayIndexes = !!config.ignoreArrayIndexes;
-
-        /**
-         * Returns whether the node is number literal
-         * @param {Node} node - the node literal being evaluated
-         * @returns {boolean} true if the node is a number literal
-         */
-        function isNumber(node) {
-            return typeof node.value === "number";
-        }
-
-        /**
-         * Returns whether the number should be ignored
-         * @param {number} num - the number
-         * @returns {boolean} true if the number should be ignored
-         */
-        function shouldIgnoreNumber(num) {
-            return ignore.indexOf(num) !== -1;
-        }
-
-        /**
-         * Returns whether the number should be ignored when used as a radix within parseInt() or Number.parseInt()
-         * @param {ASTNode} parent - the non-"UnaryExpression" parent
-         * @param {ASTNode} node - the node literal being evaluated
-         * @returns {boolean} true if the number should be ignored
-         */
-        function shouldIgnoreParseInt(parent, node) {
-            return parent.type === "CallExpression" && node === parent.arguments[1] &&
-                (parent.callee.name === "parseInt" ||
-                parent.callee.type === "MemberExpression" &&
-                parent.callee.object.name === "Number" &&
-                parent.callee.property.name === "parseInt");
-        }
-
-        /**
-         * Returns whether the number should be ignored when used to define a JSX prop
-         * @param {ASTNode} parent - the non-"UnaryExpression" parent
-         * @returns {boolean} true if the number should be ignored
-         */
-        function shouldIgnoreJSXNumbers(parent) {
-            return parent.type.indexOf("JSX") === 0;
-        }
-
-        /**
-         * Returns whether the number should be ignored when used as an array index with enabled 'ignoreArrayIndexes' option.
-         * @param {ASTNode} parent - the non-"UnaryExpression" parent.
-         * @returns {boolean} true if the number should be ignored
-         */
-        function shouldIgnoreArrayIndexes(parent) {
-            return parent.type === "MemberExpression" && ignoreArrayIndexes;
-        }
-
-        return {
-            Literal(node) {
-                let parent = node.parent,
-                    value = node.value,
-                    raw = node.raw;
-                const okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];
-
-                if (!isNumber(node)) {
-                    return;
-                }
-
-                // For negative magic numbers: update the value and parent node
-                if (parent.type === "UnaryExpression" && parent.operator === "-") {
-                    node = parent;
-                    parent = node.parent;
-                    value = -value;
-                    raw = `-${raw}`;
-                }
-
-                if (shouldIgnoreNumber(value) ||
-                    shouldIgnoreParseInt(parent, node) ||
-                    shouldIgnoreArrayIndexes(parent) ||
-                    shouldIgnoreJSXNumbers(parent)) {
-                    return;
-                }
-
-                if (parent.type === "VariableDeclarator") {
-                    if (enforceConst && parent.parent.kind !== "const") {
-                        context.report({
-                            node,
-                            message: "Number constants declarations must use 'const'."
-                        });
-                    }
-                } else if (
-                    okTypes.indexOf(parent.type) === -1 ||
-                    (parent.type === "AssignmentExpression" && parent.left.type === "Identifier")
-                ) {
-                    context.report({
-                        node,
-                        message: "No magic number: {{raw}}.",
-                        data: {
-                            raw
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-return-assign.js
===================================================================
--- node_modules/eslint/lib/rules/no-return-assign.js	(revision )
+++ node_modules/eslint/lib/rules/no-return-assign.js	(revision )
@@ -1,71 +0,0 @@
-/**
- * @fileoverview Rule to flag when return statement contains assignment
- * @author Ilya Volodin
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/;
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow assignment operators in `return` statements",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["except-parens", "always"]
-            }
-        ]
-    },
-
-    create(context) {
-        const always = (context.options[0] || "except-parens") !== "except-parens";
-        const sourceCode = context.getSourceCode();
-
-        return {
-            AssignmentExpression(node) {
-                if (!always && astUtils.isParenthesised(sourceCode, node)) {
-                    return;
-                }
-
-                let parent = node.parent;
-
-                // Find ReturnStatement or ArrowFunctionExpression in ancestors.
-                while (parent && !SENTINEL_TYPE.test(parent.type)) {
-                    node = parent;
-                    parent = parent.parent;
-                }
-
-                // Reports.
-                if (parent && parent.type === "ReturnStatement") {
-                    context.report({
-                        node: parent,
-                        message: "Return statement should not contain assignment."
-                    });
-                } else if (parent && parent.type === "ArrowFunctionExpression" && parent.body === node) {
-                    context.report({
-                        node: parent,
-                        message: "Arrow function should not return assignment."
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-sparse-arrays.js
===================================================================
--- node_modules/eslint/lib/rules/no-sparse-arrays.js	(revision )
+++ node_modules/eslint/lib/rules/no-sparse-arrays.js	(revision )
@@ -1,43 +0,0 @@
-/**
- * @fileoverview Disallow sparse arrays
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow sparse arrays",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-
-            ArrayExpression(node) {
-
-                const emptySpot = node.elements.indexOf(null) > -1;
-
-                if (emptySpot) {
-                    context.report({ node, message: "Unexpected comma in middle of array." });
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-throw-literal.js
===================================================================
--- node_modules/eslint/lib/rules/no-throw-literal.js	(revision )
+++ node_modules/eslint/lib/rules/no-throw-literal.js	(revision )
@@ -1,43 +0,0 @@
-/**
- * @fileoverview Rule to restrict what can be thrown as an exception.
- * @author Dieter Oberkofler
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow throwing literals as exceptions",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            ThrowStatement(node) {
-                if (!astUtils.couldBeError(node.argument)) {
-                    context.report({ node, message: "Expected an object to be thrown." });
-                } else if (node.argument.type === "Identifier") {
-                    if (node.argument.name === "undefined") {
-                        context.report({ node, message: "Do not throw undefined." });
-                    }
-                }
-
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-unused-labels.js
===================================================================
--- node_modules/eslint/lib/rules/no-unused-labels.js	(revision )
+++ node_modules/eslint/lib/rules/no-unused-labels.js	(revision )
@@ -1,105 +0,0 @@
-/**
- * @fileoverview Rule to disallow unused labels.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unused labels",
-            category: "Best Practices",
-            recommended: true
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        let scopeInfo = null;
-
-        /**
-         * Adds a scope info to the stack.
-         *
-         * @param {ASTNode} node - A node to add. This is a LabeledStatement.
-         * @returns {void}
-         */
-        function enterLabeledScope(node) {
-            scopeInfo = {
-                label: node.label.name,
-                used: false,
-                upper: scopeInfo
-            };
-        }
-
-        /**
-         * Removes the top of the stack.
-         * At the same time, this reports the label if it's never used.
-         *
-         * @param {ASTNode} node - A node to report. This is a LabeledStatement.
-         * @returns {void}
-         */
-        function exitLabeledScope(node) {
-            if (!scopeInfo.used) {
-                context.report({
-                    node: node.label,
-                    message: "'{{name}}:' is defined but never used.",
-                    data: node.label,
-                    fix(fixer) {
-
-                        /*
-                         * Only perform a fix if there are no comments between the label and the body. This will be the case
-                         * when there is exactly one token/comment (the ":") between the label and the body.
-                         */
-                        if (sourceCode.getTokenAfter(node.label, { includeComments: true }) === sourceCode.getTokenBefore(node.body, { includeComments: true })) {
-                            return fixer.removeRange([node.range[0], node.body.range[0]]);
-                        }
-
-                        return null;
-                    }
-                });
-            }
-
-            scopeInfo = scopeInfo.upper;
-        }
-
-        /**
-         * Marks the label of a given node as used.
-         *
-         * @param {ASTNode} node - A node to mark. This is a BreakStatement or
-         *      ContinueStatement.
-         * @returns {void}
-         */
-        function markAsUsed(node) {
-            if (!node.label) {
-                return;
-            }
-
-            const label = node.label.name;
-            let info = scopeInfo;
-
-            while (info) {
-                if (info.label === label) {
-                    info.used = true;
-                    break;
-                }
-                info = info.upper;
-            }
-        }
-
-        return {
-            LabeledStatement: enterLabeledScope,
-            "LabeledStatement:exit": exitLabeledScope,
-            BreakStatement: markAsUsed,
-            ContinueStatement: markAsUsed
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/object-shorthand.js
===================================================================
--- node_modules/eslint/lib/rules/object-shorthand.js	(revision )
+++ node_modules/eslint/lib/rules/object-shorthand.js	(revision )
@@ -1,442 +0,0 @@
-/**
- * @fileoverview Rule to enforce concise object methods and properties.
- * @author Jamund Ferguson
- */
-
-"use strict";
-
-const OPTIONS = {
-    always: "always",
-    never: "never",
-    methods: "methods",
-    properties: "properties",
-    consistent: "consistent",
-    consistentAsNeeded: "consistent-as-needed"
-};
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow method and property shorthand syntax for object literals",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        fixable: "code",
-
-        schema: {
-            anyOf: [
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"]
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 1
-                },
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["always", "methods", "properties"]
-                        },
-                        {
-                            type: "object",
-                            properties: {
-                                avoidQuotes: {
-                                    type: "boolean"
-                                }
-                            },
-                            additionalProperties: false
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 2
-                },
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["always", "methods"]
-                        },
-                        {
-                            type: "object",
-                            properties: {
-                                ignoreConstructors: {
-                                    type: "boolean"
-                                },
-                                avoidQuotes: {
-                                    type: "boolean"
-                                },
-                                avoidExplicitReturnArrows: {
-                                    type: "boolean"
-                                }
-                            },
-                            additionalProperties: false
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 2
-                }
-            ]
-        }
-    },
-
-    create(context) {
-        const APPLY = context.options[0] || OPTIONS.always;
-        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
-        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
-        const APPLY_NEVER = APPLY === OPTIONS.never;
-        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;
-        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;
-
-        const PARAMS = context.options[1] || {};
-        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;
-        const AVOID_QUOTES = PARAMS.avoidQuotes;
-        const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;
-        const sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Determines if the first character of the name is a capital letter.
-         * @param {string} name The name of the node to evaluate.
-         * @returns {boolean} True if the first character of the property name is a capital letter, false if not.
-         * @private
-         */
-        function isConstructor(name) {
-            const firstChar = name.charAt(0);
-
-            return firstChar === firstChar.toUpperCase();
-        }
-
-        /**
-         * Determines if the property can have a shorthand form.
-         * @param {ASTNode} property Property AST node
-         * @returns {boolean} True if the property can have a shorthand form
-         * @private
-         **/
-        function canHaveShorthand(property) {
-            return (property.kind !== "set" && property.kind !== "get" && property.type !== "SpreadProperty" && property.type !== "ExperimentalSpreadProperty");
-        }
-
-        /**
-          * Checks whether a node is a string literal.
-          * @param   {ASTNode} node - Any AST node.
-          * @returns {boolean} `true` if it is a string literal.
-          */
-        function isStringLiteral(node) {
-            return node.type === "Literal" && typeof node.value === "string";
-        }
-
-        /**
-         * Determines if the property is a shorthand or not.
-         * @param {ASTNode} property Property AST node
-         * @returns {boolean} True if the property is considered shorthand, false if not.
-         * @private
-         **/
-        function isShorthand(property) {
-
-            // property.method is true when `{a(){}}`.
-            return (property.shorthand || property.method);
-        }
-
-        /**
-         * Determines if the property's key and method or value are named equally.
-         * @param {ASTNode} property Property AST node
-         * @returns {boolean} True if the key and value are named equally, false if not.
-         * @private
-         **/
-        function isRedundant(property) {
-            const value = property.value;
-
-            if (value.type === "FunctionExpression") {
-                return !value.id; // Only anonymous should be shorthand method.
-            }
-            if (value.type === "Identifier") {
-                return astUtils.getStaticPropertyName(property) === value.name;
-            }
-
-            return false;
-        }
-
-        /**
-         * Ensures that an object's properties are consistently shorthand, or not shorthand at all.
-         * @param   {ASTNode} node Property AST node
-         * @param   {boolean} checkRedundancy Whether to check longform redundancy
-         * @returns {void}
-         **/
-        function checkConsistency(node, checkRedundancy) {
-
-            // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.
-            const properties = node.properties.filter(canHaveShorthand);
-
-            // Do we still have properties left after filtering the getters and setters?
-            if (properties.length > 0) {
-                const shorthandProperties = properties.filter(isShorthand);
-
-                // If we do not have an equal number of longform properties as
-                // shorthand properties, we are using the annotations inconsistently
-                if (shorthandProperties.length !== properties.length) {
-
-                    // We have at least 1 shorthand property
-                    if (shorthandProperties.length > 0) {
-                        context.report({ node, message: "Unexpected mix of shorthand and non-shorthand properties." });
-                    } else if (checkRedundancy) {
-
-                        // If all properties of the object contain a method or value with a name matching it's key,
-                        // all the keys are redundant.
-                        const canAlwaysUseShorthand = properties.every(isRedundant);
-
-                        if (canAlwaysUseShorthand) {
-                            context.report({ node, message: "Expected shorthand for all properties." });
-                        }
-                    }
-                }
-            }
-        }
-
-        /**
-        * Fixes a FunctionExpression node by making it into a shorthand property.
-        * @param {SourceCodeFixer} fixer The fixer object
-        * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value
-        * @returns {Object} A fix for this node
-        */
-        function makeFunctionShorthand(fixer, node) {
-            const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);
-            const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);
-            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
-            let keyPrefix = "";
-
-            if (node.value.generator) {
-                keyPrefix = "*";
-            } else if (node.value.async) {
-                keyPrefix = "async ";
-            }
-
-            if (node.value.type === "FunctionExpression") {
-                const functionToken = sourceCode.getTokens(node.value).find(token => token.type === "Keyword" && token.value === "function");
-                const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;
-
-                return fixer.replaceTextRange(
-                    [firstKeyToken.range[0], node.range[1]],
-                    keyPrefix + keyText + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1])
-                );
-            }
-            const arrowToken = sourceCode.getTokens(node.value).find(token => token.value === "=>");
-            const tokenBeforeArrow = sourceCode.getTokenBefore(arrowToken);
-            const hasParensAroundParameters = tokenBeforeArrow.type === "Punctuator" && tokenBeforeArrow.value === ")";
-            const oldParamText = sourceCode.text.slice(sourceCode.getFirstToken(node.value, node.value.async ? 1 : 0).range[0], tokenBeforeArrow.range[1]);
-            const newParamText = hasParensAroundParameters ? oldParamText : `(${oldParamText})`;
-
-            return fixer.replaceTextRange(
-                [firstKeyToken.range[0], node.range[1]],
-                keyPrefix + keyText + newParamText + sourceCode.text.slice(arrowToken.range[1], node.value.range[1])
-            );
-
-        }
-
-        /**
-        * Fixes a FunctionExpression node by making it into a longform property.
-        * @param {SourceCodeFixer} fixer The fixer object
-        * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value
-        * @returns {Object} A fix for this node
-        */
-        function makeFunctionLongform(fixer, node) {
-            const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === "[") : sourceCode.getFirstToken(node.key);
-            const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === "]") : sourceCode.getLastToken(node.key);
-            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
-            let functionHeader = "function";
-
-            if (node.value.generator) {
-                functionHeader = "function*";
-            } else if (node.value.async) {
-                functionHeader = "async function";
-            }
-
-            return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);
-        }
-
-        /*
-         * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),
-         * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is
-         * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical
-         * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,
-         * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.
-         * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them
-         * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,
-         * because converting it into a method would change the value of one of the lexical identifiers.
-         */
-        const lexicalScopeStack = [];
-        const arrowsWithLexicalIdentifiers = new WeakSet();
-        const argumentsIdentifiers = new WeakSet();
-
-        /**
-        * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.
-        * Also, this marks all `arguments` identifiers so that they can be detected later.
-        * @returns {void}
-        */
-        function enterFunction() {
-            lexicalScopeStack.unshift(new Set());
-            context.getScope().variables.filter(variable => variable.name === "arguments").forEach(variable => {
-                variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));
-            });
-        }
-
-        /**
-        * Exits a function. This pops the current set of arrow functions off the lexical scope stack.
-        * @returns {void}
-        */
-        function exitFunction() {
-            lexicalScopeStack.shift();
-        }
-
-        /**
-        * Marks the current function as having a lexical keyword. This implies that all arrow functions
-        * in the current lexical scope contain a reference to this lexical keyword.
-        * @returns {void}
-        */
-        function reportLexicalIdentifier() {
-            lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            Program: enterFunction,
-            FunctionDeclaration: enterFunction,
-            FunctionExpression: enterFunction,
-            "Program:exit": exitFunction,
-            "FunctionDeclaration:exit": exitFunction,
-            "FunctionExpression:exit": exitFunction,
-
-            ArrowFunctionExpression(node) {
-                lexicalScopeStack[0].add(node);
-            },
-            "ArrowFunctionExpression:exit"(node) {
-                lexicalScopeStack[0].delete(node);
-            },
-
-            ThisExpression: reportLexicalIdentifier,
-            Super: reportLexicalIdentifier,
-            MetaProperty(node) {
-                if (node.meta.name === "new" && node.property.name === "target") {
-                    reportLexicalIdentifier();
-                }
-            },
-            Identifier(node) {
-                if (argumentsIdentifiers.has(node)) {
-                    reportLexicalIdentifier();
-                }
-            },
-
-            ObjectExpression(node) {
-                if (APPLY_CONSISTENT) {
-                    checkConsistency(node, false);
-                } else if (APPLY_CONSISTENT_AS_NEEDED) {
-                    checkConsistency(node, true);
-                }
-            },
-
-            "Property:exit"(node) {
-                const isConciseProperty = node.method || node.shorthand;
-
-                // Ignore destructuring assignment
-                if (node.parent.type === "ObjectPattern") {
-                    return;
-                }
-
-                // getters and setters are ignored
-                if (node.kind === "get" || node.kind === "set") {
-                    return;
-                }
-
-                // only computed methods can fail the following checks
-                if (node.computed && node.value.type !== "FunctionExpression" && node.value.type !== "ArrowFunctionExpression") {
-                    return;
-                }
-
-                //--------------------------------------------------------------
-                // Checks for property/method shorthand.
-                if (isConciseProperty) {
-                    if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {
-                        const message = APPLY_NEVER ? "Expected longform method syntax." : "Expected longform method syntax for string literal keys.";
-
-                        // { x() {} } should be written as { x: function() {} }
-                        context.report({
-                            node,
-                            message,
-                            fix: fixer => makeFunctionLongform(fixer, node)
-                        });
-                    } else if (APPLY_NEVER) {
-
-                        // { x } should be written as { x: x }
-                        context.report({
-                            node,
-                            message: "Expected longform property syntax.",
-                            fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)
-                        });
-                    }
-                } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression")) {
-                    if (IGNORE_CONSTRUCTORS && node.key.type === "Identifier" && isConstructor(node.key.name)) {
-                        return;
-                    }
-                    if (AVOID_QUOTES && isStringLiteral(node.key)) {
-                        return;
-                    }
-
-                    // {[x]: function(){}} should be written as {[x]() {}}
-                    if (node.value.type === "FunctionExpression" ||
-                        node.value.type === "ArrowFunctionExpression" &&
-                        node.value.body.type === "BlockStatement" &&
-                        AVOID_EXPLICIT_RETURN_ARROWS &&
-                        !arrowsWithLexicalIdentifiers.has(node.value)
-                    ) {
-                        context.report({
-                            node,
-                            message: "Expected method shorthand.",
-                            fix: fixer => makeFunctionShorthand(fixer, node)
-                        });
-                    }
-                } else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) {
-
-                    // {x: x} should be written as {x}
-                    context.report({
-                        node,
-                        message: "Expected property shorthand.",
-                        fix(fixer) {
-                            return fixer.replaceText(node, node.value.name);
-                        }
-                    });
-                } else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) {
-                    if (AVOID_QUOTES) {
-                        return;
-                    }
-
-                    // {"x": x} should be written as {x}
-                    context.report({
-                        node,
-                        message: "Expected property shorthand.",
-                        fix(fixer) {
-                            return fixer.replaceText(node, node.value.name);
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/consistent-return.js
===================================================================
--- node_modules/eslint/lib/rules/consistent-return.js	(revision )
+++ node_modules/eslint/lib/rules/consistent-return.js	(revision )
@@ -1,188 +0,0 @@
-/**
- * @fileoverview Rule to flag consistent return values
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a given node is an `Identifier` node which was named a given name.
- * @param {ASTNode} node - A node to check.
- * @param {string} name - An expected name of the node.
- * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.
- */
-function isIdentifier(node, name) {
-    return node.type === "Identifier" && node.name === name;
-}
-
-/**
- * Checks whether or not a given code path segment is unreachable.
- * @param {CodePathSegment} segment - A CodePathSegment to check.
- * @returns {boolean} `true` if the segment is unreachable.
- */
-function isUnreachable(segment) {
-    return !segment.reachable;
-}
-
-/**
-* Checks whether a given node is a `constructor` method in an ES6 class
-* @param {ASTNode} node A node to check
-* @returns {boolean} `true` if the node is a `constructor` method
-*/
-function isClassConstructor(node) {
-    return node.type === "FunctionExpression" &&
-        node.parent &&
-        node.parent.type === "MethodDefinition" &&
-        node.parent.kind === "constructor";
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require `return` statements to either always or never specify values",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [{
-            type: "object",
-            properties: {
-                treatUndefinedAsUnspecified: {
-                    type: "boolean"
-                }
-            },
-            additionalProperties: false
-        }]
-    },
-
-    create(context) {
-        const options = context.options[0] || {};
-        const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;
-        let funcInfo = null;
-
-        /**
-         * Checks whether of not the implicit returning is consistent if the last
-         * code path segment is reachable.
-         *
-         * @param {ASTNode} node - A program/function node to check.
-         * @returns {void}
-         */
-        function checkLastSegment(node) {
-            let loc, name;
-
-            /*
-             * Skip if it expected no return value or unreachable.
-             * When unreachable, all paths are returned or thrown.
-             */
-            if (!funcInfo.hasReturnValue ||
-                funcInfo.codePath.currentSegments.every(isUnreachable) ||
-                astUtils.isES5Constructor(node) ||
-                isClassConstructor(node)
-            ) {
-                return;
-            }
-
-            // Adjust a location and a message.
-            if (node.type === "Program") {
-
-                // The head of program.
-                loc = { line: 1, column: 0 };
-                name = "program";
-            } else if (node.type === "ArrowFunctionExpression") {
-
-                // `=>` token
-                loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;
-            } else if (
-                node.parent.type === "MethodDefinition" ||
-                (node.parent.type === "Property" && node.parent.method)
-            ) {
-
-                // Method name.
-                loc = node.parent.key.loc.start;
-            } else {
-
-                // Function name or `function` keyword.
-                loc = (node.id || node).loc.start;
-            }
-
-            if (!name) {
-                name = astUtils.getFunctionNameWithKind(node);
-            }
-
-            // Reports.
-            context.report({
-                node,
-                loc,
-                message: "Expected to return a value at the end of {{name}}.",
-                data: { name }
-            });
-        }
-
-        return {
-
-            // Initializes/Disposes state of each code path.
-            onCodePathStart(codePath, node) {
-                funcInfo = {
-                    upper: funcInfo,
-                    codePath,
-                    hasReturn: false,
-                    hasReturnValue: false,
-                    message: "",
-                    node
-                };
-            },
-            onCodePathEnd() {
-                funcInfo = funcInfo.upper;
-            },
-
-            // Reports a given return statement if it's inconsistent.
-            ReturnStatement(node) {
-                const argument = node.argument;
-                let hasReturnValue = Boolean(argument);
-
-                if (treatUndefinedAsUnspecified && hasReturnValue) {
-                    hasReturnValue = !isIdentifier(argument, "undefined") && argument.operator !== "void";
-                }
-
-                if (!funcInfo.hasReturn) {
-                    funcInfo.hasReturn = true;
-                    funcInfo.hasReturnValue = hasReturnValue;
-                    funcInfo.message = "{{name}} expected {{which}} return value.";
-                    funcInfo.data = {
-                        name: funcInfo.node.type === "Program"
-                            ? "Program"
-                            : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node)),
-                        which: hasReturnValue ? "a" : "no"
-                    };
-                } else if (funcInfo.hasReturnValue !== hasReturnValue) {
-                    context.report({
-                        node,
-                        message: funcInfo.message,
-                        data: funcInfo.data
-                    });
-                }
-            },
-
-            // Reports a given program/function if the implicit returning is not consistent.
-            "Program:exit": checkLastSegment,
-            "FunctionDeclaration:exit": checkLastSegment,
-            "FunctionExpression:exit": checkLastSegment,
-            "ArrowFunctionExpression:exit": checkLastSegment
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/constructor-super.js
===================================================================
--- node_modules/eslint/lib/rules/constructor-super.js	(revision )
+++ node_modules/eslint/lib/rules/constructor-super.js	(revision )
@@ -1,385 +0,0 @@
-/**
- * @fileoverview A rule to verify `super()` callings in constructor.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether a given code path segment is reachable or not.
- *
- * @param {CodePathSegment} segment - A code path segment to check.
- * @returns {boolean} `true` if the segment is reachable.
- */
-function isReachable(segment) {
-    return segment.reachable;
-}
-
-/**
- * Checks whether or not a given node is a constructor.
- * @param {ASTNode} node - A node to check. This node type is one of
- *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and
- *   `ArrowFunctionExpression`.
- * @returns {boolean} `true` if the node is a constructor.
- */
-function isConstructorFunction(node) {
-    return (
-        node.type === "FunctionExpression" &&
-        node.parent.type === "MethodDefinition" &&
-        node.parent.kind === "constructor"
-    );
-}
-
-/**
- * Checks whether a given node can be a constructor or not.
- *
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} `true` if the node can be a constructor.
- */
-function isPossibleConstructor(node) {
-    if (!node) {
-        return false;
-    }
-
-    switch (node.type) {
-        case "ClassExpression":
-        case "FunctionExpression":
-        case "ThisExpression":
-        case "MemberExpression":
-        case "CallExpression":
-        case "NewExpression":
-        case "YieldExpression":
-        case "TaggedTemplateExpression":
-        case "MetaProperty":
-            return true;
-
-        case "Identifier":
-            return node.name !== "undefined";
-
-        case "AssignmentExpression":
-            return isPossibleConstructor(node.right);
-
-        case "LogicalExpression":
-            return (
-                isPossibleConstructor(node.left) ||
-                isPossibleConstructor(node.right)
-            );
-
-        case "ConditionalExpression":
-            return (
-                isPossibleConstructor(node.alternate) ||
-                isPossibleConstructor(node.consequent)
-            );
-
-        case "SequenceExpression": {
-            const lastExpression = node.expressions[node.expressions.length - 1];
-
-            return isPossibleConstructor(lastExpression);
-        }
-
-        default:
-            return false;
-    }
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require `super()` calls in constructors",
-            category: "ECMAScript 6",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /*
-         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}
-         * Information for each constructor.
-         * - upper:      Information of the upper constructor.
-         * - hasExtends: A flag which shows whether own class has a valid `extends`
-         *               part.
-         * - scope:      The scope of own class.
-         * - codePath:   The code path object of the constructor.
-         */
-        let funcInfo = null;
-
-        /*
-         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}
-         * Information for each code path segment.
-         * - calledInSomePaths:  A flag of be called `super()` in some code paths.
-         * - calledInEveryPaths: A flag of be called `super()` in all code paths.
-         * - validNodes:
-         */
-        let segInfoMap = Object.create(null);
-
-        /**
-         * Gets the flag which shows `super()` is called in some paths.
-         * @param {CodePathSegment} segment - A code path segment to get.
-         * @returns {boolean} The flag which shows `super()` is called in some paths
-         */
-        function isCalledInSomePath(segment) {
-            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;
-        }
-
-        /**
-         * Gets the flag which shows `super()` is called in all paths.
-         * @param {CodePathSegment} segment - A code path segment to get.
-         * @returns {boolean} The flag which shows `super()` is called in all paths.
-         */
-        function isCalledInEveryPath(segment) {
-
-            /*
-             * If specific segment is the looped segment of the current segment,
-             * skip the segment.
-             * If not skipped, this never becomes true after a loop.
-             */
-            if (segment.nextSegments.length === 1 &&
-                segment.nextSegments[0].isLoopedPrevSegment(segment)
-            ) {
-                return true;
-            }
-            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;
-        }
-
-        return {
-
-            /**
-             * Stacks a constructor information.
-             * @param {CodePath} codePath - A code path which was started.
-             * @param {ASTNode} node - The current node.
-             * @returns {void}
-             */
-            onCodePathStart(codePath, node) {
-                if (isConstructorFunction(node)) {
-
-                    // Class > ClassBody > MethodDefinition > FunctionExpression
-                    const classNode = node.parent.parent.parent;
-                    const superClass = classNode.superClass;
-
-                    funcInfo = {
-                        upper: funcInfo,
-                        isConstructor: true,
-                        hasExtends: Boolean(superClass),
-                        superIsConstructor: isPossibleConstructor(superClass),
-                        codePath
-                    };
-                } else {
-                    funcInfo = {
-                        upper: funcInfo,
-                        isConstructor: false,
-                        hasExtends: false,
-                        superIsConstructor: false,
-                        codePath
-                    };
-                }
-            },
-
-            /**
-             * Pops a constructor information.
-             * And reports if `super()` lacked.
-             * @param {CodePath} codePath - A code path which was ended.
-             * @param {ASTNode} node - The current node.
-             * @returns {void}
-             */
-            onCodePathEnd(codePath, node) {
-                const hasExtends = funcInfo.hasExtends;
-
-                // Pop.
-                funcInfo = funcInfo.upper;
-
-                if (!hasExtends) {
-                    return;
-                }
-
-                // Reports if `super()` lacked.
-                const segments = codePath.returnedSegments;
-                const calledInEveryPaths = segments.every(isCalledInEveryPath);
-                const calledInSomePaths = segments.some(isCalledInSomePath);
-
-                if (!calledInEveryPaths) {
-                    context.report({
-                        message: calledInSomePaths
-                            ? "Lacked a call of 'super()' in some code paths."
-                            : "Expected to call 'super()'.",
-                        node: node.parent
-                    });
-                }
-            },
-
-            /**
-             * Initialize information of a given code path segment.
-             * @param {CodePathSegment} segment - A code path segment to initialize.
-             * @returns {void}
-             */
-            onCodePathSegmentStart(segment) {
-                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
-                    return;
-                }
-
-                // Initialize info.
-                const info = segInfoMap[segment.id] = {
-                    calledInSomePaths: false,
-                    calledInEveryPaths: false,
-                    validNodes: []
-                };
-
-                // When there are previous segments, aggregates these.
-                const prevSegments = segment.prevSegments;
-
-                if (prevSegments.length > 0) {
-                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
-                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
-                }
-            },
-
-            /**
-             * Update information of the code path segment when a code path was
-             * looped.
-             * @param {CodePathSegment} fromSegment - The code path segment of the
-             *      end of a loop.
-             * @param {CodePathSegment} toSegment - A code path segment of the head
-             *      of a loop.
-             * @returns {void}
-             */
-            onCodePathSegmentLoop(fromSegment, toSegment) {
-                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
-                    return;
-                }
-
-                // Update information inside of the loop.
-                const isRealLoop = toSegment.prevSegments.length >= 2;
-
-                funcInfo.codePath.traverseSegments(
-                    { first: toSegment, last: fromSegment },
-                    segment => {
-                        const info = segInfoMap[segment.id];
-                        const prevSegments = segment.prevSegments;
-
-                        // Updates flags.
-                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
-                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
-
-                        // If flags become true anew, reports the valid nodes.
-                        if (info.calledInSomePaths || isRealLoop) {
-                            const nodes = info.validNodes;
-
-                            info.validNodes = [];
-
-                            for (let i = 0; i < nodes.length; ++i) {
-                                const node = nodes[i];
-
-                                context.report({
-                                    message: "Unexpected duplicate 'super()'.",
-                                    node
-                                });
-                            }
-                        }
-                    }
-                );
-            },
-
-            /**
-             * Checks for a call of `super()`.
-             * @param {ASTNode} node - A CallExpression node to check.
-             * @returns {void}
-             */
-            "CallExpression:exit"(node) {
-                if (!(funcInfo && funcInfo.isConstructor)) {
-                    return;
-                }
-
-                // Skips except `super()`.
-                if (node.callee.type !== "Super") {
-                    return;
-                }
-
-                // Reports if needed.
-                if (funcInfo.hasExtends) {
-                    const segments = funcInfo.codePath.currentSegments;
-                    let duplicate = false;
-                    let info = null;
-
-                    for (let i = 0; i < segments.length; ++i) {
-                        const segment = segments[i];
-
-                        if (segment.reachable) {
-                            info = segInfoMap[segment.id];
-
-                            duplicate = duplicate || info.calledInSomePaths;
-                            info.calledInSomePaths = info.calledInEveryPaths = true;
-                        }
-                    }
-
-                    if (info) {
-                        if (duplicate) {
-                            context.report({
-                                message: "Unexpected duplicate 'super()'.",
-                                node
-                            });
-                        } else if (!funcInfo.superIsConstructor) {
-                            context.report({
-                                message: "Unexpected 'super()' because 'super' is not a constructor.",
-                                node
-                            });
-                        } else {
-                            info.validNodes.push(node);
-                        }
-                    }
-                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {
-                    context.report({
-                        message: "Unexpected 'super()'.",
-                        node
-                    });
-                }
-            },
-
-            /**
-             * Set the mark to the returned path as `super()` was called.
-             * @param {ASTNode} node - A ReturnStatement node to check.
-             * @returns {void}
-             */
-            ReturnStatement(node) {
-                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
-                    return;
-                }
-
-                // Skips if no argument.
-                if (!node.argument) {
-                    return;
-                }
-
-                // Returning argument is a substitute of 'super()'.
-                const segments = funcInfo.codePath.currentSegments;
-
-                for (let i = 0; i < segments.length; ++i) {
-                    const segment = segments[i];
-
-                    if (segment.reachable) {
-                        const info = segInfoMap[segment.id];
-
-                        info.calledInSomePaths = info.calledInEveryPaths = true;
-                    }
-                }
-            },
-
-            /**
-             * Resets state.
-             * @returns {void}
-             */
-            "Program:exit"() {
-                segInfoMap = Object.create(null);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/func-call-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/func-call-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/func-call-spacing.js	(revision )
@@ -1,157 +0,0 @@
-/**
- * @fileoverview Rule to control spacing within function calls
- * @author Matt DuVall <http://www.mattduvall.com>
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow spacing between function identifiers and their invocations",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-        schema: {
-            anyOf: [
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["never"]
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 1
-                },
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["always"]
-                        },
-                        {
-                            type: "object",
-                            properties: {
-                                allowNewlines: {
-                                    type: "boolean"
-                                }
-                            },
-                            additionalProperties: false
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 2
-                }
-            ]
-        }
-    },
-
-    create(context) {
-
-        const never = context.options[0] !== "always";
-        const allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;
-        const sourceCode = context.getSourceCode();
-        const text = sourceCode.getText();
-
-        /**
-         * Check if open space is present in a function name
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkSpacing(node) {
-            const lastToken = sourceCode.getLastToken(node);
-            const lastCalleeToken = sourceCode.getLastToken(node.callee);
-            const parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);
-            const prevToken = parenToken && sourceCode.getTokenBefore(parenToken);
-
-            // Parens in NewExpression are optional
-            if (!(parenToken && parenToken.range[1] < node.range[1])) {
-                return;
-            }
-
-            const textBetweenTokens = text.slice(prevToken.range[1], parenToken.range[0]).replace(/\/\*.*?\*\//g, "");
-            const hasWhitespace = /\s/.test(textBetweenTokens);
-            const hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);
-
-            /*
-             * never allowNewlines hasWhitespace hasNewline message
-             * F     F             F             F          Missing space between function name and paren.
-             * F     F             F             T          (Invalid `!hasWhitespace && hasNewline`)
-             * F     F             T             T          Unexpected newline between function name and paren.
-             * F     F             T             F          (OK)
-             * F     T             T             F          (OK)
-             * F     T             T             T          (OK)
-             * F     T             F             T          (Invalid `!hasWhitespace && hasNewline`)
-             * F     T             F             F          Missing space between function name and paren.
-             * T     T             F             F          (Invalid `never && allowNewlines`)
-             * T     T             F             T          (Invalid `!hasWhitespace && hasNewline`)
-             * T     T             T             T          (Invalid `never && allowNewlines`)
-             * T     T             T             F          (Invalid `never && allowNewlines`)
-             * T     F             T             F          Unexpected space between function name and paren.
-             * T     F             T             T          Unexpected space between function name and paren.
-             * T     F             F             T          (Invalid `!hasWhitespace && hasNewline`)
-             * T     F             F             F          (OK)
-             *
-             * T                   T                        Unexpected space between function name and paren.
-             * F                   F                        Missing space between function name and paren.
-             * F     F                           T          Unexpected newline between function name and paren.
-             */
-
-            if (never && hasWhitespace) {
-                context.report({
-                    node,
-                    loc: lastCalleeToken.loc.start,
-                    message: "Unexpected space between function name and paren.",
-                    fix(fixer) {
-
-                        // Only autofix if there is no newline
-                        // https://github.com/eslint/eslint/issues/7787
-                        if (!hasNewline) {
-                            return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
-                        }
-
-                        return null;
-                    }
-                });
-            } else if (!never && !hasWhitespace) {
-                context.report({
-                    node,
-                    loc: lastCalleeToken.loc.start,
-                    message: "Missing space between function name and paren.",
-                    fix(fixer) {
-                        return fixer.insertTextBefore(parenToken, " ");
-                    }
-                });
-            } else if (!never && !allowNewlines && hasNewline) {
-                context.report({
-                    node,
-                    loc: lastCalleeToken.loc.start,
-                    message: "Unexpected newline between function name and paren.",
-                    fix(fixer) {
-                        return fixer.replaceTextRange([prevToken.range[1], parenToken.range[0]], " ");
-                    }
-                });
-            }
-        }
-
-        return {
-            CallExpression: checkSpacing,
-            NewExpression: checkSpacing
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/init-declarations.js
===================================================================
--- node_modules/eslint/lib/rules/init-declarations.js	(revision )
+++ node_modules/eslint/lib/rules/init-declarations.js	(revision )
@@ -1,137 +0,0 @@
-/**
- * @fileoverview A rule to control the style of variable initializations.
- * @author Colin Ihrig
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a given node is a for loop.
- * @param {ASTNode} block - A node to check.
- * @returns {boolean} `true` when the node is a for loop.
- */
-function isForLoop(block) {
-    return block.type === "ForInStatement" ||
-    block.type === "ForOfStatement" ||
-    block.type === "ForStatement";
-}
-
-/**
- * Checks whether or not a given declarator node has its initializer.
- * @param {ASTNode} node - A declarator node to check.
- * @returns {boolean} `true` when the node has its initializer.
- */
-function isInitialized(node) {
-    const declaration = node.parent;
-    const block = declaration.parent;
-
-    if (isForLoop(block)) {
-        if (block.type === "ForStatement") {
-            return block.init === declaration;
-        }
-        return block.left === declaration;
-    }
-    return Boolean(node.init);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow initialization in variable declarations",
-            category: "Variables",
-            recommended: false
-        },
-
-        schema: {
-            anyOf: [
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["always"]
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 1
-                },
-                {
-                    type: "array",
-                    items: [
-                        {
-                            enum: ["never"]
-                        },
-                        {
-                            type: "object",
-                            properties: {
-                                ignoreForLoopInit: {
-                                    type: "boolean"
-                                }
-                            },
-                            additionalProperties: false
-                        }
-                    ],
-                    minItems: 0,
-                    maxItems: 2
-                }
-            ]
-        }
-    },
-
-    create(context) {
-
-        const MODE_ALWAYS = "always",
-            MODE_NEVER = "never";
-
-        const mode = context.options[0] || MODE_ALWAYS;
-        const params = context.options[1] || {};
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            "VariableDeclaration:exit"(node) {
-
-                const kind = node.kind,
-                    declarations = node.declarations;
-
-                for (let i = 0; i < declarations.length; ++i) {
-                    const declaration = declarations[i],
-                        id = declaration.id,
-                        initialized = isInitialized(declaration),
-                        isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);
-
-                    if (id.type !== "Identifier") {
-                        continue;
-                    }
-
-                    if (mode === MODE_ALWAYS && !initialized) {
-                        context.report({
-                            node: declaration,
-                            message: "Variable '{{idName}}' should be initialized on declaration.",
-                            data: {
-                                idName: id.name
-                            }
-                        });
-                    } else if (mode === MODE_NEVER && kind !== "const" && initialized && !isIgnoredForLoop) {
-                        context.report({
-                            node: declaration,
-                            message: "Variable '{{idName}}' should not be initialized on declaration.",
-                            data: {
-                                idName: id.name
-                            }
-                        });
-                    }
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/multiline-ternary.js
===================================================================
--- node_modules/eslint/lib/rules/multiline-ternary.js	(revision )
+++ node_modules/eslint/lib/rules/multiline-ternary.js	(revision )
@@ -1,89 +0,0 @@
-/**
- * @fileoverview Enforce newlines between operands of ternary expressions
- * @author Kai Cataldo
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce newlines between operands of ternary expressions",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        schema: [
-            {
-                enum: ["always", "always-multiline", "never"]
-            }
-        ]
-    },
-
-    create(context) {
-        const option = context.options[0];
-        const multiline = option !== "never";
-        const allowSingleLine = option === "always-multiline";
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Tests whether node is preceded by supplied tokens
-         * @param {ASTNode} node - node to check
-         * @param {ASTNode} parentNode - parent of node to report
-         * @param {boolean} expected - whether newline was expected or not
-         * @returns {void}
-         * @private
-         */
-        function reportError(node, parentNode, expected) {
-            context.report({
-                node,
-                message: "{{expected}} newline between {{typeOfError}} of ternary expression.",
-                data: {
-                    expected: expected ? "Expected" : "Unexpected",
-                    typeOfError: node === parentNode.test ? "test and consequent" : "consequent and alternate"
-                }
-            });
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            ConditionalExpression(node) {
-                const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(node.test, node.consequent);
-                const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(node.consequent, node.alternate);
-
-                if (!multiline) {
-                    if (!areTestAndConsequentOnSameLine) {
-                        reportError(node.test, node, false);
-                    }
-
-                    if (!areConsequentAndAlternateOnSameLine) {
-                        reportError(node.consequent, node, false);
-                    }
-                } else {
-                    if (allowSingleLine && node.loc.start.line === node.loc.end.line) {
-                        return;
-                    }
-
-                    if (areTestAndConsequentOnSameLine) {
-                        reportError(node.test, node, true);
-                    }
-
-                    if (areConsequentAndAlternateOnSameLine) {
-                        reportError(node.consequent, node, true);
-                    }
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/newline-after-var.js
===================================================================
--- node_modules/eslint/lib/rules/newline-after-var.js	(revision )
+++ node_modules/eslint/lib/rules/newline-after-var.js	(revision )
@@ -1,252 +0,0 @@
-/**
- * @fileoverview Rule to check empty newline after "var" statement
- * @author Gopal Venkatesan
- * @deprecated
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow an empty line after variable declarations",
-            category: "Stylistic Issues",
-            recommended: false,
-            replacedBy: ["padding-line-between-statements"]
-        },
-
-        schema: [
-            {
-                enum: ["never", "always"]
-            }
-        ],
-
-        fixable: "whitespace",
-
-        deprecated: true
-    },
-
-    create(context) {
-
-        const ALWAYS_MESSAGE = "Expected blank line after variable declarations.",
-            NEVER_MESSAGE = "Unexpected blank line after variable declarations.";
-
-        const sourceCode = context.getSourceCode();
-
-        // Default `mode` to "always".
-        const mode = context.options[0] === "never" ? "never" : "always";
-
-        // Cache starting and ending line numbers of comments for faster lookup
-        const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {
-            result[token.loc.start.line] = token.loc.end.line;
-            return result;
-        }, {});
-
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Gets a token from the given node to compare line to the next statement.
-         *
-         * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.
-         *
-         * - The last token is semicolon.
-         * - The semicolon is on a different line from the previous token of the semicolon.
-         *
-         * This behavior would address semicolon-less style code. e.g.:
-         *
-         *     var foo = 1
-         *
-         *     ;(a || b).doSomething()
-         *
-         * @param {ASTNode} node - The node to get.
-         * @returns {Token} The token to compare line to the next statement.
-         */
-        function getLastToken(node) {
-            const lastToken = sourceCode.getLastToken(node);
-
-            if (lastToken.type === "Punctuator" && lastToken.value === ";") {
-                const prevToken = sourceCode.getTokenBefore(lastToken);
-
-                if (prevToken.loc.end.line !== lastToken.loc.start.line) {
-                    return prevToken;
-                }
-            }
-
-            return lastToken;
-        }
-
-        /**
-         * Determine if provided keyword is a variable declaration
-         * @private
-         * @param {string} keyword - keyword to test
-         * @returns {boolean} True if `keyword` is a type of var
-         */
-        function isVar(keyword) {
-            return keyword === "var" || keyword === "let" || keyword === "const";
-        }
-
-        /**
-         * Determine if provided keyword is a variant of for specifiers
-         * @private
-         * @param {string} keyword - keyword to test
-         * @returns {boolean} True if `keyword` is a variant of for specifier
-         */
-        function isForTypeSpecifier(keyword) {
-            return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
-        }
-
-        /**
-         * Determine if provided keyword is an export specifiers
-         * @private
-         * @param {string} nodeType - nodeType to test
-         * @returns {boolean} True if `nodeType` is an export specifier
-         */
-        function isExportSpecifier(nodeType) {
-            return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" ||
-                nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
-        }
-
-        /**
-         * Determine if provided node is the last of their parent block.
-         * @private
-         * @param {ASTNode} node - node to test
-         * @returns {boolean} True if `node` is last of their parent block.
-         */
-        function isLastNode(node) {
-            const token = sourceCode.getTokenAfter(node);
-
-            return !token || (token.type === "Punctuator" && token.value === "}");
-        }
-
-        /**
-        * Gets the last line of a group of consecutive comments
-        * @param {number} commentStartLine The starting line of the group
-        * @returns {number} The number of the last comment line of the group
-        */
-        function getLastCommentLineOfBlock(commentStartLine) {
-            const currentCommentEnd = commentEndLine[commentStartLine];
-
-            return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;
-        }
-
-        /**
-         * Determine if a token starts more than one line after a comment ends
-         * @param  {token}   token            The token being checked
-         * @param {integer}  commentStartLine The line number on which the comment starts
-         * @returns {boolean}                 True if `token` does not start immediately after a comment
-         */
-        function hasBlankLineAfterComment(token, commentStartLine) {
-            return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;
-        }
-
-        /**
-         * Checks that a blank line exists after a variable declaration when mode is
-         * set to "always", or checks that there is no blank line when mode is set
-         * to "never"
-         * @private
-         * @param {ASTNode} node - `VariableDeclaration` node to test
-         * @returns {void}
-         */
-        function checkForBlankLine(node) {
-
-            /*
-             * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will
-             * sometimes be second-last if there is a semicolon on a different line.
-             */
-            const lastToken = getLastToken(node),
-
-                /*
-                 * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken
-                 * is the last token of the node.
-                 */
-                nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),
-                nextLineNum = lastToken.loc.end.line + 1;
-
-            // Ignore if there is no following statement
-            if (!nextToken) {
-                return;
-            }
-
-            // Ignore if parent of node is a for variant
-            if (isForTypeSpecifier(node.parent.type)) {
-                return;
-            }
-
-            // Ignore if parent of node is an export specifier
-            if (isExportSpecifier(node.parent.type)) {
-                return;
-            }
-
-            // Some coding styles use multiple `var` statements, so do nothing if
-            // the next token is a `var` statement.
-            if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
-                return;
-            }
-
-            // Ignore if it is last statement in a block
-            if (isLastNode(node)) {
-                return;
-            }
-
-            // Next statement is not a `var`...
-            const noNextLineToken = nextToken.loc.start.line > nextLineNum;
-            const hasNextLineComment = (typeof commentEndLine[nextLineNum] !== "undefined");
-
-            if (mode === "never" && noNextLineToken && !hasNextLineComment) {
-                context.report({
-                    node,
-                    message: NEVER_MESSAGE,
-                    data: { identifier: node.name },
-                    fix(fixer) {
-                        const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);
-
-                        return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join("")}\n${linesBetween[linesBetween.length - 1]}`);
-                    }
-                });
-            }
-
-            // Token on the next line, or comment without blank line
-            if (
-                mode === "always" && (
-                    !noNextLineToken ||
-                    hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)
-                )
-            ) {
-                context.report({
-                    node,
-                    message: ALWAYS_MESSAGE,
-                    data: { identifier: node.name },
-                    fix(fixer) {
-                        if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {
-                            return fixer.insertTextBefore(nextToken, "\n\n");
-                        }
-
-                        return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], "\n");
-                    }
-                });
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            VariableDeclaration: checkForBlankLine
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-duplicate-case.js
===================================================================
--- node_modules/eslint/lib/rules/no-duplicate-case.js	(revision )
+++ node_modules/eslint/lib/rules/no-duplicate-case.js	(revision )
@@ -1,43 +0,0 @@
-/**
- * @fileoverview Rule to disallow a duplicate case label.
- * @author Dieter Oberkofler
- * @author Burak Yigit Kaya
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow duplicate case labels",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-            SwitchStatement(node) {
-                const mapping = {};
-
-                node.cases.forEach(switchCase => {
-                    const key = sourceCode.getText(switchCase.test);
-
-                    if (mapping[key]) {
-                        context.report({ node: switchCase, message: "Duplicate case label." });
-                    } else {
-                        mapping[key] = switchCase;
-                    }
-                });
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-empty-function.js
===================================================================
--- node_modules/eslint/lib/rules/no-empty-function.js	(revision )
+++ node_modules/eslint/lib/rules/no-empty-function.js	(revision )
@@ -1,160 +0,0 @@
-/**
- * @fileoverview Rule to disallow empty functions.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const ALLOW_OPTIONS = Object.freeze([
-    "functions",
-    "arrowFunctions",
-    "generatorFunctions",
-    "methods",
-    "generatorMethods",
-    "getters",
-    "setters",
-    "constructors"
-]);
-
-/**
- * Gets the kind of a given function node.
- *
- * @param {ASTNode} node - A function node to get. This is one of
- *      an ArrowFunctionExpression, a FunctionDeclaration, or a
- *      FunctionExpression.
- * @returns {string} The kind of the function. This is one of "functions",
- *      "arrowFunctions", "generatorFunctions", "asyncFunctions", "methods",
- *      "generatorMethods", "asyncMethods", "getters", "setters", and
- *      "constructors".
- */
-function getKind(node) {
-    const parent = node.parent;
-    let kind = "";
-
-    if (node.type === "ArrowFunctionExpression") {
-        return "arrowFunctions";
-    }
-
-    // Detects main kind.
-    if (parent.type === "Property") {
-        if (parent.kind === "get") {
-            return "getters";
-        }
-        if (parent.kind === "set") {
-            return "setters";
-        }
-        kind = parent.method ? "methods" : "functions";
-
-    } else if (parent.type === "MethodDefinition") {
-        if (parent.kind === "get") {
-            return "getters";
-        }
-        if (parent.kind === "set") {
-            return "setters";
-        }
-        if (parent.kind === "constructor") {
-            return "constructors";
-        }
-        kind = "methods";
-
-    } else {
-        kind = "functions";
-    }
-
-    // Detects prefix.
-    let prefix = "";
-
-    if (node.generator) {
-        prefix = "generator";
-    } else if (node.async) {
-        prefix = "async";
-    } else {
-        return kind;
-    }
-    return prefix + kind[0].toUpperCase() + kind.slice(1);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow empty functions",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allow: {
-                        type: "array",
-                        items: { enum: ALLOW_OPTIONS },
-                        uniqueItems: true
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0] || {};
-        const allowed = options.allow || [];
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Reports a given function node if the node matches the following patterns.
-         *
-         * - Not allowed by options.
-         * - The body is empty.
-         * - The body doesn't have any comments.
-         *
-         * @param {ASTNode} node - A function node to report. This is one of
-         *      an ArrowFunctionExpression, a FunctionDeclaration, or a
-         *      FunctionExpression.
-         * @returns {void}
-         */
-        function reportIfEmpty(node) {
-            const kind = getKind(node);
-            const name = astUtils.getFunctionNameWithKind(node);
-            const innerComments = sourceCode.getTokens(node.body, {
-                includeComments: true,
-                filter: astUtils.isCommentToken
-            });
-
-            if (allowed.indexOf(kind) === -1 &&
-                node.body.type === "BlockStatement" &&
-                node.body.body.length === 0 &&
-                innerComments.length === 0
-            ) {
-                context.report({
-                    node,
-                    loc: node.body.loc.start,
-                    message: "Unexpected empty {{name}}.",
-                    data: { name }
-                });
-            }
-        }
-
-        return {
-            ArrowFunctionExpression: reportIfEmpty,
-            FunctionDeclaration: reportIfEmpty,
-            FunctionExpression: reportIfEmpty
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-invalid-regexp.js
===================================================================
--- node_modules/eslint/lib/rules/no-invalid-regexp.js	(revision )
+++ node_modules/eslint/lib/rules/no-invalid-regexp.js	(revision )
@@ -1,106 +0,0 @@
-/**
- * @fileoverview Validate strings passed to the RegExp constructor
- * @author Michael Ficarra
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const espree = require("espree");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow invalid regular expression strings in `RegExp` constructors",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: [{
-            type: "object",
-            properties: {
-                allowConstructorFlags: {
-                    type: "array",
-                    items: {
-                        type: "string"
-                    }
-                }
-            },
-            additionalProperties: false
-        }]
-    },
-
-    create(context) {
-
-        const options = context.options[0];
-        let allowedFlags = "";
-
-        if (options && options.allowConstructorFlags) {
-            allowedFlags = options.allowConstructorFlags.join("");
-        }
-
-        /**
-         * Check if node is a string
-         * @param {ASTNode} node node to evaluate
-         * @returns {boolean} True if its a string
-         * @private
-         */
-        function isString(node) {
-            return node && node.type === "Literal" && typeof node.value === "string";
-        }
-
-        /**
-         * Validate strings passed to the RegExp constructor
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function check(node) {
-            if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0])) {
-                let flags = isString(node.arguments[1]) ? node.arguments[1].value : "";
-
-                if (allowedFlags) {
-                    flags = flags.replace(new RegExp(`[${allowedFlags}]`, "gi"), "");
-                }
-
-                try {
-                    void new RegExp(node.arguments[0].value);
-                } catch (e) {
-                    context.report({
-                        node,
-                        message: "{{message}}.",
-                        data: e
-                    });
-                }
-
-                if (flags) {
-
-                    try {
-                        espree.parse(`/./${flags}`, context.parserOptions);
-                    } catch (ex) {
-                        context.report({
-                            node,
-                            message: "Invalid flags supplied to RegExp constructor '{{flags}}'.",
-                            data: {
-                                flags
-                            }
-                        });
-                    }
-                }
-
-            }
-        }
-
-        return {
-            CallExpression: check,
-            NewExpression: check
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-mixed-requires.js
===================================================================
--- node_modules/eslint/lib/rules/no-mixed-requires.js	(revision )
+++ node_modules/eslint/lib/rules/no-mixed-requires.js	(revision )
@@ -1,216 +0,0 @@
-/**
- * @fileoverview Rule to enforce grouped require statements for Node.JS
- * @author Raphael Pigulla
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `require` calls to be mixed with regular variable declarations",
-            category: "Node.js and CommonJS",
-            recommended: false
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        type: "boolean"
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            grouping: {
-                                type: "boolean"
-                            },
-                            allowCall: {
-                                type: "boolean"
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-
-        const options = context.options[0];
-        let grouping = false,
-            allowCall = false;
-
-        if (typeof options === "object") {
-            grouping = options.grouping;
-            allowCall = options.allowCall;
-        } else {
-            grouping = !!options;
-        }
-
-        /**
-         * Returns the list of built-in modules.
-         *
-         * @returns {string[]} An array of built-in Node.js modules.
-         */
-        function getBuiltinModules() {
-
-            /*
-             * This list is generated using:
-             * `require("repl")._builtinLibs.concat('repl').sort()`
-             * This particular list is as per nodejs v0.12.2 and iojs v0.7.1
-             */
-            return [
-                "assert", "buffer", "child_process", "cluster", "crypto",
-                "dgram", "dns", "domain", "events", "fs", "http", "https",
-                "net", "os", "path", "punycode", "querystring", "readline",
-                "repl", "smalloc", "stream", "string_decoder", "tls", "tty",
-                "url", "util", "v8", "vm", "zlib"
-            ];
-        }
-
-        const BUILTIN_MODULES = getBuiltinModules();
-
-        const DECL_REQUIRE = "require",
-            DECL_UNINITIALIZED = "uninitialized",
-            DECL_OTHER = "other";
-
-        const REQ_CORE = "core",
-            REQ_FILE = "file",
-            REQ_MODULE = "module",
-            REQ_COMPUTED = "computed";
-
-        /**
-         * Determines the type of a declaration statement.
-         * @param {ASTNode} initExpression The init node of the VariableDeclarator.
-         * @returns {string} The type of declaration represented by the expression.
-         */
-        function getDeclarationType(initExpression) {
-            if (!initExpression) {
-
-                // "var x;"
-                return DECL_UNINITIALIZED;
-            }
-
-            if (initExpression.type === "CallExpression" &&
-                initExpression.callee.type === "Identifier" &&
-                initExpression.callee.name === "require"
-            ) {
-
-                // "var x = require('util');"
-                return DECL_REQUIRE;
-            } else if (allowCall &&
-                initExpression.type === "CallExpression" &&
-                initExpression.callee.type === "CallExpression"
-            ) {
-
-                // "var x = require('diagnose')('sub-module');"
-                return getDeclarationType(initExpression.callee);
-            } else if (initExpression.type === "MemberExpression") {
-
-                // "var x = require('glob').Glob;"
-                return getDeclarationType(initExpression.object);
-            }
-
-            // "var x = 42;"
-            return DECL_OTHER;
-        }
-
-        /**
-         * Determines the type of module that is loaded via require.
-         * @param {ASTNode} initExpression The init node of the VariableDeclarator.
-         * @returns {string} The module type.
-         */
-        function inferModuleType(initExpression) {
-            if (initExpression.type === "MemberExpression") {
-
-                // "var x = require('glob').Glob;"
-                return inferModuleType(initExpression.object);
-            } else if (initExpression.arguments.length === 0) {
-
-                // "var x = require();"
-                return REQ_COMPUTED;
-            }
-
-            const arg = initExpression.arguments[0];
-
-            if (arg.type !== "Literal" || typeof arg.value !== "string") {
-
-                // "var x = require(42);"
-                return REQ_COMPUTED;
-            }
-
-            if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {
-
-                // "var fs = require('fs');"
-                return REQ_CORE;
-            } else if (/^\.{0,2}\//.test(arg.value)) {
-
-                // "var utils = require('./utils');"
-                return REQ_FILE;
-            }
-
-            // "var async = require('async');"
-            return REQ_MODULE;
-
-        }
-
-        /**
-         * Check if the list of variable declarations is mixed, i.e. whether it
-         * contains both require and other declarations.
-         * @param {ASTNode} declarations The list of VariableDeclarators.
-         * @returns {boolean} True if the declarations are mixed, false if not.
-         */
-        function isMixed(declarations) {
-            const contains = {};
-
-            declarations.forEach(declaration => {
-                const type = getDeclarationType(declaration.init);
-
-                contains[type] = true;
-            });
-
-            return !!(
-                contains[DECL_REQUIRE] &&
-                (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER])
-            );
-        }
-
-        /**
-         * Check if all require declarations in the given list are of the same
-         * type.
-         * @param {ASTNode} declarations The list of VariableDeclarators.
-         * @returns {boolean} True if the declarations are grouped, false if not.
-         */
-        function isGrouped(declarations) {
-            const found = {};
-
-            declarations.forEach(declaration => {
-                if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
-                    found[inferModuleType(declaration.init)] = true;
-                }
-            });
-
-            return Object.keys(found).length <= 1;
-        }
-
-
-        return {
-
-            VariableDeclaration(node) {
-
-                if (isMixed(node.declarations)) {
-                    context.report({ node, message: "Do not mix 'require' and other declarations." });
-                } else if (grouping && !isGrouped(node.declarations)) {
-                    context.report({ node, message: "Do not mix core, module, file and computed requires." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-negated-in-lhs.js
===================================================================
--- node_modules/eslint/lib/rules/no-negated-in-lhs.js	(revision )
+++ node_modules/eslint/lib/rules/no-negated-in-lhs.js	(revision )
@@ -1,38 +0,0 @@
-/**
- * @fileoverview A rule to disallow negated left operands of the `in` operator
- * @author Michael Ficarra
- * @deprecated in ESLint v3.3.0
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow negating the left operand in `in` expressions",
-            category: "Possible Errors",
-            recommended: false,
-            replacedBy: ["no-unsafe-negation"]
-        },
-        deprecated: true,
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-
-            BinaryExpression(node) {
-                if (node.operator === "in" && node.left.type === "UnaryExpression" && node.left.operator === "!") {
-                    context.report({ node, message: "The 'in' expression's left operand is negated." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-nested-ternary.js
===================================================================
--- node_modules/eslint/lib/rules/no-nested-ternary.js	(revision )
+++ node_modules/eslint/lib/rules/no-nested-ternary.js	(revision )
@@ -1,34 +0,0 @@
-/**
- * @fileoverview Rule to flag nested ternary expressions
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow nested ternary expressions",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        return {
-            ConditionalExpression(node) {
-                if (node.alternate.type === "ConditionalExpression" ||
-                        node.consequent.type === "ConditionalExpression") {
-                    context.report({ node, message: "Do not nest ternary expressions." });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-param-reassign.js
===================================================================
--- node_modules/eslint/lib/rules/no-param-reassign.js	(revision )
+++ node_modules/eslint/lib/rules/no-param-reassign.js	(revision )
@@ -1,171 +0,0 @@
-/**
- * @fileoverview Disallow reassignment of function parameters.
- * @author Nat Burns
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/;
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow reassigning `function` parameters",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        type: "object",
-                        properties: {
-                            props: {
-                                enum: [false]
-                            }
-                        },
-                        additionalProperties: false
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            props: {
-                                enum: [true]
-                            },
-                            ignorePropertyModificationsFor: {
-                                type: "array",
-                                items: {
-                                    type: "string"
-                                },
-                                uniqueItems: true
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const props = context.options[0] && Boolean(context.options[0].props);
-        const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];
-
-        /**
-         * Checks whether or not the reference modifies properties of its variable.
-         * @param {Reference} reference - A reference to check.
-         * @returns {boolean} Whether or not the reference modifies properties of its variable.
-         */
-        function isModifyingProp(reference) {
-            let node = reference.identifier;
-            let parent = node.parent;
-
-            while (parent && !stopNodePattern.test(parent.type)) {
-                switch (parent.type) {
-
-                    // e.g. foo.a = 0;
-                    case "AssignmentExpression":
-                        return parent.left === node;
-
-                    // e.g. ++foo.a;
-                    case "UpdateExpression":
-                        return true;
-
-                    // e.g. delete foo.a;
-                    case "UnaryExpression":
-                        if (parent.operator === "delete") {
-                            return true;
-                        }
-                        break;
-
-                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;
-                    case "CallExpression":
-                        if (parent.callee !== node) {
-                            return false;
-                        }
-                        break;
-
-                    // EXCLUDES: e.g. cache[foo.a] = 0;
-                    case "MemberExpression":
-                        if (parent.property === node) {
-                            return false;
-                        }
-                        break;
-
-                    // EXCLUDES: e.g. ({ [foo]: a }) = bar;
-                    case "Property":
-                        if (parent.key === node) {
-                            return false;
-                        }
-
-                        break;
-
-                    // no default
-                }
-
-                node = parent;
-                parent = node.parent;
-            }
-
-            return false;
-        }
-
-        /**
-         * Reports a reference if is non initializer and writable.
-         * @param {Reference} reference - A reference to check.
-         * @param {int} index - The index of the reference in the references.
-         * @param {Reference[]} references - The array that the reference belongs to.
-         * @returns {void}
-         */
-        function checkReference(reference, index, references) {
-            const identifier = reference.identifier;
-
-            if (identifier &&
-                !reference.init &&
-
-                // Destructuring assignments can have multiple default value,
-                // so possibly there are multiple writeable references for the same identifier.
-                (index === 0 || references[index - 1].identifier !== identifier)
-            ) {
-                if (reference.isWrite()) {
-                    context.report({ node: identifier, message: "Assignment to function parameter '{{name}}'.", data: { name: identifier.name } });
-                } else if (props && isModifyingProp(reference) && ignoredPropertyAssignmentsFor.indexOf(identifier.name) === -1) {
-                    context.report({ node: identifier, message: "Assignment to property of function parameter '{{name}}'.", data: { name: identifier.name } });
-                }
-            }
-        }
-
-        /**
-         * Finds and reports references that are non initializer and writable.
-         * @param {Variable} variable - A variable to check.
-         * @returns {void}
-         */
-        function checkVariable(variable) {
-            if (variable.defs[0].type === "Parameter") {
-                variable.references.forEach(checkReference);
-            }
-        }
-
-        /**
-         * Checks parameters of a given function node.
-         * @param {ASTNode} node - A function node to check.
-         * @returns {void}
-         */
-        function checkForFunction(node) {
-            context.getDeclaredVariables(node).forEach(checkVariable);
-        }
-
-        return {
-
-            // `:exit` is needed for the `node.parent` property of identifier nodes.
-            "FunctionDeclaration:exit": checkForFunction,
-            "FunctionExpression:exit": checkForFunction,
-            "ArrowFunctionExpression:exit": checkForFunction
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-unsafe-finally.js
===================================================================
--- node_modules/eslint/lib/rules/no-unsafe-finally.js	(revision )
+++ node_modules/eslint/lib/rules/no-unsafe-finally.js	(revision )
@@ -1,104 +0,0 @@
-/**
- * @fileoverview Rule to flag unsafe statements in finally block
- * @author Onur Temizkan
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/;
-const SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/;
-const SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/;
-
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow control flow statements in `finally` blocks",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-    create(context) {
-
-        /**
-         * Checks if the node is the finalizer of a TryStatement
-         *
-         * @param {ASTNode} node - node to check.
-         * @returns {boolean} - true if the node is the finalizer of a TryStatement
-         */
-        function isFinallyBlock(node) {
-            return node.parent.type === "TryStatement" && node.parent.finalizer === node;
-        }
-
-        /**
-         * Climbs up the tree if the node is not a sentinel node
-         *
-         * @param {ASTNode} node - node to check.
-         * @param {string} label - label of the break or continue statement
-         * @returns {boolean} - return whether the node is a finally block or a sentinel node
-         */
-        function isInFinallyBlock(node, label) {
-            let labelInside = false;
-            let sentinelNodeType;
-
-            if (node.type === "BreakStatement" && !node.label) {
-                sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;
-            } else if (node.type === "ContinueStatement") {
-                sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;
-            } else {
-                sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;
-            }
-
-            while (node && !sentinelNodeType.test(node.type)) {
-                if (node.parent.label && label && (node.parent.label.name === label.name)) {
-                    labelInside = true;
-                }
-                if (isFinallyBlock(node)) {
-                    if (label && labelInside) {
-                        return false;
-                    }
-                    return true;
-                }
-                node = node.parent;
-            }
-            return false;
-        }
-
-        /**
-         * Checks whether the possibly-unsafe statement is inside a finally block.
-         *
-         * @param {ASTNode} node - node to check.
-         * @returns {void}
-         */
-        function check(node) {
-            if (isInFinallyBlock(node, node.label)) {
-                context.report({
-                    message: "Unsafe usage of {{nodeType}}.",
-                    data: {
-                        nodeType: node.type
-                    },
-                    node,
-                    line: node.loc.line,
-                    column: node.loc.column
-                });
-            }
-        }
-
-        return {
-            ReturnStatement: check,
-            ThrowStatement: check,
-            BreakStatement: check,
-            ContinueStatement: check
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-useless-concat.js
===================================================================
--- node_modules/eslint/lib/rules/no-useless-concat.js	(revision )
+++ node_modules/eslint/lib/rules/no-useless-concat.js	(revision )
@@ -1,108 +0,0 @@
-/**
- * @fileoverview disallow unncessary concatenation of template strings
- * @author Henry Zhu
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a given node is a concatenation.
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} `true` if the node is a concatenation.
- */
-function isConcatenation(node) {
-    return node.type === "BinaryExpression" && node.operator === "+";
-}
-
-/**
- * Checks if the given token is a `+` token or not.
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is a `+` token.
- */
-function isConcatOperatorToken(token) {
-    return token.value === "+" && token.type === "Punctuator";
-}
-
-/**
- * Get's the right most node on the left side of a BinaryExpression with + operator.
- * @param {ASTNode} node - A BinaryExpression node to check.
- * @returns {ASTNode} node
- */
-function getLeft(node) {
-    let left = node.left;
-
-    while (isConcatenation(left)) {
-        left = left.right;
-    }
-    return left;
-}
-
-/**
- * Get's the left most node on the right side of a BinaryExpression with + operator.
- * @param {ASTNode} node - A BinaryExpression node to check.
- * @returns {ASTNode} node
- */
-function getRight(node) {
-    let right = node.right;
-
-    while (isConcatenation(right)) {
-        right = right.left;
-    }
-    return right;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary concatenation of literals or template literals",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-            BinaryExpression(node) {
-
-                // check if not concatenation
-                if (node.operator !== "+") {
-                    return;
-                }
-
-                // account for the `foo + "a" + "b"` case
-                const left = getLeft(node);
-                const right = getRight(node);
-
-                if (astUtils.isStringLiteral(left) &&
-                    astUtils.isStringLiteral(right) &&
-                    astUtils.isTokenOnSameLine(left, right)
-                ) {
-                    const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);
-
-                    context.report({
-                        node,
-                        loc: operatorToken.loc.start,
-                        message: "Unexpected string concatenation of literals."
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-useless-escape.js
===================================================================
--- node_modules/eslint/lib/rules/no-useless-escape.js	(revision )
+++ node_modules/eslint/lib/rules/no-useless-escape.js	(revision )
@@ -1,215 +0,0 @@
-/**
- * @fileoverview Look for useless escapes in strings and regexes
- * @author Onur Temizkan
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-/**
-* Returns the union of two sets.
-* @param {Set} setA The first set
-* @param {Set} setB The second set
-* @returns {Set} The union of the two sets
-*/
-function union(setA, setB) {
-    return new Set(function *() {
-        yield* setA;
-        yield* setB;
-    }());
-}
-
-const VALID_STRING_ESCAPES = union(new Set("\\nrvtbfux"), astUtils.LINEBREAKS);
-const REGEX_GENERAL_ESCAPES = new Set("\\bcdDfnrsStvwWxu0123456789]");
-const REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("^/.$*+?[{}|()B"));
-
-/**
-* Parses a regular expression into a list of characters with character class info.
-* @param {string} regExpText The raw text used to create the regular expression
-* @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.
-* @example
-*
-* parseRegExp('a\\b[cd-]')
-*
-* returns:
-* [
-*   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},
-*   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},
-*   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},
-*   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},
-*   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}
-* ]
-*/
-function parseRegExp(regExpText) {
-    const charList = [];
-
-    regExpText.split("").reduce((state, char, index) => {
-        if (!state.escapeNextChar) {
-            if (char === "\\") {
-                return Object.assign(state, { escapeNextChar: true });
-            }
-            if (char === "[" && !state.inCharClass) {
-                return Object.assign(state, { inCharClass: true, startingCharClass: true });
-            }
-            if (char === "]" && state.inCharClass) {
-                if (charList.length && charList[charList.length - 1].inCharClass) {
-                    charList[charList.length - 1].endsCharClass = true;
-                }
-                return Object.assign(state, { inCharClass: false, startingCharClass: false });
-            }
-        }
-        charList.push({ text: char, index, escaped: state.escapeNextChar, inCharClass: state.inCharClass, startsCharClass: state.startingCharClass, endsCharClass: false });
-        return Object.assign(state, { escapeNextChar: false, startingCharClass: false });
-    }, { escapeNextChar: false, inCharClass: false, startingCharClass: false });
-
-    return charList;
-}
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary escape characters",
-            category: "Best Practices",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Reports a node
-         * @param {ASTNode} node The node to report
-         * @param {number} startOffset The backslash's offset from the start of the node
-         * @param {string} character The uselessly escaped character (not including the backslash)
-         * @returns {void}
-         */
-        function report(node, startOffset, character) {
-            context.report({
-                node,
-                loc: sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset),
-                message: "Unnecessary escape character: \\{{character}}.",
-                data: { character }
-            });
-        }
-
-        /**
-         * Checks if the escape character in given string slice is unnecessary.
-         *
-         * @private
-         * @param {ASTNode} node - node to validate.
-         * @param {string} match - string slice to validate.
-         * @returns {void}
-         */
-        function validateString(node, match) {
-            const isTemplateElement = node.type === "TemplateElement";
-            const escapedChar = match[0][1];
-            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
-            let isQuoteEscape;
-
-            if (isTemplateElement) {
-                isQuoteEscape = escapedChar === "`";
-
-                if (escapedChar === "$") {
-
-                    // Warn if `\$` is not followed by `{`
-                    isUnnecessaryEscape = match.input[match.index + 2] !== "{";
-                } else if (escapedChar === "{") {
-
-                    /* Warn if `\{` is not preceded by `$`. If preceded by `$`, escaping
-                     * is necessary and the rule should not warn. If preceded by `/$`, the rule
-                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.
-                     */
-                    isUnnecessaryEscape = match.input[match.index - 1] !== "$";
-                }
-            } else {
-                isQuoteEscape = escapedChar === node.raw[0];
-            }
-
-            if (isUnnecessaryEscape && !isQuoteEscape) {
-                report(node, match.index + 1, match[0].slice(1));
-            }
-        }
-
-        /**
-         * Checks if a node has an escape.
-         *
-         * @param {ASTNode} node - node to check.
-         * @returns {void}
-         */
-        function check(node) {
-            const isTemplateElement = node.type === "TemplateElement";
-
-            if (
-                isTemplateElement &&
-                node.parent &&
-                node.parent.parent &&
-                node.parent.parent.type === "TaggedTemplateExpression" &&
-                node.parent === node.parent.parent.quasi
-            ) {
-
-                // Don't report tagged template literals, because the backslash character is accessible to the tag function.
-                return;
-            }
-
-            if (typeof node.value === "string" || isTemplateElement) {
-
-                /*
-                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.
-                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.
-                 */
-                if (node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement") {
-                    return;
-                }
-
-                const value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);
-                const pattern = /\\[^\d]/g;
-                let match;
-
-                while ((match = pattern.exec(value))) {
-                    validateString(node, match);
-                }
-            } else if (node.regex) {
-                parseRegExp(node.regex.pattern)
-
-                    /*
-                     * The '-' character is a special case, because it's only valid to escape it if it's in a character
-                     * class, and is not at either edge of the character class. To account for this, don't consider '-'
-                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a
-                     * character class.
-                     */
-                    .filter(charInfo => !(charInfo.text === "-" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))
-
-                    /*
-                     * The '^' character is also a special case; it must always be escaped outside of character classes, but
-                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To
-                     * account for this, consider it to be a valid escape character outside of character classes, and filter
-                     * out '^' characters that appear at the start of a character class.
-                     */
-                    .filter(charInfo => !(charInfo.text === "^" && charInfo.startsCharClass))
-
-                    // Filter out characters that aren't escaped.
-                    .filter(charInfo => charInfo.escaped)
-
-                    // Filter out characters that are valid to escape, based on their position in the regular expression.
-                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))
-
-                    // Report all the remaining characters.
-                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));
-            }
-
-        }
-
-        return {
-            Literal: check,
-            TemplateElement: check
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-useless-rename.js
===================================================================
--- node_modules/eslint/lib/rules/no-useless-rename.js	(revision )
+++ node_modules/eslint/lib/rules/no-useless-rename.js	(revision )
@@ -1,147 +0,0 @@
-/**
- * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.
- * @author Kai Cataldo
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow renaming import, export, and destructured assignments to the same name",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-        fixable: "code",
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    ignoreDestructuring: { type: "boolean" },
-                    ignoreImport: { type: "boolean" },
-                    ignoreExport: { type: "boolean" }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0] || {},
-            ignoreDestructuring = options.ignoreDestructuring === true,
-            ignoreImport = options.ignoreImport === true,
-            ignoreExport = options.ignoreExport === true;
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Reports error for unnecessarily renamed assignments
-         * @param {ASTNode} node - node to report
-         * @param {ASTNode} initial - node with initial name value
-         * @param {ASTNode} result - node with new name value
-         * @param {string} type - the type of the offending node
-         * @returns {void}
-         */
-        function reportError(node, initial, result, type) {
-            const name = initial.type === "Identifier" ? initial.name : initial.value;
-
-            return context.report({
-                node,
-                message: "{{type}} {{name}} unnecessarily renamed.",
-                data: {
-                    name,
-                    type
-                },
-                fix(fixer) {
-                    return fixer.replaceTextRange([
-                        initial.range[0],
-                        result.range[1]
-                    ], name);
-                }
-            });
-        }
-
-        /**
-         * Checks whether a destructured assignment is unnecessarily renamed
-         * @param {ASTNode} node - node to check
-         * @returns {void}
-         */
-        function checkDestructured(node) {
-            if (ignoreDestructuring) {
-                return;
-            }
-
-            const properties = node.properties;
-
-            for (let i = 0; i < properties.length; i++) {
-                if (properties[i].shorthand) {
-                    continue;
-                }
-
-                /**
-                 * If an ObjectPattern property is computed, we have no idea
-                 * if a rename is useless or not. If an ObjectPattern property
-                 * lacks a key, it is likely an ExperimentalRestProperty and
-                 * so there is no "renaming" occurring here.
-                 */
-                if (properties[i].computed || !properties[i].key) {
-                    continue;
-                }
-
-                if (properties[i].key.type === "Identifier" && properties[i].key.name === properties[i].value.name ||
-                        properties[i].key.type === "Literal" && properties[i].key.value === properties[i].value.name) {
-                    reportError(properties[i], properties[i].key, properties[i].value, "Destructuring assignment");
-                }
-            }
-        }
-
-        /**
-         * Checks whether an import is unnecessarily renamed
-         * @param {ASTNode} node - node to check
-         * @returns {void}
-         */
-        function checkImport(node) {
-            if (ignoreImport) {
-                return;
-            }
-
-            if (node.imported.name === node.local.name &&
-                    node.imported.range[0] !== node.local.range[0]) {
-                reportError(node, node.imported, node.local, "Import");
-            }
-        }
-
-        /**
-         * Checks whether an export is unnecessarily renamed
-         * @param {ASTNode} node - node to check
-         * @returns {void}
-         */
-        function checkExport(node) {
-            if (ignoreExport) {
-                return;
-            }
-
-            if (node.local.name === node.exported.name &&
-                    node.local.range[0] !== node.exported.range[0]) {
-                reportError(node, node.local, node.exported, "Export");
-            }
-
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            ObjectPattern: checkDestructured,
-            ImportSpecifier: checkImport,
-            ExportSpecifier: checkExport
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-useless-return.js
===================================================================
--- node_modules/eslint/lib/rules/no-useless-return.js	(revision )
+++ node_modules/eslint/lib/rules/no-useless-return.js	(revision )
@@ -1,298 +0,0 @@
-/**
- * @fileoverview Disallow redundant return statements
- * @author Teddy Katz
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils"),
-    FixTracker = require("../util/fix-tracker");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Adds all elements of 2nd argument into 1st argument.
- *
- * @param {Array} array - The destination array to add.
- * @param {Array} elements - The source array to add.
- * @returns {void}
- */
-const pushAll = Function.apply.bind(Array.prototype.push);
-
-/**
- * Removes the given element from the array.
- *
- * @param {Array} array - The source array to remove.
- * @param {any} element - The target item to remove.
- * @returns {void}
- */
-function remove(array, element) {
-    const index = array.indexOf(element);
-
-    if (index !== -1) {
-        array.splice(index, 1);
-    }
-}
-
-/**
- * Checks whether it can remove the given return statement or not.
- *
- * @param {ASTNode} node - The return statement node to check.
- * @returns {boolean} `true` if the node is removeable.
- */
-function isRemovable(node) {
-    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
-}
-
-/**
- * Checks whether the given return statement is in a `finally` block or not.
- *
- * @param {ASTNode} node - The return statement node to check.
- * @returns {boolean} `true` if the node is in a `finally` block.
- */
-function isInFinally(node) {
-    while (node && node.parent && !astUtils.isFunction(node)) {
-        if (node.parent.type === "TryStatement" && node.parent.finalizer === node) {
-            return true;
-        }
-
-        node = node.parent;
-    }
-
-    return false;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow redundant return statements",
-            category: "Best Practices",
-            recommended: false
-        },
-        fixable: "code",
-        schema: []
-    },
-
-    create(context) {
-        const segmentInfoMap = new WeakMap();
-        const usedUnreachableSegments = new WeakSet();
-        let scopeInfo = null;
-
-        /**
-         * Checks whether the given segment is terminated by a return statement or not.
-         *
-         * @param {CodePathSegment} segment - The segment to check.
-         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.
-         */
-        function isReturned(segment) {
-            const info = segmentInfoMap.get(segment);
-
-            return !info || info.returned;
-        }
-
-        /**
-         * Collects useless return statements from the given previous segments.
-         *
-         * A previous segment may be an unreachable segment.
-         * In that case, the information object of the unreachable segment is not
-         * initialized because `onCodePathSegmentStart` event is not notified for
-         * unreachable segments.
-         * This goes to the previous segments of the unreachable segment recursively
-         * if the unreachable segment was generated by a return statement. Otherwise,
-         * this ignores the unreachable segment.
-         *
-         * This behavior would simulate code paths for the case that the return
-         * statement does not exist.
-         *
-         * @param {ASTNode[]} uselessReturns - The collected return statements.
-         * @param {CodePathSegment[]} prevSegments - The previous segments to traverse.
-         * @param {WeakSet<CodePathSegment>} [traversedSegments] A set of segments that have already been traversed in this call
-         * @returns {ASTNode[]} `uselessReturns`.
-         */
-        function getUselessReturns(uselessReturns, prevSegments, traversedSegments) {
-            if (!traversedSegments) {
-                traversedSegments = new WeakSet();
-            }
-            for (const segment of prevSegments) {
-                if (!segment.reachable) {
-                    if (!traversedSegments.has(segment)) {
-                        traversedSegments.add(segment);
-                        getUselessReturns(
-                            uselessReturns,
-                            segment.allPrevSegments.filter(isReturned),
-                            traversedSegments
-                        );
-                    }
-                    continue;
-                }
-
-                pushAll(uselessReturns, segmentInfoMap.get(segment).uselessReturns);
-            }
-
-            return uselessReturns;
-        }
-
-        /**
-         * Removes the return statements on the given segment from the useless return
-         * statement list.
-         *
-         * This segment may be an unreachable segment.
-         * In that case, the information object of the unreachable segment is not
-         * initialized because `onCodePathSegmentStart` event is not notified for
-         * unreachable segments.
-         * This goes to the previous segments of the unreachable segment recursively
-         * if the unreachable segment was generated by a return statement. Otherwise,
-         * this ignores the unreachable segment.
-         *
-         * This behavior would simulate code paths for the case that the return
-         * statement does not exist.
-         *
-         * @param {CodePathSegment} segment - The segment to get return statements.
-         * @returns {void}
-         */
-        function markReturnStatementsOnSegmentAsUsed(segment) {
-            if (!segment.reachable) {
-                usedUnreachableSegments.add(segment);
-                segment.allPrevSegments
-                    .filter(isReturned)
-                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))
-                    .forEach(markReturnStatementsOnSegmentAsUsed);
-                return;
-            }
-
-            const info = segmentInfoMap.get(segment);
-
-            for (const node of info.uselessReturns) {
-                remove(scopeInfo.uselessReturns, node);
-            }
-            info.uselessReturns = [];
-        }
-
-        /**
-         * Removes the return statements on the current segments from the useless
-         * return statement list.
-         *
-         * This function will be called at every statement except FunctionDeclaration,
-         * BlockStatement, and BreakStatement.
-         *
-         * - FunctionDeclarations are always executed whether it's returned or not.
-         * - BlockStatements do nothing.
-         * - BreakStatements go the next merely.
-         *
-         * @returns {void}
-         */
-        function markReturnStatementsOnCurrentSegmentsAsUsed() {
-            scopeInfo
-                .codePath
-                .currentSegments
-                .forEach(markReturnStatementsOnSegmentAsUsed);
-        }
-
-        //----------------------------------------------------------------------
-        // Public
-        //----------------------------------------------------------------------
-
-        return {
-
-            // Makes and pushs a new scope information.
-            onCodePathStart(codePath) {
-                scopeInfo = {
-                    upper: scopeInfo,
-                    uselessReturns: [],
-                    codePath
-                };
-            },
-
-            // Reports useless return statements if exist.
-            onCodePathEnd() {
-                for (const node of scopeInfo.uselessReturns) {
-                    context.report({
-                        node,
-                        loc: node.loc,
-                        message: "Unnecessary return statement.",
-                        fix(fixer) {
-                            if (isRemovable(node)) {
-
-                                // Extend the replacement range to include the
-                                // entire function to avoid conflicting with
-                                // no-else-return.
-                                // https://github.com/eslint/eslint/issues/8026
-                                return new FixTracker(fixer, context.getSourceCode())
-                                    .retainEnclosingFunction(node)
-                                    .remove(node);
-                            }
-                            return null;
-                        }
-                    });
-                }
-
-                scopeInfo = scopeInfo.upper;
-            },
-
-            // Initializes segments.
-            // NOTE: This event is notified for only reachable segments.
-            onCodePathSegmentStart(segment) {
-                const info = {
-                    uselessReturns: getUselessReturns([], segment.allPrevSegments),
-                    returned: false
-                };
-
-                // Stores the info.
-                segmentInfoMap.set(segment, info);
-            },
-
-            // Adds ReturnStatement node to check whether it's useless or not.
-            ReturnStatement(node) {
-                if (node.argument) {
-                    markReturnStatementsOnCurrentSegmentsAsUsed();
-                }
-                if (node.argument || astUtils.isInLoop(node) || isInFinally(node)) {
-                    return;
-                }
-
-                for (const segment of scopeInfo.codePath.currentSegments) {
-                    const info = segmentInfoMap.get(segment);
-
-                    if (info) {
-                        info.uselessReturns.push(node);
-                        info.returned = true;
-                    }
-                }
-                scopeInfo.uselessReturns.push(node);
-            },
-
-            // Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.
-            // Removes return statements of the current segments from the useless return statement list.
-            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
-            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
-            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
-            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
-            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
-            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
-            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/func-name-matching.js
===================================================================
--- node_modules/eslint/lib/rules/func-name-matching.js	(revision )
+++ node_modules/eslint/lib/rules/func-name-matching.js	(revision )
@@ -1,193 +0,0 @@
-/**
- * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.
- * @author Annie Zhang, Pavel Strashkin
- */
-
-"use strict";
-
-//--------------------------------------------------------------------------
-// Requirements
-//--------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-const esutils = require("esutils");
-
-//--------------------------------------------------------------------------
-// Helpers
-//--------------------------------------------------------------------------
-
-/**
- * Determines if a pattern is `module.exports` or `module["exports"]`
- * @param {ASTNode} pattern The left side of the AssignmentExpression
- * @returns {boolean} True if the pattern is `module.exports` or `module["exports"]`
- */
-function isModuleExports(pattern) {
-    if (pattern.type === "MemberExpression" && pattern.object.type === "Identifier" && pattern.object.name === "module") {
-
-        // module.exports
-        if (pattern.property.type === "Identifier" && pattern.property.name === "exports") {
-            return true;
-        }
-
-        // module["exports"]
-        if (pattern.property.type === "Literal" && pattern.property.value === "exports") {
-            return true;
-        }
-    }
-    return false;
-}
-
-/**
- * Determines if a string name is a valid identifier
- * @param {string} name The string to be checked
- * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config
- * @returns {boolean} True if the string is a valid identifier
- */
-function isIdentifier(name, ecmaVersion) {
-    if (ecmaVersion >= 6) {
-        return esutils.keyword.isIdentifierES6(name);
-    }
-    return esutils.keyword.isIdentifierES5(name);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const alwaysOrNever = { enum: ["always", "never"] };
-const optionsObject = {
-    type: "object",
-    properties: {
-        includeCommonJSModuleExports: {
-            type: "boolean"
-        }
-    },
-    additionalProperties: false
-};
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require function names to match the name of the variable or property to which they are assigned",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: {
-            anyOf: [{
-                type: "array",
-                additionalItems: false,
-                items: [alwaysOrNever, optionsObject]
-            }, {
-                type: "array",
-                additionalItems: false,
-                items: [optionsObject]
-            }]
-        }
-    },
-
-    create(context) {
-        const options = (typeof context.options[0] === "object" ? context.options[0] : context.options[1]) || {};
-        const nameMatches = typeof context.options[0] === "string" ? context.options[0] : "always";
-        const includeModuleExports = options.includeCommonJSModuleExports;
-        const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;
-
-        /**
-         * Compares identifiers based on the nameMatches option
-         * @param {string} x the first identifier
-         * @param {string} y the second identifier
-         * @returns {boolean} whether the two identifiers should warn.
-         */
-        function shouldWarn(x, y) {
-            return (nameMatches === "always" && x !== y) || (nameMatches === "never" && x === y);
-        }
-
-        /**
-         * Reports
-         * @param {ASTNode} node The node to report
-         * @param {string} name The variable or property name
-         * @param {string} funcName The function name
-         * @param {boolean} isProp True if the reported node is a property assignment
-         * @returns {void}
-         */
-        function report(node, name, funcName, isProp) {
-            let message;
-
-            if (nameMatches === "always" && isProp) {
-                message = "Function name `{{funcName}}` should match property name `{{name}}`";
-            } else if (nameMatches === "always") {
-                message = "Function name `{{funcName}}` should match variable name `{{name}}`";
-            } else if (isProp) {
-                message = "Function name `{{funcName}}` should not match property name `{{name}}`";
-            } else {
-                message = "Function name `{{funcName}}` should not match variable name `{{name}}`";
-            }
-            context.report({
-                node,
-                message,
-                data: {
-                    name,
-                    funcName
-                }
-            });
-        }
-
-        /**
-         * Determines whether a given node is a string literal
-         * @param {ASTNode} node The node to check
-         * @returns {boolean} `true` if the node is a string literal
-         */
-        function isStringLiteral(node) {
-            return node.type === "Literal" && typeof node.value === "string";
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-
-            VariableDeclarator(node) {
-                if (!node.init || node.init.type !== "FunctionExpression" || node.id.type !== "Identifier") {
-                    return;
-                }
-                if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {
-                    report(node, node.id.name, node.init.id.name, false);
-                }
-            },
-
-            AssignmentExpression(node) {
-                if (
-                    node.right.type !== "FunctionExpression" ||
-                    (node.left.computed && node.left.property.type !== "Literal") ||
-                    (!includeModuleExports && isModuleExports(node.left)) ||
-                    (node.left.type !== "Identifier" && node.left.type !== "MemberExpression")
-                ) {
-                    return;
-                }
-
-                const isProp = node.left.type === "MemberExpression";
-                const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;
-
-                if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {
-                    report(node, name, node.right.id.name, isProp);
-                }
-            },
-
-            Property(node) {
-                if (node.value.type !== "FunctionExpression" || !node.value.id || node.computed && !isStringLiteral(node.key)) {
-                    return;
-                }
-                if (node.key.type === "Identifier" && shouldWarn(node.key.name, node.value.id.name)) {
-                    report(node, node.key.name, node.value.id.name, true);
-                } else if (
-                    isStringLiteral(node.key) &&
-                    isIdentifier(node.key.value, ecmaVersion) &&
-                    shouldWarn(node.key.value, node.value.id.name)
-                ) {
-                    report(node, node.key.value, node.value.id.name, true);
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-confusing-arrow.js
===================================================================
--- node_modules/eslint/lib/rules/no-confusing-arrow.js	(revision )
+++ node_modules/eslint/lib/rules/no-confusing-arrow.js	(revision )
@@ -1,76 +0,0 @@
-/**
- * @fileoverview A rule to warn against using arrow functions when they could be
- * confused with comparisions
- * @author Jxck <https://github.com/Jxck>
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils.js");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a node is a conditional expression.
- * @param {ASTNode} node - node to test
- * @returns {boolean} `true` if the node is a conditional expression.
- */
-function isConditional(node) {
-    return node && node.type === "ConditionalExpression";
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow arrow functions where they could be confused with comparisons",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        fixable: "code",
-
-        schema: [{
-            type: "object",
-            properties: {
-                allowParens: { type: "boolean" }
-            },
-            additionalProperties: false
-        }]
-    },
-
-    create(context) {
-        const config = context.options[0] || {};
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Reports if an arrow function contains an ambiguous conditional.
-         * @param {ASTNode} node - A node to check and report.
-         * @returns {void}
-         */
-        function checkArrowFunc(node) {
-            const body = node.body;
-
-            if (isConditional(body) && !(config.allowParens && astUtils.isParenthesised(sourceCode, body))) {
-                context.report({
-                    node,
-                    message: "Arrow function used ambiguously with a conditional expression.",
-                    fix(fixer) {
-
-                        // if `allowParens` is not set to true dont bother wrapping in parens
-                        return config.allowParens && fixer.replaceText(node.body, `(${sourceCode.getText(node.body)})`);
-                    }
-                });
-            }
-        }
-
-        return {
-            ArrowFunctionExpression: checkArrowFunc
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-inline-comments.js
===================================================================
--- node_modules/eslint/lib/rules/no-inline-comments.js	(revision )
+++ node_modules/eslint/lib/rules/no-inline-comments.js	(revision )
@@ -1,65 +0,0 @@
-/**
- * @fileoverview Enforces or disallows inline comments.
- * @author Greg Cochard
- */
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow inline comments after code",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Will check that comments are not on lines starting with or ending with code
-         * @param {ASTNode} node The comment node to check
-         * @private
-         * @returns {void}
-         */
-        function testCodeAroundComment(node) {
-
-            // Get the whole line and cut it off at the start of the comment
-            const startLine = String(sourceCode.lines[node.loc.start.line - 1]);
-            const endLine = String(sourceCode.lines[node.loc.end.line - 1]);
-
-            const preamble = startLine.slice(0, node.loc.start.column).trim();
-
-            // Also check after the comment
-            const postamble = endLine.slice(node.loc.end.column).trim();
-
-            // Check that this comment isn't an ESLint directive
-            const isDirective = astUtils.isDirectiveComment(node);
-
-            // Should be empty if there was only whitespace around the comment
-            if (!isDirective && (preamble || postamble)) {
-                context.report({ node, message: "Unexpected comment inline with code." });
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            Program() {
-                const comments = sourceCode.getAllComments();
-
-                comments.filter(token => token.type !== "Shebang").forEach(testCodeAroundComment);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-mixed-operators.js
===================================================================
--- node_modules/eslint/lib/rules/no-mixed-operators.js	(revision )
+++ node_modules/eslint/lib/rules/no-mixed-operators.js	(revision )
@@ -1,209 +0,0 @@
-/**
- * @fileoverview Rule to disallow mixed binary operators.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils.js");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const ARITHMETIC_OPERATORS = ["+", "-", "*", "/", "%", "**"];
-const BITWISE_OPERATORS = ["&", "|", "^", "~", "<<", ">>", ">>>"];
-const COMPARISON_OPERATORS = ["==", "!=", "===", "!==", ">", ">=", "<", "<="];
-const LOGICAL_OPERATORS = ["&&", "||"];
-const RELATIONAL_OPERATORS = ["in", "instanceof"];
-const ALL_OPERATORS = [].concat(
-    ARITHMETIC_OPERATORS,
-    BITWISE_OPERATORS,
-    COMPARISON_OPERATORS,
-    LOGICAL_OPERATORS,
-    RELATIONAL_OPERATORS
-);
-const DEFAULT_GROUPS = [
-    ARITHMETIC_OPERATORS,
-    BITWISE_OPERATORS,
-    COMPARISON_OPERATORS,
-    LOGICAL_OPERATORS,
-    RELATIONAL_OPERATORS
-];
-const TARGET_NODE_TYPE = /^(?:Binary|Logical)Expression$/;
-
-/**
- * Normalizes options.
- *
- * @param {Object|undefined} options - A options object to normalize.
- * @returns {Object} Normalized option object.
- */
-function normalizeOptions(options) {
-    const hasGroups = (options && options.groups && options.groups.length > 0);
-    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;
-    const allowSamePrecedence = (options && options.allowSamePrecedence) !== false;
-
-    return {
-        groups,
-        allowSamePrecedence
-    };
-}
-
-/**
- * Checks whether any group which includes both given operator exists or not.
- *
- * @param {Array.<string[]>} groups - A list of groups to check.
- * @param {string} left - An operator.
- * @param {string} right - Another operator.
- * @returns {boolean} `true` if such group existed.
- */
-function includesBothInAGroup(groups, left, right) {
-    return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow mixed binary operators",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    groups: {
-                        type: "array",
-                        items: {
-                            type: "array",
-                            items: { enum: ALL_OPERATORS },
-                            minItems: 2,
-                            uniqueItems: true
-                        },
-                        uniqueItems: true
-                    },
-                    allowSamePrecedence: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const options = normalizeOptions(context.options[0]);
-
-        /**
-         * Checks whether a given node should be ignored by options or not.
-         *
-         * @param {ASTNode} node - A node to check. This is a BinaryExpression
-         *      node or a LogicalExpression node. This parent node is one of
-         *      them, too.
-         * @returns {boolean} `true` if the node should be ignored.
-         */
-        function shouldIgnore(node) {
-            const a = node;
-            const b = node.parent;
-
-            return (
-                !includesBothInAGroup(options.groups, a.operator, b.operator) ||
-                (
-                    options.allowSamePrecedence &&
-                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)
-                )
-            );
-        }
-
-        /**
-         * Checks whether the operator of a given node is mixed with parent
-         * node's operator or not.
-         *
-         * @param {ASTNode} node - A node to check. This is a BinaryExpression
-         *      node or a LogicalExpression node. This parent node is one of
-         *      them, too.
-         * @returns {boolean} `true` if the node was mixed.
-         */
-        function isMixedWithParent(node) {
-            return (
-                node.operator !== node.parent.operator &&
-                !astUtils.isParenthesised(sourceCode, node)
-            );
-        }
-
-        /**
-         * Gets the operator token of a given node.
-         *
-         * @param {ASTNode} node - A node to check. This is a BinaryExpression
-         *      node or a LogicalExpression node.
-         * @returns {Token} The operator token of the node.
-         */
-        function getOperatorToken(node) {
-            return sourceCode.getTokenAfter(node.left, astUtils.isNotClosingParenToken);
-        }
-
-        /**
-         * Reports both the operator of a given node and the operator of the
-         * parent node.
-         *
-         * @param {ASTNode} node - A node to check. This is a BinaryExpression
-         *      node or a LogicalExpression node. This parent node is one of
-         *      them, too.
-         * @returns {void}
-         */
-        function reportBothOperators(node) {
-            const parent = node.parent;
-            const left = (parent.left === node) ? node : parent;
-            const right = (parent.left !== node) ? node : parent;
-            const message =
-                "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.";
-            const data = {
-                leftOperator: left.operator,
-                rightOperator: right.operator
-            };
-
-            context.report({
-                node: left,
-                loc: getOperatorToken(left).loc.start,
-                message,
-                data
-            });
-            context.report({
-                node: right,
-                loc: getOperatorToken(right).loc.start,
-                message,
-                data
-            });
-        }
-
-        /**
-         * Checks between the operator of this node and the operator of the
-         * parent node.
-         *
-         * @param {ASTNode} node - A node to check.
-         * @returns {void}
-         */
-        function check(node) {
-            if (TARGET_NODE_TYPE.test(node.parent.type) &&
-                isMixedWithParent(node) &&
-                !shouldIgnore(node)
-            ) {
-                reportBothOperators(node);
-            }
-        }
-
-        return {
-            BinaryExpression: check,
-            LogicalExpression: check
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-native-reassign.js
===================================================================
--- node_modules/eslint/lib/rules/no-native-reassign.js	(revision )
+++ node_modules/eslint/lib/rules/no-native-reassign.js	(revision )
@@ -1,87 +0,0 @@
-/**
- * @fileoverview Rule to disallow assignments to native objects or read-only global variables
- * @author Ilya Volodin
- * @deprecated in ESLint v3.3.0
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow assignments to native objects or read-only global variables",
-            category: "Best Practices",
-            recommended: false,
-            replacedBy: ["no-global-assign"]
-        },
-
-        deprecated: true,
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    exceptions: {
-                        type: "array",
-                        items: { type: "string" },
-                        uniqueItems: true
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const config = context.options[0];
-        const exceptions = (config && config.exceptions) || [];
-
-        /**
-         * Reports write references.
-         * @param {Reference} reference - A reference to check.
-         * @param {int} index - The index of the reference in the references.
-         * @param {Reference[]} references - The array that the reference belongs to.
-         * @returns {void}
-         */
-        function checkReference(reference, index, references) {
-            const identifier = reference.identifier;
-
-            if (reference.init === false &&
-                reference.isWrite() &&
-
-                // Destructuring assignments can have multiple default value,
-                // so possibly there are multiple writeable references for the same identifier.
-                (index === 0 || references[index - 1].identifier !== identifier)
-            ) {
-                context.report({
-                    node: identifier,
-                    message: "Read-only global '{{name}}' should not be modified.",
-                    data: identifier
-                });
-            }
-        }
-
-        /**
-         * Reports write references if a given variable is read-only builtin.
-         * @param {Variable} variable - A variable to check.
-         * @returns {void}
-         */
-        function checkVariable(variable) {
-            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
-                variable.references.forEach(checkReference);
-            }
-        }
-
-        return {
-            Program() {
-                const globalScope = context.getScope();
-
-                globalScope.variables.forEach(checkVariable);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-trailing-spaces.js
===================================================================
--- node_modules/eslint/lib/rules/no-trailing-spaces.js	(revision )
+++ node_modules/eslint/lib/rules/no-trailing-spaces.js	(revision )
@@ -1,163 +0,0 @@
-/**
- * @fileoverview Disallow trailing spaces at the end of lines.
- * @author Nodeca Team <https://github.com/nodeca>
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow trailing whitespace at the end of lines",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    skipBlankLines: {
-                        type: "boolean"
-                    },
-                    ignoreComments: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        const BLANK_CLASS = "[ \t\u00a0\u2000-\u200b\u3000]",
-            SKIP_BLANK = `^${BLANK_CLASS}*$`,
-            NONBLANK = `${BLANK_CLASS}+$`;
-
-        const options = context.options[0] || {},
-            skipBlankLines = options.skipBlankLines || false,
-            ignoreComments = typeof options.ignoreComments === "undefined" || options.ignoreComments;
-
-        /**
-         * Report the error message
-         * @param {ASTNode} node node to report
-         * @param {int[]} location range information
-         * @param {int[]} fixRange Range based on the whole program
-         * @returns {void}
-         */
-        function report(node, location, fixRange) {
-
-            /*
-             * Passing node is a bit dirty, because message data will contain big
-             * text in `source`. But... who cares :) ?
-             * One more kludge will not make worse the bloody wizardry of this
-             * plugin.
-             */
-            context.report({
-                node,
-                loc: location,
-                message: "Trailing spaces not allowed.",
-                fix(fixer) {
-                    return fixer.removeRange(fixRange);
-                }
-            });
-        }
-
-        /**
-         * Given a list of comment nodes, return the line numbers for those comments.
-         * @param {Array} comments An array of comment nodes.
-         * @returns {number[]} An array of line numbers containing comments.
-         */
-        function getCommentLineNumbers(comments) {
-            const lines = new Set();
-
-            comments.forEach(comment => {
-                for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
-                    lines.add(i);
-                }
-            });
-
-            return lines;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-
-            Program: function checkTrailingSpaces(node) {
-
-                // Let's hack. Since Espree does not return whitespace nodes,
-                // fetch the source code and do matching via regexps.
-
-                const re = new RegExp(NONBLANK),
-                    skipMatch = new RegExp(SKIP_BLANK),
-                    lines = sourceCode.lines,
-                    linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),
-                    comments = sourceCode.getAllComments(),
-                    commentLineNumbers = getCommentLineNumbers(comments);
-
-                let totalLength = 0,
-                    fixRange = [];
-
-                for (let i = 0, ii = lines.length; i < ii; i++) {
-                    const matches = re.exec(lines[i]);
-
-                    // Always add linebreak length to line length to accommodate for line break (\n or \r\n)
-                    // Because during the fix time they also reserve one spot in the array.
-                    // Usually linebreak length is 2 for \r\n (CRLF) and 1 for \n (LF)
-                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
-                    const lineLength = lines[i].length + linebreakLength;
-
-                    if (matches) {
-                        const location = {
-                            line: i + 1,
-                            column: matches.index
-                        };
-
-                        const rangeStart = totalLength + location.column;
-                        const rangeEnd = totalLength + lineLength - linebreakLength;
-                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);
-
-                        if (containingNode && containingNode.type === "TemplateElement" &&
-                          rangeStart > containingNode.parent.range[0] &&
-                          rangeEnd < containingNode.parent.range[1]) {
-                            totalLength += lineLength;
-                            continue;
-                        }
-
-                        // If the line has only whitespace, and skipBlankLines
-                        // is true, don't report it
-                        if (skipBlankLines && skipMatch.test(lines[i])) {
-                            totalLength += lineLength;
-                            continue;
-                        }
-
-                        fixRange = [rangeStart, rangeEnd];
-
-                        if (!ignoreComments || !commentLineNumbers.has(location.line)) {
-                            report(node, location, fixRange);
-                        }
-                    }
-
-                    totalLength += lineLength;
-                }
-            }
-
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-unsafe-negation.js
===================================================================
--- node_modules/eslint/lib/rules/no-unsafe-negation.js	(revision )
+++ node_modules/eslint/lib/rules/no-unsafe-negation.js	(revision )
@@ -1,80 +0,0 @@
-/**
- * @fileoverview Rule to disallow negating the left operand of relational operators
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether the given operator is a relational operator or not.
- *
- * @param {string} op - The operator type to check.
- * @returns {boolean} `true` if the operator is a relational operator.
- */
-function isRelationalOperator(op) {
-    return op === "in" || op === "instanceof";
-}
-
-/**
- * Checks whether the given node is a logical negation expression or not.
- *
- * @param {ASTNode} node - The node to check.
- * @returns {boolean} `true` if the node is a logical negation expression.
- */
-function isNegation(node) {
-    return node.type === "UnaryExpression" && node.operator === "!";
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow negating the left operand of relational operators",
-            category: "Possible Errors",
-            recommended: true
-        },
-        schema: [],
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-            BinaryExpression(node) {
-                if (isRelationalOperator(node.operator) &&
-                    isNegation(node.left) &&
-                    !astUtils.isParenthesised(sourceCode, node.left)
-                ) {
-                    context.report({
-                        node,
-                        loc: node.left.loc,
-                        message: "Unexpected negating the left operand of '{{operator}}' operator.",
-                        data: node,
-
-                        fix(fixer) {
-                            const negationToken = sourceCode.getFirstToken(node.left);
-                            const fixRange = [negationToken.range[1], node.range[1]];
-                            const text = sourceCode.text.slice(fixRange[0], fixRange[1]);
-
-                            return fixer.replaceTextRange(fixRange, `(${text})`);
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/operator-linebreak.js
===================================================================
--- node_modules/eslint/lib/rules/operator-linebreak.js	(revision )
+++ node_modules/eslint/lib/rules/operator-linebreak.js	(revision )
@@ -1,248 +0,0 @@
-/**
- * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before
- * @author Benoît Zugmeyer
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent linebreak style for operators",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["after", "before", "none", null]
-            },
-            {
-                type: "object",
-                properties: {
-                    overrides: {
-                        type: "object",
-                        properties: {
-                            anyOf: {
-                                type: "string",
-                                enum: ["after", "before", "none", "ignore"]
-                            }
-                        }
-                    }
-                },
-                additionalProperties: false
-            }
-        ],
-
-        fixable: "code"
-    },
-
-    create(context) {
-
-        const usedDefaultGlobal = !context.options[0];
-        const globalStyle = context.options[0] || "after";
-        const options = context.options[1] || {};
-        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};
-
-        if (usedDefaultGlobal && !styleOverrides["?"]) {
-            styleOverrides["?"] = "before";
-        }
-
-        if (usedDefaultGlobal && !styleOverrides[":"]) {
-            styleOverrides[":"] = "before";
-        }
-
-        const sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-        * Gets a fixer function to fix rule issues
-        * @param {Token} operatorToken The operator token of an expression
-        * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'
-        * @returns {Function} A fixer function
-        */
-        function getFixer(operatorToken, desiredStyle) {
-            return fixer => {
-                const tokenBefore = sourceCode.getTokenBefore(operatorToken);
-                const tokenAfter = sourceCode.getTokenAfter(operatorToken);
-                const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);
-                const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);
-                const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);
-                const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);
-                let newTextBefore, newTextAfter;
-
-                if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== "none") {
-
-                    // If there is a comment before and after the operator, don't do a fix.
-                    if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {
-                        return null;
-                    }
-
-                    /*
-                     * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.
-                     * foo &&
-                     *           bar
-                     * would get fixed to
-                     * foo
-                     *        && bar
-                     */
-                    newTextBefore = textAfter;
-                    newTextAfter = textBefore;
-                } else {
-                    const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();
-
-                    // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.
-                    newTextBefore = desiredStyle === "before" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, "");
-                    newTextAfter = desiredStyle === "after" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, "");
-
-                    // If there was no change (due to interfering comments), don't output a fix.
-                    if (newTextBefore === textBefore && newTextAfter === textAfter) {
-                        return null;
-                    }
-                }
-
-                if (newTextAfter === "" && tokenAfter.type === "Punctuator" && "+-".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {
-
-                    // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.
-                    newTextAfter += " ";
-                }
-
-                return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);
-            };
-        }
-
-        /**
-         * Checks the operator placement
-         * @param {ASTNode} node The node to check
-         * @param {ASTNode} leftSide The node that comes before the operator in `node`
-         * @private
-         * @returns {void}
-         */
-        function validateNode(node, leftSide) {
-
-            // When the left part of a binary expression is a single expression wrapped in
-            // parentheses (ex: `(a) + b`), leftToken will be the last token of the expression
-            // and operatorToken will be the closing parenthesis.
-            // The leftToken should be the last closing parenthesis, and the operatorToken
-            // should be the token right after that.
-            const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);
-            const leftToken = sourceCode.getTokenBefore(operatorToken);
-            const rightToken = sourceCode.getTokenAfter(operatorToken);
-            const operator = operatorToken.value;
-            const operatorStyleOverride = styleOverrides[operator];
-            const style = operatorStyleOverride || globalStyle;
-            const fix = getFixer(operatorToken, style);
-
-            // if single line
-            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
-                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
-
-                // do nothing.
-
-            } else if (operatorStyleOverride !== "ignore" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
-                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
-
-                // lone operator
-                context.report({
-                    node,
-                    loc: {
-                        line: operatorToken.loc.end.line,
-                        column: operatorToken.loc.end.column
-                    },
-                    message: "Bad line breaking before and after '{{operator}}'.",
-                    data: {
-                        operator
-                    },
-                    fix
-                });
-
-            } else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {
-
-                context.report({
-                    node,
-                    loc: {
-                        line: operatorToken.loc.end.line,
-                        column: operatorToken.loc.end.column
-                    },
-                    message: "'{{operator}}' should be placed at the beginning of the line.",
-                    data: {
-                        operator
-                    },
-                    fix
-                });
-
-            } else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
-
-                context.report({
-                    node,
-                    loc: {
-                        line: operatorToken.loc.end.line,
-                        column: operatorToken.loc.end.column
-                    },
-                    message: "'{{operator}}' should be placed at the end of the line.",
-                    data: {
-                        operator
-                    },
-                    fix
-                });
-
-            } else if (style === "none") {
-
-                context.report({
-                    node,
-                    loc: {
-                        line: operatorToken.loc.end.line,
-                        column: operatorToken.loc.end.column
-                    },
-                    message: "There should be no line break before or after '{{operator}}'.",
-                    data: {
-                        operator
-                    },
-                    fix
-                });
-
-            }
-        }
-
-        /**
-         * Validates a binary expression using `validateNode`
-         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated
-         * @returns {void}
-         */
-        function validateBinaryExpression(node) {
-            validateNode(node, node.left);
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            BinaryExpression: validateBinaryExpression,
-            LogicalExpression: validateBinaryExpression,
-            AssignmentExpression: validateBinaryExpression,
-            VariableDeclarator(node) {
-                if (node.init) {
-                    validateNode(node, node.id);
-                }
-            },
-            ConditionalExpression(node) {
-                validateNode(node, node.test);
-                validateNode(node, node.consequent);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/prefer-rest-params.js
===================================================================
--- node_modules/eslint/lib/rules/prefer-rest-params.js	(revision )
+++ node_modules/eslint/lib/rules/prefer-rest-params.js	(revision )
@@ -1,109 +0,0 @@
-/**
- * @fileoverview Rule to
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Gets the variable object of `arguments` which is defined implicitly.
- * @param {eslint-scope.Scope} scope - A scope to get.
- * @returns {eslint-scope.Variable} The found variable object.
- */
-function getVariableOfArguments(scope) {
-    const variables = scope.variables;
-
-    for (let i = 0; i < variables.length; ++i) {
-        const variable = variables[i];
-
-        if (variable.name === "arguments") {
-
-            // If there was a parameter which is named "arguments", the implicit "arguments" is not defined.
-            // So does fast return with null.
-            return (variable.identifiers.length === 0) ? variable : null;
-        }
-    }
-
-    /* istanbul ignore next : unreachable */
-    return null;
-}
-
-/**
- * Checks if the given reference is not normal member access.
- *
- * - arguments         .... true    // not member access
- * - arguments[i]      .... true    // computed member access
- * - arguments[0]      .... true    // computed member access
- * - arguments.length  .... false   // normal member access
- *
- * @param {eslint-scope.Reference} reference - The reference to check.
- * @returns {boolean} `true` if the reference is not normal member access.
- */
-function isNotNormalMemberAccess(reference) {
-    const id = reference.identifier;
-    const parent = id.parent;
-
-    return !(
-        parent.type === "MemberExpression" &&
-        parent.object === id &&
-        !parent.computed
-    );
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require rest parameters instead of `arguments`",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Reports a given reference.
-         *
-         * @param {eslint-scope.Reference} reference - A reference to report.
-         * @returns {void}
-         */
-        function report(reference) {
-            context.report({
-                node: reference.identifier,
-                loc: reference.identifier.loc,
-                message: "Use the rest parameters instead of 'arguments'."
-            });
-        }
-
-        /**
-         * Reports references of the implicit `arguments` variable if exist.
-         *
-         * @returns {void}
-         */
-        function checkForArguments() {
-            const argumentsVar = getVariableOfArguments(context.getScope());
-
-            if (argumentsVar) {
-                argumentsVar
-                    .references
-                    .filter(isNotNormalMemberAccess)
-                    .forEach(report);
-            }
-        }
-
-        return {
-            "FunctionDeclaration:exit": checkForArguments,
-            "FunctionExpression:exit": checkForArguments
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/symbol-description.js
===================================================================
--- node_modules/eslint/lib/rules/symbol-description.js	(revision )
+++ node_modules/eslint/lib/rules/symbol-description.js	(revision )
@@ -1,66 +0,0 @@
-/**
- * @fileoverview Rule to enforce description with the `Symbol` object
- * @author Jarek Rencz
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require symbol descriptions",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Reports if node does not conform the rule in case rule is set to
-         * report missing description
-         *
-         * @param {ASTNode} node - A CallExpression node to check.
-         * @returns {void}
-         */
-        function checkArgument(node) {
-            if (node.arguments.length === 0) {
-                context.report({
-                    node,
-                    message: "Expected Symbol to have a description."
-                });
-            }
-        }
-
-        return {
-            "Program:exit"() {
-                const scope = context.getScope();
-                const variable = astUtils.getVariableByName(scope, "Symbol");
-
-                if (variable && variable.defs.length === 0) {
-                    variable.references.forEach(reference => {
-                        const node = reference.identifier;
-
-                        if (astUtils.isCallee(node)) {
-                            checkArgument(node.parent);
-                        }
-                    });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/yield-star-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/yield-star-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/yield-star-spacing.js	(revision )
@@ -1,117 +0,0 @@
-/**
- * @fileoverview Rule to check the spacing around the * in yield* expressions.
- * @author Bryan Smith
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow spacing around the `*` in `yield*` expressions",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["before", "after", "both", "neither"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            before: { type: "boolean" },
-                            after: { type: "boolean" }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        const mode = (function(option) {
-            if (!option || typeof option === "string") {
-                return {
-                    before: { before: true, after: false },
-                    after: { before: false, after: true },
-                    both: { before: true, after: true },
-                    neither: { before: false, after: false }
-                }[option || "after"];
-            }
-            return option;
-        }(context.options[0]));
-
-        /**
-         * Checks the spacing between two tokens before or after the star token.
-         * @param {string} side Either "before" or "after".
-         * @param {Token} leftToken `function` keyword token if side is "before", or
-         *     star token if side is "after".
-         * @param {Token} rightToken Star token if side is "before", or identifier
-         *     token if side is "after".
-         * @returns {void}
-         */
-        function checkSpacing(side, leftToken, rightToken) {
-            if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {
-                const after = leftToken.value === "*";
-                const spaceRequired = mode[side];
-                const node = after ? leftToken : rightToken;
-                const type = spaceRequired ? "Missing" : "Unexpected";
-                const message = "{{type}} space {{side}} *.";
-
-                context.report({
-                    node,
-                    message,
-                    data: {
-                        type,
-                        side
-                    },
-                    fix(fixer) {
-                        if (spaceRequired) {
-                            if (after) {
-                                return fixer.insertTextAfter(node, " ");
-                            }
-                            return fixer.insertTextBefore(node, " ");
-                        }
-                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
-                    }
-                });
-            }
-        }
-
-        /**
-         * Enforces the spacing around the star if node is a yield* expression.
-         * @param {ASTNode} node A yield expression node.
-         * @returns {void}
-         */
-        function checkExpression(node) {
-            if (!node.delegate) {
-                return;
-            }
-
-            const tokens = sourceCode.getFirstTokens(node, 3);
-            const yieldToken = tokens[0];
-            const starToken = tokens[1];
-            const nextToken = tokens[2];
-
-            checkSpacing("before", yieldToken, starToken);
-            checkSpacing("after", starToken, nextToken);
-        }
-
-        return {
-            YieldExpression: checkExpression
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/handle-callback-err.js
===================================================================
--- node_modules/eslint/lib/rules/handle-callback-err.js	(revision )
+++ node_modules/eslint/lib/rules/handle-callback-err.js	(revision )
@@ -1,89 +0,0 @@
-/**
- * @fileoverview Ensure handling of errors when we know they exist.
- * @author Jamund Ferguson
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require error handling in callbacks",
-            category: "Node.js and CommonJS",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "string"
-            }
-        ]
-    },
-
-    create(context) {
-
-        const errorArgument = context.options[0] || "err";
-
-        /**
-         * Checks if the given argument should be interpreted as a regexp pattern.
-         * @param {string} stringToCheck The string which should be checked.
-         * @returns {boolean} Whether or not the string should be interpreted as a pattern.
-         */
-        function isPattern(stringToCheck) {
-            const firstChar = stringToCheck[0];
-
-            return firstChar === "^";
-        }
-
-        /**
-         * Checks if the given name matches the configured error argument.
-         * @param {string} name The name which should be compared.
-         * @returns {boolean} Whether or not the given name matches the configured error variable name.
-         */
-        function matchesConfiguredErrorName(name) {
-            if (isPattern(errorArgument)) {
-                const regexp = new RegExp(errorArgument);
-
-                return regexp.test(name);
-            }
-            return name === errorArgument;
-        }
-
-        /**
-         * Get the parameters of a given function scope.
-         * @param {Object} scope The function scope.
-         * @returns {array} All parameters of the given scope.
-         */
-        function getParameters(scope) {
-            return scope.variables.filter(variable => variable.defs[0] && variable.defs[0].type === "Parameter");
-        }
-
-        /**
-         * Check to see if we're handling the error object properly.
-         * @param {ASTNode} node The AST node to check.
-         * @returns {void}
-         */
-        function checkForError(node) {
-            const scope = context.getScope(),
-                parameters = getParameters(scope),
-                firstParameter = parameters[0];
-
-            if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
-                if (firstParameter.references.length === 0) {
-                    context.report({ node, message: "Expected error to be handled." });
-                }
-            }
-        }
-
-        return {
-            FunctionDeclaration: checkForError,
-            FunctionExpression: checkForError,
-            ArrowFunctionExpression: checkForError
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-compare-neg-zero.js
===================================================================
--- node_modules/eslint/lib/rules/no-compare-neg-zero.js	(revision )
+++ node_modules/eslint/lib/rules/no-compare-neg-zero.js	(revision )
@@ -1,53 +0,0 @@
-/**
- * @fileoverview The rule should warn against code that tries to compare against -0.
- * @author Aladdin-ADD <hh_2013@foxmail.com>
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow comparing against -0",
-            category: "Possible Errors",
-            recommended: true
-        },
-        fixable: null,
-        schema: []
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Checks a given node is -0
-         *
-         * @param {ASTNode} node - A node to check.
-         * @returns {boolean} `true` if the node is -0.
-         */
-        function isNegZero(node) {
-            return node.type === "UnaryExpression" && node.operator === "-" && node.argument.type === "Literal" && node.argument.value === 0;
-        }
-        const OPERATORS_TO_CHECK = new Set([">", ">=", "<", "<=", "==", "===", "!=", "!=="]);
-
-        return {
-            BinaryExpression(node) {
-                if (OPERATORS_TO_CHECK.has(node.operator)) {
-                    if (isNegZero(node.left) || isNegZero(node.right)) {
-                        context.report({
-                            node,
-                            message: "Do not use the '{{operator}}' operator to compare against -0.",
-                            data: { operator: node.operator }
-                        });
-                    }
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-floating-decimal.js
===================================================================
--- node_modules/eslint/lib/rules/no-floating-decimal.js	(revision )
+++ node_modules/eslint/lib/rules/no-floating-decimal.js	(revision )
@@ -1,64 +0,0 @@
-/**
- * @fileoverview Rule to flag use of a leading/trailing decimal point in a numeric literal
- * @author James Allardice
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow leading or trailing decimal points in numeric literals",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-            Literal(node) {
-
-                if (typeof node.value === "number") {
-                    if (node.raw.startsWith(".")) {
-                        context.report({
-                            node,
-                            message: "A leading decimal point can be confused with a dot.",
-                            fix(fixer) {
-                                const tokenBefore = sourceCode.getTokenBefore(node);
-                                const needsSpaceBefore = tokenBefore &&
-                                    tokenBefore.range[1] === node.range[0] &&
-                                    !astUtils.canTokensBeAdjacent(tokenBefore, `0${node.raw}`);
-
-                                return fixer.insertTextBefore(node, needsSpaceBefore ? " 0" : "0");
-                            }
-                        });
-                    }
-                    if (node.raw.indexOf(".") === node.raw.length - 1) {
-                        context.report({
-                            node,
-                            message: "A trailing decimal point can be confused with a dot.",
-                            fix: fixer => fixer.insertTextAfter(node, "0")
-                        });
-                    }
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-implicit-globals.js
===================================================================
--- node_modules/eslint/lib/rules/no-implicit-globals.js	(revision )
+++ node_modules/eslint/lib/rules/no-implicit-globals.js	(revision )
@@ -1,55 +0,0 @@
-/**
- * @fileoverview Rule to check for implicit global variables and functions.
- * @author Joshua Peek
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow variable and `function` declarations in the global scope",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        return {
-            Program() {
-                const scope = context.getScope();
-
-                scope.variables.forEach(variable => {
-                    if (variable.writeable) {
-                        return;
-                    }
-
-                    variable.defs.forEach(def => {
-                        if (def.type === "FunctionName" || (def.type === "Variable" && def.parent.kind === "var")) {
-                            context.report({ node: def.node, message: "Implicit global variable, assign as global property instead." });
-                        }
-                    });
-                });
-
-                scope.implicit.variables.forEach(variable => {
-                    const scopeVariable = scope.set.get(variable.name);
-
-                    if (scopeVariable && scopeVariable.writeable) {
-                        return;
-                    }
-
-                    variable.defs.forEach(def => {
-                        context.report({ node: def.node, message: "Implicit global variable, assign as global property instead." });
-                    });
-                });
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-unneeded-ternary.js
===================================================================
--- node_modules/eslint/lib/rules/no-unneeded-ternary.js	(revision )
+++ node_modules/eslint/lib/rules/no-unneeded-ternary.js	(revision )
@@ -1,153 +0,0 @@
-/**
- * @fileoverview Rule to flag no-unneeded-ternary
- * @author Gyandeep Singh
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-// Operators that always result in a boolean value
-const BOOLEAN_OPERATORS = new Set(["==", "===", "!=", "!==", ">", ">=", "<", "<=", "in", "instanceof"]);
-const OPERATOR_INVERSES = {
-    "==": "!=",
-    "!=": "==",
-    "===": "!==",
-    "!==": "==="
-
-    // Operators like < and >= are not true inverses, since both will return false with NaN.
-};
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow ternary operators when simpler alternatives exist",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    defaultAssignment: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const options = context.options[0] || {};
-        const defaultAssignment = options.defaultAssignment !== false;
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Test if the node is a boolean literal
-         * @param {ASTNode} node - The node to report.
-         * @returns {boolean} True if the its a boolean literal
-         * @private
-         */
-        function isBooleanLiteral(node) {
-            return node.type === "Literal" && typeof node.value === "boolean";
-        }
-
-        /**
-         * Creates an expression that represents the boolean inverse of the expression represented by the original node
-         * @param {ASTNode} node A node representing an expression
-         * @returns {string} A string representing an inverted expression
-         */
-        function invertExpression(node) {
-            if (node.type === "BinaryExpression" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {
-                const operatorToken = sourceCode.getFirstTokenBetween(
-                    node.left,
-                    node.right,
-                    token => token.value === node.operator
-                );
-
-                return sourceCode.getText().slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + sourceCode.getText().slice(operatorToken.range[1], node.range[1]);
-            }
-
-            if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: "UnaryExpression" })) {
-                return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;
-            }
-            return `!${astUtils.getParenthesisedText(sourceCode, node)}`;
-        }
-
-        /**
-         * Tests if a given node always evaluates to a boolean value
-         * @param {ASTNode} node - An expression node
-         * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value
-         */
-        function isBooleanExpression(node) {
-            return node.type === "BinaryExpression" && BOOLEAN_OPERATORS.has(node.operator) ||
-                node.type === "UnaryExpression" && node.operator === "!";
-        }
-
-        /**
-         * Test if the node matches the pattern id ? id : expression
-         * @param {ASTNode} node - The ConditionalExpression to check.
-         * @returns {boolean} True if the pattern is matched, and false otherwise
-         * @private
-         */
-        function matchesDefaultAssignment(node) {
-            return node.test.type === "Identifier" &&
-                   node.consequent.type === "Identifier" &&
-                   node.test.name === node.consequent.name;
-        }
-
-        return {
-
-            ConditionalExpression(node) {
-                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
-                    context.report({
-                        node,
-                        loc: node.consequent.loc.start,
-                        message: "Unnecessary use of boolean literals in conditional expression.",
-                        fix(fixer) {
-                            if (node.consequent.value === node.alternate.value) {
-
-                                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`
-                                return node.test.type === "Identifier" ? fixer.replaceText(node, node.consequent.value.toString()) : null;
-                            }
-                            if (node.alternate.value) {
-
-                                // Replace `foo() ? false : true` with `!(foo())`
-                                return fixer.replaceText(node, invertExpression(node.test));
-                            }
-
-                            // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.
-
-                            return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);
-                        }
-                    });
-                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {
-                    context.report({
-                        node,
-                        loc: node.consequent.loc.start,
-                        message: "Unnecessary use of conditional expression for default assignment.",
-                        fix: fixer => {
-                            let nodeAlternate = astUtils.getParenthesisedText(sourceCode, node.alternate);
-
-                            if (node.alternate.type === "ConditionalExpression") {
-                                const isAlternateParenthesised = astUtils.isParenthesised(sourceCode, node.alternate);
-
-                                nodeAlternate = isAlternateParenthesised ? nodeAlternate : `(${nodeAlternate})`;
-                            }
-
-                            return fixer.replaceText(node, `${astUtils.getParenthesisedText(sourceCode, node.test)} || ${nodeAlternate}`);
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-warning-comments.js
===================================================================
--- node_modules/eslint/lib/rules/no-warning-comments.js	(revision )
+++ node_modules/eslint/lib/rules/no-warning-comments.js	(revision )
@@ -1,139 +0,0 @@
-/**
- * @fileoverview Rule that warns about used warning comments
- * @author Alexander Schmidt <https://github.com/lxanders>
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow specified warning terms in comments",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    terms: {
-                        type: "array",
-                        items: {
-                            type: "string"
-                        }
-                    },
-                    location: {
-                        enum: ["start", "anywhere"]
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const sourceCode = context.getSourceCode(),
-            configuration = context.options[0] || {},
-            warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
-            location = configuration.location || "start",
-            selfConfigRegEx = /\bno-warning-comments\b/;
-
-        /**
-         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified
-         * location ("start" or "anywhere"). If the term starts or ends with non word characters, then the match will not
-         * require word boundaries on that side.
-         *
-         * @param {string} term A term to convert to a RegExp
-         * @returns {RegExp} The term converted to a RegExp
-         */
-        function convertToRegExp(term) {
-            const escaped = term.replace(/[-/\\$^*+?.()|[\]{}]/g, "\\$&");
-            let prefix;
-
-            /*
-             * If the term ends in a word character (a-z0-9_), ensure a word
-             * boundary at the end, so that substrings do not get falsely
-             * matched. eg "todo" in a string such as "mastodon".
-             * If the term ends in a non-word character, then \b won't match on
-             * the boundary to the next non-word character, which would likely
-             * be a space. For example `/\bFIX!\b/.test('FIX! blah') === false`.
-             * In these cases, use no bounding match. Same applies for the
-             * prefix, handled below.
-             */
-            const suffix = /\w$/.test(term) ? "\\b" : "";
-
-            if (location === "start") {
-
-                /*
-                 * When matching at the start, ignore leading whitespace, and
-                 * there's no need to worry about word boundaries.
-                 */
-                prefix = "^\\s*";
-            } else if (/^\w/.test(term)) {
-                prefix = "\\b";
-            } else {
-                prefix = "";
-            }
-
-            return new RegExp(prefix + escaped + suffix, "i");
-        }
-
-        const warningRegExps = warningTerms.map(convertToRegExp);
-
-        /**
-         * Checks the specified comment for matches of the configured warning terms and returns the matches.
-         * @param {string} comment The comment which is checked.
-         * @returns {Array} All matched warning terms for this comment.
-         */
-        function commentContainsWarningTerm(comment) {
-            const matches = [];
-
-            warningRegExps.forEach((regex, index) => {
-                if (regex.test(comment)) {
-                    matches.push(warningTerms[index]);
-                }
-            });
-
-            return matches;
-        }
-
-        /**
-         * Checks the specified node for matching warning comments and reports them.
-         * @param {ASTNode} node The AST node being checked.
-         * @returns {void} undefined.
-         */
-        function checkComment(node) {
-            if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {
-                return;
-            }
-
-            const matches = commentContainsWarningTerm(node.value);
-
-            matches.forEach(matchedTerm => {
-                context.report({
-                    node,
-                    message: "Unexpected '{{matchedTerm}}' comment.",
-                    data: {
-                        matchedTerm
-                    }
-                });
-            });
-        }
-
-        return {
-            Program() {
-                const comments = sourceCode.getAllComments();
-
-                comments.filter(token => token.type !== "Shebang").forEach(checkComment);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/operator-assignment.js
===================================================================
--- node_modules/eslint/lib/rules/operator-assignment.js	(revision )
+++ node_modules/eslint/lib/rules/operator-assignment.js	(revision )
@@ -1,206 +0,0 @@
-/**
- * @fileoverview Rule to replace assignment expressions with operator assignment
- * @author Brandon Mills
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether an operator is commutative and has an operator assignment
- * shorthand form.
- * @param   {string}  operator Operator to check.
- * @returns {boolean}          True if the operator is commutative and has a
- *     shorthand form.
- */
-function isCommutativeOperatorWithShorthand(operator) {
-    return ["*", "&", "^", "|"].indexOf(operator) >= 0;
-}
-
-/**
- * Checks whether an operator is not commuatative and has an operator assignment
- * shorthand form.
- * @param   {string}  operator Operator to check.
- * @returns {boolean}          True if the operator is not commuatative and has
- *     a shorthand form.
- */
-function isNonCommutativeOperatorWithShorthand(operator) {
-    return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].indexOf(operator) >= 0;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether two expressions reference the same value. For example:
- *     a = a
- *     a.b = a.b
- *     a[0] = a[0]
- *     a['b'] = a['b']
- * @param   {ASTNode} a Left side of the comparison.
- * @param   {ASTNode} b Right side of the comparison.
- * @returns {boolean}   True if both sides match and reference the same value.
- */
-function same(a, b) {
-    if (a.type !== b.type) {
-        return false;
-    }
-
-    switch (a.type) {
-        case "Identifier":
-            return a.name === b.name;
-
-        case "Literal":
-            return a.value === b.value;
-
-        case "MemberExpression":
-
-            /*
-             * x[0] = x[0]
-             * x[y] = x[y]
-             * x.y = x.y
-             */
-            return same(a.object, b.object) && same(a.property, b.property);
-
-        default:
-            return false;
-    }
-}
-
-/**
-* Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)
-* toString calls regardless of whether assignment shorthand is used)
-* @param {ASTNode} node The node on the left side of the expression
-* @returns {boolean} `true` if the node can be fixed
-*/
-function canBeFixed(node) {
-    return node.type === "Identifier" ||
-        node.type === "MemberExpression" && node.object.type === "Identifier" && (!node.computed || node.property.type === "Literal");
-}
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow assignment operator shorthand where possible",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["always", "never"]
-            }
-        ],
-
-        fixable: "code"
-    },
-
-    create(context) {
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-        * Returns the operator token of an AssignmentExpression or BinaryExpression
-        * @param {ASTNode} node An AssignmentExpression or BinaryExpression node
-        * @returns {Token} The operator token in the node
-        */
-        function getOperatorToken(node) {
-            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
-        }
-
-        /**
-         * Ensures that an assignment uses the shorthand form where possible.
-         * @param   {ASTNode} node An AssignmentExpression node.
-         * @returns {void}
-         */
-        function verify(node) {
-            if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
-                return;
-            }
-
-            const left = node.left;
-            const expr = node.right;
-            const operator = expr.operator;
-
-            if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {
-                if (same(left, expr.left)) {
-                    context.report({
-                        node,
-                        message: "Assignment can be replaced with operator assignment.",
-                        fix(fixer) {
-                            if (canBeFixed(left)) {
-                                const equalsToken = getOperatorToken(node);
-                                const operatorToken = getOperatorToken(expr);
-                                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);
-                                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);
-
-                                return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);
-                            }
-                            return null;
-                        }
-                    });
-                } else if (same(left, expr.right) && isCommutativeOperatorWithShorthand(operator)) {
-
-                    /*
-                     * This case can't be fixed safely.
-                     * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would
-                     * change the execution order of the valueOf() functions.
-                     */
-                    context.report({
-                        node,
-                        message: "Assignment can be replaced with operator assignment."
-                    });
-                }
-            }
-        }
-
-        /**
-         * Warns if an assignment expression uses operator assignment shorthand.
-         * @param   {ASTNode} node An AssignmentExpression node.
-         * @returns {void}
-         */
-        function prohibit(node) {
-            if (node.operator !== "=") {
-                context.report({
-                    node,
-                    message: "Unexpected operator assignment shorthand.",
-                    fix(fixer) {
-                        if (canBeFixed(node.left)) {
-                            const operatorToken = getOperatorToken(node);
-                            const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);
-                            const newOperator = node.operator.slice(0, -1);
-                            let rightText;
-
-                            // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.
-                            if (
-                                astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: "BinaryExpression", operator: newOperator }) &&
-                                !astUtils.isParenthesised(sourceCode, node.right)
-                            ) {
-                                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;
-                            } else {
-                                rightText = sourceCode.text.slice(operatorToken.range[1], node.range[1]);
-                            }
-
-                            return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);
-                        }
-                        return null;
-                    }
-                });
-            }
-        }
-
-        return {
-            AssignmentExpression: context.options[0] !== "never" ? verify : prohibit
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/rest-spread-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/rest-spread-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/rest-spread-spacing.js	(revision )
@@ -1,107 +0,0 @@
-/**
- * @fileoverview Enforce spacing between rest and spread operators and their expressions.
- * @author Kai Cataldo
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce spacing between rest and spread operators and their expressions",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-        fixable: "whitespace",
-        schema: [
-            {
-                enum: ["always", "never"]
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode(),
-            alwaysSpace = context.options[0] === "always";
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Checks whitespace between rest/spread operators and their expressions
-         * @param {ASTNode} node - The node to check
-         * @returns {void}
-         */
-        function checkWhiteSpace(node) {
-            const operator = sourceCode.getFirstToken(node),
-                nextToken = sourceCode.getTokenAfter(operator),
-                hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);
-            let type;
-
-            switch (node.type) {
-                case "SpreadElement":
-                    type = "spread";
-                    break;
-                case "RestElement":
-                    type = "rest";
-                    break;
-                case "ExperimentalSpreadProperty":
-                    type = "spread property";
-                    break;
-                case "ExperimentalRestProperty":
-                    type = "rest property";
-                    break;
-                default:
-                    return;
-            }
-
-            if (alwaysSpace && !hasWhitespace) {
-                context.report({
-                    node,
-                    loc: {
-                        line: operator.loc.end.line,
-                        column: operator.loc.end.column
-                    },
-                    message: "Expected whitespace after {{type}} operator.",
-                    data: {
-                        type
-                    },
-                    fix(fixer) {
-                        return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], " ");
-                    }
-                });
-            } else if (!alwaysSpace && hasWhitespace) {
-                context.report({
-                    node,
-                    loc: {
-                        line: operator.loc.end.line,
-                        column: operator.loc.end.column
-                    },
-                    message: "Unexpected whitespace after {{type}} operator.",
-                    data: {
-                        type
-                    },
-                    fix(fixer) {
-                        return fixer.removeRange([operator.range[1], nextToken.range[0]]);
-                    }
-                });
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            SpreadElement: checkWhiteSpace,
-            RestElement: checkWhiteSpace,
-            ExperimentalSpreadProperty: checkWhiteSpace,
-            ExperimentalRestProperty: checkWhiteSpace
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/space-before-blocks.js
===================================================================
--- node_modules/eslint/lib/rules/space-before-blocks.js	(revision )
+++ node_modules/eslint/lib/rules/space-before-blocks.js	(revision )
@@ -1,148 +0,0 @@
-/**
- * @fileoverview A rule to ensure whitespace before blocks.
- * @author Mathias Schreck <https://github.com/lo1tuma>
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing before blocks",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["always", "never"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            keywords: {
-                                enum: ["always", "never"]
-                            },
-                            functions: {
-                                enum: ["always", "never"]
-                            },
-                            classes: {
-                                enum: ["always", "never"]
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const config = context.options[0],
-            sourceCode = context.getSourceCode();
-        let checkFunctions = true,
-            checkKeywords = true,
-            checkClasses = true;
-
-        if (typeof config === "object") {
-            checkFunctions = config.functions !== "never";
-            checkKeywords = config.keywords !== "never";
-            checkClasses = config.classes !== "never";
-        } else if (config === "never") {
-            checkFunctions = false;
-            checkKeywords = false;
-            checkClasses = false;
-        }
-
-        /**
-         * Checks whether or not a given token is an arrow operator (=>) or a keyword
-         * in order to avoid to conflict with `arrow-spacing` and `keyword-spacing`.
-         *
-         * @param {Token} token - A token to check.
-         * @returns {boolean} `true` if the token is an arrow operator.
-         */
-        function isConflicted(token) {
-            return (token.type === "Punctuator" && token.value === "=>") || token.type === "Keyword";
-        }
-
-        /**
-         * Checks the given BlockStatement node has a preceding space if it doesn’t start on a new line.
-         * @param {ASTNode|Token} node The AST node of a BlockStatement.
-         * @returns {void} undefined.
-         */
-        function checkPrecedingSpace(node) {
-            const precedingToken = sourceCode.getTokenBefore(node);
-
-            if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {
-                const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);
-                const parent = context.getAncestors().pop();
-                let requireSpace;
-
-                if (parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration") {
-                    requireSpace = checkFunctions;
-                } else if (node.type === "ClassBody") {
-                    requireSpace = checkClasses;
-                } else {
-                    requireSpace = checkKeywords;
-                }
-
-                if (requireSpace) {
-                    if (!hasSpace) {
-                        context.report({
-                            node,
-                            message: "Missing space before opening brace.",
-                            fix(fixer) {
-                                return fixer.insertTextBefore(node, " ");
-                            }
-                        });
-                    }
-                } else {
-                    if (hasSpace) {
-                        context.report({
-                            node,
-                            message: "Unexpected space before opening brace.",
-                            fix(fixer) {
-                                return fixer.removeRange([precedingToken.range[1], node.range[0]]);
-                            }
-                        });
-                    }
-                }
-            }
-        }
-
-        /**
-         * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.
-         * @param {ASTNode} node The node of a SwitchStatement.
-         * @returns {void} undefined.
-         */
-        function checkSpaceBeforeCaseBlock(node) {
-            const cases = node.cases;
-            let openingBrace;
-
-            if (cases.length > 0) {
-                openingBrace = sourceCode.getTokenBefore(cases[0]);
-            } else {
-                openingBrace = sourceCode.getLastToken(node, 1);
-            }
-
-            checkPrecedingSpace(openingBrace);
-        }
-
-        return {
-            BlockStatement: checkPrecedingSpace,
-            ClassBody: checkPrecedingSpace,
-            SwitchStatement: checkSpaceBeforeCaseBlock
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/capitalized-comments.js
===================================================================
--- node_modules/eslint/lib/rules/capitalized-comments.js	(revision )
+++ node_modules/eslint/lib/rules/capitalized-comments.js	(revision )
@@ -1,302 +0,0 @@
-/**
- * @fileoverview enforce or disallow capitalization of the first letter of a comment
- * @author Kevin Partington
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const LETTER_PATTERN = require("../util/patterns/letters");
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const ALWAYS_MESSAGE = "Comments should not begin with a lowercase character",
-    NEVER_MESSAGE = "Comments should not begin with an uppercase character",
-    DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,
-    WHITESPACE = /\s/g,
-    MAYBE_URL = /^\s*[^:/?#\s]+:\/\/[^?#]/, // TODO: Combine w/ max-len pattern?
-    DEFAULTS = {
-        ignorePattern: null,
-        ignoreInlineComments: false,
-        ignoreConsecutiveComments: false
-    };
-
-/*
- * Base schema body for defining the basic capitalization rule, ignorePattern,
- * and ignoreInlineComments values.
- * This can be used in a few different ways in the actual schema.
- */
-const SCHEMA_BODY = {
-    type: "object",
-    properties: {
-        ignorePattern: {
-            type: "string"
-        },
-        ignoreInlineComments: {
-            type: "boolean"
-        },
-        ignoreConsecutiveComments: {
-            type: "boolean"
-        }
-    },
-    additionalProperties: false
-};
-
-/**
- * Get normalized options for either block or line comments from the given
- * user-provided options.
- * - If the user-provided options is just a string, returns a normalized
- *   set of options using default values for all other options.
- * - If the user-provided options is an object, then a normalized option
- *   set is returned. Options specified in overrides will take priority
- *   over options specified in the main options object, which will in
- *   turn take priority over the rule's defaults.
- *
- * @param {Object|string} rawOptions The user-provided options.
- * @param {string} which Either "line" or "block".
- * @returns {Object} The normalized options.
- */
-function getNormalizedOptions(rawOptions, which) {
-    if (!rawOptions) {
-        return Object.assign({}, DEFAULTS);
-    }
-
-    return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);
-}
-
-/**
- * Get normalized options for block and line comments.
- *
- * @param {Object|string} rawOptions The user-provided options.
- * @returns {Object} An object with "Line" and "Block" keys and corresponding
- * normalized options objects.
- */
-function getAllNormalizedOptions(rawOptions) {
-    return {
-        Line: getNormalizedOptions(rawOptions, "line"),
-        Block: getNormalizedOptions(rawOptions, "block")
-    };
-}
-
-/**
- * Creates a regular expression for each ignorePattern defined in the rule
- * options.
- *
- * This is done in order to avoid invoking the RegExp constructor repeatedly.
- *
- * @param {Object} normalizedOptions The normalized rule options.
- * @returns {void}
- */
-function createRegExpForIgnorePatterns(normalizedOptions) {
-    Object.keys(normalizedOptions).forEach(key => {
-        const ignorePatternStr = normalizedOptions[key].ignorePattern;
-
-        if (ignorePatternStr) {
-            const regExp = RegExp(`^\\s*(?:${ignorePatternStr})`);
-
-            normalizedOptions[key].ignorePatternRegExp = regExp;
-        }
-    });
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce or disallow capitalization of the first letter of a comment",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "code",
-        schema: [
-            { enum: ["always", "never"] },
-            {
-                oneOf: [
-                    SCHEMA_BODY,
-                    {
-                        type: "object",
-                        properties: {
-                            line: SCHEMA_BODY,
-                            block: SCHEMA_BODY
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-
-        const capitalize = context.options[0] || "always",
-            normalizedOptions = getAllNormalizedOptions(context.options[1]),
-            sourceCode = context.getSourceCode();
-
-        createRegExpForIgnorePatterns(normalizedOptions);
-
-        //----------------------------------------------------------------------
-        // Helpers
-        //----------------------------------------------------------------------
-
-        /**
-         * Checks whether a comment is an inline comment.
-         *
-         * For the purpose of this rule, a comment is inline if:
-         * 1. The comment is preceded by a token on the same line; and
-         * 2. The command is followed by a token on the same line.
-         *
-         * Note that the comment itself need not be single-line!
-         *
-         * Also, it follows from this definition that only block comments can
-         * be considered as possibly inline. This is because line comments
-         * would consume any following tokens on the same line as the comment.
-         *
-         * @param {ASTNode} comment The comment node to check.
-         * @returns {boolean} True if the comment is an inline comment, false
-         * otherwise.
-         */
-        function isInlineComment(comment) {
-            const previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }),
-                nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });
-
-            return Boolean(
-                previousToken &&
-                nextToken &&
-                comment.loc.start.line === previousToken.loc.end.line &&
-                comment.loc.end.line === nextToken.loc.start.line
-            );
-        }
-
-        /**
-         * Determine if a comment follows another comment.
-         *
-         * @param {ASTNode} comment The comment to check.
-         * @returns {boolean} True if the comment follows a valid comment.
-         */
-        function isConsecutiveComment(comment) {
-            const previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });
-
-            return Boolean(
-                previousTokenOrComment &&
-                ["Block", "Line"].indexOf(previousTokenOrComment.type) !== -1
-            );
-        }
-
-        /**
-         * Check a comment to determine if it is valid for this rule.
-         *
-         * @param {ASTNode} comment The comment node to process.
-         * @param {Object} options The options for checking this comment.
-         * @returns {boolean} True if the comment is valid, false otherwise.
-         */
-        function isCommentValid(comment, options) {
-
-            // 1. Check for default ignore pattern.
-            if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {
-                return true;
-            }
-
-            // 2. Check for custom ignore pattern.
-            const commentWithoutAsterisks = comment.value
-                .replace(/\*/g, "");
-
-            if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {
-                return true;
-            }
-
-            // 3. Check for inline comments.
-            if (options.ignoreInlineComments && isInlineComment(comment)) {
-                return true;
-            }
-
-            // 4. Is this a consecutive comment (and are we tolerating those)?
-            if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {
-                return true;
-            }
-
-            // 5. Does the comment start with a possible URL?
-            if (MAYBE_URL.test(commentWithoutAsterisks)) {
-                return true;
-            }
-
-            // 6. Is the initial word character a letter?
-            const commentWordCharsOnly = commentWithoutAsterisks
-                .replace(WHITESPACE, "");
-
-            if (commentWordCharsOnly.length === 0) {
-                return true;
-            }
-
-            const firstWordChar = commentWordCharsOnly[0];
-
-            if (!LETTER_PATTERN.test(firstWordChar)) {
-                return true;
-            }
-
-            // 7. Check the case of the initial word character.
-            const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),
-                isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();
-
-            if (capitalize === "always" && isLowercase) {
-                return false;
-            } else if (capitalize === "never" && isUppercase) {
-                return false;
-            }
-
-            return true;
-        }
-
-        /**
-         * Process a comment to determine if it needs to be reported.
-         *
-         * @param {ASTNode} comment The comment node to process.
-         * @returns {void}
-         */
-        function processComment(comment) {
-            const options = normalizedOptions[comment.type],
-                commentValid = isCommentValid(comment, options);
-
-            if (!commentValid) {
-                const message = capitalize === "always"
-                    ? ALWAYS_MESSAGE
-                    : NEVER_MESSAGE;
-
-                context.report({
-                    node: null, // Intentionally using loc instead
-                    loc: comment.loc,
-                    message,
-                    fix(fixer) {
-                        const match = comment.value.match(LETTER_PATTERN);
-
-                        return fixer.replaceTextRange(
-
-                            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)
-                            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3],
-                            capitalize === "always" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase()
-                        );
-                    }
-                });
-            }
-        }
-
-        //----------------------------------------------------------------------
-        // Public
-        //----------------------------------------------------------------------
-
-        return {
-            Program() {
-                const comments = sourceCode.getAllComments();
-
-                comments.filter(token => token.type !== "Shebang").forEach(processComment);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/lines-around-comment.js
===================================================================
--- node_modules/eslint/lib/rules/lines-around-comment.js	(revision )
+++ node_modules/eslint/lib/rules/lines-around-comment.js	(revision )
@@ -1,368 +0,0 @@
-/**
- * @fileoverview Enforces empty lines around comments.
- * @author Jamund Ferguson
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash"),
-    astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Return an array with with any line numbers that are empty.
- * @param {Array} lines An array of each line of the file.
- * @returns {Array} An array of line numbers.
- */
-function getEmptyLineNums(lines) {
-    const emptyLines = lines.map((line, i) => ({
-        code: line.trim(),
-        num: i + 1
-    })).filter(line => !line.code).map(line => line.num);
-
-    return emptyLines;
-}
-
-/**
- * Return an array with with any line numbers that contain comments.
- * @param {Array} comments An array of comment tokens.
- * @returns {Array} An array of line numbers.
- */
-function getCommentLineNums(comments) {
-    const lines = [];
-
-    comments.forEach(token => {
-        const start = token.loc.start.line;
-        const end = token.loc.end.line;
-
-        lines.push(start, end);
-    });
-    return lines;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require empty lines around comments",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    beforeBlockComment: {
-                        type: "boolean"
-                    },
-                    afterBlockComment: {
-                        type: "boolean"
-                    },
-                    beforeLineComment: {
-                        type: "boolean"
-                    },
-                    afterLineComment: {
-                        type: "boolean"
-                    },
-                    allowBlockStart: {
-                        type: "boolean"
-                    },
-                    allowBlockEnd: {
-                        type: "boolean"
-                    },
-                    allowObjectStart: {
-                        type: "boolean"
-                    },
-                    allowObjectEnd: {
-                        type: "boolean"
-                    },
-                    allowArrayStart: {
-                        type: "boolean"
-                    },
-                    allowArrayEnd: {
-                        type: "boolean"
-                    },
-                    ignorePattern: {
-                        type: "string"
-                    },
-                    applyDefaultIgnorePatterns: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const options = context.options[0] ? Object.assign({}, context.options[0]) : {};
-        const ignorePattern = options.ignorePattern;
-        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
-        const customIgnoreRegExp = new RegExp(ignorePattern);
-        const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;
-
-
-        options.beforeLineComment = options.beforeLineComment || false;
-        options.afterLineComment = options.afterLineComment || false;
-        options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
-        options.afterBlockComment = options.afterBlockComment || false;
-        options.allowBlockStart = options.allowBlockStart || false;
-        options.allowBlockEnd = options.allowBlockEnd || false;
-
-        const sourceCode = context.getSourceCode();
-
-        const lines = sourceCode.lines,
-            numLines = lines.length + 1,
-            comments = sourceCode.getAllComments(),
-            commentLines = getCommentLineNums(comments),
-            emptyLines = getEmptyLineNums(lines),
-            commentAndEmptyLines = commentLines.concat(emptyLines);
-
-        /**
-         * Returns whether or not comments are on lines starting with or ending with code
-         * @param {token} token The comment token to check.
-         * @returns {boolean} True if the comment is not alone.
-         */
-        function codeAroundComment(token) {
-            let currentToken = token;
-
-            do {
-                currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });
-            } while (currentToken && astUtils.isCommentToken(currentToken));
-
-            if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {
-                return true;
-            }
-
-            currentToken = token;
-            do {
-                currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });
-            } while (currentToken && astUtils.isCommentToken(currentToken));
-
-            if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {
-                return true;
-            }
-
-            return false;
-        }
-
-        /**
-         * Returns whether or not comments are inside a node type or not.
-         * @param {ASTNode} parent The Comment parent node.
-         * @param {string} nodeType The parent type to check against.
-         * @returns {boolean} True if the comment is inside nodeType.
-         */
-        function isParentNodeType(parent, nodeType) {
-            return parent.type === nodeType ||
-                (parent.body && parent.body.type === nodeType) ||
-                (parent.consequent && parent.consequent.type === nodeType);
-        }
-
-        /**
-         * Returns the parent node that contains the given token.
-         * @param {token} token The token to check.
-         * @returns {ASTNode} The parent node that contains the given token.
-         */
-        function getParentNodeOfToken(token) {
-            return sourceCode.getNodeByRangeIndex(token.range[0]);
-        }
-
-        /**
-         * Returns whether or not comments are at the parent start or not.
-         * @param {token} token The Comment token.
-         * @param {string} nodeType The parent type to check against.
-         * @returns {boolean} True if the comment is at parent start.
-         */
-        function isCommentAtParentStart(token, nodeType) {
-            const parent = getParentNodeOfToken(token);
-
-            return parent && isParentNodeType(parent, nodeType) &&
-                    token.loc.start.line - parent.loc.start.line === 1;
-        }
-
-        /**
-         * Returns whether or not comments are at the parent end or not.
-         * @param {token} token The Comment token.
-         * @param {string} nodeType The parent type to check against.
-         * @returns {boolean} True if the comment is at parent end.
-         */
-        function isCommentAtParentEnd(token, nodeType) {
-            const parent = getParentNodeOfToken(token);
-
-            return parent && isParentNodeType(parent, nodeType) &&
-                    parent.loc.end.line - token.loc.end.line === 1;
-        }
-
-        /**
-         * Returns whether or not comments are at the block start or not.
-         * @param {token} token The Comment token.
-         * @returns {boolean} True if the comment is at block start.
-         */
-        function isCommentAtBlockStart(token) {
-            return isCommentAtParentStart(token, "ClassBody") || isCommentAtParentStart(token, "BlockStatement") || isCommentAtParentStart(token, "SwitchCase");
-        }
-
-        /**
-         * Returns whether or not comments are at the block end or not.
-         * @param {token} token The Comment token.
-         * @returns {boolean} True if the comment is at block end.
-         */
-        function isCommentAtBlockEnd(token) {
-            return isCommentAtParentEnd(token, "ClassBody") || isCommentAtParentEnd(token, "BlockStatement") || isCommentAtParentEnd(token, "SwitchCase") || isCommentAtParentEnd(token, "SwitchStatement");
-        }
-
-        /**
-         * Returns whether or not comments are at the object start or not.
-         * @param {token} token The Comment token.
-         * @returns {boolean} True if the comment is at object start.
-         */
-        function isCommentAtObjectStart(token) {
-            return isCommentAtParentStart(token, "ObjectExpression") || isCommentAtParentStart(token, "ObjectPattern");
-        }
-
-        /**
-         * Returns whether or not comments are at the object end or not.
-         * @param {token} token The Comment token.
-         * @returns {boolean} True if the comment is at object end.
-         */
-        function isCommentAtObjectEnd(token) {
-            return isCommentAtParentEnd(token, "ObjectExpression") || isCommentAtParentEnd(token, "ObjectPattern");
-        }
-
-        /**
-         * Returns whether or not comments are at the array start or not.
-         * @param {token} token The Comment token.
-         * @returns {boolean} True if the comment is at array start.
-         */
-        function isCommentAtArrayStart(token) {
-            return isCommentAtParentStart(token, "ArrayExpression") || isCommentAtParentStart(token, "ArrayPattern");
-        }
-
-        /**
-         * Returns whether or not comments are at the array end or not.
-         * @param {token} token The Comment token.
-         * @returns {boolean} True if the comment is at array end.
-         */
-        function isCommentAtArrayEnd(token) {
-            return isCommentAtParentEnd(token, "ArrayExpression") || isCommentAtParentEnd(token, "ArrayPattern");
-        }
-
-        /**
-         * Checks if a comment token has lines around it (ignores inline comments)
-         * @param {token} token The Comment token.
-         * @param {Object} opts Options to determine the newline.
-         * @param {boolean} opts.after Should have a newline after this line.
-         * @param {boolean} opts.before Should have a newline before this line.
-         * @returns {void}
-         */
-        function checkForEmptyLine(token, opts) {
-            if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {
-                return;
-            }
-
-            if (ignorePattern && customIgnoreRegExp.test(token.value)) {
-                return;
-            }
-
-            let after = opts.after,
-                before = opts.before;
-
-            const prevLineNum = token.loc.start.line - 1,
-                nextLineNum = token.loc.end.line + 1,
-                commentIsNotAlone = codeAroundComment(token);
-
-            const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token),
-                blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token),
-                objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),
-                objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),
-                arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),
-                arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);
-
-            const exceptionStartAllowed = blockStartAllowed || objectStartAllowed || arrayStartAllowed;
-            const exceptionEndAllowed = blockEndAllowed || objectEndAllowed || arrayEndAllowed;
-
-            // ignore top of the file and bottom of the file
-            if (prevLineNum < 1) {
-                before = false;
-            }
-            if (nextLineNum >= numLines) {
-                after = false;
-            }
-
-            // we ignore all inline comments
-            if (commentIsNotAlone) {
-                return;
-            }
-
-            const previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });
-            const nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });
-
-            // check for newline before
-            if (!exceptionStartAllowed && before && !lodash.includes(commentAndEmptyLines, prevLineNum) &&
-                    !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {
-                const lineStart = token.range[0] - token.loc.start.column;
-                const range = [lineStart, lineStart];
-
-                context.report({
-                    node: token,
-                    message: "Expected line before comment.",
-                    fix(fixer) {
-                        return fixer.insertTextBeforeRange(range, "\n");
-                    }
-                });
-            }
-
-            // check for newline after
-            if (!exceptionEndAllowed && after && !lodash.includes(commentAndEmptyLines, nextLineNum) &&
-                    !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {
-                context.report({
-                    node: token,
-                    message: "Expected line after comment.",
-                    fix(fixer) {
-                        return fixer.insertTextAfter(token, "\n");
-                    }
-                });
-            }
-
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            Program() {
-                comments.forEach(token => {
-                    if (token.type === "Line") {
-                        if (options.beforeLineComment || options.afterLineComment) {
-                            checkForEmptyLine(token, {
-                                after: options.afterLineComment,
-                                before: options.beforeLineComment
-                            });
-                        }
-                    } else if (token.type === "Block") {
-                        if (options.beforeBlockComment || options.afterBlockComment) {
-                            checkForEmptyLine(token, {
-                                after: options.afterBlockComment,
-                                before: options.beforeBlockComment
-                            });
-                        }
-                    }
-                });
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/max-nested-callbacks.js
===================================================================
--- node_modules/eslint/lib/rules/max-nested-callbacks.js	(revision )
+++ node_modules/eslint/lib/rules/max-nested-callbacks.js	(revision )
@@ -1,112 +0,0 @@
-/**
- * @fileoverview Rule to enforce a maximum number of nested callbacks.
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce a maximum depth that callbacks can be nested",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            maximum: {
-                                type: "integer",
-                                minimum: 0
-                            },
-                            max: {
-                                type: "integer",
-                                minimum: 0
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-
-        //--------------------------------------------------------------------------
-        // Constants
-        //--------------------------------------------------------------------------
-        const option = context.options[0];
-        let THRESHOLD = 10;
-
-        if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
-            THRESHOLD = option.maximum;
-        }
-        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
-            THRESHOLD = option.max;
-        }
-        if (typeof option === "number") {
-            THRESHOLD = option;
-        }
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        const callbackStack = [];
-
-        /**
-         * Checks a given function node for too many callbacks.
-         * @param {ASTNode} node The node to check.
-         * @returns {void}
-         * @private
-         */
-        function checkFunction(node) {
-            const parent = node.parent;
-
-            if (parent.type === "CallExpression") {
-                callbackStack.push(node);
-            }
-
-            if (callbackStack.length > THRESHOLD) {
-                const opts = { num: callbackStack.length, max: THRESHOLD };
-
-                context.report({ node, message: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.", data: opts });
-            }
-        }
-
-        /**
-         * Pops the call stack.
-         * @returns {void}
-         * @private
-         */
-        function popStack() {
-            callbackStack.pop();
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            ArrowFunctionExpression: checkFunction,
-            "ArrowFunctionExpression:exit": popStack,
-
-            FunctionExpression: checkFunction,
-            "FunctionExpression:exit": popStack
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-array-constructor.js
===================================================================
--- node_modules/eslint/lib/rules/no-array-constructor.js	(revision )
+++ node_modules/eslint/lib/rules/no-array-constructor.js	(revision )
@@ -1,47 +0,0 @@
-/**
- * @fileoverview Disallow construction of dense arrays using the Array constructor
- * @author Matt DuVall <http://www.mattduvall.com/>
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `Array` constructors",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Disallow construction of dense arrays using the Array constructor
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function check(node) {
-            if (
-                node.arguments.length !== 1 &&
-                node.callee.type === "Identifier" &&
-                node.callee.name === "Array"
-            ) {
-                context.report({ node, message: "The array literal notation [] is preferrable." });
-            }
-        }
-
-        return {
-            CallExpression: check,
-            NewExpression: check
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-case-declarations.js
===================================================================
--- node_modules/eslint/lib/rules/no-case-declarations.js	(revision )
+++ node_modules/eslint/lib/rules/no-case-declarations.js	(revision )
@@ -1,57 +0,0 @@
-/**
- * @fileoverview Rule to flag use of an lexical declarations inside a case clause
- * @author Erik Arvidsson
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow lexical declarations in case clauses",
-            category: "Best Practices",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Checks whether or not a node is a lexical declaration.
-         * @param {ASTNode} node A direct child statement of a switch case.
-         * @returns {boolean} Whether or not the node is a lexical declaration.
-         */
-        function isLexicalDeclaration(node) {
-            switch (node.type) {
-                case "FunctionDeclaration":
-                case "ClassDeclaration":
-                    return true;
-                case "VariableDeclaration":
-                    return node.kind !== "var";
-                default:
-                    return false;
-            }
-        }
-
-        return {
-            SwitchCase(node) {
-                for (let i = 0; i < node.consequent.length; i++) {
-                    const statement = node.consequent[i];
-
-                    if (isLexicalDeclaration(statement)) {
-                        context.report({
-                            node,
-                            message: "Unexpected lexical declaration in case block."
-                        });
-                    }
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-duplicate-imports.js
===================================================================
--- node_modules/eslint/lib/rules/no-duplicate-imports.js	(revision )
+++ node_modules/eslint/lib/rules/no-duplicate-imports.js	(revision )
@@ -1,137 +0,0 @@
-/**
- * @fileoverview Restrict usage of duplicate imports.
- * @author Simen Bekkhus
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-/**
- * Returns the name of the module imported or re-exported.
- *
- * @param {ASTNode} node - A node to get.
- * @returns {string} the name of the module, or empty string if no name.
- */
-function getValue(node) {
-    if (node && node.source && node.source.value) {
-        return node.source.value.trim();
-    }
-
-    return "";
-}
-
-/**
- * Checks if the name of the import or export exists in the given array, and reports if so.
- *
- * @param {RuleContext} context - The ESLint rule context object.
- * @param {ASTNode} node - A node to get.
- * @param {string} value - The name of the imported or exported module.
- * @param {string[]} array - The array containing other imports or exports in the file.
- * @param {string} message - A message to be reported after the name of the module
- *
- * @returns {void} No return value
- */
-function checkAndReport(context, node, value, array, message) {
-    if (array.indexOf(value) !== -1) {
-        context.report({
-            node,
-            message: "'{{module}}' {{message}}",
-            data: {
-                module: value,
-                message
-            }
-        });
-    }
-}
-
-/**
- * @callback nodeCallback
- * @param {ASTNode} node - A node to handle.
- */
-
-/**
- * Returns a function handling the imports of a given file
- *
- * @param {RuleContext} context - The ESLint rule context object.
- * @param {boolean} includeExports - Whether or not to check for exports in addition to imports.
- * @param {string[]} importsInFile - The array containing other imports in the file.
- * @param {string[]} exportsInFile - The array containing other exports in the file.
- *
- * @returns {nodeCallback} A function passed to ESLint to handle the statement.
- */
-function handleImports(context, includeExports, importsInFile, exportsInFile) {
-    return function(node) {
-        const value = getValue(node);
-
-        if (value) {
-            checkAndReport(context, node, value, importsInFile, "import is duplicated.");
-
-            if (includeExports) {
-                checkAndReport(context, node, value, exportsInFile, "import is duplicated as export.");
-            }
-
-            importsInFile.push(value);
-        }
-    };
-}
-
-/**
- * Returns a function handling the exports of a given file
- *
- * @param {RuleContext} context - The ESLint rule context object.
- * @param {string[]} importsInFile - The array containing other imports in the file.
- * @param {string[]} exportsInFile - The array containing other exports in the file.
- *
- * @returns {nodeCallback} A function passed to ESLint to handle the statement.
- */
-function handleExports(context, importsInFile, exportsInFile) {
-    return function(node) {
-        const value = getValue(node);
-
-        if (value) {
-            checkAndReport(context, node, value, exportsInFile, "export is duplicated.");
-            checkAndReport(context, node, value, importsInFile, "export is duplicated as import.");
-
-            exportsInFile.push(value);
-        }
-    };
-}
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow duplicate module imports",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: [{
-            type: "object",
-            properties: {
-                includeExports: {
-                    type: "boolean"
-                }
-            },
-            additionalProperties: false
-        }]
-    },
-
-    create(context) {
-        const includeExports = (context.options[0] || {}).includeExports,
-            importsInFile = [],
-            exportsInFile = [];
-
-        const handlers = {
-            ImportDeclaration: handleImports(context, includeExports, importsInFile, exportsInFile)
-        };
-
-        if (includeExports) {
-            handlers.ExportNamedDeclaration = handleExports(context, importsInFile, exportsInFile);
-            handlers.ExportAllDeclaration = handleExports(context, importsInFile, exportsInFile);
-        }
-
-        return handlers;
-    }
-};
Index: node_modules/eslint/lib/rules/no-implicit-coercion.js
===================================================================
--- node_modules/eslint/lib/rules/no-implicit-coercion.js	(revision )
+++ node_modules/eslint/lib/rules/no-implicit-coercion.js	(revision )
@@ -1,292 +0,0 @@
-/**
- * @fileoverview A rule to disallow the type conversions with shorter notations.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/;
-const ALLOWABLE_OPERATORS = ["~", "!!", "+", "*"];
-
-/**
- * Parses and normalizes an option object.
- * @param {Object} options - An option object to parse.
- * @returns {Object} The parsed and normalized option object.
- */
-function parseOptions(options) {
-    options = options || {};
-    return {
-        boolean: "boolean" in options ? Boolean(options.boolean) : true,
-        number: "number" in options ? Boolean(options.number) : true,
-        string: "string" in options ? Boolean(options.string) : true,
-        allow: options.allow || []
-    };
-}
-
-/**
- * Checks whether or not a node is a double logical nigating.
- * @param {ASTNode} node - An UnaryExpression node to check.
- * @returns {boolean} Whether or not the node is a double logical nigating.
- */
-function isDoubleLogicalNegating(node) {
-    return (
-        node.operator === "!" &&
-        node.argument.type === "UnaryExpression" &&
-        node.argument.operator === "!"
-    );
-}
-
-/**
- * Checks whether or not a node is a binary negating of `.indexOf()` method calling.
- * @param {ASTNode} node - An UnaryExpression node to check.
- * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.
- */
-function isBinaryNegatingOfIndexOf(node) {
-    return (
-        node.operator === "~" &&
-        node.argument.type === "CallExpression" &&
-        node.argument.callee.type === "MemberExpression" &&
-        node.argument.callee.property.type === "Identifier" &&
-        INDEX_OF_PATTERN.test(node.argument.callee.property.name)
-    );
-}
-
-/**
- * Checks whether or not a node is a multiplying by one.
- * @param {BinaryExpression} node - A BinaryExpression node to check.
- * @returns {boolean} Whether or not the node is a multiplying by one.
- */
-function isMultiplyByOne(node) {
-    return node.operator === "*" && (
-        node.left.type === "Literal" && node.left.value === 1 ||
-        node.right.type === "Literal" && node.right.value === 1
-    );
-}
-
-/**
- * Checks whether the result of a node is numeric or not
- * @param {ASTNode} node The node to test
- * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call
- */
-function isNumeric(node) {
-    return (
-        node.type === "Literal" && typeof node.value === "number" ||
-        node.type === "CallExpression" && (
-            node.callee.name === "Number" ||
-            node.callee.name === "parseInt" ||
-            node.callee.name === "parseFloat"
-        )
-    );
-}
-
-/**
- * Returns the first non-numeric operand in a BinaryExpression. Designed to be
- * used from bottom to up since it walks up the BinaryExpression trees using
- * node.parent to find the result.
- * @param {BinaryExpression} node The BinaryExpression node to be walked up on
- * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null
- */
-function getNonNumericOperand(node) {
-    const left = node.left,
-        right = node.right;
-
-    if (right.type !== "BinaryExpression" && !isNumeric(right)) {
-        return right;
-    }
-
-    if (left.type !== "BinaryExpression" && !isNumeric(left)) {
-        return left;
-    }
-
-    return null;
-}
-
-/**
- * Checks whether a node is an empty string literal or not.
- * @param {ASTNode} node The node to check.
- * @returns {boolean} Whether or not the passed in node is an
- * empty string literal or not.
- */
-function isEmptyString(node) {
-    return astUtils.isStringLiteral(node) && (node.value === "" || (node.type === "TemplateLiteral" && node.quasis.length === 1 && node.quasis[0].value.cooked === ""));
-}
-
-/**
- * Checks whether or not a node is a concatenating with an empty string.
- * @param {ASTNode} node - A BinaryExpression node to check.
- * @returns {boolean} Whether or not the node is a concatenating with an empty string.
- */
-function isConcatWithEmptyString(node) {
-    return node.operator === "+" && (
-        (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right)) ||
-        (isEmptyString(node.right) && !astUtils.isStringLiteral(node.left))
-    );
-}
-
-/**
- * Checks whether or not a node is appended with an empty string.
- * @param {ASTNode} node - An AssignmentExpression node to check.
- * @returns {boolean} Whether or not the node is appended with an empty string.
- */
-function isAppendEmptyString(node) {
-    return node.operator === "+=" && isEmptyString(node.right);
-}
-
-/**
- * Returns the operand that is not an empty string from a flagged BinaryExpression.
- * @param {ASTNode} node - The flagged BinaryExpression node to check.
- * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.
- */
-function getNonEmptyOperand(node) {
-    return isEmptyString(node.left) ? node.right : node.left;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow shorthand type conversions",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        fixable: "code",
-        schema: [{
-            type: "object",
-            properties: {
-                boolean: {
-                    type: "boolean"
-                },
-                number: {
-                    type: "boolean"
-                },
-                string: {
-                    type: "boolean"
-                },
-                allow: {
-                    type: "array",
-                    items: {
-                        enum: ALLOWABLE_OPERATORS
-                    },
-                    uniqueItems: true
-                }
-            },
-            additionalProperties: false
-        }]
-    },
-
-    create(context) {
-        const options = parseOptions(context.options[0]);
-        const sourceCode = context.getSourceCode();
-
-        /**
-        * Reports an error and autofixes the node
-        * @param {ASTNode} node - An ast node to report the error on.
-        * @param {string} recommendation - The recommended code for the issue
-        * @param {bool} shouldFix - Whether this report should fix the node
-        * @returns {void}
-        */
-        function report(node, recommendation, shouldFix) {
-            shouldFix = typeof shouldFix === "undefined" ? true : shouldFix;
-
-            context.report({
-                node,
-                message: "use `{{recommendation}}` instead.",
-                data: {
-                    recommendation
-                },
-                fix(fixer) {
-                    if (!shouldFix) {
-                        return null;
-                    }
-
-                    const tokenBefore = sourceCode.getTokenBefore(node);
-
-                    if (
-                        tokenBefore &&
-                        tokenBefore.range[1] === node.range[0] &&
-                        !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)
-                    ) {
-                        return fixer.replaceText(node, ` ${recommendation}`);
-                    }
-                    return fixer.replaceText(node, recommendation);
-                }
-            });
-        }
-
-        return {
-            UnaryExpression(node) {
-                let operatorAllowed;
-
-                // !!foo
-                operatorAllowed = options.allow.indexOf("!!") >= 0;
-                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {
-                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;
-
-                    report(node, recommendation);
-                }
-
-                // ~foo.indexOf(bar)
-                operatorAllowed = options.allow.indexOf("~") >= 0;
-                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {
-                    const recommendation = `${sourceCode.getText(node.argument)} !== -1`;
-
-                    report(node, recommendation, false);
-                }
-
-                // +foo
-                operatorAllowed = options.allow.indexOf("+") >= 0;
-                if (!operatorAllowed && options.number && node.operator === "+" && !isNumeric(node.argument)) {
-                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;
-
-                    report(node, recommendation);
-                }
-            },
-
-            // Use `:exit` to prevent double reporting
-            "BinaryExpression:exit"(node) {
-                let operatorAllowed;
-
-                // 1 * foo
-                operatorAllowed = options.allow.indexOf("*") >= 0;
-                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);
-
-                if (nonNumericOperand) {
-                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;
-
-                    report(node, recommendation);
-                }
-
-                // "" + foo
-                operatorAllowed = options.allow.indexOf("+") >= 0;
-                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {
-                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;
-
-                    report(node, recommendation);
-                }
-            },
-
-            AssignmentExpression(node) {
-
-                // foo += ""
-                const operatorAllowed = options.allow.indexOf("+") >= 0;
-
-                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {
-                    const code = sourceCode.getText(getNonEmptyOperand(node));
-                    const recommendation = `${code} = String(${code})`;
-
-                    report(node, recommendation);
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-negated-condition.js
===================================================================
--- node_modules/eslint/lib/rules/no-negated-condition.js	(revision )
+++ node_modules/eslint/lib/rules/no-negated-condition.js	(revision )
@@ -1,82 +0,0 @@
-/**
- * @fileoverview Rule to disallow a negated condition
- * @author Alberto Rodríguez
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow negated conditions",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Determines if a given node is an if-else without a condition on the else
-         * @param {ASTNode} node The node to check.
-         * @returns {boolean} True if the node has an else without an if.
-         * @private
-         */
-        function hasElseWithoutCondition(node) {
-            return node.alternate && node.alternate.type !== "IfStatement";
-        }
-
-        /**
-         * Determines if a given node is a negated unary expression
-         * @param {Object} test The test object to check.
-         * @returns {boolean} True if the node is a negated unary expression.
-         * @private
-         */
-        function isNegatedUnaryExpression(test) {
-            return test.type === "UnaryExpression" && test.operator === "!";
-        }
-
-        /**
-         * Determines if a given node is a negated binary expression
-         * @param {Test} test The test to check.
-         * @returns {boolean} True if the node is a negated binary expression.
-         * @private
-         */
-        function isNegatedBinaryExpression(test) {
-            return test.type === "BinaryExpression" &&
-                (test.operator === "!=" || test.operator === "!==");
-        }
-
-        /**
-         * Determines if a given node has a negated if expression
-         * @param {ASTNode} node The node to check.
-         * @returns {boolean} True if the node has a negated if expression.
-         * @private
-         */
-        function isNegatedIf(node) {
-            return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);
-        }
-
-        return {
-            IfStatement(node) {
-                if (!hasElseWithoutCondition(node)) {
-                    return;
-                }
-
-                if (isNegatedIf(node)) {
-                    context.report({ node, message: "Unexpected negated condition." });
-                }
-            },
-            ConditionalExpression(node) {
-                if (isNegatedIf(node)) {
-                    context.report({ node, message: "Unexpected negated condition." });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-restricted-syntax.js
===================================================================
--- node_modules/eslint/lib/rules/no-restricted-syntax.js	(revision )
+++ node_modules/eslint/lib/rules/no-restricted-syntax.js	(revision )
@@ -1,62 +0,0 @@
-/**
- * @fileoverview Rule to flag use of certain node types
- * @author Burak Yigit Kaya
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow specified syntax",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: {
-            type: "array",
-            items: [{
-                oneOf: [
-                    {
-                        type: "string"
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            selector: { type: "string" },
-                            message: { type: "string" }
-                        },
-                        required: ["selector"],
-                        additionalProperties: false
-                    }
-                ]
-            }],
-            uniqueItems: true,
-            minItems: 0
-        }
-    },
-
-    create(context) {
-        return context.options.reduce((result, selectorOrObject) => {
-            const isStringFormat = (typeof selectorOrObject === "string");
-            const hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);
-
-            const selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;
-            const message = hasCustomMessage ? selectorOrObject.message : "Using '{{selector}}' is not allowed.";
-
-            return Object.assign(result, {
-                [selector](node) {
-                    context.report({
-                        node,
-                        message,
-                        data: hasCustomMessage ? {} : { selector }
-                    });
-                }
-            });
-        }, {});
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-this-before-super.js
===================================================================
--- node_modules/eslint/lib/rules/no-this-before-super.js	(revision )
+++ node_modules/eslint/lib/rules/no-this-before-super.js	(revision )
@@ -1,299 +0,0 @@
-/**
- * @fileoverview A rule to disallow using `this`/`super` before `super()`.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a given node is a constructor.
- * @param {ASTNode} node - A node to check. This node type is one of
- *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and
- *   `ArrowFunctionExpression`.
- * @returns {boolean} `true` if the node is a constructor.
- */
-function isConstructorFunction(node) {
-    return (
-        node.type === "FunctionExpression" &&
-        node.parent.type === "MethodDefinition" &&
-        node.parent.kind === "constructor"
-    );
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `this`/`super` before calling `super()` in constructors",
-            category: "ECMAScript 6",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /*
-         * Information for each constructor.
-         * - upper:      Information of the upper constructor.
-         * - hasExtends: A flag which shows whether the owner class has a valid
-         *   `extends` part.
-         * - scope:      The scope of the owner class.
-         * - codePath:   The code path of this constructor.
-         */
-        let funcInfo = null;
-
-        /*
-         * Information for each code path segment.
-         * Each key is the id of a code path segment.
-         * Each value is an object:
-         * - superCalled:  The flag which shows `super()` called in all code paths.
-         * - invalidNodes: The array of invalid ThisExpression and Super nodes.
-         */
-        let segInfoMap = Object.create(null);
-
-        /**
-         * Gets whether or not `super()` is called in a given code path segment.
-         * @param {CodePathSegment} segment - A code path segment to get.
-         * @returns {boolean} `true` if `super()` is called.
-         */
-        function isCalled(segment) {
-            return !segment.reachable || segInfoMap[segment.id].superCalled;
-        }
-
-        /**
-         * Checks whether or not this is in a constructor.
-         * @returns {boolean} `true` if this is in a constructor.
-         */
-        function isInConstructorOfDerivedClass() {
-            return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
-        }
-
-        /**
-         * Checks whether or not this is before `super()` is called.
-         * @returns {boolean} `true` if this is before `super()` is called.
-         */
-        function isBeforeCallOfSuper() {
-            return (
-                isInConstructorOfDerivedClass() &&
-                !funcInfo.codePath.currentSegments.every(isCalled)
-            );
-        }
-
-        /**
-         * Sets a given node as invalid.
-         * @param {ASTNode} node - A node to set as invalid. This is one of
-         *      a ThisExpression and a Super.
-         * @returns {void}
-         */
-        function setInvalid(node) {
-            const segments = funcInfo.codePath.currentSegments;
-
-            for (let i = 0; i < segments.length; ++i) {
-                const segment = segments[i];
-
-                if (segment.reachable) {
-                    segInfoMap[segment.id].invalidNodes.push(node);
-                }
-            }
-        }
-
-        /**
-         * Sets the current segment as `super` was called.
-         * @returns {void}
-         */
-        function setSuperCalled() {
-            const segments = funcInfo.codePath.currentSegments;
-
-            for (let i = 0; i < segments.length; ++i) {
-                const segment = segments[i];
-
-                if (segment.reachable) {
-                    segInfoMap[segment.id].superCalled = true;
-                }
-            }
-        }
-
-        return {
-
-            /**
-             * Adds information of a constructor into the stack.
-             * @param {CodePath} codePath - A code path which was started.
-             * @param {ASTNode} node - The current node.
-             * @returns {void}
-             */
-            onCodePathStart(codePath, node) {
-                if (isConstructorFunction(node)) {
-
-                    // Class > ClassBody > MethodDefinition > FunctionExpression
-                    const classNode = node.parent.parent.parent;
-
-                    funcInfo = {
-                        upper: funcInfo,
-                        isConstructor: true,
-                        hasExtends: Boolean(
-                            classNode.superClass &&
-                            !astUtils.isNullOrUndefined(classNode.superClass)
-                        ),
-                        codePath
-                    };
-                } else {
-                    funcInfo = {
-                        upper: funcInfo,
-                        isConstructor: false,
-                        hasExtends: false,
-                        codePath
-                    };
-                }
-            },
-
-            /**
-             * Removes the top of stack item.
-             *
-             * And this treverses all segments of this code path then reports every
-             * invalid node.
-             *
-             * @param {CodePath} codePath - A code path which was ended.
-             * @param {ASTNode} node - The current node.
-             * @returns {void}
-             */
-            onCodePathEnd(codePath) {
-                const isDerivedClass = funcInfo.hasExtends;
-
-                funcInfo = funcInfo.upper;
-                if (!isDerivedClass) {
-                    return;
-                }
-
-                codePath.traverseSegments((segment, controller) => {
-                    const info = segInfoMap[segment.id];
-
-                    for (let i = 0; i < info.invalidNodes.length; ++i) {
-                        const invalidNode = info.invalidNodes[i];
-
-                        context.report({
-                            message: "'{{kind}}' is not allowed before 'super()'.",
-                            node: invalidNode,
-                            data: {
-                                kind: invalidNode.type === "Super" ? "super" : "this"
-                            }
-                        });
-                    }
-
-                    if (info.superCalled) {
-                        controller.skip();
-                    }
-                });
-            },
-
-            /**
-             * Initialize information of a given code path segment.
-             * @param {CodePathSegment} segment - A code path segment to initialize.
-             * @returns {void}
-             */
-            onCodePathSegmentStart(segment) {
-                if (!isInConstructorOfDerivedClass()) {
-                    return;
-                }
-
-                // Initialize info.
-                segInfoMap[segment.id] = {
-                    superCalled: (
-                        segment.prevSegments.length > 0 &&
-                        segment.prevSegments.every(isCalled)
-                    ),
-                    invalidNodes: []
-                };
-            },
-
-            /**
-             * Update information of the code path segment when a code path was
-             * looped.
-             * @param {CodePathSegment} fromSegment - The code path segment of the
-             *      end of a loop.
-             * @param {CodePathSegment} toSegment - A code path segment of the head
-             *      of a loop.
-             * @returns {void}
-             */
-            onCodePathSegmentLoop(fromSegment, toSegment) {
-                if (!isInConstructorOfDerivedClass()) {
-                    return;
-                }
-
-                // Update information inside of the loop.
-                funcInfo.codePath.traverseSegments(
-                    { first: toSegment, last: fromSegment },
-                    (segment, controller) => {
-                        const info = segInfoMap[segment.id];
-
-                        if (info.superCalled) {
-                            info.invalidNodes = [];
-                            controller.skip();
-                        } else if (
-                            segment.prevSegments.length > 0 &&
-                            segment.prevSegments.every(isCalled)
-                        ) {
-                            info.superCalled = true;
-                            info.invalidNodes = [];
-                        }
-                    }
-                );
-            },
-
-            /**
-             * Reports if this is before `super()`.
-             * @param {ASTNode} node - A target node.
-             * @returns {void}
-             */
-            ThisExpression(node) {
-                if (isBeforeCallOfSuper()) {
-                    setInvalid(node);
-                }
-            },
-
-            /**
-             * Reports if this is before `super()`.
-             * @param {ASTNode} node - A target node.
-             * @returns {void}
-             */
-            Super(node) {
-                if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
-                    setInvalid(node);
-                }
-            },
-
-            /**
-             * Marks `super()` called.
-             * @param {ASTNode} node - A target node.
-             * @returns {void}
-             */
-            "CallExpression:exit"(node) {
-                if (node.callee.type === "Super" && isBeforeCallOfSuper()) {
-                    setSuperCalled();
-                }
-            },
-
-            /**
-             * Resets state.
-             * @returns {void}
-             */
-            "Program:exit"() {
-                segInfoMap = Object.create(null);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-underscore-dangle.js
===================================================================
--- node_modules/eslint/lib/rules/no-underscore-dangle.js	(revision )
+++ node_modules/eslint/lib/rules/no-underscore-dangle.js	(revision )
@@ -1,203 +0,0 @@
-/**
- * @fileoverview Rule to flag trailing underscores in variable declarations.
- * @author Matt DuVall <http://www.mattduvall.com>
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow dangling underscores in identifiers",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allow: {
-                        type: "array",
-                        items: {
-                            type: "string"
-                        }
-                    },
-                    allowAfterThis: {
-                        type: "boolean"
-                    },
-                    allowAfterSuper: {
-                        type: "boolean"
-                    },
-                    enforceInMethodNames: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const options = context.options[0] || {};
-        const ALLOWED_VARIABLES = options.allow ? options.allow : [];
-        const allowAfterThis = typeof options.allowAfterThis !== "undefined" ? options.allowAfterThis : false;
-        const allowAfterSuper = typeof options.allowAfterSuper !== "undefined" ? options.allowAfterSuper : false;
-        const enforceInMethodNames = typeof options.enforceInMethodNames !== "undefined" ? options.enforceInMethodNames : false;
-
-        //-------------------------------------------------------------------------
-        // Helpers
-        //-------------------------------------------------------------------------
-
-        /**
-         * Check if identifier is present inside the allowed option
-         * @param {string} identifier name of the node
-         * @returns {boolean} true if its is present
-         * @private
-         */
-        function isAllowed(identifier) {
-            return ALLOWED_VARIABLES.some(ident => ident === identifier);
-        }
-
-        /**
-         * Check if identifier has a underscore at the end
-         * @param {ASTNode} identifier node to evaluate
-         * @returns {boolean} true if its is present
-         * @private
-         */
-        function hasTrailingUnderscore(identifier) {
-            const len = identifier.length;
-
-            return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
-        }
-
-        /**
-         * Check if identifier is a special case member expression
-         * @param {ASTNode} identifier node to evaluate
-         * @returns {boolean} true if its is a special case
-         * @private
-         */
-        function isSpecialCaseIdentifierForMemberExpression(identifier) {
-            return identifier === "__proto__";
-        }
-
-        /**
-         * Check if identifier is a special case variable expression
-         * @param {ASTNode} identifier node to evaluate
-         * @returns {boolean} true if its is a special case
-         * @private
-         */
-        function isSpecialCaseIdentifierInVariableExpression(identifier) {
-
-            // Checks for the underscore library usage here
-            return identifier === "_";
-        }
-
-        /**
-         * Check if function has a underscore at the end
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkForTrailingUnderscoreInFunctionDeclaration(node) {
-            if (node.id) {
-                const identifier = node.id.name;
-
-                if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !isAllowed(identifier)) {
-                    context.report({
-                        node,
-                        message: "Unexpected dangling '_' in '{{identifier}}'.",
-                        data: {
-                            identifier
-                        }
-                    });
-                }
-            }
-        }
-
-        /**
-         * Check if variable expression has a underscore at the end
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkForTrailingUnderscoreInVariableExpression(node) {
-            const identifier = node.id.name;
-
-            if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) &&
-                !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {
-                context.report({
-                    node,
-                    message: "Unexpected dangling '_' in '{{identifier}}'.",
-                    data: {
-                        identifier
-                    }
-                });
-            }
-        }
-
-        /**
-         * Check if member expression has a underscore at the end
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkForTrailingUnderscoreInMemberExpression(node) {
-            const identifier = node.property.name,
-                isMemberOfThis = node.object.type === "ThisExpression",
-                isMemberOfSuper = node.object.type === "Super";
-
-            if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) &&
-                !(isMemberOfThis && allowAfterThis) &&
-                !(isMemberOfSuper && allowAfterSuper) &&
-                !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {
-                context.report({
-                    node,
-                    message: "Unexpected dangling '_' in '{{identifier}}'.",
-                    data: {
-                        identifier
-                    }
-                });
-            }
-        }
-
-        /**
-         * Check if method declaration or method property has a underscore at the end
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkForTrailingUnderscoreInMethod(node) {
-            const identifier = node.key.name;
-            const isMethod = node.type === "MethodDefinition" || node.type === "Property" && node.method;
-
-            if (typeof identifier !== "undefined" && enforceInMethodNames && isMethod && hasTrailingUnderscore(identifier)) {
-                context.report({
-                    node,
-                    message: "Unexpected dangling '_' in '{{identifier}}'.",
-                    data: {
-                        identifier
-                    }
-                });
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            FunctionDeclaration: checkForTrailingUnderscoreInFunctionDeclaration,
-            VariableDeclarator: checkForTrailingUnderscoreInVariableExpression,
-            MemberExpression: checkForTrailingUnderscoreInMemberExpression,
-            MethodDefinition: checkForTrailingUnderscoreInMethod,
-            Property: checkForTrailingUnderscoreInMethod
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-use-before-define.js
===================================================================
--- node_modules/eslint/lib/rules/no-use-before-define.js	(revision )
+++ node_modules/eslint/lib/rules/no-use-before-define.js	(revision )
@@ -1,264 +0,0 @@
-/**
- * @fileoverview Rule to flag use of variables before they are defined
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;
-const FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/;
-
-/**
- * Parses a given value as options.
- *
- * @param {any} options - A value to parse.
- * @returns {Object} The parsed options.
- */
-function parseOptions(options) {
-    let functions = true;
-    let classes = true;
-    let variables = true;
-
-    if (typeof options === "string") {
-        functions = (options !== "nofunc");
-    } else if (typeof options === "object" && options !== null) {
-        functions = options.functions !== false;
-        classes = options.classes !== false;
-        variables = options.variables !== false;
-    }
-
-    return { functions, classes, variables };
-}
-
-/**
- * Checks whether or not a given variable is a function declaration.
- *
- * @param {eslint-scope.Variable} variable - A variable to check.
- * @returns {boolean} `true` if the variable is a function declaration.
- */
-function isFunction(variable) {
-    return variable.defs[0].type === "FunctionName";
-}
-
-/**
- * Checks whether or not a given variable is a class declaration in an upper function scope.
- *
- * @param {eslint-scope.Variable} variable - A variable to check.
- * @param {eslint-scope.Reference} reference - A reference to check.
- * @returns {boolean} `true` if the variable is a class declaration.
- */
-function isOuterClass(variable, reference) {
-    return (
-        variable.defs[0].type === "ClassName" &&
-        variable.scope.variableScope !== reference.from.variableScope
-    );
-}
-
-/**
-* Checks whether or not a given variable is a variable declaration in an upper function scope.
-* @param {eslint-scope.Variable} variable - A variable to check.
-* @param {eslint-scope.Reference} reference - A reference to check.
-* @returns {boolean} `true` if the variable is a variable declaration.
-*/
-function isOuterVariable(variable, reference) {
-    return (
-        variable.defs[0].type === "Variable" &&
-        variable.scope.variableScope !== reference.from.variableScope
-    );
-}
-
-/**
- * Checks whether or not a given location is inside of the range of a given node.
- *
- * @param {ASTNode} node - An node to check.
- * @param {number} location - A location to check.
- * @returns {boolean} `true` if the location is inside of the range of the node.
- */
-function isInRange(node, location) {
-    return node && node.range[0] <= location && location <= node.range[1];
-}
-
-/**
- * Checks whether or not a given reference is inside of the initializers of a given variable.
- *
- * This returns `true` in the following cases:
- *
- *     var a = a
- *     var [a = a] = list
- *     var {a = a} = obj
- *     for (var a in a) {}
- *     for (var a of a) {}
- *
- * @param {Variable} variable - A variable to check.
- * @param {Reference} reference - A reference to check.
- * @returns {boolean} `true` if the reference is inside of the initializers.
- */
-function isInInitializer(variable, reference) {
-    if (variable.scope !== reference.from) {
-        return false;
-    }
-
-    let node = variable.identifiers[0].parent;
-    const location = reference.identifier.range[1];
-
-    while (node) {
-        if (node.type === "VariableDeclarator") {
-            if (isInRange(node.init, location)) {
-                return true;
-            }
-            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&
-                isInRange(node.parent.parent.right, location)
-            ) {
-                return true;
-            }
-            break;
-        } else if (node.type === "AssignmentPattern") {
-            if (isInRange(node.right, location)) {
-                return true;
-            }
-        } else if (SENTINEL_TYPE.test(node.type)) {
-            break;
-        }
-
-        node = node.parent;
-    }
-
-    return false;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow the use of variables before they are defined",
-            category: "Variables",
-            recommended: false
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["nofunc"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            functions: { type: "boolean" },
-                            classes: { type: "boolean" },
-                            variables: { type: "boolean" }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const options = parseOptions(context.options[0]);
-
-        /**
-         * Determines whether a given use-before-define case should be reported according to the options.
-         * @param {eslint-scope.Variable} variable The variable that gets used before being defined
-         * @param {eslint-scope.Reference} reference The reference to the variable
-         * @returns {boolean} `true` if the usage should be reported
-         */
-        function isForbidden(variable, reference) {
-            if (isFunction(variable)) {
-                return options.functions;
-            }
-            if (isOuterClass(variable, reference)) {
-                return options.classes;
-            }
-            if (isOuterVariable(variable, reference)) {
-                return options.variables;
-            }
-            return true;
-        }
-
-        /**
-         * Finds and validates all variables in a given scope.
-         * @param {Scope} scope The scope object.
-         * @returns {void}
-         * @private
-         */
-        function findVariablesInScope(scope) {
-            scope.references.forEach(reference => {
-                const variable = reference.resolved;
-
-                // Skips when the reference is:
-                // - initialization's.
-                // - referring to an undefined variable.
-                // - referring to a global environment variable (there're no identifiers).
-                // - located preceded by the variable (except in initializers).
-                // - allowed by options.
-                if (reference.init ||
-                    !variable ||
-                    variable.identifiers.length === 0 ||
-                    (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||
-                    !isForbidden(variable, reference)
-                ) {
-                    return;
-                }
-
-                // Reports.
-                context.report({
-                    node: reference.identifier,
-                    message: "'{{name}}' was used before it was defined.",
-                    data: reference.identifier
-                });
-            });
-        }
-
-        /**
-         * Validates variables inside of a node's scope.
-         * @param {ASTNode} node The node to check.
-         * @returns {void}
-         * @private
-         */
-        function findVariables() {
-            const scope = context.getScope();
-
-            findVariablesInScope(scope);
-        }
-
-        const ruleDefinition = {
-            "Program:exit"(node) {
-                const scope = context.getScope(),
-                    ecmaFeatures = context.parserOptions.ecmaFeatures || {};
-
-                findVariablesInScope(scope);
-
-                // both Node.js and Modules have an extra scope
-                if (ecmaFeatures.globalReturn || node.sourceType === "module") {
-                    findVariablesInScope(scope.childScopes[0]);
-                }
-            }
-        };
-
-        if (context.parserOptions.ecmaVersion >= 6) {
-            ruleDefinition["BlockStatement:exit"] =
-                ruleDefinition["SwitchStatement:exit"] = findVariables;
-
-            ruleDefinition["ArrowFunctionExpression:exit"] = function(node) {
-                if (node.body.type !== "BlockStatement") {
-                    findVariables();
-                }
-            };
-        } else {
-            ruleDefinition["FunctionExpression:exit"] =
-                ruleDefinition["FunctionDeclaration:exit"] =
-                ruleDefinition["ArrowFunctionExpression:exit"] = findVariables;
-        }
-
-        return ruleDefinition;
-    }
-};
Index: node_modules/eslint/lib/rules/object-curly-newline.js
===================================================================
--- node_modules/eslint/lib/rules/object-curly-newline.js	(revision )
+++ node_modules/eslint/lib/rules/object-curly-newline.js	(revision )
@@ -1,242 +0,0 @@
-/**
- * @fileoverview Rule to require or disallow line breaks inside braces.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-// Schema objects.
-const OPTION_VALUE = {
-    oneOf: [
-        {
-            enum: ["always", "never"]
-        },
-        {
-            type: "object",
-            properties: {
-                multiline: {
-                    type: "boolean"
-                },
-                minProperties: {
-                    type: "integer",
-                    minimum: 0
-                },
-                consistent: {
-                    type: "boolean"
-                }
-            },
-            additionalProperties: false,
-            minProperties: 1
-        }
-    ]
-};
-
-/**
- * Normalizes a given option value.
- *
- * @param {string|Object|undefined} value - An option value to parse.
- * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.
- */
-function normalizeOptionValue(value) {
-    let multiline = false;
-    let minProperties = Number.POSITIVE_INFINITY;
-    let consistent = false;
-
-    if (value) {
-        if (value === "always") {
-            minProperties = 0;
-        } else if (value === "never") {
-            minProperties = Number.POSITIVE_INFINITY;
-        } else {
-            multiline = Boolean(value.multiline);
-            minProperties = value.minProperties || Number.POSITIVE_INFINITY;
-            consistent = Boolean(value.consistent);
-        }
-    } else {
-        multiline = true;
-    }
-
-    return { multiline, minProperties, consistent };
-}
-
-/**
- * Normalizes a given option value.
- *
- * @param {string|Object|undefined} options - An option value to parse.
- * @returns {{ObjectExpression: {multiline: boolean, minProperties: number}, ObjectPattern: {multiline: boolean, minProperties: number}}} Normalized option object.
- */
-function normalizeOptions(options) {
-    if (options && (options.ObjectExpression || options.ObjectPattern)) {
-        return {
-            ObjectExpression: normalizeOptionValue(options.ObjectExpression),
-            ObjectPattern: normalizeOptionValue(options.ObjectPattern)
-        };
-    }
-
-    const value = normalizeOptionValue(options);
-
-    return { ObjectExpression: value, ObjectPattern: value };
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent line breaks inside braces",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "whitespace",
-        schema: [
-            {
-                oneOf: [
-                    OPTION_VALUE,
-                    {
-                        type: "object",
-                        properties: {
-                            ObjectExpression: OPTION_VALUE,
-                            ObjectPattern: OPTION_VALUE
-                        },
-                        additionalProperties: false,
-                        minProperties: 1
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const normalizedOptions = normalizeOptions(context.options[0]);
-
-        /**
-         * Reports a given node if it violated this rule.
-         *
-         * @param {ASTNode} node - A node to check. This is an ObjectExpression node or an ObjectPattern node.
-         * @param {{multiline: boolean, minProperties: number}} options - An option object.
-         * @returns {void}
-         */
-        function check(node) {
-            const options = normalizedOptions[node.type];
-            const openBrace = sourceCode.getFirstToken(node);
-            const closeBrace = sourceCode.getLastToken(node);
-            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });
-            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });
-            const needsLinebreaks = (
-                node.properties.length >= options.minProperties ||
-                (
-                    options.multiline &&
-                    node.properties.length > 0 &&
-                    first.loc.start.line !== last.loc.end.line
-                )
-            );
-            const hasCommentsFirstToken = astUtils.isCommentToken(first);
-            const hasCommentsLastToken = astUtils.isCommentToken(last);
-
-            /*
-             * Use tokens or comments to check multiline or not.
-             * But use only tokens to check whether line breaks are needed.
-             * This allows:
-             *     var obj = { // eslint-disable-line foo
-             *         a: 1
-             *     }
-             */
-            first = sourceCode.getTokenAfter(openBrace);
-            last = sourceCode.getTokenBefore(closeBrace);
-
-            if (needsLinebreaks) {
-                if (astUtils.isTokenOnSameLine(openBrace, first)) {
-                    context.report({
-                        message: "Expected a line break after this opening brace.",
-                        node,
-                        loc: openBrace.loc.start,
-                        fix(fixer) {
-                            if (hasCommentsFirstToken) {
-                                return null;
-                            }
-
-                            return fixer.insertTextAfter(openBrace, "\n");
-                        }
-                    });
-                }
-                if (astUtils.isTokenOnSameLine(last, closeBrace)) {
-                    context.report({
-                        message: "Expected a line break before this closing brace.",
-                        node,
-                        loc: closeBrace.loc.start,
-                        fix(fixer) {
-                            if (hasCommentsLastToken) {
-                                return null;
-                            }
-
-                            return fixer.insertTextBefore(closeBrace, "\n");
-                        }
-                    });
-                }
-            } else {
-                const consistent = options.consistent;
-                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);
-                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);
-
-                if (
-                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||
-                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)
-                ) {
-                    context.report({
-                        message: "Unexpected line break after this opening brace.",
-                        node,
-                        loc: openBrace.loc.start,
-                        fix(fixer) {
-                            if (hasCommentsFirstToken) {
-                                return null;
-                            }
-
-                            return fixer.removeRange([
-                                openBrace.range[1],
-                                first.range[0]
-                            ]);
-                        }
-                    });
-                }
-                if (
-                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||
-                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)
-                ) {
-                    context.report({
-                        message: "Unexpected line break before this closing brace.",
-                        node,
-                        loc: closeBrace.loc.start,
-                        fix(fixer) {
-                            if (hasCommentsLastToken) {
-                                return null;
-                            }
-
-                            return fixer.removeRange([
-                                last.range[1],
-                                closeBrace.range[0]
-                            ]);
-                        }
-                    });
-                }
-            }
-        }
-
-        return {
-            ObjectExpression: check,
-            ObjectPattern: check
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/object-curly-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/object-curly-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/object-curly-spacing.js	(revision )
@@ -1,299 +0,0 @@
-/**
- * @fileoverview Disallows or enforces spaces inside of object literals.
- * @author Jamund Ferguson
- */
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing inside braces",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                enum: ["always", "never"]
-            },
-            {
-                type: "object",
-                properties: {
-                    arraysInObjects: {
-                        type: "boolean"
-                    },
-                    objectsInObjects: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const spaced = context.options[0] === "always",
-            sourceCode = context.getSourceCode();
-
-        /**
-         * Determines whether an option is set, relative to the spacing option.
-         * If spaced is "always", then check whether option is set to false.
-         * If spaced is "never", then check whether option is set to true.
-         * @param {Object} option - The option to exclude.
-         * @returns {boolean} Whether or not the property is excluded.
-         */
-        function isOptionSet(option) {
-            return context.options[1] ? context.options[1][option] === !spaced : false;
-        }
-
-        const options = {
-            spaced,
-            arraysInObjectsException: isOptionSet("arraysInObjects"),
-            objectsInObjectsException: isOptionSet("objectsInObjects")
-        };
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-        * Reports that there shouldn't be a space after the first token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportNoBeginningSpace(node, token) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "There should be no space after '{{token}}'.",
-                data: {
-                    token: token.value
-                },
-                fix(fixer) {
-                    const nextToken = context.getSourceCode().getTokenAfter(token);
-
-                    return fixer.removeRange([token.range[1], nextToken.range[0]]);
-                }
-            });
-        }
-
-        /**
-        * Reports that there shouldn't be a space before the last token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportNoEndingSpace(node, token) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "There should be no space before '{{token}}'.",
-                data: {
-                    token: token.value
-                },
-                fix(fixer) {
-                    const previousToken = context.getSourceCode().getTokenBefore(token);
-
-                    return fixer.removeRange([previousToken.range[1], token.range[0]]);
-                }
-            });
-        }
-
-        /**
-        * Reports that there should be a space after the first token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportRequiredBeginningSpace(node, token) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "A space is required after '{{token}}'.",
-                data: {
-                    token: token.value
-                },
-                fix(fixer) {
-                    return fixer.insertTextAfter(token, " ");
-                }
-            });
-        }
-
-        /**
-        * Reports that there should be a space before the last token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportRequiredEndingSpace(node, token) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "A space is required before '{{token}}'.",
-                data: {
-                    token: token.value
-                },
-                fix(fixer) {
-                    return fixer.insertTextBefore(token, " ");
-                }
-            });
-        }
-
-        /**
-         * Determines if spacing in curly braces is valid.
-         * @param {ASTNode} node The AST node to check.
-         * @param {Token} first The first token to check (should be the opening brace)
-         * @param {Token} second The second token to check (should be first after the opening brace)
-         * @param {Token} penultimate The penultimate token to check (should be last before closing brace)
-         * @param {Token} last The last token to check (should be closing brace)
-         * @returns {void}
-         */
-        function validateBraceSpacing(node, first, second, penultimate, last) {
-            if (astUtils.isTokenOnSameLine(first, second)) {
-                const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);
-
-                if (options.spaced && !firstSpaced) {
-                    reportRequiredBeginningSpace(node, first);
-                }
-                if (!options.spaced && firstSpaced) {
-                    reportNoBeginningSpace(node, first);
-                }
-            }
-
-            if (astUtils.isTokenOnSameLine(penultimate, last)) {
-                const shouldCheckPenultimate = (
-                    options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) ||
-                    options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate)
-                );
-                const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;
-
-                const closingCurlyBraceMustBeSpaced = (
-                    options.arraysInObjectsException && penultimateType === "ArrayExpression" ||
-                    options.objectsInObjectsException && (penultimateType === "ObjectExpression" || penultimateType === "ObjectPattern")
-                ) ? !options.spaced : options.spaced;
-
-                const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);
-
-                if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
-                    reportRequiredEndingSpace(node, last);
-                }
-                if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
-                    reportNoEndingSpace(node, last);
-                }
-            }
-        }
-
-        /**
-         * Gets '}' token of an object node.
-         *
-         * Because the last token of object patterns might be a type annotation,
-         * this traverses tokens preceded by the last property, then returns the
-         * first '}' token.
-         *
-         * @param {ASTNode} node - The node to get. This node is an
-         *      ObjectExpression or an ObjectPattern. And this node has one or
-         *      more properties.
-         * @returns {Token} '}' token.
-         */
-        function getClosingBraceOfObject(node) {
-            const lastProperty = node.properties[node.properties.length - 1];
-
-            return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);
-        }
-
-        /**
-         * Reports a given object node if spacing in curly braces is invalid.
-         * @param {ASTNode} node - An ObjectExpression or ObjectPattern node to check.
-         * @returns {void}
-         */
-        function checkForObject(node) {
-            if (node.properties.length === 0) {
-                return;
-            }
-
-            const first = sourceCode.getFirstToken(node),
-                last = getClosingBraceOfObject(node),
-                second = sourceCode.getTokenAfter(first),
-                penultimate = sourceCode.getTokenBefore(last);
-
-            validateBraceSpacing(node, first, second, penultimate, last);
-        }
-
-        /**
-         * Reports a given import node if spacing in curly braces is invalid.
-         * @param {ASTNode} node - An ImportDeclaration node to check.
-         * @returns {void}
-         */
-        function checkForImport(node) {
-            if (node.specifiers.length === 0) {
-                return;
-            }
-
-            let firstSpecifier = node.specifiers[0];
-            const lastSpecifier = node.specifiers[node.specifiers.length - 1];
-
-            if (lastSpecifier.type !== "ImportSpecifier") {
-                return;
-            }
-            if (firstSpecifier.type !== "ImportSpecifier") {
-                firstSpecifier = node.specifiers[1];
-            }
-
-            const first = sourceCode.getTokenBefore(firstSpecifier),
-                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),
-                second = sourceCode.getTokenAfter(first),
-                penultimate = sourceCode.getTokenBefore(last);
-
-            validateBraceSpacing(node, first, second, penultimate, last);
-        }
-
-        /**
-         * Reports a given export node if spacing in curly braces is invalid.
-         * @param {ASTNode} node - An ExportNamedDeclaration node to check.
-         * @returns {void}
-         */
-        function checkForExport(node) {
-            if (node.specifiers.length === 0) {
-                return;
-            }
-
-            const firstSpecifier = node.specifiers[0],
-                lastSpecifier = node.specifiers[node.specifiers.length - 1],
-                first = sourceCode.getTokenBefore(firstSpecifier),
-                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),
-                second = sourceCode.getTokenAfter(first),
-                penultimate = sourceCode.getTokenBefore(last);
-
-            validateBraceSpacing(node, first, second, penultimate, last);
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-
-            // var {x} = y;
-            ObjectPattern: checkForObject,
-
-            // var y = {x: 'y'}
-            ObjectExpression: checkForObject,
-
-            // import {y} from 'x';
-            ImportDeclaration: checkForImport,
-
-            // export {name} from 'yo';
-            ExportNamedDeclaration: checkForExport
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/prefer-destructuring.js
===================================================================
--- node_modules/eslint/lib/rules/prefer-destructuring.js	(revision )
+++ node_modules/eslint/lib/rules/prefer-destructuring.js	(revision )
@@ -1,215 +0,0 @@
-/**
- * @fileoverview Prefer destructuring from arrays and objects
- * @author Alex LaFroscia
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require destructuring from arrays and/or objects",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-        schema: [
-            {
-
-                // old support {array: Boolean, object: Boolean}
-                // new support {VariableDeclarator: {}, AssignmentExpression: {}}
-                oneOf: [
-                    {
-                        type: "object",
-                        properties: {
-                            VariableDeclarator: {
-                                type: "object",
-                                properties: {
-                                    array: {
-                                        type: "boolean"
-                                    },
-                                    object: {
-                                        type: "boolean"
-                                    }
-                                },
-                                additionalProperties: false
-                            },
-                            AssignmentExpression: {
-                                type: "object",
-                                properties: {
-                                    array: {
-                                        type: "boolean"
-                                    },
-                                    object: {
-                                        type: "boolean"
-                                    }
-                                },
-                                additionalProperties: false
-                            }
-                        },
-                        additionalProperties: false
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            array: {
-                                type: "boolean"
-                            },
-                            object: {
-                                type: "boolean"
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            },
-            {
-                type: "object",
-                properties: {
-                    enforceForRenamedProperties: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-    create(context) {
-
-        const enabledTypes = context.options[0];
-        const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;
-        let normalizedOptions = {
-            VariableDeclarator: { array: true, object: true },
-            AssignmentExpression: { array: true, object: true }
-        };
-
-        if (enabledTypes) {
-            normalizedOptions = typeof enabledTypes.array !== "undefined" || typeof enabledTypes.object !== "undefined"
-                ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes }
-                : enabledTypes;
-        }
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * @param {string} nodeType "AssignmentExpression" or "VariableDeclarator"
-         * @param {string} destructuringType "array" or "object"
-         * @returns {boolean} `true` if the destructuring type should be checked for the given node
-         */
-        function shouldCheck(nodeType, destructuringType) {
-            return normalizedOptions &&
-                normalizedOptions[nodeType] &&
-                normalizedOptions[nodeType][destructuringType];
-        }
-
-        /**
-         * Determines if the given node is accessing an array index
-         *
-         * This is used to differentiate array index access from object property
-         * access.
-         *
-         * @param {ASTNode} node the node to evaluate
-         * @returns {boolean} whether or not the node is an integer
-         */
-        function isArrayIndexAccess(node) {
-            return Number.isInteger(node.property.value);
-        }
-
-        /**
-         * Report that the given node should use destructuring
-         *
-         * @param {ASTNode} reportNode the node to report
-         * @param {string} type the type of destructuring that should have been done
-         * @returns {void}
-         */
-        function report(reportNode, type) {
-            context.report({ node: reportNode, message: "Use {{type}} destructuring.", data: { type } });
-        }
-
-        /**
-         * Check that the `prefer-destructuring` rules are followed based on the
-         * given left- and right-hand side of the assignment.
-         *
-         * Pulled out into a separate method so that VariableDeclarators and
-         * AssignmentExpressions can share the same verification logic.
-         *
-         * @param {ASTNode} leftNode the left-hand side of the assignment
-         * @param {ASTNode} rightNode the right-hand side of the assignment
-         * @param {ASTNode} reportNode the node to report the error on
-         * @returns {void}
-         */
-        function performCheck(leftNode, rightNode, reportNode) {
-            if (rightNode.type !== "MemberExpression") {
-                return;
-            }
-
-            if (isArrayIndexAccess(rightNode)) {
-                if (shouldCheck(reportNode.type, "array")) {
-                    report(reportNode, "array");
-                }
-                return;
-            }
-
-            if (shouldCheck(reportNode.type, "object") && enforceForRenamedProperties) {
-                report(reportNode, "object");
-                return;
-            }
-
-            if (shouldCheck(reportNode.type, "object")) {
-                const property = rightNode.property;
-
-                if ((property.type === "Literal" && leftNode.name === property.value) || (property.type === "Identifier" &&
-                    leftNode.name === property.name)) {
-                    report(reportNode, "object");
-                }
-            }
-        }
-
-        /**
-         * Check if a given variable declarator is coming from an property access
-         * that should be using destructuring instead
-         *
-         * @param {ASTNode} node the variable declarator to check
-         * @returns {void}
-         */
-        function checkVariableDeclarator(node) {
-
-            // Skip if variable is declared without assignment
-            if (!node.init) {
-                return;
-            }
-
-            // We only care about member expressions past this point
-            if (node.init.type !== "MemberExpression") {
-                return;
-            }
-
-            performCheck(node.id, node.init, node);
-        }
-
-        /**
-         * Run the `prefer-destructuring` check on an AssignmentExpression
-         *
-         * @param {ASTNode} node the AssignmentExpression node
-         * @returns {void}
-         */
-        function checkAssigmentExpression(node) {
-            if (node.operator === "=") {
-                performCheck(node.left, node.right, node);
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            VariableDeclarator: checkVariableDeclarator,
-            AssignmentExpression: checkAssigmentExpression
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/switch-colon-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/switch-colon-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/switch-colon-spacing.js	(revision )
@@ -1,133 +0,0 @@
-/**
- * @fileoverview Rule to enforce spacing around colons of switch statements.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce spacing around colons of switch statements",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    before: { type: "boolean" },
-                    after: { type: "boolean" }
-                },
-                additionalProperties: false
-            }
-        ],
-        fixable: "whitespace"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const options = context.options[0] || {};
-        const beforeSpacing = options.before === true; // false by default
-        const afterSpacing = options.after !== false; // true by default
-
-        /**
-         * Get the colon token of the given SwitchCase node.
-         * @param {ASTNode} node The SwitchCase node to get.
-         * @returns {Token} The colon token of the node.
-         */
-        function getColonToken(node) {
-            if (node.test) {
-                return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);
-            }
-            return sourceCode.getFirstToken(node, 1);
-        }
-
-        /**
-         * Check whether the spacing between the given 2 tokens is valid or not.
-         * @param {Token} left The left token to check.
-         * @param {Token} right The right token to check.
-         * @param {boolean} expected The expected spacing to check. `true` if there should be a space.
-         * @returns {boolean} `true` if the spacing between the tokens is valid.
-         */
-        function isValidSpacing(left, right, expected) {
-            return (
-                astUtils.isClosingBraceToken(right) ||
-                !astUtils.isTokenOnSameLine(left, right) ||
-                sourceCode.isSpaceBetweenTokens(left, right) === expected
-            );
-        }
-
-        /**
-         * Check whether comments exist between the given 2 tokens.
-         * @param {Token} left The left token to check.
-         * @param {Token} right The right token to check.
-         * @returns {boolean} `true` if comments exist between the given 2 tokens.
-         */
-        function commentsExistBetween(left, right) {
-            return sourceCode.getFirstTokenBetween(
-                left,
-                right,
-                {
-                    includeComments: true,
-                    filter: astUtils.isCommentToken
-                }
-            ) !== null;
-        }
-
-        /**
-         * Fix the spacing between the given 2 tokens.
-         * @param {RuleFixer} fixer The fixer to fix.
-         * @param {Token} left The left token of fix range.
-         * @param {Token} right The right token of fix range.
-         * @param {boolean} spacing The spacing style. `true` if there should be a space.
-         * @returns {Fix|null} The fix object.
-         */
-        function fix(fixer, left, right, spacing) {
-            if (commentsExistBetween(left, right)) {
-                return null;
-            }
-            if (spacing) {
-                return fixer.insertTextAfter(left, " ");
-            }
-            return fixer.removeRange([left.range[1], right.range[0]]);
-        }
-
-        return {
-            SwitchCase(node) {
-                const colonToken = getColonToken(node);
-                const beforeToken = sourceCode.getTokenBefore(colonToken);
-                const afterToken = sourceCode.getTokenAfter(colonToken);
-
-                if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {
-                    context.report({
-                        node,
-                        loc: colonToken.loc,
-                        message: "{{verb}} space(s) before this colon.",
-                        data: { verb: beforeSpacing ? "Expected" : "Unexpected" },
-                        fix: fixer => fix(fixer, beforeToken, colonToken, beforeSpacing)
-                    });
-                }
-                if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {
-                    context.report({
-                        node,
-                        loc: colonToken.loc,
-                        message: "{{verb}} space(s) after this colon.",
-                        data: { verb: afterSpacing ? "Expected" : "Unexpected" },
-                        fix: fixer => fix(fixer, colonToken, afterToken, afterSpacing)
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/template-tag-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/template-tag-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/template-tag-spacing.js	(revision )
@@ -1,77 +0,0 @@
-/**
- * @fileoverview Rule to check spacing between template tags and their literals
- * @author Jonathan Wilsson
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow spacing between template tags and their literals",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            { enum: ["always", "never"] }
-        ]
-    },
-
-    create(context) {
-        const never = context.options[0] !== "always";
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Check if a space is present between a template tag and its literal
-         * @param {ASTNode} node node to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkSpacing(node) {
-            const tagToken = sourceCode.getTokenBefore(node.quasi);
-            const literalToken = sourceCode.getFirstToken(node.quasi);
-            const hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);
-
-            if (never && hasWhitespace) {
-                context.report({
-                    node,
-                    loc: tagToken.loc.start,
-                    message: "Unexpected space between template tag and template literal.",
-                    fix(fixer) {
-                        const comments = sourceCode.getCommentsBefore(node.quasi);
-
-                        // Don't fix anything if there's a single line comment after the template tag
-                        if (comments.some(comment => comment.type === "Line")) {
-                            return null;
-                        }
-
-                        return fixer.replaceTextRange(
-                            [tagToken.range[1], literalToken.range[0]],
-                            comments.reduce((text, comment) => text + sourceCode.getText(comment), "")
-                        );
-                    }
-                });
-            } else if (!never && !hasWhitespace) {
-                context.report({
-                    node,
-                    loc: tagToken.loc.start,
-                    message: "Missing space between template tag and template literal.",
-                    fix(fixer) {
-                        return fixer.insertTextAfter(tagToken, " ");
-                    }
-                });
-            }
-        }
-
-        return {
-            TaggedTemplateExpression: checkSpacing
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/array-bracket-newline.js
===================================================================
--- node_modules/eslint/lib/rules/array-bracket-newline.js	(revision )
+++ node_modules/eslint/lib/rules/array-bracket-newline.js	(revision )
@@ -1,235 +0,0 @@
-/**
- * @fileoverview Rule to enforce linebreaks after open and before close array brackets
- * @author Jan Peer Stöcklmair <https://github.com/JPeer264>
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce linebreaks after opening and before closing array brackets",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "whitespace",
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["always", "never"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            multiline: {
-                                type: "boolean"
-                            },
-                            minItems: {
-                                type: ["integer", "null"],
-                                minimum: 0
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-
-        //----------------------------------------------------------------------
-        // Helpers
-        //----------------------------------------------------------------------
-
-        /**
-         * Normalizes a given option value.
-         *
-         * @param {string|Object|undefined} option - An option value to parse.
-         * @returns {{multiline: boolean, minItems: number}} Normalized option object.
-         */
-        function normalizeOptionValue(option) {
-            let multiline = false;
-            let minItems = 0;
-
-            if (option) {
-                if (option === "always" || option.minItems === 0) {
-                    minItems = 0;
-                } else if (option === "never") {
-                    minItems = Number.POSITIVE_INFINITY;
-                } else {
-                    multiline = Boolean(option.multiline);
-                    minItems = option.minItems || Number.POSITIVE_INFINITY;
-                }
-            } else {
-                multiline = true;
-                minItems = Number.POSITIVE_INFINITY;
-            }
-
-            return { multiline, minItems };
-        }
-
-        /**
-         * Normalizes a given option value.
-         *
-         * @param {string|Object|undefined} options - An option value to parse.
-         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.
-         */
-        function normalizeOptions(options) {
-            const value = normalizeOptionValue(options);
-
-            return { ArrayExpression: value, ArrayPattern: value };
-        }
-
-        /**
-        * Reports that there shouldn't be a linebreak after the first token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportNoBeginningLinebreak(node, token) {
-            context.report({
-                node,
-                loc: token.loc,
-                message: "There should be no linebreak after '['.",
-                fix(fixer) {
-                    const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });
-
-                    if (astUtils.isCommentToken(nextToken)) {
-                        return null;
-                    }
-
-                    return fixer.removeRange([token.range[1], nextToken.range[0]]);
-                }
-            });
-        }
-
-        /**
-        * Reports that there shouldn't be a linebreak before the last token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportNoEndingLinebreak(node, token) {
-            context.report({
-                node,
-                loc: token.loc,
-                message: "There should be no linebreak before ']'.",
-                fix(fixer) {
-                    const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });
-
-                    if (astUtils.isCommentToken(previousToken)) {
-                        return null;
-                    }
-
-                    return fixer.removeRange([previousToken.range[1], token.range[0]]);
-                }
-            });
-        }
-
-        /**
-        * Reports that there should be a linebreak after the first token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportRequiredBeginningLinebreak(node, token) {
-            context.report({
-                node,
-                loc: token.loc,
-                message: "A linebreak is required after '['.",
-                fix(fixer) {
-                    return fixer.insertTextAfter(token, "\n");
-                }
-            });
-        }
-
-        /**
-        * Reports that there should be a linebreak before the last token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportRequiredEndingLinebreak(node, token) {
-            context.report({
-                node,
-                loc: token.loc,
-                message: "A linebreak is required before ']'.",
-                fix(fixer) {
-                    return fixer.insertTextBefore(token, "\n");
-                }
-            });
-        }
-
-        /**
-         * Reports a given node if it violated this rule.
-         *
-         * @param {ASTNode} node - A node to check. This is an ObjectExpression node or an ObjectPattern node.
-         * @param {{multiline: boolean, minItems: number}} options - An option object.
-         * @returns {void}
-         */
-        function check(node) {
-            const elements = node.elements;
-            const normalizedOptions = normalizeOptions(context.options[0]);
-            const options = normalizedOptions[node.type];
-            const openBracket = sourceCode.getFirstToken(node);
-            const closeBracket = sourceCode.getLastToken(node);
-            const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });
-            const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });
-            const first = sourceCode.getTokenAfter(openBracket);
-            const last = sourceCode.getTokenBefore(closeBracket);
-
-            const needsLinebreaks = (
-                elements.length >= options.minItems ||
-                (
-                    options.multiline &&
-                    elements.length > 0 &&
-                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line
-                )
-            );
-
-            /*
-             * Use tokens or comments to check multiline or not.
-             * But use only tokens to check whether linebreaks are needed.
-             * This allows:
-             *     var arr = [ // eslint-disable-line foo
-             *         'a'
-             *     ]
-             */
-
-            if (needsLinebreaks) {
-                if (astUtils.isTokenOnSameLine(openBracket, first)) {
-                    reportRequiredBeginningLinebreak(node, openBracket);
-                }
-                if (astUtils.isTokenOnSameLine(last, closeBracket)) {
-                    reportRequiredEndingLinebreak(node, closeBracket);
-                }
-            } else {
-                if (!astUtils.isTokenOnSameLine(openBracket, first)) {
-                    reportNoBeginningLinebreak(node, openBracket);
-                }
-                if (!astUtils.isTokenOnSameLine(last, closeBracket)) {
-                    reportNoEndingLinebreak(node, closeBracket);
-                }
-            }
-        }
-
-        //----------------------------------------------------------------------
-        // Public
-        //----------------------------------------------------------------------
-
-        return {
-            ArrayPattern: check,
-            ArrayExpression: check
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/array-bracket-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/array-bracket-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/array-bracket-spacing.js	(revision )
@@ -1,229 +0,0 @@
-/**
- * @fileoverview Disallows or enforces spaces inside of array brackets.
- * @author Jamund Ferguson
- */
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing inside array brackets",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "whitespace",
-        schema: [
-            {
-                enum: ["always", "never"]
-            },
-            {
-                type: "object",
-                properties: {
-                    singleValue: {
-                        type: "boolean"
-                    },
-                    objectsInArrays: {
-                        type: "boolean"
-                    },
-                    arraysInArrays: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-    create(context) {
-        const spaced = context.options[0] === "always",
-            sourceCode = context.getSourceCode();
-
-        /**
-         * Determines whether an option is set, relative to the spacing option.
-         * If spaced is "always", then check whether option is set to false.
-         * If spaced is "never", then check whether option is set to true.
-         * @param {Object} option - The option to exclude.
-         * @returns {boolean} Whether or not the property is excluded.
-         */
-        function isOptionSet(option) {
-            return context.options[1] ? context.options[1][option] === !spaced : false;
-        }
-
-        const options = {
-            spaced,
-            singleElementException: isOptionSet("singleValue"),
-            objectsInArraysException: isOptionSet("objectsInArrays"),
-            arraysInArraysException: isOptionSet("arraysInArrays")
-        };
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-        * Reports that there shouldn't be a space after the first token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportNoBeginningSpace(node, token) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "There should be no space after '{{tokenValue}}'.",
-                data: {
-                    tokenValue: token.value
-                },
-                fix(fixer) {
-                    const nextToken = sourceCode.getTokenAfter(token);
-
-                    return fixer.removeRange([token.range[1], nextToken.range[0]]);
-                }
-            });
-        }
-
-        /**
-        * Reports that there shouldn't be a space before the last token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportNoEndingSpace(node, token) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "There should be no space before '{{tokenValue}}'.",
-                data: {
-                    tokenValue: token.value
-                },
-                fix(fixer) {
-                    const previousToken = sourceCode.getTokenBefore(token);
-
-                    return fixer.removeRange([previousToken.range[1], token.range[0]]);
-                }
-            });
-        }
-
-        /**
-        * Reports that there should be a space after the first token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportRequiredBeginningSpace(node, token) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "A space is required after '{{tokenValue}}'.",
-                data: {
-                    tokenValue: token.value
-                },
-                fix(fixer) {
-                    return fixer.insertTextAfter(token, " ");
-                }
-            });
-        }
-
-        /**
-        * Reports that there should be a space before the last token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportRequiredEndingSpace(node, token) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "A space is required before '{{tokenValue}}'.",
-                data: {
-                    tokenValue: token.value
-                },
-                fix(fixer) {
-                    return fixer.insertTextBefore(token, " ");
-                }
-            });
-        }
-
-        /**
-        * Determines if a node is an object type
-        * @param {ASTNode} node - The node to check.
-        * @returns {boolean} Whether or not the node is an object type.
-        */
-        function isObjectType(node) {
-            return node && (node.type === "ObjectExpression" || node.type === "ObjectPattern");
-        }
-
-        /**
-        * Determines if a node is an array type
-        * @param {ASTNode} node - The node to check.
-        * @returns {boolean} Whether or not the node is an array type.
-        */
-        function isArrayType(node) {
-            return node && (node.type === "ArrayExpression" || node.type === "ArrayPattern");
-        }
-
-        /**
-         * Validates the spacing around array brackets
-         * @param {ASTNode} node - The node we're checking for spacing
-         * @returns {void}
-         */
-        function validateArraySpacing(node) {
-            if (options.spaced && node.elements.length === 0) {
-                return;
-            }
-
-            const first = sourceCode.getFirstToken(node),
-                second = sourceCode.getFirstToken(node, 1),
-                last = node.typeAnnotation
-                    ? sourceCode.getTokenBefore(node.typeAnnotation)
-                    : sourceCode.getLastToken(node),
-                penultimate = sourceCode.getTokenBefore(last),
-                firstElement = node.elements[0],
-                lastElement = node.elements[node.elements.length - 1];
-
-            const openingBracketMustBeSpaced =
-                options.objectsInArraysException && isObjectType(firstElement) ||
-                options.arraysInArraysException && isArrayType(firstElement) ||
-                options.singleElementException && node.elements.length === 1
-                    ? !options.spaced : options.spaced;
-
-            const closingBracketMustBeSpaced =
-                options.objectsInArraysException && isObjectType(lastElement) ||
-                options.arraysInArraysException && isArrayType(lastElement) ||
-                options.singleElementException && node.elements.length === 1
-                    ? !options.spaced : options.spaced;
-
-            if (astUtils.isTokenOnSameLine(first, second)) {
-                if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {
-                    reportRequiredBeginningSpace(node, first);
-                }
-                if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {
-                    reportNoBeginningSpace(node, first);
-                }
-            }
-
-            if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {
-                if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {
-                    reportRequiredEndingSpace(node, last);
-                }
-                if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {
-                    reportNoEndingSpace(node, last);
-                }
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            ArrayPattern: validateArraySpacing,
-            ArrayExpression: validateArraySpacing
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/array-callback-return.js
===================================================================
--- node_modules/eslint/lib/rules/array-callback-return.js	(revision )
+++ node_modules/eslint/lib/rules/array-callback-return.js	(revision )
@@ -1,228 +0,0 @@
-/**
- * @fileoverview Rule to enforce return statements in callbacks of array's methods
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;
-const TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/;
-
-/**
- * Checks a given code path segment is reachable.
- *
- * @param {CodePathSegment} segment - A segment to check.
- * @returns {boolean} `true` if the segment is reachable.
- */
-function isReachable(segment) {
-    return segment.reachable;
-}
-
-/**
- * Gets a readable location.
- *
- * - FunctionExpression -> the function name or `function` keyword.
- * - ArrowFunctionExpression -> `=>` token.
- *
- * @param {ASTNode} node - A function node to get.
- * @param {SourceCode} sourceCode - A source code to get tokens.
- * @returns {ASTNode|Token} The node or the token of a location.
- */
-function getLocation(node, sourceCode) {
-    if (node.type === "ArrowFunctionExpression") {
-        return sourceCode.getTokenBefore(node.body);
-    }
-    return node.id || node;
-}
-
-/**
- * Checks a given node is a MemberExpression node which has the specified name's
- * property.
- *
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} `true` if the node is a MemberExpression node which has
- *      the specified name's property
- */
-function isTargetMethod(node) {
-    return (
-        node.type === "MemberExpression" &&
-        TARGET_METHODS.test(astUtils.getStaticPropertyName(node) || "")
-    );
-}
-
-/**
- * Checks whether or not a given node is a function expression which is the
- * callback of an array method.
- *
- * @param {ASTNode} node - A node to check. This is one of
- *      FunctionExpression or ArrowFunctionExpression.
- * @returns {boolean} `true` if the node is the callback of an array method.
- */
-function isCallbackOfArrayMethod(node) {
-    while (node) {
-        const parent = node.parent;
-
-        switch (parent.type) {
-
-            /*
-             * Looks up the destination. e.g.,
-             * foo.every(nativeFoo || function foo() { ... });
-             */
-            case "LogicalExpression":
-            case "ConditionalExpression":
-                node = parent;
-                break;
-
-            // If the upper function is IIFE, checks the destination of the return value.
-            // e.g.
-            //   foo.every((function() {
-            //     // setup...
-            //     return function callback() { ... };
-            //   })());
-            case "ReturnStatement": {
-                const func = astUtils.getUpperFunction(parent);
-
-                if (func === null || !astUtils.isCallee(func)) {
-                    return false;
-                }
-                node = func.parent;
-                break;
-            }
-
-            // e.g.
-            //   Array.from([], function() {});
-            //   list.every(function() {});
-            case "CallExpression":
-                if (astUtils.isArrayFromMethod(parent.callee)) {
-                    return (
-                        parent.arguments.length >= 2 &&
-                        parent.arguments[1] === node
-                    );
-                }
-                if (isTargetMethod(parent.callee)) {
-                    return (
-                        parent.arguments.length >= 1 &&
-                        parent.arguments[0] === node
-                    );
-                }
-                return false;
-
-            // Otherwise this node is not target.
-            default:
-                return false;
-        }
-    }
-
-    /* istanbul ignore next: unreachable */
-    return false;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce `return` statements in callbacks of array methods",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        let funcInfo = {
-            upper: null,
-            codePath: null,
-            hasReturn: false,
-            shouldCheck: false,
-            node: null
-        };
-
-        /**
-         * Checks whether or not the last code path segment is reachable.
-         * Then reports this function if the segment is reachable.
-         *
-         * If the last code path segment is reachable, there are paths which are not
-         * returned or thrown.
-         *
-         * @param {ASTNode} node - A node to check.
-         * @returns {void}
-         */
-        function checkLastSegment(node) {
-            if (funcInfo.shouldCheck &&
-                funcInfo.codePath.currentSegments.some(isReachable)
-            ) {
-                context.report({
-                    node,
-                    loc: getLocation(node, context.getSourceCode()).loc.start,
-                    message: funcInfo.hasReturn
-                        ? "Expected to return a value at the end of {{name}}."
-                        : "Expected to return a value in {{name}}.",
-                    data: {
-                        name: astUtils.getFunctionNameWithKind(funcInfo.node)
-                    }
-                });
-            }
-        }
-
-        return {
-
-            // Stacks this function's information.
-            onCodePathStart(codePath, node) {
-                funcInfo = {
-                    upper: funcInfo,
-                    codePath,
-                    hasReturn: false,
-                    shouldCheck:
-                        TARGET_NODE_TYPE.test(node.type) &&
-                        node.body.type === "BlockStatement" &&
-                        isCallbackOfArrayMethod(node) &&
-                        !node.async &&
-                        !node.generator,
-                    node
-                };
-            },
-
-            // Pops this function's information.
-            onCodePathEnd() {
-                funcInfo = funcInfo.upper;
-            },
-
-            // Checks the return statement is valid.
-            ReturnStatement(node) {
-                if (funcInfo.shouldCheck) {
-                    funcInfo.hasReturn = true;
-
-                    if (!node.argument) {
-                        context.report({
-                            node,
-                            message: "{{name}} expected a return value.",
-                            data: {
-                                name: lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))
-                            }
-                        });
-                    }
-                }
-            },
-
-            // Reports a given function if the last path is reachable.
-            "FunctionExpression:exit": checkLastSegment,
-            "ArrowFunctionExpression:exit": checkLastSegment
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/array-element-newline.js
===================================================================
--- node_modules/eslint/lib/rules/array-element-newline.js	(revision )
+++ node_modules/eslint/lib/rules/array-element-newline.js	(revision )
@@ -1,230 +0,0 @@
-/**
- * @fileoverview Rule to enforce line breaks after each array element
- * @author Jan Peer Stöcklmair <https://github.com/JPeer264>
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce line breaks after each array element",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "whitespace",
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["always", "never"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            multiline: {
-                                type: "boolean"
-                            },
-                            minItems: {
-                                type: ["integer", "null"],
-                                minimum: 0
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        //----------------------------------------------------------------------
-        // Helpers
-        //----------------------------------------------------------------------
-
-        /**
-         * Normalizes a given option value.
-         *
-         * @param {string|Object|undefined} option - An option value to parse.
-         * @returns {{multiline: boolean, minItems: number}} Normalized option object.
-         */
-        function normalizeOptionValue(option) {
-            let multiline = false;
-            let minItems;
-
-            option = option || "always";
-
-            if (option === "always" || option.minItems === 0) {
-                minItems = 0;
-            } else if (option === "never") {
-                minItems = Number.POSITIVE_INFINITY;
-            } else {
-                multiline = Boolean(option.multiline);
-                minItems = option.minItems || Number.POSITIVE_INFINITY;
-            }
-
-            return { multiline, minItems };
-        }
-
-        /**
-         * Normalizes a given option value.
-         *
-         * @param {string|Object|undefined} options - An option value to parse.
-         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.
-         */
-        function normalizeOptions(options) {
-            const value = normalizeOptionValue(options);
-
-            return { ArrayExpression: value, ArrayPattern: value };
-        }
-
-        /**
-        * Reports that there shouldn't be a line break after the first token
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportNoLineBreak(token) {
-            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });
-
-            context.report({
-                loc: {
-                    start: tokenBefore.loc.end,
-                    end: token.loc.start
-                },
-                message: "There should be no linebreak here.",
-                fix(fixer) {
-                    if (astUtils.isCommentToken(tokenBefore)) {
-                        return null;
-                    }
-
-                    if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {
-                        return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ");
-                    }
-
-                    /*
-                     * This will check if the comma is on the same line as the next element
-                     * Following array:
-                     * [
-                     *     1
-                     *     , 2
-                     *     , 3
-                     * ]
-                     *
-                     * will be fixed to:
-                     * [
-                     *     1, 2, 3
-                     * ]
-                     */
-                    const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });
-
-                    if (astUtils.isCommentToken(twoTokensBefore)) {
-                        return null;
-                    }
-
-                    return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], "");
-
-                }
-            });
-        }
-
-        /**
-        * Reports that there should be a line break after the first token
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportRequiredLineBreak(token) {
-            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });
-
-            context.report({
-                loc: {
-                    start: tokenBefore.loc.end,
-                    end: token.loc.start
-                },
-                message: "There should be a linebreak after this element.",
-                fix(fixer) {
-                    return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n");
-                }
-            });
-        }
-
-        /**
-         * Reports a given node if it violated this rule.
-         *
-         * @param {ASTNode} node - A node to check. This is an ObjectExpression node or an ObjectPattern node.
-         * @param {{multiline: boolean, minItems: number}} options - An option object.
-         * @returns {void}
-         */
-        function check(node) {
-            const elements = node.elements;
-            const normalizedOptions = normalizeOptions(context.options[0]);
-            const options = normalizedOptions[node.type];
-
-            let elementBreak = false;
-
-            /*
-             * MULTILINE: true
-             * loop through every element and check
-             * if at least one element has linebreaks inside
-             * this ensures that following is not valid (due to elements are on the same line):
-             *
-             * [
-             *      1,
-             *      2,
-             *      3
-             * ]
-             */
-            if (options.multiline) {
-                elementBreak = elements
-                    .filter(element => element !== null)
-                    .some(element => element.loc.start.line !== element.loc.end.line);
-            }
-
-            const needsLinebreaks = (
-                elements.length >= options.minItems ||
-                (
-                    options.multiline &&
-                    elementBreak
-                )
-            );
-
-            elements.forEach((element, i) => {
-                const previousElement = elements[i - 1];
-
-                if (i === 0 || element === null || previousElement === null) {
-                    return;
-                }
-
-                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
-                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
-                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);
-
-                if (needsLinebreaks) {
-                    if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
-                        reportRequiredLineBreak(firstTokenOfCurrentElement);
-                    }
-                } else {
-                    if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
-                        reportNoLineBreak(firstTokenOfCurrentElement);
-                    }
-                }
-            });
-        }
-
-        //----------------------------------------------------------------------
-        // Public
-        //----------------------------------------------------------------------
-
-        return {
-            ArrayPattern: check,
-            ArrayExpression: check
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/line-comment-position.js
===================================================================
--- node_modules/eslint/lib/rules/line-comment-position.js	(revision )
+++ node_modules/eslint/lib/rules/line-comment-position.js	(revision )
@@ -1,115 +0,0 @@
-/**
- * @fileoverview Rule to enforce the position of line comments
- * @author Alberto Rodríguez
- */
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce position of line comments",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["above", "beside"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            position: {
-                                enum: ["above", "beside"]
-                            },
-                            ignorePattern: {
-                                type: "string"
-                            },
-                            applyDefaultPatterns: {
-                                type: "boolean"
-                            },
-                            applyDefaultIgnorePatterns: {
-                                type: "boolean"
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0];
-
-        let above,
-            ignorePattern,
-            applyDefaultIgnorePatterns = true;
-
-        if (!options || typeof options === "string") {
-            above = !options || options === "above";
-
-        } else {
-            above = options.position === "above";
-            ignorePattern = options.ignorePattern;
-
-            if (options.hasOwnProperty("applyDefaultIgnorePatterns")) {
-                applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;
-            } else {
-                applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;
-            }
-        }
-
-        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
-        const fallThroughRegExp = /^\s*falls?\s?through/;
-        const customIgnoreRegExp = new RegExp(ignorePattern);
-        const sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            Program() {
-                const comments = sourceCode.getAllComments();
-
-                comments.filter(token => token.type === "Line").forEach(node => {
-                    if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || fallThroughRegExp.test(node.value))) {
-                        return;
-                    }
-
-                    if (ignorePattern && customIgnoreRegExp.test(node.value)) {
-                        return;
-                    }
-
-                    const previous = sourceCode.getTokenBefore(node, { includeComments: true });
-                    const isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;
-
-                    if (above) {
-                        if (isOnSameLine) {
-                            context.report({
-                                node,
-                                message: "Expected comment to be above code."
-                            });
-                        }
-                    } else {
-                        if (!isOnSameLine) {
-                            context.report({
-                                node,
-                                message: "Expected comment to be beside code."
-                            });
-                        }
-                    }
-                });
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/newline-before-return.js
===================================================================
--- node_modules/eslint/lib/rules/newline-before-return.js	(revision )
+++ node_modules/eslint/lib/rules/newline-before-return.js	(revision )
@@ -1,206 +0,0 @@
-/**
- * @fileoverview Rule to require newlines before `return` statement
- * @author Kai Cataldo
- * @deprecated
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require an empty line before `return` statements",
-            category: "Stylistic Issues",
-            recommended: false,
-            replacedBy: ["padding-line-between-statements"]
-        },
-        fixable: "whitespace",
-        schema: [],
-        deprecated: true
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Tests whether node is preceded by supplied tokens
-         * @param {ASTNode} node - node to check
-         * @param {array} testTokens - array of tokens to test against
-         * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens
-         * @private
-         */
-        function isPrecededByTokens(node, testTokens) {
-            const tokenBefore = sourceCode.getTokenBefore(node);
-
-            return testTokens.some(token => tokenBefore.value === token);
-        }
-
-        /**
-         * Checks whether node is the first node after statement or in block
-         * @param {ASTNode} node - node to check
-         * @returns {boolean} Whether or not the node is the first node after statement or in block
-         * @private
-         */
-        function isFirstNode(node) {
-            const parentType = node.parent.type;
-
-            if (node.parent.body) {
-                return Array.isArray(node.parent.body)
-                    ? node.parent.body[0] === node
-                    : node.parent.body === node;
-            }
-
-            if (parentType === "IfStatement") {
-                return isPrecededByTokens(node, ["else", ")"]);
-            } else if (parentType === "DoWhileStatement") {
-                return isPrecededByTokens(node, ["do"]);
-            } else if (parentType === "SwitchCase") {
-                return isPrecededByTokens(node, [":"]);
-            }
-            return isPrecededByTokens(node, [")"]);
-
-        }
-
-        /**
-         * Returns the number of lines of comments that precede the node
-         * @param {ASTNode} node - node to check for overlapping comments
-         * @param {number} lineNumTokenBefore - line number of previous token, to check for overlapping comments
-         * @returns {number} Number of lines of comments that precede the node
-         * @private
-         */
-        function calcCommentLines(node, lineNumTokenBefore) {
-            const comments = sourceCode.getCommentsBefore(node);
-            let numLinesComments = 0;
-
-            if (!comments.length) {
-                return numLinesComments;
-            }
-
-            comments.forEach(comment => {
-                numLinesComments++;
-
-                if (comment.type === "Block") {
-                    numLinesComments += comment.loc.end.line - comment.loc.start.line;
-                }
-
-                // avoid counting lines with inline comments twice
-                if (comment.loc.start.line === lineNumTokenBefore) {
-                    numLinesComments--;
-                }
-
-                if (comment.loc.end.line === node.loc.start.line) {
-                    numLinesComments--;
-                }
-            });
-
-            return numLinesComments;
-        }
-
-        /**
-         * Returns the line number of the token before the node that is passed in as an argument
-         * @param {ASTNode} node - The node to use as the start of the calculation
-         * @returns {number} Line number of the token before `node`
-         * @private
-         */
-        function getLineNumberOfTokenBefore(node) {
-            const tokenBefore = sourceCode.getTokenBefore(node);
-            let lineNumTokenBefore;
-
-            /**
-             * Global return (at the beginning of a script) is a special case.
-             * If there is no token before `return`, then we expect no line
-             * break before the return. Comments are allowed to occupy lines
-             * before the global return, just no blank lines.
-             * Setting lineNumTokenBefore to zero in that case results in the
-             * desired behavior.
-             */
-            if (tokenBefore) {
-                lineNumTokenBefore = tokenBefore.loc.end.line;
-            } else {
-                lineNumTokenBefore = 0; // global return at beginning of script
-            }
-
-            return lineNumTokenBefore;
-        }
-
-        /**
-         * Checks whether node is preceded by a newline
-         * @param {ASTNode} node - node to check
-         * @returns {boolean} Whether or not the node is preceded by a newline
-         * @private
-         */
-        function hasNewlineBefore(node) {
-            const lineNumNode = node.loc.start.line;
-            const lineNumTokenBefore = getLineNumberOfTokenBefore(node);
-            const commentLines = calcCommentLines(node, lineNumTokenBefore);
-
-            return (lineNumNode - lineNumTokenBefore - commentLines) > 1;
-        }
-
-        /**
-         * Checks whether it is safe to apply a fix to a given return statement.
-         *
-         * The fix is not considered safe if the given return statement has leading comments,
-         * as we cannot safely determine if the newline should be added before or after the comments.
-         * For more information, see: https://github.com/eslint/eslint/issues/5958#issuecomment-222767211
-         *
-         * @param {ASTNode} node - The return statement node to check.
-         * @returns {boolean} `true` if it can fix the node.
-         * @private
-         */
-        function canFix(node) {
-            const leadingComments = sourceCode.getCommentsBefore(node);
-            const lastLeadingComment = leadingComments[leadingComments.length - 1];
-            const tokenBefore = sourceCode.getTokenBefore(node);
-
-            if (leadingComments.length === 0) {
-                return true;
-            }
-
-            // if the last leading comment ends in the same line as the previous token and
-            // does not share a line with the `return` node, we can consider it safe to fix.
-            // Example:
-            // function a() {
-            //     var b; //comment
-            //     return;
-            // }
-            if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line &&
-                lastLeadingComment.loc.end.line !== node.loc.start.line) {
-                return true;
-            }
-
-            return false;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            ReturnStatement(node) {
-                if (!isFirstNode(node) && !hasNewlineBefore(node)) {
-                    context.report({
-                        node,
-                        message: "Expected newline before return statement.",
-                        fix(fixer) {
-                            if (canFix(node)) {
-                                const tokenBefore = sourceCode.getTokenBefore(node);
-                                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? "\n\n" : "\n";
-
-                                return fixer.insertTextBefore(node, newlines);
-                            }
-                            return null;
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-buffer-constructor.js
===================================================================
--- node_modules/eslint/lib/rules/no-buffer-constructor.js	(revision )
+++ node_modules/eslint/lib/rules/no-buffer-constructor.js	(revision )
@@ -1,37 +0,0 @@
-/**
- * @fileoverview disallow use of the Buffer() constructor
- * @author Teddy Katz
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow use of the Buffer() constructor",
-            category: "Node.js and CommonJS",
-            recommended: false
-        },
-        schema: []
-    },
-
-    create(context) {
-
-        //----------------------------------------------------------------------
-        // Public
-        //----------------------------------------------------------------------
-
-        return {
-            "CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']"(node) {
-                context.report({
-                    node,
-                    message: "{{example}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead.",
-                    data: { example: node.type === "CallExpression" ? "Buffer()" : "new Buffer()" }
-                });
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-constant-condition.js
===================================================================
--- node_modules/eslint/lib/rules/no-constant-condition.js	(revision )
+++ node_modules/eslint/lib/rules/no-constant-condition.js	(revision )
@@ -1,210 +0,0 @@
-/**
- * @fileoverview Rule to flag use constant conditions
- * @author Christian Schulz <http://rndm.de>
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow constant expressions in conditions",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    checkLoops: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-
-        ]
-    },
-
-    create(context) {
-        const options = context.options[0] || {},
-            checkLoops = options.checkLoops !== false,
-            loopSetStack = [];
-
-        let loopsInCurrentScope = new Set();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-
-        /**
-         * Checks if a branch node of LogicalExpression short circuits the whole condition
-         * @param {ASTNode} node The branch of main condition which needs to be checked
-         * @param {string} operator The operator of the main LogicalExpression.
-         * @returns {boolean} true when condition short circuits whole condition
-         */
-        function isLogicalIdentity(node, operator) {
-            switch (node.type) {
-                case "Literal":
-                    return (operator === "||" && node.value === true) ||
-                           (operator === "&&" && node.value === false);
-
-                case "UnaryExpression":
-                    return (operator === "&&" && node.operator === "void");
-
-                case "LogicalExpression":
-                    return isLogicalIdentity(node.left, node.operator) ||
-                             isLogicalIdentity(node.right, node.operator);
-
-                // no default
-            }
-            return false;
-        }
-
-        /**
-         * Checks if a node has a constant truthiness value.
-         * @param {ASTNode} node The AST node to check.
-         * @param {boolean} inBooleanPosition `false` if checking branch of a condition.
-         *  `true` in all other cases
-         * @returns {Bool} true when node's truthiness is constant
-         * @private
-         */
-        function isConstant(node, inBooleanPosition) {
-            switch (node.type) {
-                case "Literal":
-                case "ArrowFunctionExpression":
-                case "FunctionExpression":
-                case "ObjectExpression":
-                case "ArrayExpression":
-                    return true;
-
-                case "UnaryExpression":
-                    if (node.operator === "void") {
-                        return true;
-                    }
-
-                    return (node.operator === "typeof" && inBooleanPosition) ||
-                        isConstant(node.argument, true);
-
-                case "BinaryExpression":
-                    return isConstant(node.left, false) &&
-                            isConstant(node.right, false) &&
-                            node.operator !== "in";
-
-                case "LogicalExpression": {
-                    const isLeftConstant = isConstant(node.left, inBooleanPosition);
-                    const isRightConstant = isConstant(node.right, inBooleanPosition);
-                    const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));
-                    const isRightShortCircuit = (isRightConstant && isLogicalIdentity(node.right, node.operator));
-
-                    return (isLeftConstant && isRightConstant) || isLeftShortCircuit || isRightShortCircuit;
-                }
-
-                case "AssignmentExpression":
-                    return (node.operator === "=") && isConstant(node.right, inBooleanPosition);
-
-                case "SequenceExpression":
-                    return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);
-
-                // no default
-            }
-            return false;
-        }
-
-        /**
-         * Tracks when the given node contains a constant condition.
-         * @param {ASTNode} node The AST node to check.
-         * @returns {void}
-         * @private
-         */
-        function trackConstantConditionLoop(node) {
-            if (node.test && isConstant(node.test, true)) {
-                loopsInCurrentScope.add(node);
-            }
-        }
-
-        /**
-         * Reports when the set contains the given constant condition node
-         * @param {ASTNode} node The AST node to check.
-         * @returns {void}
-         * @private
-         */
-        function checkConstantConditionLoopInSet(node) {
-            if (loopsInCurrentScope.has(node)) {
-                loopsInCurrentScope.delete(node);
-                context.report({ node, message: "Unexpected constant condition." });
-            }
-        }
-
-        /**
-         * Reports when the given node contains a constant condition.
-         * @param {ASTNode} node The AST node to check.
-         * @returns {void}
-         * @private
-         */
-        function reportIfConstant(node) {
-            if (node.test && isConstant(node.test, true)) {
-                context.report({ node, message: "Unexpected constant condition." });
-            }
-        }
-
-        /**
-         * Stores current set of constant loops in loopSetStack temporarily
-         * and uses a new set to track constant loops
-         * @returns {void}
-         * @private
-         */
-        function enterFunction() {
-            loopSetStack.push(loopsInCurrentScope);
-            loopsInCurrentScope = new Set();
-        }
-
-        /**
-         * Reports when the set still contains stored constant conditions
-         * @param {ASTNode} node The AST node to check.
-         * @returns {void}
-         * @private
-         */
-        function exitFunction() {
-            loopsInCurrentScope = loopSetStack.pop();
-        }
-
-        /**
-         * Checks node when checkLoops option is enabled
-         * @param {ASTNode} node The AST node to check.
-         * @returns {void}
-         * @private
-         */
-        function checkLoop(node) {
-            if (checkLoops) {
-                trackConstantConditionLoop(node);
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            ConditionalExpression: reportIfConstant,
-            IfStatement: reportIfConstant,
-            WhileStatement: checkLoop,
-            "WhileStatement:exit": checkConstantConditionLoopInSet,
-            DoWhileStatement: checkLoop,
-            "DoWhileStatement:exit": checkConstantConditionLoopInSet,
-            ForStatement: checkLoop,
-            "ForStatement > .test": node => checkLoop(node.parent),
-            "ForStatement:exit": checkConstantConditionLoopInSet,
-            FunctionDeclaration: enterFunction,
-            "FunctionDeclaration:exit": exitFunction,
-            YieldExpression: () => loopsInCurrentScope.clear()
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-dupe-class-members.js
===================================================================
--- node_modules/eslint/lib/rules/no-dupe-class-members.js	(revision )
+++ node_modules/eslint/lib/rules/no-dupe-class-members.js	(revision )
@@ -1,109 +0,0 @@
-/**
- * @fileoverview A rule to disallow duplicate name in class members.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow duplicate class members",
-            category: "ECMAScript 6",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        let stack = [];
-
-        /**
-         * Gets state of a given member name.
-         * @param {string} name - A name of a member.
-         * @param {boolean} isStatic - A flag which specifies that is a static member.
-         * @returns {Object} A state of a given member name.
-         *   - retv.init {boolean} A flag which shows the name is declared as normal member.
-         *   - retv.get {boolean} A flag which shows the name is declared as getter.
-         *   - retv.set {boolean} A flag which shows the name is declared as setter.
-         */
-        function getState(name, isStatic) {
-            const stateMap = stack[stack.length - 1];
-            const key = `$${name}`; // to avoid "__proto__".
-
-            if (!stateMap[key]) {
-                stateMap[key] = {
-                    nonStatic: { init: false, get: false, set: false },
-                    static: { init: false, get: false, set: false }
-                };
-            }
-
-            return stateMap[key][isStatic ? "static" : "nonStatic"];
-        }
-
-        /**
-         * Gets the name text of a given node.
-         *
-         * @param {ASTNode} node - A node to get the name.
-         * @returns {string} The name text of the node.
-         */
-        function getName(node) {
-            switch (node.type) {
-                case "Identifier": return node.name;
-                case "Literal": return String(node.value);
-
-                /* istanbul ignore next: syntax error */
-                default: return "";
-            }
-        }
-
-        return {
-
-            // Initializes the stack of state of member declarations.
-            Program() {
-                stack = [];
-            },
-
-            // Initializes state of member declarations for the class.
-            ClassBody() {
-                stack.push(Object.create(null));
-            },
-
-            // Disposes the state for the class.
-            "ClassBody:exit"() {
-                stack.pop();
-            },
-
-            // Reports the node if its name has been declared already.
-            MethodDefinition(node) {
-                if (node.computed) {
-                    return;
-                }
-
-                const name = getName(node.key);
-                const state = getState(name, node.static);
-                let isDuplicate = false;
-
-                if (node.kind === "get") {
-                    isDuplicate = (state.init || state.get);
-                    state.get = true;
-                } else if (node.kind === "set") {
-                    isDuplicate = (state.init || state.set);
-                    state.set = true;
-                } else {
-                    isDuplicate = (state.init || state.get || state.set);
-                    state.init = true;
-                }
-
-                if (isDuplicate) {
-                    context.report({ node, message: "Duplicate name '{{name}}'.", data: { name } });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-extra-boolean-cast.js
===================================================================
--- node_modules/eslint/lib/rules/no-extra-boolean-cast.js	(revision )
+++ node_modules/eslint/lib/rules/no-extra-boolean-cast.js	(revision )
@@ -1,122 +0,0 @@
-/**
- * @fileoverview Rule to flag unnecessary double negation in Boolean contexts
- * @author Brandon Mills
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary boolean casts",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        // Node types which have a test which will coerce values to booleans.
-        const BOOLEAN_NODE_TYPES = [
-            "IfStatement",
-            "DoWhileStatement",
-            "WhileStatement",
-            "ConditionalExpression",
-            "ForStatement"
-        ];
-
-        /**
-         * Check if a node is in a context where its value would be coerced to a boolean at runtime.
-         *
-         * @param {Object} node The node
-         * @param {Object} parent Its parent
-         * @returns {boolean} If it is in a boolean context
-         */
-        function isInBooleanContext(node, parent) {
-            return (
-                (BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 &&
-                    node === parent.test) ||
-
-                // !<bool>
-                (parent.type === "UnaryExpression" &&
-                    parent.operator === "!")
-            );
-        }
-
-
-        return {
-            UnaryExpression(node) {
-                const ancestors = context.getAncestors(),
-                    parent = ancestors.pop(),
-                    grandparent = ancestors.pop();
-
-                // Exit early if it's guaranteed not to match
-                if (node.operator !== "!" ||
-                        parent.type !== "UnaryExpression" ||
-                        parent.operator !== "!") {
-                    return;
-                }
-
-                if (isInBooleanContext(parent, grandparent) ||
-
-                    // Boolean(<bool>) and new Boolean(<bool>)
-                    ((grandparent.type === "CallExpression" || grandparent.type === "NewExpression") &&
-                        grandparent.callee.type === "Identifier" &&
-                        grandparent.callee.name === "Boolean")
-                ) {
-                    context.report({
-                        node,
-                        message: "Redundant double negation.",
-                        fix: fixer => fixer.replaceText(parent, sourceCode.getText(node.argument))
-                    });
-                }
-            },
-            CallExpression(node) {
-                const parent = node.parent;
-
-                if (node.callee.type !== "Identifier" || node.callee.name !== "Boolean") {
-                    return;
-                }
-
-                if (isInBooleanContext(node, parent)) {
-                    context.report({
-                        node,
-                        message: "Redundant Boolean call.",
-                        fix: fixer => {
-                            if (!node.arguments.length) {
-                                return fixer.replaceText(parent, "true");
-                            }
-
-                            if (node.arguments.length > 1 || node.arguments[0].type === "SpreadElement") {
-                                return null;
-                            }
-
-                            const argument = node.arguments[0];
-
-                            if (astUtils.getPrecedence(argument) < astUtils.getPrecedence(node.parent)) {
-                                return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);
-                            }
-                            return fixer.replaceText(node, sourceCode.getText(argument));
-                        }
-                    });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-inner-declarations.js
===================================================================
--- node_modules/eslint/lib/rules/no-inner-declarations.js	(revision )
+++ node_modules/eslint/lib/rules/no-inner-declarations.js	(revision )
@@ -1,89 +0,0 @@
-/**
- * @fileoverview Rule to enforce declarations in program or function body root.
- * @author Brandon Mills
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow variable or `function` declarations in nested blocks",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: [
-            {
-                enum: ["functions", "both"]
-            }
-        ]
-    },
-
-    create(context) {
-
-        /**
-         * Find the nearest Program or Function ancestor node.
-         * @returns {Object} Ancestor's type and distance from node.
-         */
-        function nearestBody() {
-            const ancestors = context.getAncestors();
-            let ancestor = ancestors.pop(),
-                generation = 1;
-
-            while (ancestor && ["Program", "FunctionDeclaration",
-                "FunctionExpression", "ArrowFunctionExpression"
-            ].indexOf(ancestor.type) < 0) {
-                generation += 1;
-                ancestor = ancestors.pop();
-            }
-
-            return {
-
-                // Type of containing ancestor
-                type: ancestor.type,
-
-                // Separation between ancestor and node
-                distance: generation
-            };
-        }
-
-        /**
-         * Ensure that a given node is at a program or function body's root.
-         * @param {ASTNode} node Declaration node to check.
-         * @returns {void}
-         */
-        function check(node) {
-            const body = nearestBody(),
-                valid = ((body.type === "Program" && body.distance === 1) ||
-                    body.distance === 2);
-
-            if (!valid) {
-                context.report({
-                    node,
-                    message: "Move {{type}} declaration to {{body}} root.",
-                    data: {
-                        type: (node.type === "FunctionDeclaration" ? "function" : "variable"),
-                        body: (body.type === "Program" ? "program" : "function body")
-                    }
-                });
-            }
-        }
-
-        return {
-
-            FunctionDeclaration: check,
-            VariableDeclaration(node) {
-                if (context.options[0] === "both" && node.kind === "var") {
-                    check(node);
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-prototype-builtins.js
===================================================================
--- node_modules/eslint/lib/rules/no-prototype-builtins.js	(revision )
+++ node_modules/eslint/lib/rules/no-prototype-builtins.js	(revision )
@@ -1,54 +0,0 @@
-/**
- * @fileoverview Rule to disallow use of Object.prototype builtins on objects
- * @author Andrew Levine
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow calling some `Object.prototype` methods directly on objects",
-            category: "Possible Errors",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const DISALLOWED_PROPS = [
-            "hasOwnProperty",
-            "isPrototypeOf",
-            "propertyIsEnumerable"
-        ];
-
-        /**
-         * Reports if a disallowed property is used in a CallExpression
-         * @param {ASTNode} node The CallExpression node.
-         * @returns {void}
-         */
-        function disallowBuiltIns(node) {
-            if (node.callee.type !== "MemberExpression" || node.callee.computed) {
-                return;
-            }
-            const propName = node.callee.property.name;
-
-            if (DISALLOWED_PROPS.indexOf(propName) > -1) {
-                context.report({
-                    message: "Do not access Object.prototype method '{{prop}}' from target object.",
-                    loc: node.callee.property.loc.start,
-                    data: { prop: propName },
-                    node
-                });
-            }
-        }
-
-        return {
-            CallExpression: disallowBuiltIns
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-restricted-globals.js
===================================================================
--- node_modules/eslint/lib/rules/no-restricted-globals.js	(revision )
+++ node_modules/eslint/lib/rules/no-restricted-globals.js	(revision )
@@ -1,120 +0,0 @@
-/**
- * @fileoverview Restrict usage of specified globals.
- * @author Benoît Zugmeyer
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const DEFAULT_MESSAGE_TEMPLATE = "Unexpected use of '{{name}}'.",
-    CUSTOM_MESSAGE_TEMPLATE = "Unexpected use of '{{name}}'. {{customMessage}}";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow specified global variables",
-            category: "Variables",
-            recommended: false
-        },
-
-        schema: {
-            type: "array",
-            items: {
-                oneOf: [
-                    {
-                        type: "string"
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            name: { type: "string" },
-                            message: { type: "string" }
-                        },
-                        required: ["name"],
-                        additionalProperties: false
-                    }
-                ]
-            },
-            uniqueItems: true,
-            minItems: 0
-        }
-    },
-
-    create(context) {
-
-        // If no globals are restricted, we don't need to do anything
-        if (context.options.length === 0) {
-            return {};
-        }
-
-        const restrictedGlobalMessages = context.options.reduce((memo, option) => {
-            if (typeof option === "string") {
-                memo[option] = null;
-            } else {
-                memo[option.name] = option.message;
-            }
-
-            return memo;
-        }, {});
-
-        /**
-         * Report a variable to be used as a restricted global.
-         * @param {Reference} reference the variable reference
-         * @returns {void}
-         * @private
-         */
-        function reportReference(reference) {
-            const name = reference.identifier.name,
-                customMessage = restrictedGlobalMessages[name],
-                message = customMessage
-                    ? CUSTOM_MESSAGE_TEMPLATE
-                    : DEFAULT_MESSAGE_TEMPLATE;
-
-            context.report({
-                node: reference.identifier,
-                message,
-                data: {
-                    name,
-                    customMessage
-                }
-            });
-        }
-
-        /**
-         * Check if the given name is a restricted global name.
-         * @param {string} name name of a variable
-         * @returns {boolean} whether the variable is a restricted global or not
-         * @private
-         */
-        function isRestricted(name) {
-            return restrictedGlobalMessages.hasOwnProperty(name);
-        }
-
-        return {
-            Program() {
-                const scope = context.getScope();
-
-                // Report variables declared elsewhere (ex: variables defined as "global" by eslint)
-                scope.variables.forEach(variable => {
-                    if (!variable.defs.length && isRestricted(variable.name)) {
-                        variable.references.forEach(reportReference);
-                    }
-                });
-
-                // Report variables not declared at all
-                scope.through.forEach(reference => {
-                    if (isRestricted(reference.identifier.name)) {
-                        reportReference(reference);
-                    }
-                });
-
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-restricted-imports.js
===================================================================
--- node_modules/eslint/lib/rules/no-restricted-imports.js	(revision )
+++ node_modules/eslint/lib/rules/no-restricted-imports.js	(revision )
@@ -1,85 +0,0 @@
-/**
- * @fileoverview Restrict usage of specified node imports.
- * @author Guy Ellis
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const ignore = require("ignore");
-
-const arrayOfStrings = {
-    type: "array",
-    items: {
-        type: "string"
-    },
-    uniqueItems: true
-};
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow specified modules when loaded by `import`",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: {
-            anyOf: [
-                arrayOfStrings,
-                {
-                    type: "array",
-                    items: [{
-                        type: "object",
-                        properties: {
-                            paths: arrayOfStrings,
-                            patterns: arrayOfStrings
-                        },
-                        additionalProperties: false
-                    }],
-                    additionalItems: false
-                }
-            ]
-        }
-    },
-
-    create(context) {
-        const options = Array.isArray(context.options) ? context.options : [];
-        const isStringArray = typeof options[0] !== "object";
-        const restrictedPaths = new Set(isStringArray ? context.options : options[0].paths || []);
-        const restrictedPatterns = isStringArray ? [] : options[0].patterns || [];
-
-        // if no imports are restricted we don"t need to check
-        if (restrictedPaths.size === 0 && restrictedPatterns.length === 0) {
-            return {};
-        }
-
-        const ig = ignore().add(restrictedPatterns);
-
-        return {
-            ImportDeclaration(node) {
-                if (node && node.source && node.source.value) {
-
-                    const importName = node.source.value.trim();
-
-                    if (restrictedPaths.has(importName)) {
-                        context.report({
-                            node,
-                            message: "'{{importName}}' import is restricted from being used.",
-                            data: { importName }
-                        });
-                    }
-                    if (restrictedPatterns.length > 0 && ig.ignores(importName)) {
-                        context.report({
-                            node,
-                            message: "'{{importName}}' import is restricted from being used by a pattern.",
-                            data: { importName }
-                        });
-                    }
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-restricted-modules.js
===================================================================
--- node_modules/eslint/lib/rules/no-restricted-modules.js	(revision )
+++ node_modules/eslint/lib/rules/no-restricted-modules.js	(revision )
@@ -1,108 +0,0 @@
-/**
- * @fileoverview Restrict usage of specified node modules.
- * @author Christian Schulz
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const ignore = require("ignore");
-
-const arrayOfStrings = {
-    type: "array",
-    items: {
-        type: "string"
-    },
-    uniqueItems: true
-};
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow specified modules when loaded by `require`",
-            category: "Node.js and CommonJS",
-            recommended: false
-        },
-
-        schema: {
-            anyOf: [
-                arrayOfStrings,
-                {
-                    type: "array",
-                    items: [{
-                        type: "object",
-                        properties: {
-                            paths: arrayOfStrings,
-                            patterns: arrayOfStrings
-                        },
-                        additionalProperties: false
-                    }],
-                    additionalItems: false
-                }
-            ]
-        }
-    },
-
-    create(context) {
-        const options = Array.isArray(context.options) ? context.options : [];
-        const isStringArray = typeof options[0] !== "object";
-        const restrictedPaths = new Set(isStringArray ? context.options : options[0].paths || []);
-        const restrictedPatterns = isStringArray ? [] : options[0].patterns || [];
-
-        // if no imports are restricted we don"t need to check
-        if (restrictedPaths.size === 0 && restrictedPatterns.length === 0) {
-            return {};
-        }
-
-        const ig = ignore().add(restrictedPatterns);
-
-        /**
-         * Function to check if a node is a string literal.
-         * @param {ASTNode} node The node to check.
-         * @returns {boolean} If the node is a string literal.
-         */
-        function isString(node) {
-            return node && node.type === "Literal" && typeof node.value === "string";
-        }
-
-        /**
-         * Function to check if a node is a require call.
-         * @param {ASTNode} node The node to check.
-         * @returns {boolean} If the node is a require call.
-         */
-        function isRequireCall(node) {
-            return node.callee.type === "Identifier" && node.callee.name === "require";
-        }
-
-        return {
-            CallExpression(node) {
-                if (isRequireCall(node)) {
-
-                    // node has arguments and first argument is string
-                    if (node.arguments.length && isString(node.arguments[0])) {
-                        const moduleName = node.arguments[0].value.trim();
-
-                        // check if argument value is in restricted modules array
-                        if (restrictedPaths.has(moduleName)) {
-                            context.report({
-                                node,
-                                message: "'{{moduleName}}' module is restricted from being used.",
-                                data: { moduleName }
-                            });
-                        }
-
-                        if (restrictedPatterns.length > 0 && ig.ignores(moduleName)) {
-                            context.report({
-                                node,
-                                message: "'{{moduleName}}' module is restricted from being used by a pattern.",
-                                data: { moduleName }
-                            });
-                        }
-                    }
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-unused-expressions.js
===================================================================
--- node_modules/eslint/lib/rules/no-unused-expressions.js	(revision )
+++ node_modules/eslint/lib/rules/no-unused-expressions.js	(revision )
@@ -1,126 +0,0 @@
-/**
- * @fileoverview Flag expressions in statement position that do not side effect
- * @author Michael Ficarra
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unused expressions",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allowShortCircuit: {
-                        type: "boolean"
-                    },
-                    allowTernary: {
-                        type: "boolean"
-                    },
-                    allowTaggedTemplates: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const config = context.options[0] || {},
-            allowShortCircuit = config.allowShortCircuit || false,
-            allowTernary = config.allowTernary || false,
-            allowTaggedTemplates = config.allowTaggedTemplates || false;
-
-        /**
-         * @param {ASTNode} node - any node
-         * @returns {boolean} whether the given node structurally represents a directive
-         */
-        function looksLikeDirective(node) {
-            return node.type === "ExpressionStatement" &&
-                node.expression.type === "Literal" && typeof node.expression.value === "string";
-        }
-
-        /**
-         * @param {Function} predicate - ([a] -> Boolean) the function used to make the determination
-         * @param {a[]} list - the input list
-         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate
-         */
-        function takeWhile(predicate, list) {
-            for (let i = 0; i < list.length; ++i) {
-                if (!predicate(list[i])) {
-                    return list.slice(0, i);
-                }
-            }
-            return list.slice();
-        }
-
-        /**
-         * @param {ASTNode} node - a Program or BlockStatement node
-         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body
-         */
-        function directives(node) {
-            return takeWhile(looksLikeDirective, node.body);
-        }
-
-        /**
-         * @param {ASTNode} node - any node
-         * @param {ASTNode[]} ancestors - the given node's ancestors
-         * @returns {boolean} whether the given node is considered a directive in its current position
-         */
-        function isDirective(node, ancestors) {
-            const parent = ancestors[ancestors.length - 1],
-                grandparent = ancestors[ancestors.length - 2];
-
-            return (parent.type === "Program" || parent.type === "BlockStatement" &&
-                    (/Function/.test(grandparent.type))) &&
-                    directives(parent).indexOf(node) >= 0;
-        }
-
-        /**
-         * Determines whether or not a given node is a valid expression. Recurses on short circuit eval and ternary nodes if enabled by flags.
-         * @param {ASTNode} node - any node
-         * @returns {boolean} whether the given node is a valid expression
-         */
-        function isValidExpression(node) {
-            if (allowTernary) {
-
-                // Recursive check for ternary and logical expressions
-                if (node.type === "ConditionalExpression") {
-                    return isValidExpression(node.consequent) && isValidExpression(node.alternate);
-                }
-            }
-
-            if (allowShortCircuit) {
-                if (node.type === "LogicalExpression") {
-                    return isValidExpression(node.right);
-                }
-            }
-
-            if (allowTaggedTemplates && node.type === "TaggedTemplateExpression") {
-                return true;
-            }
-
-            return /^(?:Assignment|Call|New|Update|Yield|Await)Expression$/.test(node.type) ||
-                (node.type === "UnaryExpression" && ["delete", "void"].indexOf(node.operator) >= 0);
-        }
-
-        return {
-            ExpressionStatement(node) {
-                if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {
-                    context.report({ node, message: "Expected an assignment or function call and instead saw an expression." });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/prefer-arrow-callback.js
===================================================================
--- node_modules/eslint/lib/rules/prefer-arrow-callback.js	(revision )
+++ node_modules/eslint/lib/rules/prefer-arrow-callback.js	(revision )
@@ -1,302 +0,0 @@
-/**
- * @fileoverview A rule to suggest using arrow functions as callbacks.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a given variable is a function name.
- * @param {eslint-scope.Variable} variable - A variable to check.
- * @returns {boolean} `true` if the variable is a function name.
- */
-function isFunctionName(variable) {
-    return variable && variable.defs[0].type === "FunctionName";
-}
-
-/**
- * Checks whether or not a given MetaProperty node equals to a given value.
- * @param {ASTNode} node - A MetaProperty node to check.
- * @param {string} metaName - The name of `MetaProperty.meta`.
- * @param {string} propertyName - The name of `MetaProperty.property`.
- * @returns {boolean} `true` if the node is the specific value.
- */
-function checkMetaProperty(node, metaName, propertyName) {
-    return node.meta.name === metaName && node.property.name === propertyName;
-}
-
-/**
- * Gets the variable object of `arguments` which is defined implicitly.
- * @param {eslint-scope.Scope} scope - A scope to get.
- * @returns {eslint-scope.Variable} The found variable object.
- */
-function getVariableOfArguments(scope) {
-    const variables = scope.variables;
-
-    for (let i = 0; i < variables.length; ++i) {
-        const variable = variables[i];
-
-        if (variable.name === "arguments") {
-
-            /*
-             * If there was a parameter which is named "arguments", the
-             * implicit "arguments" is not defined.
-             * So does fast return with null.
-             */
-            return (variable.identifiers.length === 0) ? variable : null;
-        }
-    }
-
-    /* istanbul ignore next */
-    return null;
-}
-
-/**
- * Checkes whether or not a given node is a callback.
- * @param {ASTNode} node - A node to check.
- * @returns {Object}
- *   {boolean} retv.isCallback - `true` if the node is a callback.
- *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.
- */
-function getCallbackInfo(node) {
-    const retv = { isCallback: false, isLexicalThis: false };
-    let parent = node.parent;
-
-    while (node) {
-        switch (parent.type) {
-
-            // Checks parents recursively.
-
-            case "LogicalExpression":
-            case "ConditionalExpression":
-                break;
-
-            // Checks whether the parent node is `.bind(this)` call.
-            case "MemberExpression":
-                if (parent.object === node &&
-                    !parent.property.computed &&
-                    parent.property.type === "Identifier" &&
-                    parent.property.name === "bind" &&
-                    parent.parent.type === "CallExpression" &&
-                    parent.parent.callee === parent
-                ) {
-                    retv.isLexicalThis = (
-                        parent.parent.arguments.length === 1 &&
-                        parent.parent.arguments[0].type === "ThisExpression"
-                    );
-                    parent = parent.parent;
-                } else {
-                    return retv;
-                }
-                break;
-
-            // Checks whether the node is a callback.
-            case "CallExpression":
-            case "NewExpression":
-                if (parent.callee !== node) {
-                    retv.isCallback = true;
-                }
-                return retv;
-
-            default:
-                return retv;
-        }
-
-        node = parent;
-        parent = parent.parent;
-    }
-
-    /* istanbul ignore next */
-    throw new Error("unreachable");
-}
-
-/**
-* Checks whether a simple list of parameters contains any duplicates. This does not handle complex
-parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate
-parameter names anyway. Instead, it always returns `false` for complex parameter lists.
-* @param {ASTNode[]} paramsList The list of parameters for a function
-* @returns {boolean} `true` if the list of parameters contains any duplicates
-*/
-function hasDuplicateParams(paramsList) {
-    return paramsList.every(param => param.type === "Identifier") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require using arrow functions for callbacks",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allowNamedFunctions: {
-                        type: "boolean"
-                    },
-                    allowUnboundThis: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const options = context.options[0] || {};
-
-        const allowUnboundThis = options.allowUnboundThis !== false; // default to true
-        const allowNamedFunctions = options.allowNamedFunctions;
-        const sourceCode = context.getSourceCode();
-
-        /*
-         * {Array<{this: boolean, super: boolean, meta: boolean}>}
-         * - this - A flag which shows there are one or more ThisExpression.
-         * - super - A flag which shows there are one or more Super.
-         * - meta - A flag which shows there are one or more MethProperty.
-         */
-        let stack = [];
-
-        /**
-         * Pushes new function scope with all `false` flags.
-         * @returns {void}
-         */
-        function enterScope() {
-            stack.push({ this: false, super: false, meta: false });
-        }
-
-        /**
-         * Pops a function scope from the stack.
-         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.
-         */
-        function exitScope() {
-            return stack.pop();
-        }
-
-        return {
-
-            // Reset internal state.
-            Program() {
-                stack = [];
-            },
-
-            // If there are below, it cannot replace with arrow functions merely.
-            ThisExpression() {
-                const info = stack[stack.length - 1];
-
-                if (info) {
-                    info.this = true;
-                }
-            },
-
-            Super() {
-                const info = stack[stack.length - 1];
-
-                if (info) {
-                    info.super = true;
-                }
-            },
-
-            MetaProperty(node) {
-                const info = stack[stack.length - 1];
-
-                if (info && checkMetaProperty(node, "new", "target")) {
-                    info.meta = true;
-                }
-            },
-
-            // To skip nested scopes.
-            FunctionDeclaration: enterScope,
-            "FunctionDeclaration:exit": exitScope,
-
-            // Main.
-            FunctionExpression: enterScope,
-            "FunctionExpression:exit"(node) {
-                const scopeInfo = exitScope();
-
-                // Skip named function expressions
-                if (allowNamedFunctions && node.id && node.id.name) {
-                    return;
-                }
-
-                // Skip generators.
-                if (node.generator) {
-                    return;
-                }
-
-                // Skip recursive functions.
-                const nameVar = context.getDeclaredVariables(node)[0];
-
-                if (isFunctionName(nameVar) && nameVar.references.length > 0) {
-                    return;
-                }
-
-                // Skip if it's using arguments.
-                const variable = getVariableOfArguments(context.getScope());
-
-                if (variable && variable.references.length > 0) {
-                    return;
-                }
-
-                // Reports if it's a callback which can replace with arrows.
-                const callbackInfo = getCallbackInfo(node);
-
-                if (callbackInfo.isCallback &&
-                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&
-                    !scopeInfo.super &&
-                    !scopeInfo.meta
-                ) {
-                    context.report({
-                        node,
-                        message: "Unexpected function expression.",
-                        fix(fixer) {
-                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {
-
-                                // If the callback function does not have .bind(this) and contains a reference to `this`, there
-                                // is no way to determine what `this` should be, so don't perform any fixes.
-                                // If the callback function has duplicates in its list of parameters (possible in sloppy mode),
-                                // don't replace it with an arrow function, because this is a SyntaxError with arrow functions.
-                                return null;
-                            }
-
-                            const paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);
-                            const paramsRightParen = sourceCode.getTokenBefore(node.body);
-                            const asyncKeyword = node.async ? "async " : "";
-                            const paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);
-                            const arrowFunctionText = `${asyncKeyword}${paramsFullText} => ${sourceCode.getText(node.body)}`;
-
-                            /*
-                             * If the callback function has `.bind(this)`, replace it with an arrow function and remove the binding.
-                             * Otherwise, just replace the arrow function itself.
-                             */
-                            const replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;
-
-                            /*
-                             * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then
-                             * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even
-                             * though `foo || function() {}` is valid.
-                             */
-                            const needsParens = replacedNode.parent.type !== "CallExpression" && replacedNode.parent.type !== "ConditionalExpression";
-                            const replacementText = needsParens ? `(${arrowFunctionText})` : arrowFunctionText;
-
-                            return fixer.replaceText(replacedNode, replacementText);
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/class-methods-use-this.js
===================================================================
--- node_modules/eslint/lib/rules/class-methods-use-this.js	(revision )
+++ node_modules/eslint/lib/rules/class-methods-use-this.js	(revision )
@@ -1,110 +0,0 @@
-/**
- * @fileoverview Rule to enforce that all class methods use 'this'.
- * @author Patrick Williams
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce that class methods utilize `this`",
-            category: "Best Practices",
-            recommended: false
-        },
-        schema: [{
-            type: "object",
-            properties: {
-                exceptMethods: {
-                    type: "array",
-                    items: {
-                        type: "string"
-                    }
-                }
-            },
-            additionalProperties: false
-        }]
-    },
-    create(context) {
-        const config = context.options[0] ? Object.assign({}, context.options[0]) : {};
-        const exceptMethods = new Set(config.exceptMethods || []);
-
-        const stack = [];
-
-        /**
-         * Initializes the current context to false and pushes it onto the stack.
-         * These booleans represent whether 'this' has been used in the context.
-         * @returns {void}
-         * @private
-         */
-        function enterFunction() {
-            stack.push(false);
-        }
-
-        /**
-         * Check if the node is an instance method
-         * @param {ASTNode} node - node to check
-         * @returns {boolean} True if its an instance method
-         * @private
-         */
-        function isInstanceMethod(node) {
-            return !node.static && node.kind !== "constructor" && node.type === "MethodDefinition";
-        }
-
-        /**
-         * Check if the node is an instance method not excluded by config
-         * @param {ASTNode} node - node to check
-         * @returns {boolean} True if it is an instance method, and not excluded by config
-         * @private
-         */
-        function isIncludedInstanceMethod(node) {
-            return isInstanceMethod(node) && !exceptMethods.has(node.key.name);
-        }
-
-        /**
-         * Checks if we are leaving a function that is a method, and reports if 'this' has not been used.
-         * Static methods and the constructor are exempt.
-         * Then pops the context off the stack.
-         * @param {ASTNode} node - A function node that was entered.
-         * @returns {void}
-         * @private
-         */
-        function exitFunction(node) {
-            const methodUsesThis = stack.pop();
-
-            if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {
-                context.report({
-                    node,
-                    message: "Expected 'this' to be used by class method '{{classMethod}}'.",
-                    data: {
-                        classMethod: node.parent.key.name
-                    }
-                });
-            }
-        }
-
-        /**
-         * Mark the current context as having used 'this'.
-         * @returns {void}
-         * @private
-         */
-        function markThisUsed() {
-            if (stack.length) {
-                stack[stack.length - 1] = true;
-            }
-        }
-
-        return {
-            FunctionDeclaration: enterFunction,
-            "FunctionDeclaration:exit": exitFunction,
-            FunctionExpression: enterFunction,
-            "FunctionExpression:exit": exitFunction,
-            ThisExpression: markThisUsed,
-            Super: markThisUsed
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/function-paren-newline.js
===================================================================
--- node_modules/eslint/lib/rules/function-paren-newline.js	(revision )
+++ node_modules/eslint/lib/rules/function-paren-newline.js	(revision )
@@ -1,221 +0,0 @@
-/**
- * @fileoverview enforce consistent line breaks inside function parentheses
- * @author Teddy Katz
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent line breaks inside function parentheses",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "whitespace",
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["always", "never", "consistent", "multiline"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            minItems: {
-                                type: "integer",
-                                minimum: 0
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const rawOption = context.options[0] || "multiline";
-        const multilineOption = rawOption === "multiline";
-        const consistentOption = rawOption === "consistent";
-        let minItems;
-
-        if (typeof rawOption === "object") {
-            minItems = rawOption.minItems;
-        } else if (rawOption === "always") {
-            minItems = 0;
-        } else if (rawOption === "never") {
-            minItems = Infinity;
-        } else {
-            minItems = null;
-        }
-
-        //----------------------------------------------------------------------
-        // Helpers
-        //----------------------------------------------------------------------
-
-        /**
-         * Determines whether there should be newlines inside function parens
-         * @param {ASTNode[]} elements The arguments or parameters in the list
-         * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.
-         * @returns {boolean} `true` if there should be newlines inside the function parens
-         */
-        function shouldHaveNewlines(elements, hasLeftNewline) {
-            if (multilineOption) {
-                return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);
-            }
-            if (consistentOption) {
-                return hasLeftNewline;
-            }
-            return elements.length >= minItems;
-        }
-
-        /**
-         * Validates a list of arguments or parameters
-         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token
-         * @param {ASTNode[]} elements The arguments or parameters in the list
-         * @returns {void}
-         */
-        function validateParens(parens, elements) {
-            const leftParen = parens.leftParen;
-            const rightParen = parens.rightParen;
-            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
-            const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
-            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
-            const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);
-            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);
-
-            if (hasLeftNewline && !needsNewlines) {
-                context.report({
-                    node: leftParen,
-                    message: "Unexpected newline after '('.",
-                    fix(fixer) {
-                        return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()
-
-                            // If there is a comment between the ( and the first element, don't do a fix.
-                            ? null
-                            : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);
-                    }
-                });
-            } else if (!hasLeftNewline && needsNewlines) {
-                context.report({
-                    node: leftParen,
-                    message: "Expected a newline after '('.",
-                    fix: fixer => fixer.insertTextAfter(leftParen, "\n")
-                });
-            }
-
-            if (hasRightNewline && !needsNewlines) {
-                context.report({
-                    node: rightParen,
-                    message: "Unexpected newline before ')'.",
-                    fix(fixer) {
-                        return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()
-
-                            // If there is a comment between the last element and the ), don't do a fix.
-                            ? null
-                            : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);
-                    }
-                });
-            } else if (!hasRightNewline && needsNewlines) {
-                context.report({
-                    node: rightParen,
-                    message: "Expected a newline before ')'.",
-                    fix: fixer => fixer.insertTextBefore(rightParen, "\n")
-                });
-            }
-        }
-
-        /**
-         * Gets the left paren and right paren tokens of a node.
-         * @param {ASTNode} node The node with parens
-         * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.
-         * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression
-         * with a single parameter)
-         */
-        function getParenTokens(node) {
-            switch (node.type) {
-                case "NewExpression":
-                    if (!node.arguments.length && !(
-                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) &&
-                        astUtils.isClosingParenToken(sourceCode.getLastToken(node))
-                    )) {
-
-                        // If the NewExpression does not have parens (e.g. `new Foo`), return null.
-                        return null;
-                    }
-
-                    // falls through
-
-                case "CallExpression":
-                    return {
-                        leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),
-                        rightParen: sourceCode.getLastToken(node)
-                    };
-
-                case "FunctionDeclaration":
-                case "FunctionExpression": {
-                    const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
-                    const rightParen = node.params.length
-                        ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken)
-                        : sourceCode.getTokenAfter(leftParen);
-
-                    return { leftParen, rightParen };
-                }
-
-                case "ArrowFunctionExpression": {
-                    const firstToken = sourceCode.getFirstToken(node);
-
-                    if (!astUtils.isOpeningParenToken(firstToken)) {
-
-                        // If the ArrowFunctionExpression has a single param without parens, return null.
-                        return null;
-                    }
-
-                    return {
-                        leftParen: firstToken,
-                        rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)
-                    };
-                }
-
-                default:
-                    throw new TypeError(`unexpected node with type ${node.type}`);
-            }
-        }
-
-        /**
-         * Validates the parentheses for a node
-         * @param {ASTNode} node The node with parens
-         * @returns {void}
-         */
-        function validateNode(node) {
-            const parens = getParenTokens(node);
-
-            if (parens) {
-                validateParens(parens, astUtils.isFunction(node) ? node.params : node.arguments);
-            }
-        }
-
-        //----------------------------------------------------------------------
-        // Public
-        //----------------------------------------------------------------------
-
-        return {
-            ArrowFunctionExpression: validateNode,
-            CallExpression: validateNode,
-            FunctionDeclaration: validateNode,
-            FunctionExpression: validateNode,
-            NewExpression: validateNode
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/generator-star-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/generator-star-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/generator-star-spacing.js	(revision )
@@ -1,199 +0,0 @@
-/**
- * @fileoverview Rule to check the spacing around the * in generator functions.
- * @author Jamund Ferguson
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const OVERRIDE_SCHEMA = {
-    oneOf: [
-        {
-            enum: ["before", "after", "both", "neither"]
-        },
-        {
-            type: "object",
-            properties: {
-                before: { type: "boolean" },
-                after: { type: "boolean" }
-            },
-            additionalProperties: false
-        }
-    ]
-};
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing around `*` operators in generator functions",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["before", "after", "both", "neither"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            before: { type: "boolean" },
-                            after: { type: "boolean" },
-                            named: OVERRIDE_SCHEMA,
-                            anonymous: OVERRIDE_SCHEMA,
-                            method: OVERRIDE_SCHEMA
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-
-        const optionDefinitions = {
-            before: { before: true, after: false },
-            after: { before: false, after: true },
-            both: { before: true, after: true },
-            neither: { before: false, after: false }
-        };
-
-        /**
-         * Returns resolved option definitions based on an option and defaults
-         * 
-         * @param {any} option - The option object or string value
-         * @param {Object} defaults - The defaults to use if options are not present
-         * @returns {Object} the resolved object definition
-         */
-        function optionToDefinition(option, defaults) {
-            if (!option) {
-                return defaults;
-            }
-
-            return typeof option === "string"
-                ? optionDefinitions[option]
-                : Object.assign({}, defaults, option);
-        }
-
-        const modes = (function(option) {
-            option = option || {};
-            const defaults = optionToDefinition(option, optionDefinitions.before);
-
-            return {
-                named: optionToDefinition(option.named, defaults),
-                anonymous: optionToDefinition(option.anonymous, defaults),
-                method: optionToDefinition(option.method, defaults)
-            };
-        }(context.options[0]));
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Checks if the given token is a star token or not.
-         *
-         * @param {Token} token - The token to check.
-         * @returns {boolean} `true` if the token is a star token.
-         */
-        function isStarToken(token) {
-            return token.value === "*" && token.type === "Punctuator";
-        }
-
-        /**
-         * Gets the generator star token of the given function node.
-         *
-         * @param {ASTNode} node - The function node to get.
-         * @returns {Token} Found star token.
-         */
-        function getStarToken(node) {
-            return sourceCode.getFirstToken(
-                (node.parent.method || node.parent.type === "MethodDefinition") ? node.parent : node,
-                isStarToken
-            );
-        }
-
-        /**
-         * Checks the spacing between two tokens before or after the star token.
-         * 
-         * @param {string} kind Either "named", "anonymous", or "method"
-         * @param {string} side Either "before" or "after".
-         * @param {Token} leftToken `function` keyword token if side is "before", or
-         *     star token if side is "after".
-         * @param {Token} rightToken Star token if side is "before", or identifier
-         *     token if side is "after".
-         * @returns {void}
-         */
-        function checkSpacing(kind, side, leftToken, rightToken) {
-            if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {
-                const after = leftToken.value === "*";
-                const spaceRequired = modes[kind][side];
-                const node = after ? leftToken : rightToken;
-                const type = spaceRequired ? "Missing" : "Unexpected";
-                const message = "{{type}} space {{side}} *.";
-                const data = {
-                    type,
-                    side
-                };
-
-                context.report({
-                    node,
-                    message,
-                    data,
-                    fix(fixer) {
-                        if (spaceRequired) {
-                            if (after) {
-                                return fixer.insertTextAfter(node, " ");
-                            }
-                            return fixer.insertTextBefore(node, " ");
-                        }
-                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
-                    }
-                });
-            }
-        }
-
-        /**
-         * Enforces the spacing around the star if node is a generator function.
-         * 
-         * @param {ASTNode} node A function expression or declaration node.
-         * @returns {void}
-         */
-        function checkFunction(node) {
-            if (!node.generator) {
-                return;
-            }
-
-            const starToken = getStarToken(node);
-            const prevToken = sourceCode.getTokenBefore(starToken);
-            const nextToken = sourceCode.getTokenAfter(starToken);
-
-            let kind = "named";
-
-            if (node.parent.type === "MethodDefinition" || (node.parent.type === "Property" && node.parent.method)) {
-                kind = "method";
-            } else if (!node.id) {
-                kind = "anonymous";
-            }
-
-            // Only check before when preceded by `function`|`static` keyword
-            if (!(kind === "method" && starToken === sourceCode.getFirstToken(node.parent))) {
-                checkSpacing(kind, "before", prevToken, starToken);
-            }
-
-            checkSpacing(kind, "after", starToken, nextToken);
-        }
-
-        return {
-            FunctionDeclaration: checkFunction,
-            FunctionExpression: checkFunction
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/lines-around-directive.js
===================================================================
--- node_modules/eslint/lib/rules/lines-around-directive.js	(revision )
+++ node_modules/eslint/lib/rules/lines-around-directive.js	(revision )
@@ -1,189 +0,0 @@
-/**
- * @fileoverview Require or disallow newlines around directives.
- * @author Kai Cataldo
- * @deprecated
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow newlines around directives",
-            category: "Stylistic Issues",
-            recommended: false,
-            replacedBy: ["padding-line-between-statements"]
-        },
-        schema: [{
-            oneOf: [
-                {
-                    enum: ["always", "never"]
-                },
-                {
-                    type: "object",
-                    properties: {
-                        before: {
-                            enum: ["always", "never"]
-                        },
-                        after: {
-                            enum: ["always", "never"]
-                        }
-                    },
-                    additionalProperties: false,
-                    minProperties: 2
-                }
-            ]
-        }],
-        fixable: "whitespace",
-        deprecated: true
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const config = context.options[0] || "always";
-        const expectLineBefore = typeof config === "string" ? config : config.before;
-        const expectLineAfter = typeof config === "string" ? config : config.after;
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Check if node is preceded by a blank newline.
-         * @param {ASTNode} node Node to check.
-         * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.
-         */
-        function hasNewlineBefore(node) {
-            const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });
-            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;
-
-            return node.loc.start.line - tokenLineBefore >= 2;
-        }
-
-        /**
-        * Gets the last token of a node that is on the same line as the rest of the node.
-        * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing
-        * semicolon on a different line.
-        * @param {ASTNode} node A directive node
-        * @returns {Token} The last token of the node on the line
-        */
-        function getLastTokenOnLine(node) {
-            const lastToken = sourceCode.getLastToken(node);
-            const secondToLastToken = sourceCode.getTokenBefore(lastToken);
-
-            return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line
-                ? secondToLastToken
-                : lastToken;
-        }
-
-        /**
-         * Check if node is followed by a blank newline.
-         * @param {ASTNode} node Node to check.
-         * @returns {boolean} Whether or not the passed in node is followed by a blank newline.
-         */
-        function hasNewlineAfter(node) {
-            const lastToken = getLastTokenOnLine(node);
-            const tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });
-
-            return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;
-        }
-
-        /**
-         * Report errors for newlines around directives.
-         * @param {ASTNode} node Node to check.
-         * @param {string} location Whether the error was found before or after the directive.
-         * @param {boolean} expected Whether or not a newline was expected or unexpected.
-         * @returns {void}
-         */
-        function reportError(node, location, expected) {
-            context.report({
-                node,
-                message: "{{expected}} newline {{location}} \"{{value}}\" directive.",
-                data: {
-                    expected: expected ? "Expected" : "Unexpected",
-                    value: node.expression.value,
-                    location
-                },
-                fix(fixer) {
-                    const lastToken = getLastTokenOnLine(node);
-
-                    if (expected) {
-                        return location === "before" ? fixer.insertTextBefore(node, "\n") : fixer.insertTextAfter(lastToken, "\n");
-                    }
-                    return fixer.removeRange(location === "before" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);
-                }
-            });
-        }
-
-        /**
-         * Check lines around directives in node
-         * @param {ASTNode} node - node to check
-         * @returns {void}
-         */
-        function checkDirectives(node) {
-            const directives = astUtils.getDirectivePrologue(node);
-
-            if (!directives.length) {
-                return;
-            }
-
-            const firstDirective = directives[0];
-            const leadingComments = sourceCode.getCommentsBefore(firstDirective);
-
-            // Only check before the first directive if it is preceded by a comment or if it is at the top of
-            // the file and expectLineBefore is set to "never". This is to not force a newline at the top of
-            // the file if there are no comments as well as for compatibility with padded-blocks.
-            if (leadingComments.length) {
-                if (expectLineBefore === "always" && !hasNewlineBefore(firstDirective)) {
-                    reportError(firstDirective, "before", true);
-                }
-
-                if (expectLineBefore === "never" && hasNewlineBefore(firstDirective)) {
-                    reportError(firstDirective, "before", false);
-                }
-            } else if (
-                node.type === "Program" &&
-                expectLineBefore === "never" &&
-                !leadingComments.length &&
-                hasNewlineBefore(firstDirective)
-            ) {
-                reportError(firstDirective, "before", false);
-            }
-
-            const lastDirective = directives[directives.length - 1];
-            const statements = node.type === "Program" ? node.body : node.body.body;
-
-            // Do not check after the last directive if the body only
-            // contains a directive prologue and isn't followed by a comment to ensure
-            // this rule behaves well with padded-blocks.
-            if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {
-                return;
-            }
-
-            if (expectLineAfter === "always" && !hasNewlineAfter(lastDirective)) {
-                reportError(lastDirective, "after", true);
-            }
-
-            if (expectLineAfter === "never" && hasNewlineAfter(lastDirective)) {
-                reportError(lastDirective, "after", false);
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            Program: checkDirectives,
-            FunctionDeclaration: checkDirectives,
-            FunctionExpression: checkDirectives,
-            ArrowFunctionExpression: checkDirectives
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-useless-constructor.js
===================================================================
--- node_modules/eslint/lib/rules/no-useless-constructor.js	(revision )
+++ node_modules/eslint/lib/rules/no-useless-constructor.js	(revision )
@@ -1,182 +0,0 @@
-/**
- * @fileoverview Rule to flag the use of redundant constructors in classes.
- * @author Alberto Rodríguez
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether a given array of statements is a single call of `super`.
- *
- * @param {ASTNode[]} body - An array of statements to check.
- * @returns {boolean} `true` if the body is a single call of `super`.
- */
-function isSingleSuperCall(body) {
-    return (
-        body.length === 1 &&
-        body[0].type === "ExpressionStatement" &&
-        body[0].expression.type === "CallExpression" &&
-        body[0].expression.callee.type === "Super"
-    );
-}
-
-/**
- * Checks whether a given node is a pattern which doesn't have any side effects.
- * Default parameters and Destructuring parameters can have side effects.
- *
- * @param {ASTNode} node - A pattern node.
- * @returns {boolean} `true` if the node doesn't have any side effects.
- */
-function isSimple(node) {
-    return node.type === "Identifier" || node.type === "RestElement";
-}
-
-/**
- * Checks whether a given array of expressions is `...arguments` or not.
- * `super(...arguments)` passes all arguments through.
- *
- * @param {ASTNode[]} superArgs - An array of expressions to check.
- * @returns {boolean} `true` if the superArgs is `...arguments`.
- */
-function isSpreadArguments(superArgs) {
-    return (
-        superArgs.length === 1 &&
-        superArgs[0].type === "SpreadElement" &&
-        superArgs[0].argument.type === "Identifier" &&
-        superArgs[0].argument.name === "arguments"
-    );
-}
-
-/**
- * Checks whether given 2 nodes are identifiers which have the same name or not.
- *
- * @param {ASTNode} ctorParam - A node to check.
- * @param {ASTNode} superArg - A node to check.
- * @returns {boolean} `true` if the nodes are identifiers which have the same
- *      name.
- */
-function isValidIdentifierPair(ctorParam, superArg) {
-    return (
-        ctorParam.type === "Identifier" &&
-        superArg.type === "Identifier" &&
-        ctorParam.name === superArg.name
-    );
-}
-
-/**
- * Checks whether given 2 nodes are a rest/spread pair which has the same values.
- *
- * @param {ASTNode} ctorParam - A node to check.
- * @param {ASTNode} superArg - A node to check.
- * @returns {boolean} `true` if the nodes are a rest/spread pair which has the
- *      same values.
- */
-function isValidRestSpreadPair(ctorParam, superArg) {
-    return (
-        ctorParam.type === "RestElement" &&
-        superArg.type === "SpreadElement" &&
-        isValidIdentifierPair(ctorParam.argument, superArg.argument)
-    );
-}
-
-/**
- * Checks whether given 2 nodes have the same value or not.
- *
- * @param {ASTNode} ctorParam - A node to check.
- * @param {ASTNode} superArg - A node to check.
- * @returns {boolean} `true` if the nodes have the same value or not.
- */
-function isValidPair(ctorParam, superArg) {
-    return (
-        isValidIdentifierPair(ctorParam, superArg) ||
-        isValidRestSpreadPair(ctorParam, superArg)
-    );
-}
-
-/**
- * Checks whether the parameters of a constructor and the arguments of `super()`
- * have the same values or not.
- *
- * @param {ASTNode} ctorParams - The parameters of a constructor to check.
- * @param {ASTNode} superArgs - The arguments of `super()` to check.
- * @returns {boolean} `true` if those have the same values.
- */
-function isPassingThrough(ctorParams, superArgs) {
-    if (ctorParams.length !== superArgs.length) {
-        return false;
-    }
-
-    for (let i = 0; i < ctorParams.length; ++i) {
-        if (!isValidPair(ctorParams[i], superArgs[i])) {
-            return false;
-        }
-    }
-
-    return true;
-}
-
-/**
- * Checks whether the constructor body is a redundant super call.
- *
- * @param {Array} body - constructor body content.
- * @param {Array} ctorParams - The params to check against super call.
- * @returns {boolean} true if the construtor body is redundant
- */
-function isRedundantSuperCall(body, ctorParams) {
-    return (
-        isSingleSuperCall(body) &&
-        ctorParams.every(isSimple) &&
-        (
-            isSpreadArguments(body[0].expression.arguments) ||
-            isPassingThrough(ctorParams, body[0].expression.arguments)
-        )
-    );
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary constructors",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        /**
-         * Checks whether a node is a redundant constructor
-         * @param {ASTNode} node - node to check
-         * @returns {void}
-         */
-        function checkForConstructor(node) {
-            if (node.kind !== "constructor") {
-                return;
-            }
-
-            const body = node.value.body.body;
-            const ctorParams = node.value.params;
-            const superClass = node.parent.parent.superClass;
-
-            if (superClass ? isRedundantSuperCall(body, ctorParams) : (body.length === 0)) {
-                context.report({
-                    node,
-                    message: "Useless constructor."
-                });
-            }
-        }
-
-        return {
-            MethodDefinition: checkForConstructor
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/template-curly-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/template-curly-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/template-curly-spacing.js	(revision )
@@ -1,121 +0,0 @@
-/**
- * @fileoverview Rule to enforce spacing around embedded expressions of template strings
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const OPEN_PAREN = /\$\{$/;
-const CLOSE_PAREN = /^\}/;
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow spacing around embedded expressions of template strings",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            { enum: ["always", "never"] }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const always = context.options[0] === "always";
-        const prefix = always ? "Expected" : "Unexpected";
-
-        /**
-         * Checks spacing before `}` of a given token.
-         * @param {Token} token - A token to check. This is a Template token.
-         * @returns {void}
-         */
-        function checkSpacingBefore(token) {
-            const prevToken = sourceCode.getTokenBefore(token);
-
-            if (prevToken &&
-                CLOSE_PAREN.test(token.value) &&
-                astUtils.isTokenOnSameLine(prevToken, token) &&
-                sourceCode.isSpaceBetweenTokens(prevToken, token) !== always
-            ) {
-                context.report({
-                    loc: token.loc.start,
-                    message: "{{prefix}} space(s) before '}'.",
-                    data: {
-                        prefix
-                    },
-                    fix(fixer) {
-                        if (always) {
-                            return fixer.insertTextBefore(token, " ");
-                        }
-                        return fixer.removeRange([
-                            prevToken.range[1],
-                            token.range[0]
-                        ]);
-                    }
-                });
-            }
-        }
-
-        /**
-         * Checks spacing after `${` of a given token.
-         * @param {Token} token - A token to check. This is a Template token.
-         * @returns {void}
-         */
-        function checkSpacingAfter(token) {
-            const nextToken = sourceCode.getTokenAfter(token);
-
-            if (nextToken &&
-                OPEN_PAREN.test(token.value) &&
-                astUtils.isTokenOnSameLine(token, nextToken) &&
-                sourceCode.isSpaceBetweenTokens(token, nextToken) !== always
-            ) {
-                context.report({
-                    loc: {
-                        line: token.loc.end.line,
-                        column: token.loc.end.column - 2
-                    },
-                    message: "{{prefix}} space(s) after '${'.",
-                    data: {
-                        prefix
-                    },
-                    fix(fixer) {
-                        if (always) {
-                            return fixer.insertTextAfter(token, " ");
-                        }
-                        return fixer.removeRange([
-                            token.range[1],
-                            nextToken.range[0]
-                        ]);
-                    }
-                });
-            }
-        }
-
-        return {
-            TemplateElement(node) {
-                const token = sourceCode.getFirstToken(node);
-
-                checkSpacingBefore(token);
-                checkSpacingAfter(token);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/max-statements-per-line.js
===================================================================
--- node_modules/eslint/lib/rules/max-statements-per-line.js	(revision )
+++ node_modules/eslint/lib/rules/max-statements-per-line.js	(revision )
@@ -1,192 +0,0 @@
-/**
- * @fileoverview Specify the maximum number of statements allowed per line.
- * @author Kenneth Williams
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce a maximum number of statements allowed per line",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    max: {
-                        type: "integer",
-                        minimum: 1
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const sourceCode = context.getSourceCode(),
-            options = context.options[0] || {},
-            maxStatementsPerLine = typeof options.max !== "undefined" ? options.max : 1,
-            message = "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}.";
-
-        let lastStatementLine = 0,
-            numberOfStatementsOnThisLine = 0,
-            firstExtraStatement;
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        const SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/;
-
-        /**
-         * Reports with the first extra statement, and clears it.
-         *
-         * @returns {void}
-         */
-        function reportFirstExtraStatementAndClear() {
-            if (firstExtraStatement) {
-                context.report({
-                    node: firstExtraStatement,
-                    message,
-                    data: {
-                        numberOfStatementsOnThisLine,
-                        maxStatementsPerLine,
-                        statements: numberOfStatementsOnThisLine === 1 ? "statement" : "statements"
-                    }
-                });
-            }
-            firstExtraStatement = null;
-        }
-
-        /**
-         * Gets the actual last token of a given node.
-         *
-         * @param {ASTNode} node - A node to get. This is a node except EmptyStatement.
-         * @returns {Token} The actual last token.
-         */
-        function getActualLastToken(node) {
-            return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
-        }
-
-        /**
-         * Addresses a given node.
-         * It updates the state of this rule, then reports the node if the node violated this rule.
-         *
-         * @param {ASTNode} node - A node to check.
-         * @returns {void}
-         */
-        function enterStatement(node) {
-            const line = node.loc.start.line;
-
-            // Skip to allow non-block statements if this is direct child of control statements.
-            // `if (a) foo();` is counted as 1.
-            // But `if (a) foo(); else foo();` should be counted as 2.
-            if (SINGLE_CHILD_ALLOWED.test(node.parent.type) &&
-                node.parent.alternate !== node
-            ) {
-                return;
-            }
-
-            // Update state.
-            if (line === lastStatementLine) {
-                numberOfStatementsOnThisLine += 1;
-            } else {
-                reportFirstExtraStatementAndClear();
-                numberOfStatementsOnThisLine = 1;
-                lastStatementLine = line;
-            }
-
-            // Reports if the node violated this rule.
-            if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {
-                firstExtraStatement = firstExtraStatement || node;
-            }
-        }
-
-        /**
-         * Updates the state of this rule with the end line of leaving node to check with the next statement.
-         *
-         * @param {ASTNode} node - A node to check.
-         * @returns {void}
-         */
-        function leaveStatement(node) {
-            const line = getActualLastToken(node).loc.end.line;
-
-            // Update state.
-            if (line !== lastStatementLine) {
-                reportFirstExtraStatementAndClear();
-                numberOfStatementsOnThisLine = 1;
-                lastStatementLine = line;
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-            BreakStatement: enterStatement,
-            ClassDeclaration: enterStatement,
-            ContinueStatement: enterStatement,
-            DebuggerStatement: enterStatement,
-            DoWhileStatement: enterStatement,
-            ExpressionStatement: enterStatement,
-            ForInStatement: enterStatement,
-            ForOfStatement: enterStatement,
-            ForStatement: enterStatement,
-            FunctionDeclaration: enterStatement,
-            IfStatement: enterStatement,
-            ImportDeclaration: enterStatement,
-            LabeledStatement: enterStatement,
-            ReturnStatement: enterStatement,
-            SwitchStatement: enterStatement,
-            ThrowStatement: enterStatement,
-            TryStatement: enterStatement,
-            VariableDeclaration: enterStatement,
-            WhileStatement: enterStatement,
-            WithStatement: enterStatement,
-            ExportNamedDeclaration: enterStatement,
-            ExportDefaultDeclaration: enterStatement,
-            ExportAllDeclaration: enterStatement,
-
-            "BreakStatement:exit": leaveStatement,
-            "ClassDeclaration:exit": leaveStatement,
-            "ContinueStatement:exit": leaveStatement,
-            "DebuggerStatement:exit": leaveStatement,
-            "DoWhileStatement:exit": leaveStatement,
-            "ExpressionStatement:exit": leaveStatement,
-            "ForInStatement:exit": leaveStatement,
-            "ForOfStatement:exit": leaveStatement,
-            "ForStatement:exit": leaveStatement,
-            "FunctionDeclaration:exit": leaveStatement,
-            "IfStatement:exit": leaveStatement,
-            "ImportDeclaration:exit": leaveStatement,
-            "LabeledStatement:exit": leaveStatement,
-            "ReturnStatement:exit": leaveStatement,
-            "SwitchStatement:exit": leaveStatement,
-            "ThrowStatement:exit": leaveStatement,
-            "TryStatement:exit": leaveStatement,
-            "VariableDeclaration:exit": leaveStatement,
-            "WhileStatement:exit": leaveStatement,
-            "WithStatement:exit": leaveStatement,
-            "ExportNamedDeclaration:exit": leaveStatement,
-            "ExportDefaultDeclaration:exit": leaveStatement,
-            "ExportAllDeclaration:exit": leaveStatement,
-            "Program:exit": reportFirstExtraStatementAndClear
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-irregular-whitespace.js
===================================================================
--- node_modules/eslint/lib/rules/no-irregular-whitespace.js	(revision )
+++ node_modules/eslint/lib/rules/no-irregular-whitespace.js	(revision )
@@ -1,236 +0,0 @@
-/**
- * @fileoverview Rule to disalow whitespace that is not a tab or space, whitespace inside strings and comments are allowed
- * @author Jonathan Kingston
- * @author Christophe Porteneuve
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Constants
-//------------------------------------------------------------------------------
-
-const ALL_IRREGULARS = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/;
-const IRREGULAR_WHITESPACE = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mg;
-const IRREGULAR_LINE_TERMINATORS = /[\u2028\u2029]/mg;
-const LINE_BREAK = astUtils.createGlobalLinebreakMatcher();
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow irregular whitespace outside of strings and comments",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    skipComments: {
-                        type: "boolean"
-                    },
-                    skipStrings: {
-                        type: "boolean"
-                    },
-                    skipTemplates: {
-                        type: "boolean"
-                    },
-                    skipRegExps: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        // Module store of errors that we have found
-        let errors = [];
-
-        // Lookup the `skipComments` option, which defaults to `false`.
-        const options = context.options[0] || {};
-        const skipComments = !!options.skipComments;
-        const skipStrings = options.skipStrings !== false;
-        const skipRegExps = !!options.skipRegExps;
-        const skipTemplates = !!options.skipTemplates;
-
-        const sourceCode = context.getSourceCode();
-        const commentNodes = sourceCode.getAllComments();
-
-        /**
-         * Removes errors that occur inside a string node
-         * @param {ASTNode} node to check for matching errors.
-         * @returns {void}
-         * @private
-         */
-        function removeWhitespaceError(node) {
-            const locStart = node.loc.start;
-            const locEnd = node.loc.end;
-
-            errors = errors.filter(error => {
-                const errorLoc = error[1];
-
-                if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {
-                    if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {
-                        return false;
-                    }
-                }
-                return true;
-            });
-        }
-
-        /**
-         * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
-         * @param {ASTNode} node to check for matching errors.
-         * @returns {void}
-         * @private
-         */
-        function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {
-            const shouldCheckStrings = skipStrings && (typeof node.value === "string");
-            const shouldCheckRegExps = skipRegExps && (node.value instanceof RegExp);
-
-            if (shouldCheckStrings || shouldCheckRegExps) {
-
-                // If we have irregular characters remove them from the errors list
-                if (ALL_IRREGULARS.test(node.raw)) {
-                    removeWhitespaceError(node);
-                }
-            }
-        }
-
-        /**
-         * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
-         * @param {ASTNode} node to check for matching errors.
-         * @returns {void}
-         * @private
-         */
-        function removeInvalidNodeErrorsInTemplateLiteral(node) {
-            if (typeof node.value.raw === "string") {
-                if (ALL_IRREGULARS.test(node.value.raw)) {
-                    removeWhitespaceError(node);
-                }
-            }
-        }
-
-        /**
-         * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
-         * @param {ASTNode} node to check for matching errors.
-         * @returns {void}
-         * @private
-         */
-        function removeInvalidNodeErrorsInComment(node) {
-            if (ALL_IRREGULARS.test(node.value)) {
-                removeWhitespaceError(node);
-            }
-        }
-
-        /**
-         * Checks the program source for irregular whitespace
-         * @param {ASTNode} node The program node
-         * @returns {void}
-         * @private
-         */
-        function checkForIrregularWhitespace(node) {
-            const sourceLines = sourceCode.lines;
-
-            sourceLines.forEach((sourceLine, lineIndex) => {
-                const lineNumber = lineIndex + 1;
-                let match;
-
-                while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {
-                    const location = {
-                        line: lineNumber,
-                        column: match.index
-                    };
-
-                    errors.push([node, location, "Irregular whitespace not allowed."]);
-                }
-            });
-        }
-
-        /**
-         * Checks the program source for irregular line terminators
-         * @param {ASTNode} node The program node
-         * @returns {void}
-         * @private
-         */
-        function checkForIrregularLineTerminators(node) {
-            const source = sourceCode.getText(),
-                sourceLines = sourceCode.lines,
-                linebreaks = source.match(LINE_BREAK);
-            let lastLineIndex = -1,
-                match;
-
-            while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {
-                const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;
-                const location = {
-                    line: lineIndex + 1,
-                    column: sourceLines[lineIndex].length
-                };
-
-                errors.push([node, location, "Irregular whitespace not allowed."]);
-                lastLineIndex = lineIndex;
-            }
-        }
-
-        /**
-         * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.
-         * @returns {void}
-         * @private
-         */
-        function noop() {}
-
-        const nodes = {};
-
-        if (ALL_IRREGULARS.test(sourceCode.getText())) {
-            nodes.Program = function(node) {
-
-                /*
-                 * As we can easily fire warnings for all white space issues with
-                 * all the source its simpler to fire them here.
-                 * This means we can check all the application code without having
-                 * to worry about issues caused in the parser tokens.
-                 * When writing this code also evaluating per node was missing out
-                 * connecting tokens in some cases.
-                 * We can later filter the errors when they are found to be not an
-                 * issue in nodes we don't care about.
-                 */
-                checkForIrregularWhitespace(node);
-                checkForIrregularLineTerminators(node);
-            };
-
-            nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;
-            nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;
-            nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;
-            nodes["Program:exit"] = function() {
-                if (skipComments) {
-
-                    // First strip errors occurring in comment nodes.
-                    commentNodes.forEach(removeInvalidNodeErrorsInComment);
-                }
-
-                // If we have any errors remaining report on them
-                errors.forEach(error => {
-                    context.report.apply(context, error);
-                });
-            };
-        } else {
-            nodes.Program = noop;
-        }
-
-        return nodes;
-    }
-};
Index: node_modules/eslint/lib/rules/no-multiple-empty-lines.js
===================================================================
--- node_modules/eslint/lib/rules/no-multiple-empty-lines.js	(revision )
+++ node_modules/eslint/lib/rules/no-multiple-empty-lines.js	(revision )
@@ -1,136 +0,0 @@
-/**
- * @fileoverview Disallows multiple blank lines.
- * implementation adapted from the no-trailing-spaces rule.
- * @author Greg Cochard
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow multiple empty lines",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    max: {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    maxEOF: {
-                        type: "integer",
-                        minimum: 0
-                    },
-                    maxBOF: {
-                        type: "integer",
-                        minimum: 0
-                    }
-                },
-                required: ["max"],
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        // Use options.max or 2 as default
-        let max = 2,
-            maxEOF = max,
-            maxBOF = max;
-
-        if (context.options.length) {
-            max = context.options[0].max;
-            maxEOF = typeof context.options[0].maxEOF !== "undefined" ? context.options[0].maxEOF : max;
-            maxBOF = typeof context.options[0].maxBOF !== "undefined" ? context.options[0].maxBOF : max;
-        }
-
-        const sourceCode = context.getSourceCode();
-
-        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue
-        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === "" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;
-        const templateLiteralLines = new Set();
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            TemplateLiteral(node) {
-                node.quasis.forEach(literalPart => {
-
-                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.
-                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {
-                        templateLiteralLines.add(ignoredLine);
-                    }
-                });
-            },
-            "Program:exit"(node) {
-                return allLines
-
-                    // Given a list of lines, first get a list of line numbers that are non-empty.
-                    .reduce((nonEmptyLineNumbers, line, index) => {
-                        if (line.trim() || templateLiteralLines.has(index + 1)) {
-                            nonEmptyLineNumbers.push(index + 1);
-                        }
-                        return nonEmptyLineNumbers;
-                    }, [])
-
-                    // Add a value at the end to allow trailing empty lines to be checked.
-                    .concat(allLines.length + 1)
-
-                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.
-                    .reduce((lastLineNumber, lineNumber) => {
-                        let message, maxAllowed;
-
-                        if (lastLineNumber === 0) {
-                            message = "Too many blank lines at the beginning of file. Max of {{max}} allowed.";
-                            maxAllowed = maxBOF;
-                        } else if (lineNumber === allLines.length + 1) {
-                            message = "Too many blank lines at the end of file. Max of {{max}} allowed.";
-                            maxAllowed = maxEOF;
-                        } else {
-                            message = "More than {{max}} blank {{pluralizedLines}} not allowed.";
-                            maxAllowed = max;
-                        }
-
-                        if (lineNumber - lastLineNumber - 1 > maxAllowed) {
-                            context.report({
-                                node,
-                                loc: { start: { line: lastLineNumber + 1, column: 0 }, end: { line: lineNumber, column: 0 } },
-                                message,
-                                data: { max: maxAllowed, pluralizedLines: maxAllowed === 1 ? "line" : "lines" },
-                                fix(fixer) {
-                                    const rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });
-
-                                    /*
-                                     * The end of the removal range is usually the start index of the next line.
-                                     * However, at the end of the file there is no next line, so the end of the
-                                     * range is just the length of the text.
-                                     */
-                                    const lineNumberAfterRemovedLines = lineNumber - maxAllowed;
-                                    const rangeEnd = lineNumberAfterRemovedLines <= allLines.length
-                                        ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 })
-                                        : sourceCode.text.length;
-
-                                    return fixer.removeRange([rangeStart, rangeEnd]);
-                                }
-                            });
-                        }
-
-                        return lineNumber;
-                    }, 0);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-unexpected-multiline.js
===================================================================
--- node_modules/eslint/lib/rules/no-unexpected-multiline.js	(revision )
+++ node_modules/eslint/lib/rules/no-unexpected-multiline.js	(revision )
@@ -1,98 +0,0 @@
-/**
- * @fileoverview Rule to spot scenarios where a newline looks like it is ending a statement, but is not.
- * @author Glen Mailer
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow confusing multiline expressions",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        const FUNCTION_MESSAGE = "Unexpected newline between function and ( of function call.";
-        const PROPERTY_MESSAGE = "Unexpected newline between object and [ of property access.";
-        const TAGGED_TEMPLATE_MESSAGE = "Unexpected newline between template tag and template literal.";
-        const DIVISION_MESSAGE = "Unexpected newline between numerator and division operator.";
-
-        const REGEX_FLAG_MATCHER = /^[gimuy]+$/;
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Check to see if there is a newline between the node and the following open bracket
-         * line's expression
-         * @param {ASTNode} node The node to check.
-         * @param {string} msg The error message to use.
-         * @returns {void}
-         * @private
-         */
-        function checkForBreakAfter(node, msg) {
-            const openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);
-            const nodeExpressionEnd = sourceCode.getTokenBefore(openParen);
-
-            if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {
-                context.report({ node, loc: openParen.loc.start, message: msg, data: { char: openParen.value } });
-            }
-        }
-
-        //--------------------------------------------------------------------------
-        // Public API
-        //--------------------------------------------------------------------------
-
-        return {
-
-            MemberExpression(node) {
-                if (!node.computed) {
-                    return;
-                }
-                checkForBreakAfter(node.object, PROPERTY_MESSAGE);
-            },
-
-            TaggedTemplateExpression(node) {
-                if (node.tag.loc.end.line === node.quasi.loc.start.line) {
-                    return;
-                }
-                context.report({ node, loc: node.loc.start, message: TAGGED_TEMPLATE_MESSAGE });
-            },
-
-            CallExpression(node) {
-                if (node.arguments.length === 0) {
-                    return;
-                }
-                checkForBreakAfter(node.callee, FUNCTION_MESSAGE);
-            },
-
-            "BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left"(node) {
-                const secondSlash = sourceCode.getTokenAfter(node, token => token.value === "/");
-                const tokenAfterOperator = sourceCode.getTokenAfter(secondSlash);
-
-                if (
-                    tokenAfterOperator.type === "Identifier" &&
-                    REGEX_FLAG_MATCHER.test(tokenAfterOperator.value) &&
-                    secondSlash.range[1] === tokenAfterOperator.range[0]
-                ) {
-                    checkForBreakAfter(node.left, DIVISION_MESSAGE);
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-useless-computed-key.js
===================================================================
--- node_modules/eslint/lib/rules/no-useless-computed-key.js	(revision )
+++ node_modules/eslint/lib/rules/no-useless-computed-key.js	(revision )
@@ -1,74 +0,0 @@
-/**
- * @fileoverview Rule to disallow unnecessary computed property keys in object literals
- * @author Burak Yigit Kaya
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const MESSAGE_UNNECESSARY_COMPUTED = "Unnecessarily computed property [{{property}}] found.";
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unnecessary computed property keys in object literals",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-            Property(node) {
-                if (!node.computed) {
-                    return;
-                }
-
-                const key = node.key,
-                    nodeType = typeof key.value;
-
-                if (key.type === "Literal" && (nodeType === "string" || nodeType === "number") && key.value !== "__proto__") {
-                    context.report({
-                        node,
-                        message: MESSAGE_UNNECESSARY_COMPUTED,
-                        data: { property: sourceCode.getText(key) },
-                        fix(fixer) {
-                            const leftSquareBracket = sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken);
-                            const rightSquareBracket = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken);
-                            const tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);
-
-                            if (tokensBetween.slice(0, -1).some((token, index) => sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim())) {
-
-                                // If there are comments between the brackets and the property name, don't do a fix.
-                                return null;
-                            }
-
-                            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);
-
-                            // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })
-                            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&
-                                !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));
-
-                            const replacementKey = (needsSpaceBeforeKey ? " " : "") + key.raw;
-
-                            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/object-property-newline.js
===================================================================
--- node_modules/eslint/lib/rules/object-property-newline.js	(revision )
+++ node_modules/eslint/lib/rules/object-property-newline.js	(revision )
@@ -1,84 +0,0 @@
-/**
- * @fileoverview Rule to enforce placing object properties on separate lines.
- * @author Vitor Balocco
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce placing object properties on separate lines",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allowMultiplePropertiesPerLine: {
-                        type: "boolean"
-                    }
-                },
-                additionalProperties: false
-            }
-        ],
-
-        fixable: "whitespace"
-    },
-
-    create(context) {
-        const allowSameLine = context.options[0] && Boolean(context.options[0].allowMultiplePropertiesPerLine);
-        const errorMessage = allowSameLine
-            ? "Object properties must go on a new line if they aren't all on the same line."
-            : "Object properties must go on a new line.";
-
-        const sourceCode = context.getSourceCode();
-
-        return {
-            ObjectExpression(node) {
-                if (allowSameLine) {
-                    if (node.properties.length > 1) {
-                        const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);
-                        const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);
-
-                        if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {
-
-                            // All keys and values are on the same line
-                            return;
-                        }
-                    }
-                }
-
-                for (let i = 1; i < node.properties.length; i++) {
-                    const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);
-                    const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);
-
-                    if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {
-                        context.report({
-                            node,
-                            loc: firstTokenOfCurrentProperty.loc.start,
-                            message: errorMessage,
-                            fix(fixer) {
-                                const comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);
-                                const rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];
-
-                                // Don't perform a fix if there are any comments between the comma and the next property.
-                                if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {
-                                    return null;
-                                }
-
-                                return fixer.replaceTextRange(rangeAfterComma, "\n");
-                            }
-                        });
-                    }
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/prefer-numeric-literals.js
===================================================================
--- node_modules/eslint/lib/rules/prefer-numeric-literals.js	(revision )
+++ node_modules/eslint/lib/rules/prefer-numeric-literals.js	(revision )
@@ -1,110 +0,0 @@
-/**
- * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals
- * @author Annie Zhang, Henry Zhu
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks to see if a CallExpression's callee node is `parseInt` or
- * `Number.parseInt`.
- * @param {ASTNode} calleeNode The callee node to evaluate.
- * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,
- * false otherwise.
- */
-function isParseInt(calleeNode) {
-    switch (calleeNode.type) {
-        case "Identifier":
-            return calleeNode.name === "parseInt";
-        case "MemberExpression":
-            return calleeNode.object.type === "Identifier" &&
-                calleeNode.object.name === "Number" &&
-                calleeNode.property.type === "Identifier" &&
-                calleeNode.property.name === "parseInt";
-
-        // no default
-    }
-
-    return false;
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
-            category: "ECMAScript 6",
-            recommended: false
-        },
-
-        schema: [],
-
-        fixable: "code"
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        const radixMap = {
-            2: "binary",
-            8: "octal",
-            16: "hexadecimal"
-        };
-
-        const prefixMap = {
-            2: "0b",
-            8: "0o",
-            16: "0x"
-        };
-
-        //----------------------------------------------------------------------
-        // Public
-        //----------------------------------------------------------------------
-
-        return {
-
-            CallExpression(node) {
-
-                // doesn't check parseInt() if it doesn't have a radix argument
-                if (node.arguments.length !== 2) {
-                    return;
-                }
-
-                // only error if the radix is 2, 8, or 16
-                const radixName = radixMap[node.arguments[1].value];
-
-                if (isParseInt(node.callee) &&
-                    radixName &&
-                    node.arguments[0].type === "Literal"
-                ) {
-                    context.report({
-                        node,
-                        message: "Use {{radixName}} literals instead of {{functionName}}().",
-                        data: {
-                            radixName,
-                            functionName: sourceCode.getText(node.callee)
-                        },
-                        fix(fixer) {
-                            const newPrefix = prefixMap[node.arguments[1].value];
-
-                            if (+(newPrefix + node.arguments[0].value) !== parseInt(node.arguments[0].value, node.arguments[1].value)) {
-
-                                // If the newly-produced literal would be invalid, (e.g. 0b1234),
-                                // or it would yield an incorrect parseInt result for some other reason, don't make a fix.
-                                return null;
-                            }
-                            return fixer.replaceText(node, prefixMap[node.arguments[1].value] + node.arguments[0].value);
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/newline-per-chained-call.js
===================================================================
--- node_modules/eslint/lib/rules/newline-per-chained-call.js	(revision )
+++ node_modules/eslint/lib/rules/newline-per-chained-call.js	(revision )
@@ -1,103 +0,0 @@
-/**
- * @fileoverview Rule to ensure newline per method call when chaining calls
- * @author Rajendra Patil
- * @author Burak Yigit Kaya
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require a newline after each call in a method chain",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "whitespace",
-        schema: [{
-            type: "object",
-            properties: {
-                ignoreChainWithDepth: {
-                    type: "integer",
-                    minimum: 1,
-                    maximum: 10
-                }
-            },
-            additionalProperties: false
-        }]
-    },
-
-    create(context) {
-
-        const options = context.options[0] || {},
-            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;
-
-        const sourceCode = context.getSourceCode();
-
-        /**
-         * Get the prefix of a given MemberExpression node.
-         * If the MemberExpression node is a computed value it returns a
-         * left bracket. If not it returns a period.
-         *
-         * @param  {ASTNode} node - A MemberExpression node to get
-         * @returns {string} The prefix of the node.
-         */
-        function getPrefix(node) {
-            return node.computed ? "[" : ".";
-        }
-
-        /**
-         * Gets the property text of a given MemberExpression node.
-         * If the text is multiline, this returns only the first line.
-         *
-         * @param {ASTNode} node - A MemberExpression node to get.
-         * @returns {string} The property text of the node.
-         */
-        function getPropertyText(node) {
-            const prefix = getPrefix(node);
-            const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);
-            const suffix = node.computed && lines.length === 1 ? "]" : "";
-
-            return prefix + lines[0] + suffix;
-        }
-
-        return {
-            "CallExpression:exit"(node) {
-                if (!node.callee || node.callee.type !== "MemberExpression") {
-                    return;
-                }
-
-                const callee = node.callee;
-                let parent = callee.object;
-                let depth = 1;
-
-                while (parent && parent.callee) {
-                    depth += 1;
-                    parent = parent.callee.object;
-                }
-
-                if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {
-                    context.report({
-                        node: callee.property,
-                        loc: callee.property.loc.start,
-                        message: "Expected line break before `{{callee}}`.",
-                        data: {
-                            callee: getPropertyText(callee)
-                        },
-                        fix(fixer) {
-                            const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);
-
-                            return fixer.insertTextBefore(firstTokenAfterObject, "\n");
-                        }
-                    });
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-empty-character-class.js
===================================================================
--- node_modules/eslint/lib/rules/no-empty-character-class.js	(revision )
+++ node_modules/eslint/lib/rules/no-empty-character-class.js	(revision )
@@ -1,57 +0,0 @@
-/**
- * @fileoverview Rule to flag the use of empty character classes in regular expressions
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/*
-plain-English description of the following regexp:
-0. `^` fix the match at the beginning of the string
-1. `\/`: the `/` that begins the regexp
-2. `([^\\[]|\\.|\[([^\\\]]|\\.)+\])*`: regexp contents; 0 or more of the following
-  2.0. `[^\\[]`: any character that's not a `\` or a `[` (anything but escape sequences and character classes)
-  2.1. `\\.`: an escape sequence
-  2.2. `\[([^\\\]]|\\.)+\]`: a character class that isn't empty
-3. `\/` the `/` that ends the regexp
-4. `[gimuy]*`: optional regexp flags
-5. `$`: fix the match at the end of the string
-*/
-const regex = /^\/([^\\[]|\\.|\[([^\\\]]|\\.)+])*\/[gimuy]*$/;
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow empty character classes in regular expressions",
-            category: "Possible Errors",
-            recommended: true
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        return {
-
-            Literal(node) {
-                const token = sourceCode.getFirstToken(node);
-
-                if (token.type === "RegularExpression" && !regex.test(token.value)) {
-                    context.report({ node, message: "Empty class." });
-                }
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-mixed-spaces-and-tabs.js
===================================================================
--- node_modules/eslint/lib/rules/no-mixed-spaces-and-tabs.js	(revision )
+++ node_modules/eslint/lib/rules/no-mixed-spaces-and-tabs.js	(revision )
@@ -1,143 +0,0 @@
-/**
- * @fileoverview Disallow mixed spaces and tabs for indentation
- * @author Jary Niebur
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow mixed spaces and tabs for indentation",
-            category: "Stylistic Issues",
-            recommended: true
-        },
-
-        schema: [
-            {
-                enum: ["smart-tabs", true, false]
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        let smartTabs;
-        const ignoredLocs = [];
-
-        switch (context.options[0]) {
-            case true: // Support old syntax, maybe add deprecation warning here
-            case "smart-tabs":
-                smartTabs = true;
-                break;
-            default:
-                smartTabs = false;
-        }
-
-        /**
-         * Determines if a given line and column are before a location.
-         * @param {Location} loc The location object from an AST node.
-         * @param {int} line The line to check.
-         * @param {int} column The column to check.
-         * @returns {boolean} True if the line and column are before the location, false if not.
-         * @private
-         */
-        function beforeLoc(loc, line, column) {
-            if (line < loc.start.line) {
-                return true;
-            }
-            return line === loc.start.line && column < loc.start.column;
-        }
-
-        /**
-         * Determines if a given line and column are after a location.
-         * @param {Location} loc The location object from an AST node.
-         * @param {int} line The line to check.
-         * @param {int} column The column to check.
-         * @returns {boolean} True if the line and column are after the location, false if not.
-         * @private
-         */
-        function afterLoc(loc, line, column) {
-            if (line > loc.end.line) {
-                return true;
-            }
-            return line === loc.end.line && column > loc.end.column;
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-
-            TemplateElement(node) {
-                ignoredLocs.push(node.loc);
-            },
-
-            "Program:exit"(node) {
-
-                /*
-                 * At least one space followed by a tab
-                 * or the reverse before non-tab/-space
-                 * characters begin.
-                 */
-                let regex = /^(?=[\t ]*(\t | \t))/;
-                const lines = sourceCode.lines,
-                    comments = sourceCode.getAllComments();
-
-                comments.forEach(comment => {
-                    ignoredLocs.push(comment.loc);
-                });
-
-                ignoredLocs.sort((first, second) => {
-                    if (beforeLoc(first, second.start.line, second.start.column)) {
-                        return 1;
-                    }
-
-                    if (beforeLoc(second, first.start.line, second.start.column)) {
-                        return -1;
-                    }
-
-                    return 0;
-                });
-
-                if (smartTabs) {
-
-                    /*
-                     * At least one space followed by a tab
-                     * before non-tab/-space characters begin.
-                     */
-                    regex = /^(?=[\t ]* \t)/;
-                }
-
-                lines.forEach((line, i) => {
-                    const match = regex.exec(line);
-
-                    if (match) {
-                        const lineNumber = i + 1,
-                            column = match.index + 1;
-
-                        for (let j = 0; j < ignoredLocs.length; j++) {
-                            if (beforeLoc(ignoredLocs[j], lineNumber, column)) {
-                                continue;
-                            }
-                            if (afterLoc(ignoredLocs[j], lineNumber, column)) {
-                                continue;
-                            }
-
-                            return;
-                        }
-
-                        context.report({ node, loc: { line: lineNumber, column }, message: "Mixed spaces and tabs." });
-                    }
-                });
-            }
-
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-restricted-properties.js
===================================================================
--- node_modules/eslint/lib/rules/no-restricted-properties.js	(revision )
+++ node_modules/eslint/lib/rules/no-restricted-properties.js	(revision )
@@ -1,173 +0,0 @@
-/**
- * @fileoverview Rule to disallow certain object properties
- * @author Will Klein & Eli White
- */
-
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow certain properties on certain objects",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: {
-            type: "array",
-            items: {
-                anyOf: [ // `object` and `property` are both optional, but at least one of them must be provided.
-                    {
-                        type: "object",
-                        properties: {
-                            object: {
-                                type: "string"
-                            },
-                            property: {
-                                type: "string"
-                            },
-                            message: {
-                                type: "string"
-                            }
-                        },
-                        additionalProperties: false,
-                        required: ["object"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            object: {
-                                type: "string"
-                            },
-                            property: {
-                                type: "string"
-                            },
-                            message: {
-                                type: "string"
-                            }
-                        },
-                        additionalProperties: false,
-                        required: ["property"]
-                    }
-                ]
-            },
-            uniqueItems: true
-        }
-    },
-
-    create(context) {
-        const restrictedCalls = context.options;
-
-        if (restrictedCalls.length === 0) {
-            return {};
-        }
-
-        const restrictedProperties = new Map();
-        const globallyRestrictedObjects = new Map();
-        const globallyRestrictedProperties = new Map();
-
-        restrictedCalls.forEach(option => {
-            const objectName = option.object;
-            const propertyName = option.property;
-
-            if (typeof objectName === "undefined") {
-                globallyRestrictedProperties.set(propertyName, { message: option.message });
-            } else if (typeof propertyName === "undefined") {
-                globallyRestrictedObjects.set(objectName, { message: option.message });
-            } else {
-                if (!restrictedProperties.has(objectName)) {
-                    restrictedProperties.set(objectName, new Map());
-                }
-
-                restrictedProperties.get(objectName).set(propertyName, {
-                    message: option.message
-                });
-            }
-        });
-
-        /**
-        * Checks to see whether a property access is restricted, and reports it if so.
-        * @param {ASTNode} node The node to report
-        * @param {string} objectName The name of the object
-        * @param {string} propertyName The name of the property
-        * @returns {undefined}
-        */
-        function checkPropertyAccess(node, objectName, propertyName) {
-            if (propertyName === null) {
-                return;
-            }
-            const matchedObject = restrictedProperties.get(objectName);
-            const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);
-            const globalMatchedProperty = globallyRestrictedProperties.get(propertyName);
-
-            if (matchedObjectProperty) {
-                const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : "";
-
-                context.report({
-                    node,
-                    // eslint-disable-next-line eslint-plugin/report-message-format
-                    message: "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}",
-                    data: {
-                        objectName,
-                        propertyName,
-                        message
-                    }
-                });
-            } else if (globalMatchedProperty) {
-                const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : "";
-
-                context.report({
-                    node,
-                    // eslint-disable-next-line eslint-plugin/report-message-format
-                    message: "'{{propertyName}}' is restricted from being used.{{message}}",
-                    data: {
-                        propertyName,
-                        message
-                    }
-                });
-            }
-        }
-
-        /**
-        * Checks property accesses in a destructuring assignment expression, e.g. `var foo; ({foo} = bar);`
-        * @param {ASTNode} node An AssignmentExpression or AssignmentPattern node
-        * @returns {undefined}
-        */
-        function checkDestructuringAssignment(node) {
-            if (node.right.type === "Identifier") {
-                const objectName = node.right.name;
-
-                if (node.left.type === "ObjectPattern") {
-                    node.left.properties.forEach(property => {
-                        checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));
-                    });
-                }
-            }
-        }
-
-        return {
-            MemberExpression(node) {
-                checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));
-            },
-            VariableDeclarator(node) {
-                if (node.init && node.init.type === "Identifier") {
-                    const objectName = node.init.name;
-
-                    if (node.id.type === "ObjectPattern") {
-                        node.id.properties.forEach(property => {
-                            checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));
-                        });
-                    }
-                }
-            },
-            AssignmentExpression: checkDestructuringAssignment,
-            AssignmentPattern: checkDestructuringAssignment
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/computed-property-spacing.js
===================================================================
--- node_modules/eslint/lib/rules/computed-property-spacing.js	(revision )
+++ node_modules/eslint/lib/rules/computed-property-spacing.js	(revision )
@@ -1,176 +0,0 @@
-/**
- * @fileoverview Disallows or enforces spaces inside computed properties.
- * @author Jamund Ferguson
- */
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing inside computed property brackets",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                enum: ["always", "never"]
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const propertyNameMustBeSpaced = context.options[0] === "always"; // default is "never"
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-        * Reports that there shouldn't be a space after the first token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @param {Token} tokenAfter - The token after `token`.
-        * @returns {void}
-        */
-        function reportNoBeginningSpace(node, token, tokenAfter) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "There should be no space after '{{tokenValue}}'.",
-                data: {
-                    tokenValue: token.value
-                },
-                fix(fixer) {
-                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
-                }
-            });
-        }
-
-        /**
-        * Reports that there shouldn't be a space before the last token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @param {Token} tokenBefore - The token before `token`.
-        * @returns {void}
-        */
-        function reportNoEndingSpace(node, token, tokenBefore) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "There should be no space before '{{tokenValue}}'.",
-                data: {
-                    tokenValue: token.value
-                },
-                fix(fixer) {
-                    return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
-                }
-            });
-        }
-
-        /**
-        * Reports that there should be a space after the first token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportRequiredBeginningSpace(node, token) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "A space is required after '{{tokenValue}}'.",
-                data: {
-                    tokenValue: token.value
-                },
-                fix(fixer) {
-                    return fixer.insertTextAfter(token, " ");
-                }
-            });
-        }
-
-        /**
-        * Reports that there should be a space before the last token
-        * @param {ASTNode} node - The node to report in the event of an error.
-        * @param {Token} token - The token to use for the report.
-        * @returns {void}
-        */
-        function reportRequiredEndingSpace(node, token) {
-            context.report({
-                node,
-                loc: token.loc.start,
-                message: "A space is required before '{{tokenValue}}'.",
-                data: {
-                    tokenValue: token.value
-                },
-                fix(fixer) {
-                    return fixer.insertTextBefore(token, " ");
-                }
-            });
-        }
-
-        /**
-         * Returns a function that checks the spacing of a node on the property name
-         * that was passed in.
-         * @param {string} propertyName The property on the node to check for spacing
-         * @returns {Function} A function that will check spacing on a node
-         */
-        function checkSpacing(propertyName) {
-            return function(node) {
-                if (!node.computed) {
-                    return;
-                }
-
-                const property = node[propertyName];
-
-                const before = sourceCode.getTokenBefore(property),
-                    first = sourceCode.getFirstToken(property),
-                    last = sourceCode.getLastToken(property),
-                    after = sourceCode.getTokenAfter(property);
-
-                if (astUtils.isTokenOnSameLine(before, first)) {
-                    if (propertyNameMustBeSpaced) {
-                        if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {
-                            reportRequiredBeginningSpace(node, before);
-                        }
-                    } else {
-                        if (sourceCode.isSpaceBetweenTokens(before, first)) {
-                            reportNoBeginningSpace(node, before, first);
-                        }
-                    }
-                }
-
-                if (astUtils.isTokenOnSameLine(last, after)) {
-                    if (propertyNameMustBeSpaced) {
-                        if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {
-                            reportRequiredEndingSpace(node, after);
-                        }
-                    } else {
-                        if (sourceCode.isSpaceBetweenTokens(last, after)) {
-                            reportNoEndingSpace(node, after, last);
-                        }
-                    }
-                }
-            };
-        }
-
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            Property: checkSpacing("key"),
-            MemberExpression: checkSpacing("property")
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-shadow-restricted-names.js
===================================================================
--- node_modules/eslint/lib/rules/no-shadow-restricted-names.js	(revision )
+++ node_modules/eslint/lib/rules/no-shadow-restricted-names.js	(revision )
@@ -1,69 +0,0 @@
-/**
- * @fileoverview Disallow shadowing of NaN, undefined, and Infinity (ES5 section 15.1.1)
- * @author Michael Ficarra
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow identifiers from shadowing restricted names",
-            category: "Variables",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-
-        const RESTRICTED = ["undefined", "NaN", "Infinity", "arguments", "eval"];
-
-        /**
-         * Check if the node name is present inside the restricted list
-         * @param {ASTNode} id id to evaluate
-         * @returns {void}
-         * @private
-         */
-        function checkForViolation(id) {
-            if (RESTRICTED.indexOf(id.name) > -1) {
-                context.report({
-                    node: id,
-                    message: "Shadowing of global property '{{idName}}'.",
-                    data: {
-                        idName: id.name
-                    }
-                });
-            }
-        }
-
-        return {
-            VariableDeclarator(node) {
-                checkForViolation(node.id);
-            },
-            ArrowFunctionExpression(node) {
-                [].map.call(node.params, checkForViolation);
-            },
-            FunctionExpression(node) {
-                if (node.id) {
-                    checkForViolation(node.id);
-                }
-                [].map.call(node.params, checkForViolation);
-            },
-            FunctionDeclaration(node) {
-                if (node.id) {
-                    checkForViolation(node.id);
-                    [].map.call(node.params, checkForViolation);
-                }
-            },
-            CatchClause(node) {
-                checkForViolation(node.param);
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/no-template-curly-in-string.js
===================================================================
--- node_modules/eslint/lib/rules/no-template-curly-in-string.js	(revision )
+++ node_modules/eslint/lib/rules/no-template-curly-in-string.js	(revision )
@@ -1,37 +0,0 @@
-/**
- * @fileoverview Warn when using template string syntax in regular strings
- * @author Jeroen Engels
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow template literal placeholder syntax in regular strings",
-            category: "Possible Errors",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        const regex = /\$\{[^}]+\}/;
-
-        return {
-            Literal(node) {
-                if (typeof node.value === "string" && regex.test(node.value)) {
-                    context.report({
-                        node,
-                        message: "Unexpected template string expression."
-                    });
-                }
-            }
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/space-before-function-paren.js
===================================================================
--- node_modules/eslint/lib/rules/space-before-function-paren.js	(revision )
+++ node_modules/eslint/lib/rules/space-before-function-paren.js	(revision )
@@ -1,142 +0,0 @@
-/**
- * @fileoverview Rule to validate spacing before function paren.
- * @author Mathias Schreck <https://github.com/lo1tuma>
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce consistent spacing before `function` definition opening parenthesis",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-
-        schema: [
-            {
-                oneOf: [
-                    {
-                        enum: ["always", "never"]
-                    },
-                    {
-                        type: "object",
-                        properties: {
-                            anonymous: {
-                                enum: ["always", "never", "ignore"]
-                            },
-                            named: {
-                                enum: ["always", "never", "ignore"]
-                            },
-                            asyncArrow: {
-                                enum: ["always", "never", "ignore"]
-                            }
-                        },
-                        additionalProperties: false
-                    }
-                ]
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const baseConfig = typeof context.options[0] === "string" ? context.options[0] : "always";
-        const overrideConfig = typeof context.options[0] === "object" ? context.options[0] : {};
-
-        /**
-         * Determines whether a function has a name.
-         * @param {ASTNode} node The function node.
-         * @returns {boolean} Whether the function has a name.
-         */
-        function isNamedFunction(node) {
-            if (node.id) {
-                return true;
-            }
-
-            const parent = node.parent;
-
-            return parent.type === "MethodDefinition" ||
-                (parent.type === "Property" &&
-                    (
-                        parent.kind === "get" ||
-                        parent.kind === "set" ||
-                        parent.method
-                    )
-                );
-        }
-
-        /**
-         * Gets the config for a given function
-         * @param {ASTNode} node The function node
-         * @returns {string} "always", "never", or "ignore"
-         */
-        function getConfigForFunction(node) {
-            if (node.type === "ArrowFunctionExpression") {
-
-                // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar
-                if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {
-                    return overrideConfig.asyncArrow || baseConfig;
-                }
-            } else if (isNamedFunction(node)) {
-                return overrideConfig.named || baseConfig;
-
-            // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`
-            } else if (!node.generator) {
-                return overrideConfig.anonymous || baseConfig;
-            }
-
-            return "ignore";
-        }
-
-        /**
-         * Checks the parens of a function node
-         * @param {ASTNode} node A function node
-         * @returns {void}
-         */
-        function checkFunction(node) {
-            const functionConfig = getConfigForFunction(node);
-
-            if (functionConfig === "ignore") {
-                return;
-            }
-
-            const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
-            const leftToken = sourceCode.getTokenBefore(rightToken);
-            const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);
-
-            if (hasSpacing && functionConfig === "never") {
-                context.report({
-                    node,
-                    loc: leftToken.loc.end,
-                    message: "Unexpected space before function parentheses.",
-                    fix: fixer => fixer.removeRange([leftToken.range[1], rightToken.range[0]])
-                });
-            } else if (!hasSpacing && functionConfig === "always") {
-                context.report({
-                    node,
-                    loc: leftToken.loc.end,
-                    message: "Missing space before function parentheses.",
-                    fix: fixer => fixer.insertTextAfter(leftToken, " ")
-                });
-            }
-        }
-
-        return {
-            ArrowFunctionExpression: checkFunction,
-            FunctionDeclaration: checkFunction,
-            FunctionExpression: checkFunction
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-unmodified-loop-condition.js
===================================================================
--- node_modules/eslint/lib/rules/no-unmodified-loop-condition.js	(revision )
+++ node_modules/eslint/lib/rules/no-unmodified-loop-condition.js	(revision )
@@ -1,366 +0,0 @@
-/**
- * @fileoverview Rule to disallow use of unmodified expressions in loop conditions
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const Traverser = require("../util/traverser"),
-    astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const pushAll = Function.apply.bind(Array.prototype.push);
-const SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/;
-const LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/; // for-in/of statements don't have `test` property.
-const GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/;
-const SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/;
-const DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/;
-
-/**
- * @typedef {Object} LoopConditionInfo
- * @property {eslint-scope.Reference} reference - The reference.
- * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes
- *      that the reference is belonging to.
- * @property {Function} isInLoop - The predicate which checks a given reference
- *      is in this loop.
- * @property {boolean} modified - The flag that the reference is modified in
- *      this loop.
- */
-
-/**
- * Checks whether or not a given reference is a write reference.
- *
- * @param {eslint-scope.Reference} reference - A reference to check.
- * @returns {boolean} `true` if the reference is a write reference.
- */
-function isWriteReference(reference) {
-    if (reference.init) {
-        const def = reference.resolved && reference.resolved.defs[0];
-
-        if (!def || def.type !== "Variable" || def.parent.kind !== "var") {
-            return false;
-        }
-    }
-    return reference.isWrite();
-}
-
-/**
- * Checks whether or not a given loop condition info does not have the modified
- * flag.
- *
- * @param {LoopConditionInfo} condition - A loop condition info to check.
- * @returns {boolean} `true` if the loop condition info is "unmodified".
- */
-function isUnmodified(condition) {
-    return !condition.modified;
-}
-
-/**
- * Checks whether or not a given loop condition info does not have the modified
- * flag and does not have the group this condition belongs to.
- *
- * @param {LoopConditionInfo} condition - A loop condition info to check.
- * @returns {boolean} `true` if the loop condition info is "unmodified".
- */
-function isUnmodifiedAndNotBelongToGroup(condition) {
-    return !(condition.modified || condition.group);
-}
-
-/**
- * Checks whether or not a given reference is inside of a given node.
- *
- * @param {ASTNode} node - A node to check.
- * @param {eslint-scope.Reference} reference - A reference to check.
- * @returns {boolean} `true` if the reference is inside of the node.
- */
-function isInRange(node, reference) {
-    const or = node.range;
-    const ir = reference.identifier.range;
-
-    return or[0] <= ir[0] && ir[1] <= or[1];
-}
-
-/**
- * Checks whether or not a given reference is inside of a loop node's condition.
- *
- * @param {ASTNode} node - A node to check.
- * @param {eslint-scope.Reference} reference - A reference to check.
- * @returns {boolean} `true` if the reference is inside of the loop node's
- *      condition.
- */
-const isInLoop = {
-    WhileStatement: isInRange,
-    DoWhileStatement: isInRange,
-    ForStatement(node, reference) {
-        return (
-            isInRange(node, reference) &&
-            !(node.init && isInRange(node.init, reference))
-        );
-    }
-};
-
-/**
- * Checks whether or not a given group node has any dynamic elements.
- *
- * @param {ASTNode} root - A node to check.
- *      This node is one of BinaryExpression or ConditionalExpression.
- * @returns {boolean} `true` if the node is dynamic.
- */
-function hasDynamicExpressions(root) {
-    let retv = false;
-    const traverser = new Traverser();
-
-    traverser.traverse(root, {
-        enter(node) {
-            if (DYNAMIC_PATTERN.test(node.type)) {
-                retv = true;
-                this.break();
-            } else if (SKIP_PATTERN.test(node.type)) {
-                this.skip();
-            }
-        }
-    });
-
-    return retv;
-}
-
-/**
- * Creates the loop condition information from a given reference.
- *
- * @param {eslint-scope.Reference} reference - A reference to create.
- * @returns {LoopConditionInfo|null} Created loop condition info, or null.
- */
-function toLoopCondition(reference) {
-    if (reference.init) {
-        return null;
-    }
-
-    let group = null;
-    let child = reference.identifier;
-    let node = child.parent;
-
-    while (node) {
-        if (SENTINEL_PATTERN.test(node.type)) {
-            if (LOOP_PATTERN.test(node.type) && node.test === child) {
-
-                // This reference is inside of a loop condition.
-                return {
-                    reference,
-                    group,
-                    isInLoop: isInLoop[node.type].bind(null, node),
-                    modified: false
-                };
-            }
-
-            // This reference is outside of a loop condition.
-            break;
-        }
-
-        /*
-         * If it's inside of a group, OK if either operand is modified.
-         * So stores the group this reference belongs to.
-         */
-        if (GROUP_PATTERN.test(node.type)) {
-
-            // If this expression is dynamic, no need to check.
-            if (hasDynamicExpressions(node)) {
-                break;
-            } else {
-                group = node;
-            }
-        }
-
-        child = node;
-        node = node.parent;
-    }
-
-    return null;
-}
-
-/**
- * Gets the function which encloses a given reference.
- * This supports only FunctionDeclaration.
- *
- * @param {eslint-scope.Reference} reference - A reference to get.
- * @returns {ASTNode|null} The function node or null.
- */
-function getEncloseFunctionDeclaration(reference) {
-    let node = reference.identifier;
-
-    while (node) {
-        if (node.type === "FunctionDeclaration") {
-            return node.id ? node : null;
-        }
-
-        node = node.parent;
-    }
-
-    return null;
-}
-
-/**
- * Updates the "modified" flags of given loop conditions with given modifiers.
- *
- * @param {LoopConditionInfo[]} conditions - The loop conditions to be updated.
- * @param {eslint-scope.Reference[]} modifiers - The references to update.
- * @returns {void}
- */
-function updateModifiedFlag(conditions, modifiers) {
-
-    for (let i = 0; i < conditions.length; ++i) {
-        const condition = conditions[i];
-
-        for (let j = 0; !condition.modified && j < modifiers.length; ++j) {
-            const modifier = modifiers[j];
-            let funcNode, funcVar;
-
-            /*
-             * Besides checking for the condition being in the loop, we want to
-             * check the function that this modifier is belonging to is called
-             * in the loop.
-             * FIXME: This should probably be extracted to a function.
-             */
-            const inLoop = condition.isInLoop(modifier) || Boolean(
-                (funcNode = getEncloseFunctionDeclaration(modifier)) &&
-                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&
-                funcVar.references.some(condition.isInLoop)
-            );
-
-            condition.modified = inLoop;
-        }
-    }
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow unmodified loop conditions",
-            category: "Best Practices",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        let groupMap = null;
-
-        /**
-         * Reports a given condition info.
-         *
-         * @param {LoopConditionInfo} condition - A loop condition info to report.
-         * @returns {void}
-         */
-        function report(condition) {
-            const node = condition.reference.identifier;
-
-            context.report({
-                node,
-                message: "'{{name}}' is not modified in this loop.",
-                data: node
-            });
-        }
-
-        /**
-         * Registers given conditions to the group the condition belongs to.
-         *
-         * @param {LoopConditionInfo[]} conditions - A loop condition info to
-         *      register.
-         * @returns {void}
-         */
-        function registerConditionsToGroup(conditions) {
-            for (let i = 0; i < conditions.length; ++i) {
-                const condition = conditions[i];
-
-                if (condition.group) {
-                    let group = groupMap.get(condition.group);
-
-                    if (!group) {
-                        group = [];
-                        groupMap.set(condition.group, group);
-                    }
-                    group.push(condition);
-                }
-            }
-        }
-
-        /**
-         * Reports references which are inside of unmodified groups.
-         *
-         * @param {LoopConditionInfo[]} conditions - A loop condition info to report.
-         * @returns {void}
-         */
-        function checkConditionsInGroup(conditions) {
-            if (conditions.every(isUnmodified)) {
-                conditions.forEach(report);
-            }
-        }
-
-        /**
-         * Finds unmodified references which are inside of a loop condition.
-         * Then reports the references which are outside of groups.
-         *
-         * @param {eslint-scope.Variable} variable - A variable to report.
-         * @returns {void}
-         */
-        function checkReferences(variable) {
-
-            // Gets references that exist in loop conditions.
-            const conditions = variable
-                .references
-                .map(toLoopCondition)
-                .filter(Boolean);
-
-            if (conditions.length === 0) {
-                return;
-            }
-
-            // Registers the conditions to belonging groups.
-            registerConditionsToGroup(conditions);
-
-            // Check the conditions are modified.
-            const modifiers = variable.references.filter(isWriteReference);
-
-            if (modifiers.length > 0) {
-                updateModifiedFlag(conditions, modifiers);
-            }
-
-            /*
-             * Reports the conditions which are not belonging to groups.
-             * Others will be reported after all variables are done.
-             */
-            conditions
-                .filter(isUnmodifiedAndNotBelongToGroup)
-                .forEach(report);
-        }
-
-        return {
-            "Program:exit"() {
-                const queue = [context.getScope()];
-
-                groupMap = new Map();
-
-                let scope;
-
-                while ((scope = queue.pop())) {
-                    pushAll(queue, scope.childScopes);
-                    scope.variables.forEach(checkReferences);
-                }
-
-                groupMap.forEach(checkConditionsInGroup);
-                groupMap = null;
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/one-var-declaration-per-line.js
===================================================================
--- node_modules/eslint/lib/rules/one-var-declaration-per-line.js	(revision )
+++ node_modules/eslint/lib/rules/one-var-declaration-per-line.js	(revision )
@@ -1,86 +0,0 @@
-/**
- * @fileoverview Rule to check multiple var declarations per line
- * @author Alberto Rodríguez
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow newlines around variable declarations",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        schema: [
-            {
-                enum: ["always", "initializations"]
-            }
-        ],
-
-        fixable: "whitespace"
-    },
-
-    create(context) {
-
-        const ERROR_MESSAGE = "Expected variable declaration to be on a new line.";
-        const always = context.options[0] === "always";
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-
-        /**
-         * Determine if provided keyword is a variant of for specifiers
-         * @private
-         * @param {string} keyword - keyword to test
-         * @returns {boolean} True if `keyword` is a variant of for specifier
-         */
-        function isForTypeSpecifier(keyword) {
-            return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
-        }
-
-        /**
-         * Checks newlines around variable declarations.
-         * @private
-         * @param {ASTNode} node - `VariableDeclaration` node to test
-         * @returns {void}
-         */
-        function checkForNewLine(node) {
-            if (isForTypeSpecifier(node.parent.type)) {
-                return;
-            }
-
-            const declarations = node.declarations;
-            let prev;
-
-            declarations.forEach(current => {
-                if (prev && prev.loc.end.line === current.loc.start.line) {
-                    if (always || prev.init || current.init) {
-                        context.report({
-                            node,
-                            message: ERROR_MESSAGE,
-                            loc: current.loc.start,
-                            fix: fixer => fixer.insertTextBefore(current, "\n")
-                        });
-                    }
-                }
-                prev = current;
-            });
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            VariableDeclaration: checkForNewLine
-        };
-
-    }
-};
Index: node_modules/eslint/lib/rules/prefer-promise-reject-errors.js
===================================================================
--- node_modules/eslint/lib/rules/prefer-promise-reject-errors.js	(revision )
+++ node_modules/eslint/lib/rules/prefer-promise-reject-errors.js	(revision )
@@ -1,124 +0,0 @@
-/**
- * @fileoverview restrict values that can be used as Promise rejection reasons
- * @author Teddy Katz
- */
-"use strict";
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require using Error objects as Promise rejection reasons",
-            category: "Best Practices",
-            recommended: false
-        },
-        fixable: null,
-        schema: [
-            {
-                type: "object",
-                properties: {
-                    allowEmptyReject: { type: "boolean" }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-
-        const ALLOW_EMPTY_REJECT = context.options.length && context.options[0].allowEmptyReject;
-
-        //----------------------------------------------------------------------
-        // Helpers
-        //----------------------------------------------------------------------
-
-        /**
-        * Checks the argument of a reject() or Promise.reject() CallExpression, and reports it if it can't be an Error
-        * @param {ASTNode} callExpression A CallExpression node which is used to reject a Promise
-        * @returns {void}
-        */
-        function checkRejectCall(callExpression) {
-            if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {
-                return;
-            }
-            if (
-                !callExpression.arguments.length ||
-                !astUtils.couldBeError(callExpression.arguments[0]) ||
-                callExpression.arguments[0].type === "Identifier" && callExpression.arguments[0].name === "undefined"
-            ) {
-                context.report({
-                    node: callExpression,
-                    message: "Expected the Promise rejection reason to be an Error."
-                });
-            }
-        }
-
-        /**
-        * Determines whether a function call is a Promise.reject() call
-        * @param {ASTNode} node A CallExpression node
-        * @returns {boolean} `true` if the call is a Promise.reject() call
-        */
-        function isPromiseRejectCall(node) {
-            return node.callee.type === "MemberExpression" &&
-                node.callee.object.type === "Identifier" && node.callee.object.name === "Promise" &&
-                node.callee.property.type === "Identifier" && node.callee.property.name === "reject";
-        }
-
-        //----------------------------------------------------------------------
-        // Public
-        //----------------------------------------------------------------------
-
-        return {
-
-            // Check `Promise.reject(value)` calls.
-            CallExpression(node) {
-                if (isPromiseRejectCall(node)) {
-                    checkRejectCall(node);
-                }
-            },
-
-            /*
-             * Check for `new Promise((resolve, reject) => {})`, and check for reject() calls.
-             * This function is run on "NewExpression:exit" instead of "NewExpression" to ensure that
-             * the nodes in the expression already have the `parent` property.
-             */
-            "NewExpression:exit"(node) {
-                if (
-                    node.callee.type === "Identifier" && node.callee.name === "Promise" &&
-                    node.arguments.length && astUtils.isFunction(node.arguments[0]) &&
-                    node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === "Identifier"
-                ) {
-                    context.getDeclaredVariables(node.arguments[0])
-
-                        /*
-                        * Find the first variable that matches the second parameter's name.
-                        * If the first parameter has the same name as the second parameter, then the variable will actually
-                        * be "declared" when the first parameter is evaluated, but then it will be immediately overwritten
-                        * by the second parameter. It's not possible for an expression with the variable to be evaluated before
-                        * the variable is overwritten, because functions with duplicate parameters cannot have destructuring or
-                        * default assignments in their parameter lists. Therefore, it's not necessary to explicitly account for
-                        * this case.
-                        */
-                        .find(variable => variable.name === node.arguments[0].params[1].name)
-
-                        // Get the references to that variable.
-                        .references
-
-                        // Only check the references that read the parameter's value.
-                        .filter(ref => ref.isRead())
-
-                        // Only check the references that are used as the callee in a function call, e.g. `reject(foo)`.
-                        .filter(ref => ref.identifier.parent.type === "CallExpression" && ref.identifier === ref.identifier.parent.callee)
-
-                        // Check the argument of the function call to determine whether it's an Error.
-                        .forEach(ref => checkRejectCall(ref.identifier.parent));
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/no-whitespace-before-property.js
===================================================================
--- node_modules/eslint/lib/rules/no-whitespace-before-property.js	(revision )
+++ node_modules/eslint/lib/rules/no-whitespace-before-property.js	(revision )
@@ -1,92 +0,0 @@
-/**
- * @fileoverview Rule to disallow whitespace before properties
- * @author Kai Cataldo
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "disallow whitespace before properties",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-
-        fixable: "whitespace",
-        schema: []
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        //--------------------------------------------------------------------------
-        // Helpers
-        //--------------------------------------------------------------------------
-
-        /**
-         * Reports whitespace before property token
-         * @param {ASTNode} node - the node to report in the event of an error
-         * @param {Token} leftToken - the left token
-         * @param {Token} rightToken - the right token
-         * @returns {void}
-         * @private
-         */
-        function reportError(node, leftToken, rightToken) {
-            const replacementText = node.computed ? "" : ".";
-
-            context.report({
-                node,
-                message: "Unexpected whitespace before property {{propName}}.",
-                data: {
-                    propName: sourceCode.getText(node.property)
-                },
-                fix(fixer) {
-                    if (!node.computed && astUtils.isDecimalInteger(node.object)) {
-
-                        // If the object is a number literal, fixing it to something like 5.toString() would cause a SyntaxError.
-                        // Don't fix this case.
-                        return null;
-                    }
-                    return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);
-                }
-            });
-        }
-
-        //--------------------------------------------------------------------------
-        // Public
-        //--------------------------------------------------------------------------
-
-        return {
-            MemberExpression(node) {
-                let rightToken;
-                let leftToken;
-
-                if (!astUtils.isTokenOnSameLine(node.object, node.property)) {
-                    return;
-                }
-
-                if (node.computed) {
-                    rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);
-                    leftToken = sourceCode.getTokenBefore(rightToken);
-                } else {
-                    rightToken = sourceCode.getFirstToken(node.property);
-                    leftToken = sourceCode.getTokenBefore(rightToken, 1);
-                }
-
-                if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
-                    reportError(node, leftToken, rightToken);
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/padding-line-between-statements.js
===================================================================
--- node_modules/eslint/lib/rules/padding-line-between-statements.js	(revision )
+++ node_modules/eslint/lib/rules/padding-line-between-statements.js	(revision )
@@ -1,587 +0,0 @@
-/**
- * @fileoverview Rule to require or disallow newlines between statements
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const LT = `[${Array.from(astUtils.LINEBREAKS).join("")}]`;
-const PADDING_LINE_SEQUENCE = new RegExp(
-    String.raw`^(\s*?${LT})\s*${LT}(\s*;?)$`
-);
-const CJS_EXPORT = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/;
-const CJS_IMPORT = /^require\(/;
-
-/**
- * Creates tester which check if a node starts with specific keyword.
- *
- * @param {string} keyword The keyword to test.
- * @returns {Object} the created tester.
- * @private
- */
-function newKeywordTester(keyword) {
-    return {
-        test: (node, sourceCode) =>
-            sourceCode.getFirstToken(node).value === keyword
-    };
-}
-
-/**
- * Creates tester which check if a node is specific type.
- *
- * @param {string} type The node type to test.
- * @returns {Object} the created tester.
- * @private
- */
-function newNodeTypeTester(type) {
-    return {
-        test: node =>
-            node.type === type
-    };
-}
-
-/**
- * Checks the given node is an expression statement of IIFE.
- *
- * @param {ASTNode} node The node to check.
- * @returns {boolean} `true` if the node is an expression statement of IIFE.
- * @private
- */
-function isIIFEStatement(node) {
-    if (node.type === "ExpressionStatement") {
-        let call = node.expression;
-
-        if (call.type === "UnaryExpression") {
-            call = call.argument;
-        }
-        return call.type === "CallExpression" && astUtils.isFunction(call.callee);
-    }
-    return false;
-}
-
-/**
- * Checks whether the given node is a block-like statement.
- * This checks the last token of the node is the closing brace of a block.
- *
- * @param {SourceCode} sourceCode The source code to get tokens.
- * @param {ASTNode} node The node to check.
- * @returns {boolean} `true` if the node is a block-like statement.
- * @private
- */
-function isBlockLikeStatement(sourceCode, node) {
-
-    // do-while with a block is a block-like statement.
-    if (node.type === "DoWhileStatement" && node.body.type === "BlockStatement") {
-        return true;
-    }
-
-    // IIFE is a block-like statement specially from
-    // JSCS#disallowPaddingNewLinesAfterBlocks.
-    if (isIIFEStatement(node)) {
-        return true;
-    }
-
-    // Checks the last token is a closing brace of blocks.
-    const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
-    const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken)
-        ? sourceCode.getNodeByRangeIndex(lastToken.range[0])
-        : null;
-
-    return Boolean(belongingNode) && (
-        belongingNode.type === "BlockStatement" ||
-        belongingNode.type === "SwitchStatement"
-    );
-}
-
-/**
- * Check whether the given node is a directive or not.
- * @param {ASTNode} node The node to check.
- * @param {SourceCode} sourceCode The source code object to get tokens.
- * @returns {boolean} `true` if the node is a directive.
- */
-function isDirective(node, sourceCode) {
-    return (
-        node.type === "ExpressionStatement" &&
-        (
-            node.parent.type === "Program" ||
-            (
-                node.parent.type === "BlockStatement" &&
-                astUtils.isFunction(node.parent.parent)
-            )
-        ) &&
-        node.expression.type === "Literal" &&
-        typeof node.expression.value === "string" &&
-        !astUtils.isParenthesised(sourceCode, node.expression)
-    );
-}
-
-/**
- * Check whether the given node is a part of directive prologue or not.
- * @param {ASTNode} node The node to check.
- * @param {SourceCode} sourceCode The source code object to get tokens.
- * @returns {boolean} `true` if the node is a part of directive prologue.
- */
-function isDirectivePrologue(node, sourceCode) {
-    if (isDirective(node, sourceCode)) {
-        for (const sibling of node.parent.body) {
-            if (sibling === node) {
-                break;
-            }
-            if (!isDirective(sibling, sourceCode)) {
-                return false;
-            }
-        }
-        return true;
-    }
-    return false;
-}
-
-/**
- * Gets the actual last token.
- *
- * If a semicolon is semicolon-less style's semicolon, this ignores it.
- * For example:
- *
- *     foo()
- *     ;[1, 2, 3].forEach(bar)
- *
- * @param {SourceCode} sourceCode The source code to get tokens.
- * @param {ASTNode} node The node to get.
- * @returns {Token} The actual last token.
- * @private
- */
-function getActualLastToken(sourceCode, node) {
-    const semiToken = sourceCode.getLastToken(node);
-    const prevToken = sourceCode.getTokenBefore(semiToken);
-    const nextToken = sourceCode.getTokenAfter(semiToken);
-    const isSemicolonLessStyle = Boolean(
-        prevToken &&
-        nextToken &&
-        prevToken.range[0] >= node.range[0] &&
-        astUtils.isSemicolonToken(semiToken) &&
-        semiToken.loc.start.line !== prevToken.loc.end.line &&
-        semiToken.loc.end.line === nextToken.loc.start.line
-    );
-
-    return isSemicolonLessStyle ? prevToken : semiToken;
-}
-
-/**
- * This returns the concatenation of the first 2 captured strings.
- * @param {string} _ Unused. Whole matched string.
- * @param {string} trailingSpaces The trailing spaces of the first line.
- * @param {string} indentSpaces The indentation spaces of the last line.
- * @returns {string} The concatenation of trailingSpaces and indentSpaces.
- * @private
- */
-function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {
-    return trailingSpaces + indentSpaces;
-}
-
-/**
- * Check and report statements for `any` configuration.
- * It does nothing.
- *
- * @returns {void}
- * @private
- */
-function verifyForAny() {
-}
-
-/**
- * Check and report statements for `never` configuration.
- * This autofix removes blank lines between the given 2 statements.
- * However, if comments exist between 2 blank lines, it does not remove those
- * blank lines automatically.
- *
- * @param {RuleContext} context The rule context to report.
- * @param {ASTNode} prevNode The previous node to check.
- * @param {ASTNode} nextNode The next node to check.
- * @param {Array<Token[]>} paddingLines The array of token pairs that blank
- * lines exist between the pair.
- * @returns {void}
- * @private
- */
-function verifyForNever(context, prevNode, nextNode, paddingLines) {
-    if (paddingLines.length === 0) {
-        return;
-    }
-
-    context.report({
-        node: nextNode,
-        message: "Unexpected blank line before this statement.",
-        fix(fixer) {
-            if (paddingLines.length >= 2) {
-                return null;
-            }
-
-            const prevToken = paddingLines[0][0];
-            const nextToken = paddingLines[0][1];
-            const start = prevToken.range[1];
-            const end = nextToken.range[0];
-            const text = context.getSourceCode().text
-                .slice(start, end)
-                .replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);
-
-            return fixer.replaceTextRange([start, end], text);
-        }
-    });
-}
-
-/**
- * Check and report statements for `always` configuration.
- * This autofix inserts a blank line between the given 2 statements.
- * If the `prevNode` has trailing comments, it inserts a blank line after the
- * trailing comments.
- *
- * @param {RuleContext} context The rule context to report.
- * @param {ASTNode} prevNode The previous node to check.
- * @param {ASTNode} nextNode The next node to check.
- * @param {Array<Token[]>} paddingLines The array of token pairs that blank
- * lines exist between the pair.
- * @returns {void}
- * @private
- */
-function verifyForAlways(context, prevNode, nextNode, paddingLines) {
-    if (paddingLines.length > 0) {
-        return;
-    }
-
-    context.report({
-        node: nextNode,
-        message: "Expected blank line before this statement.",
-        fix(fixer) {
-            const sourceCode = context.getSourceCode();
-            let prevToken = getActualLastToken(sourceCode, prevNode);
-            const nextToken = sourceCode.getFirstTokenBetween(
-                prevToken,
-                nextNode,
-                {
-                    includeComments: true,
-
-                    /**
-                     * Skip the trailing comments of the previous node.
-                     * This inserts a blank line after the last trailing comment.
-                     *
-                     * For example:
-                     *
-                     *     foo(); // trailing comment.
-                     *     // comment.
-                     *     bar();
-                     *
-                     * Get fixed to:
-                     *
-                     *     foo(); // trailing comment.
-                     *
-                     *     // comment.
-                     *     bar();
-                     *
-                     * @param {Token} token The token to check.
-                     * @returns {boolean} `true` if the token is not a trailing comment.
-                     * @private
-                     */
-                    filter(token) {
-                        if (astUtils.isTokenOnSameLine(prevToken, token)) {
-                            prevToken = token;
-                            return false;
-                        }
-                        return true;
-                    }
-                }
-            ) || nextNode;
-            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)
-                ? "\n\n"
-                : "\n";
-
-            return fixer.insertTextAfter(prevToken, insertText);
-        }
-    });
-}
-
-/**
- * Types of blank lines.
- * `any`, `never`, and `always` are defined.
- * Those have `verify` method to check and report statements.
- * @private
- */
-const PaddingTypes = {
-    any: { verify: verifyForAny },
-    never: { verify: verifyForNever },
-    always: { verify: verifyForAlways }
-};
-
-/**
- * Types of statements.
- * Those have `test` method to check it matches to the given statement.
- * @private
- */
-const StatementTypes = {
-    "*": { test: () => true },
-    "block-like": {
-        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)
-    },
-    "cjs-export": {
-        test: (node, sourceCode) =>
-            node.type === "ExpressionStatement" &&
-            node.expression.type === "AssignmentExpression" &&
-            CJS_EXPORT.test(sourceCode.getText(node.expression.left))
-    },
-    "cjs-import": {
-        test: (node, sourceCode) =>
-            node.type === "VariableDeclaration" &&
-            node.declarations.length > 0 &&
-            Boolean(node.declarations[0].init) &&
-            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))
-    },
-    directive: {
-        test: isDirectivePrologue
-    },
-    expression: {
-        test: (node, sourceCode) =>
-            node.type === "ExpressionStatement" &&
-            !isDirectivePrologue(node, sourceCode)
-    },
-    "multiline-block-like": {
-        test: (node, sourceCode) =>
-            node.loc.start.line !== node.loc.end.line &&
-            isBlockLikeStatement(sourceCode, node)
-    },
-
-    block: newNodeTypeTester("BlockStatement"),
-    empty: newNodeTypeTester("EmptyStatement"),
-
-    break: newKeywordTester("break"),
-    case: newKeywordTester("case"),
-    class: newKeywordTester("class"),
-    const: newKeywordTester("const"),
-    continue: newKeywordTester("continue"),
-    debugger: newKeywordTester("debugger"),
-    default: newKeywordTester("default"),
-    do: newKeywordTester("do"),
-    export: newKeywordTester("export"),
-    for: newKeywordTester("for"),
-    function: newKeywordTester("function"),
-    if: newKeywordTester("if"),
-    import: newKeywordTester("import"),
-    let: newKeywordTester("let"),
-    return: newKeywordTester("return"),
-    switch: newKeywordTester("switch"),
-    throw: newKeywordTester("throw"),
-    try: newKeywordTester("try"),
-    var: newKeywordTester("var"),
-    while: newKeywordTester("while"),
-    with: newKeywordTester("with")
-};
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "require or disallow padding lines between statements",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "whitespace",
-        schema: {
-            definitions: {
-                paddingType: {
-                    enum: Object.keys(PaddingTypes)
-                },
-                statementType: {
-                    anyOf: [
-                        { enum: Object.keys(StatementTypes) },
-                        {
-                            type: "array",
-                            items: { enum: Object.keys(StatementTypes) },
-                            minItems: 1,
-                            uniqueItems: true,
-                            additionalItems: false
-                        }
-                    ]
-                }
-            },
-            type: "array",
-            items: {
-                type: "object",
-                properties: {
-                    blankLine: { $ref: "#/definitions/paddingType" },
-                    prev: { $ref: "#/definitions/statementType" },
-                    next: { $ref: "#/definitions/statementType" }
-                },
-                additionalProperties: false,
-                required: ["blankLine", "prev", "next"]
-            },
-            additionalItems: false
-        }
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-        const configureList = context.options || [];
-        let scopeInfo = null;
-
-        /**
-         * Processes to enter to new scope.
-         * This manages the current previous statement.
-         * @returns {void}
-         * @private
-         */
-        function enterScope() {
-            scopeInfo = {
-                upper: scopeInfo,
-                prevNode: null
-            };
-        }
-
-        /**
-         * Processes to exit from the current scope.
-         * @returns {void}
-         * @private
-         */
-        function exitScope() {
-            scopeInfo = scopeInfo.upper;
-        }
-
-        /**
-         * Checks whether the given node matches the given type.
-         *
-         * @param {ASTNode} node The statement node to check.
-         * @param {string|string[]} type The statement type to check.
-         * @returns {boolean} `true` if the statement node matched the type.
-         * @private
-         */
-        function match(node, type) {
-            while (node.type === "LabeledStatement") {
-                node = node.body;
-            }
-            if (Array.isArray(type)) {
-                return type.some(match.bind(null, node));
-            }
-            return StatementTypes[type].test(node, sourceCode);
-        }
-
-        /**
-         * Finds the last matched configure from configureList.
-         *
-         * @param {ASTNode} prevNode The previous statement to match.
-         * @param {ASTNode} nextNode The current statement to match.
-         * @returns {Object} The tester of the last matched configure.
-         * @private
-         */
-        function getPaddingType(prevNode, nextNode) {
-            for (let i = configureList.length - 1; i >= 0; --i) {
-                const configure = configureList[i];
-                const matched =
-                    match(prevNode, configure.prev) &&
-                    match(nextNode, configure.next);
-
-                if (matched) {
-                    return PaddingTypes[configure.blankLine];
-                }
-            }
-            return PaddingTypes.any;
-        }
-
-        /**
-         * Gets padding line sequences between the given 2 statements.
-         * Comments are separators of the padding line sequences.
-         *
-         * @param {ASTNode} prevNode The previous statement to count.
-         * @param {ASTNode} nextNode The current statement to count.
-         * @returns {Array<Token[]>} The array of token pairs.
-         * @private
-         */
-        function getPaddingLineSequences(prevNode, nextNode) {
-            const pairs = [];
-            let prevToken = getActualLastToken(sourceCode, prevNode);
-
-            if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {
-                do {
-                    const token = sourceCode.getTokenAfter(
-                        prevToken,
-                        { includeComments: true }
-                    );
-
-                    if (token.loc.start.line - prevToken.loc.end.line >= 2) {
-                        pairs.push([prevToken, token]);
-                    }
-                    prevToken = token;
-
-                } while (prevToken.range[0] < nextNode.range[0]);
-            }
-
-            return pairs;
-        }
-
-        /**
-         * Verify padding lines between the given node and the previous node.
-         *
-         * @param {ASTNode} node The node to verify.
-         * @returns {void}
-         * @private
-         */
-        function verify(node) {
-            const parentType = node.parent.type;
-            const validParent =
-                astUtils.STATEMENT_LIST_PARENTS.has(parentType) ||
-                parentType === "SwitchStatement";
-
-            if (!validParent) {
-                return;
-            }
-
-            // Save this node as the current previous statement.
-            const prevNode = scopeInfo.prevNode;
-
-            // Verify.
-            if (prevNode) {
-                const type = getPaddingType(prevNode, node);
-                const paddingLines = getPaddingLineSequences(prevNode, node);
-
-                type.verify(context, prevNode, node, paddingLines);
-            }
-
-            scopeInfo.prevNode = node;
-        }
-
-        /**
-         * Verify padding lines between the given node and the previous node.
-         * Then process to enter to new scope.
-         *
-         * @param {ASTNode} node The node to verify.
-         * @returns {void}
-         * @private
-         */
-        function verifyThenEnterScope(node) {
-            verify(node);
-            enterScope();
-        }
-
-        return {
-            Program: enterScope,
-            BlockStatement: enterScope,
-            SwitchStatement: enterScope,
-            "Program:exit": exitScope,
-            "BlockStatement:exit": exitScope,
-            "SwitchStatement:exit": exitScope,
-
-            ":statement": verify,
-
-            SwitchCase: verifyThenEnterScope,
-            "SwitchCase:exit": exitScope
-        };
-    }
-};
Index: node_modules/eslint/lib/rules/nonblock-statement-body-position.js
===================================================================
--- node_modules/eslint/lib/rules/nonblock-statement-body-position.js	(revision )
+++ node_modules/eslint/lib/rules/nonblock-statement-body-position.js	(revision )
@@ -1,114 +0,0 @@
-/**
- * @fileoverview enforce the location of single-line statements
- * @author Teddy Katz
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-const POSITION_SCHEMA = { enum: ["beside", "below", "any"] };
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce the location of single-line statements",
-            category: "Stylistic Issues",
-            recommended: false
-        },
-        fixable: "whitespace",
-        schema: [
-            POSITION_SCHEMA,
-            {
-                properties: {
-                    overrides: {
-                        properties: {
-                            if: POSITION_SCHEMA,
-                            else: POSITION_SCHEMA,
-                            while: POSITION_SCHEMA,
-                            do: POSITION_SCHEMA,
-                            for: POSITION_SCHEMA
-                        },
-                        additionalProperties: false
-                    }
-                },
-                additionalProperties: false
-            }
-        ]
-    },
-
-    create(context) {
-        const sourceCode = context.getSourceCode();
-
-        //----------------------------------------------------------------------
-        // Helpers
-        //----------------------------------------------------------------------
-
-        /**
-         * Gets the applicable preference for a particular keyword
-         * @param {string} keywordName The name of a keyword, e.g. 'if'
-         * @returns {string} The applicable option for the keyword, e.g. 'beside'
-         */
-        function getOption(keywordName) {
-            return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] ||
-                context.options[0] ||
-                "beside";
-        }
-
-        /**
-         * Validates the location of a single-line statement
-         * @param {ASTNode} node The single-line statement
-         * @param {string} keywordName The applicable keyword name for the single-line statement
-         * @returns {void}
-         */
-        function validateStatement(node, keywordName) {
-            const option = getOption(keywordName);
-
-            if (node.type === "BlockStatement" || option === "any") {
-                return;
-            }
-
-            const tokenBefore = sourceCode.getTokenBefore(node);
-
-            if (tokenBefore.loc.end.line === node.loc.start.line && option === "below") {
-                context.report({
-                    node,
-                    message: "Expected a linebreak before this statement.",
-                    fix: fixer => fixer.insertTextBefore(node, "\n")
-                });
-            } else if (tokenBefore.loc.end.line !== node.loc.start.line && option === "beside") {
-                context.report({
-                    node,
-                    message: "Expected no linebreak before this statement.",
-                    fix(fixer) {
-                        if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {
-                            return null;
-                        }
-                        return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], " ");
-                    }
-                });
-            }
-        }
-
-        //----------------------------------------------------------------------
-        // Public
-        //----------------------------------------------------------------------
-
-        return {
-            IfStatement(node) {
-                validateStatement(node.consequent, "if");
-
-                // Check the `else` node, but don't check 'else if' statements.
-                if (node.alternate && node.alternate.type !== "IfStatement") {
-                    validateStatement(node.alternate, "else");
-                }
-            },
-            WhileStatement: node => validateStatement(node.body, "while"),
-            DoWhileStatement: node => validateStatement(node.body, "do"),
-            ForStatement: node => validateStatement(node.body, "for"),
-            ForInStatement: node => validateStatement(node.body, "for"),
-            ForOfStatement: node => validateStatement(node.body, "for")
-        };
-    }
-};
Index: node_modules/eslint/lib/api.js
===================================================================
--- node_modules/eslint/lib/api.js	(revision )
+++ node_modules/eslint/lib/api.js	(revision )
@@ -1,16 +0,0 @@
-/**
- * @fileoverview Expose out ESLint and CLI to require.
- * @author Ian Christian Myers
- */
-
-"use strict";
-
-const Linter = require("./linter");
-
-module.exports = {
-    linter: new Linter(),
-    Linter,
-    CLIEngine: require("./cli-engine"),
-    RuleTester: require("./testers/rule-tester"),
-    SourceCode: require("./util/source-code")
-};
Index: node_modules/eslint/lib/cli.js
===================================================================
--- node_modules/eslint/lib/cli.js	(revision )
+++ node_modules/eslint/lib/cli.js	(revision )
@@ -1,211 +0,0 @@
-/**
- * @fileoverview Main CLI object.
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-/*
- * The CLI object should *not* call process.exit() directly. It should only return
- * exit codes. This allows other programs to use the CLI object and still control
- * when the program exits.
- */
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const fs = require("fs"),
-    path = require("path"),
-    options = require("./options"),
-    CLIEngine = require("./cli-engine"),
-    mkdirp = require("mkdirp"),
-    log = require("./logging");
-
-const debug = require("debug")("eslint:cli");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Predicate function for whether or not to apply fixes in quiet mode.
- * If a message is a warning, do not apply a fix.
- * @param {LintResult} lintResult The lint result.
- * @returns {boolean} True if the lint message is an error (and thus should be
- * autofixed), false otherwise.
- */
-function quietFixPredicate(lintResult) {
-    return lintResult.severity === 2;
-}
-
-/**
- * Translates the CLI options into the options expected by the CLIEngine.
- * @param {Object} cliOptions The CLI options to translate.
- * @returns {CLIEngineOptions} The options object for the CLIEngine.
- * @private
- */
-function translateOptions(cliOptions) {
-    return {
-        envs: cliOptions.env,
-        extensions: cliOptions.ext,
-        rules: cliOptions.rule,
-        plugins: cliOptions.plugin,
-        globals: cliOptions.global,
-        ignore: cliOptions.ignore,
-        ignorePath: cliOptions.ignorePath,
-        ignorePattern: cliOptions.ignorePattern,
-        configFile: cliOptions.config,
-        rulePaths: cliOptions.rulesdir,
-        useEslintrc: cliOptions.eslintrc,
-        parser: cliOptions.parser,
-        parserOptions: cliOptions.parserOptions,
-        cache: cliOptions.cache,
-        cacheFile: cliOptions.cacheFile,
-        cacheLocation: cliOptions.cacheLocation,
-        fix: cliOptions.fix && (cliOptions.quiet ? quietFixPredicate : true),
-        allowInlineConfig: cliOptions.inlineConfig
-    };
-}
-
-/**
- * Outputs the results of the linting.
- * @param {CLIEngine} engine The CLIEngine to use.
- * @param {LintResult[]} results The results to print.
- * @param {string} format The name of the formatter to use or the path to the formatter.
- * @param {string} outputFile The path for the output file.
- * @returns {boolean} True if the printing succeeds, false if not.
- * @private
- */
-function printResults(engine, results, format, outputFile) {
-    let formatter;
-
-    try {
-        formatter = engine.getFormatter(format);
-    } catch (e) {
-        log.error(e.message);
-        return false;
-    }
-
-    const output = formatter(results);
-
-    if (output) {
-        if (outputFile) {
-            const filePath = path.resolve(process.cwd(), outputFile);
-
-            if (fs.existsSync(filePath) && fs.statSync(filePath).isDirectory()) {
-                log.error("Cannot write to output file path, it is a directory: %s", outputFile);
-                return false;
-            }
-
-            try {
-                mkdirp.sync(path.dirname(filePath));
-                fs.writeFileSync(filePath, output);
-            } catch (ex) {
-                log.error("There was a problem writing the output file:\n%s", ex);
-                return false;
-            }
-        } else {
-            log.info(output);
-        }
-    }
-
-    return true;
-
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * Encapsulates all CLI behavior for eslint. Makes it easier to test as well as
- * for other Node.js programs to effectively run the CLI.
- */
-const cli = {
-
-    /**
-     * Executes the CLI based on an array of arguments that is passed in.
-     * @param {string|Array|Object} args The arguments to process.
-     * @param {string} [text] The text to lint (used for TTY).
-     * @returns {int} The exit code for the operation.
-     */
-    execute(args, text) {
-
-        let currentOptions;
-
-        try {
-            currentOptions = options.parse(args);
-        } catch (error) {
-            log.error(error.message);
-            return 1;
-        }
-
-        const files = currentOptions._;
-
-        if (currentOptions.version) { // version from package.json
-
-            log.info(`v${require("../package.json").version}`);
-
-        } else if (currentOptions.printConfig) {
-            if (files.length) {
-                log.error("The --print-config option must be used with exactly one file name.");
-                return 1;
-            } else if (text) {
-                log.error("The --print-config option is not available for piped-in code.");
-                return 1;
-            }
-
-            const engine = new CLIEngine(translateOptions(currentOptions));
-
-            const fileConfig = engine.getConfigForFile(currentOptions.printConfig);
-
-            log.info(JSON.stringify(fileConfig, null, "  "));
-            return 0;
-        } else if (currentOptions.help || (!files.length && !text)) {
-
-            log.info(options.generateHelp());
-
-        } else {
-
-            debug(`Running on ${text ? "text" : "files"}`);
-
-            // disable --fix for piped-in code until we know how to do it correctly
-            if (text && currentOptions.fix) {
-                log.error("The --fix option is not available for piped-in code.");
-                return 1;
-            }
-
-            const engine = new CLIEngine(translateOptions(currentOptions));
-
-            const report = text ? engine.executeOnText(text, currentOptions.stdinFilename, true) : engine.executeOnFiles(files);
-
-            if (currentOptions.fix) {
-                debug("Fix mode enabled - applying fixes");
-                CLIEngine.outputFixes(report);
-            }
-
-            if (currentOptions.quiet) {
-                debug("Quiet mode enabled - filtering out warnings");
-                report.results = CLIEngine.getErrorResults(report.results);
-            }
-
-            if (printResults(engine, report.results, currentOptions.format, currentOptions.outputFile)) {
-                const tooManyWarnings = currentOptions.maxWarnings >= 0 && report.warningCount > currentOptions.maxWarnings;
-
-                if (!report.errorCount && tooManyWarnings) {
-                    log.error("ESLint found too many warnings (maximum: %s).", currentOptions.maxWarnings);
-                }
-
-                return (report.errorCount || tooManyWarnings) ? 1 : 0;
-            }
-            return 1;
-
-
-        }
-
-        return 0;
-    }
-};
-
-module.exports = cli;
Index: node_modules/eslint/lib/config/plugins.js
===================================================================
--- node_modules/eslint/lib/config/plugins.js	(revision )
+++ node_modules/eslint/lib/config/plugins.js	(revision )
@@ -1,177 +0,0 @@
-/**
- * @fileoverview Plugins manager
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const debug = require("debug")("eslint:plugins");
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-const PLUGIN_NAME_PREFIX = "eslint-plugin-",
-    NAMESPACE_REGEX = /^@.*\//i;
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * Plugin class
- */
-class Plugins {
-
-    /**
-     * Creates the plugins context
-     * @param {Environments} envContext - env context
-     * @param {Rules} rulesContext - rules context
-     */
-    constructor(envContext, rulesContext) {
-        this._plugins = Object.create(null);
-        this._environments = envContext;
-        this._rules = rulesContext;
-    }
-
-    /**
-     * Removes the prefix `eslint-plugin-` from a plugin name.
-     * @param {string} pluginName The name of the plugin which may have the prefix.
-     * @returns {string} The name of the plugin without prefix.
-     */
-    static removePrefix(pluginName) {
-        return pluginName.startsWith(PLUGIN_NAME_PREFIX) ? pluginName.slice(PLUGIN_NAME_PREFIX.length) : pluginName;
-    }
-
-    /**
-     * Gets the scope (namespace) of a plugin.
-     * @param {string} pluginName The name of the plugin which may have the prefix.
-     * @returns {string} The name of the plugins namepace if it has one.
-     */
-    static getNamespace(pluginName) {
-        return pluginName.match(NAMESPACE_REGEX) ? pluginName.match(NAMESPACE_REGEX)[0] : "";
-    }
-
-    /**
-     * Removes the namespace from a plugin name.
-     * @param {string} pluginName The name of the plugin which may have the prefix.
-     * @returns {string} The name of the plugin without the namespace.
-     */
-    static removeNamespace(pluginName) {
-        return pluginName.replace(NAMESPACE_REGEX, "");
-    }
-
-    /**
-     * Defines a plugin with a given name rather than loading from disk.
-     * @param {string} pluginName The name of the plugin to load.
-     * @param {Object} plugin The plugin object.
-     * @returns {void}
-     */
-    define(pluginName, plugin) {
-        const pluginNamespace = Plugins.getNamespace(pluginName),
-            pluginNameWithoutNamespace = Plugins.removeNamespace(pluginName),
-            pluginNameWithoutPrefix = Plugins.removePrefix(pluginNameWithoutNamespace),
-            shortName = pluginNamespace + pluginNameWithoutPrefix;
-
-        // load up environments and rules
-        this._plugins[shortName] = plugin;
-        this._environments.importPlugin(plugin, shortName);
-        this._rules.importPlugin(plugin, shortName);
-    }
-
-    /**
-     * Gets a plugin with the given name.
-     * @param {string} pluginName The name of the plugin to retrieve.
-     * @returns {Object} The plugin or null if not loaded.
-     */
-    get(pluginName) {
-        return this._plugins[pluginName] || null;
-    }
-
-    /**
-     * Returns all plugins that are loaded.
-     * @returns {Object} The plugins cache.
-     */
-    getAll() {
-        return this._plugins;
-    }
-
-    /**
-     * Loads a plugin with the given name.
-     * @param {string} pluginName The name of the plugin to load.
-     * @returns {void}
-     * @throws {Error} If the plugin cannot be loaded.
-     */
-    load(pluginName) {
-        const pluginNamespace = Plugins.getNamespace(pluginName),
-            pluginNameWithoutNamespace = Plugins.removeNamespace(pluginName),
-            pluginNameWithoutPrefix = Plugins.removePrefix(pluginNameWithoutNamespace),
-            shortName = pluginNamespace + pluginNameWithoutPrefix,
-            longName = pluginNamespace + PLUGIN_NAME_PREFIX + pluginNameWithoutPrefix;
-        let plugin = null;
-
-        if (pluginName.match(/\s+/)) {
-            const whitespaceError = new Error(`Whitespace found in plugin name '${pluginName}'`);
-
-            whitespaceError.messageTemplate = "whitespace-found";
-            whitespaceError.messageData = {
-                pluginName: longName
-            };
-            throw whitespaceError;
-        }
-
-        if (!this._plugins[shortName]) {
-            try {
-                plugin = require(longName);
-            } catch (pluginLoadErr) {
-                try {
-
-                    // Check whether the plugin exists
-                    require.resolve(longName);
-                } catch (missingPluginErr) {
-
-                    // If the plugin can't be resolved, display the missing plugin error (usually a config or install error)
-                    debug(`Failed to load plugin ${longName}.`);
-                    missingPluginErr.message = `Failed to load plugin ${pluginName}: ${missingPluginErr.message}`;
-                    missingPluginErr.messageTemplate = "plugin-missing";
-                    missingPluginErr.messageData = {
-                        pluginName: longName
-                    };
-                    throw missingPluginErr;
-                }
-
-                // Otherwise, the plugin exists and is throwing on module load for some reason, so print the stack trace.
-                throw pluginLoadErr;
-            }
-
-            this.define(pluginName, plugin);
-        }
-    }
-
-    /**
-     * Loads all plugins from an array.
-     * @param {string[]} pluginNames An array of plugins names.
-     * @returns {void}
-     * @throws {Error} If a plugin cannot be loaded.
-     * @throws {Error} If "plugins" in config is not an array
-     */
-    loadAll(pluginNames) {
-
-        // if "plugins" in config is not an array, throw an error so user can fix their config.
-        if (!Array.isArray(pluginNames)) {
-            const pluginNotArrayMessage = "ESLint configuration error: \"plugins\" value must be an array";
-
-            debug(`${pluginNotArrayMessage}: ${JSON.stringify(pluginNames)}`);
-
-            throw new Error(pluginNotArrayMessage);
-        }
-
-        // load each plugin by name
-        pluginNames.forEach(this.load, this);
-    }
-}
-
-module.exports = Plugins;
Index: node_modules/eslint/lib/config/autoconfig.js
===================================================================
--- node_modules/eslint/lib/config/autoconfig.js	(revision )
+++ node_modules/eslint/lib/config/autoconfig.js	(revision )
@@ -1,357 +0,0 @@
-/**
- * @fileoverview Used for creating a suggested configuration based on project code.
- * @author Ian VanSchooten
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash"),
-    Linter = require("../linter"),
-    configRule = require("./config-rule"),
-    ConfigOps = require("./config-ops"),
-    recConfig = require("../../conf/eslint-recommended");
-
-const debug = require("debug")("eslint:autoconfig");
-const linter = new Linter();
-
-//------------------------------------------------------------------------------
-// Data
-//------------------------------------------------------------------------------
-
-const MAX_CONFIG_COMBINATIONS = 17, // 16 combinations + 1 for severity only
-    RECOMMENDED_CONFIG_NAME = "eslint:recommended";
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-/**
- * Information about a rule configuration, in the context of a Registry.
- *
- * @typedef {Object}     registryItem
- * @param   {ruleConfig} config        A valid configuration for the rule
- * @param   {number}     specificity   The number of elements in the ruleConfig array
- * @param   {number}     errorCount    The number of errors encountered when linting with the config
- */
-
-/**
- * This callback is used to measure execution status in a progress bar
- * @callback progressCallback
- * @param {number} The total number of times the callback will be called.
- */
-
-/**
- * Create registryItems for rules
- * @param   {rulesConfig} rulesConfig Hash of rule names and arrays of ruleConfig items
- * @returns {Object}                  registryItems for each rule in provided rulesConfig
- */
-function makeRegistryItems(rulesConfig) {
-    return Object.keys(rulesConfig).reduce((accumulator, ruleId) => {
-        accumulator[ruleId] = rulesConfig[ruleId].map(config => ({
-            config,
-            specificity: config.length || 1,
-            errorCount: void 0
-        }));
-        return accumulator;
-    }, {});
-}
-
-/**
-* Creates an object in which to store rule configs and error counts
-*
-* Unless a rulesConfig is provided at construction, the registry will not contain
-* any rules, only methods.  This will be useful for building up registries manually.
-*
-* Registry class
-*/
-class Registry {
-
-    /**
-     * @param {rulesConfig} [rulesConfig] Hash of rule names and arrays of possible configurations
-     */
-    constructor(rulesConfig) {
-        this.rules = (rulesConfig) ? makeRegistryItems(rulesConfig) : {};
-    }
-
-    /**
-     * Populate the registry with core rule configs.
-     *
-     * It will set the registry's `rule` property to an object having rule names
-     * as keys and an array of registryItems as values.
-     *
-     * @returns {void}
-     */
-    populateFromCoreRules() {
-        const rulesConfig = configRule.createCoreRuleConfigs();
-
-        this.rules = makeRegistryItems(rulesConfig);
-    }
-
-    /**
-     * Creates sets of rule configurations which can be used for linting
-     * and initializes registry errors to zero for those configurations (side effect).
-     *
-     * This combines as many rules together as possible, such that the first sets
-     * in the array will have the highest number of rules configured, and later sets
-     * will have fewer and fewer, as not all rules have the same number of possible
-     * configurations.
-     *
-     * The length of the returned array will be <= MAX_CONFIG_COMBINATIONS.
-     *
-     * @param   {Object}   registry The autoconfig registry
-     * @returns {Object[]}          "rules" configurations to use for linting
-     */
-    buildRuleSets() {
-        let idx = 0;
-        const ruleIds = Object.keys(this.rules),
-            ruleSets = [];
-
-        /**
-         * Add a rule configuration from the registry to the ruleSets
-         *
-         * This is broken out into its own function so that it doesn't need to be
-         * created inside of the while loop.
-         *
-         * @param   {string} rule The ruleId to add.
-         * @returns {void}
-         */
-        const addRuleToRuleSet = function(rule) {
-
-            /*
-             * This check ensures that there is a rule configuration and that
-             * it has fewer than the max combinations allowed.
-             * If it has too many configs, we will only use the most basic of
-             * the possible configurations.
-             */
-            const hasFewCombos = (this.rules[rule].length <= MAX_CONFIG_COMBINATIONS);
-
-            if (this.rules[rule][idx] && (hasFewCombos || this.rules[rule][idx].specificity <= 2)) {
-
-                /*
-                 * If the rule has too many possible combinations, only take
-                 * simple ones, avoiding objects.
-                 */
-                if (!hasFewCombos && typeof this.rules[rule][idx].config[1] === "object") {
-                    return;
-                }
-
-                ruleSets[idx] = ruleSets[idx] || {};
-                ruleSets[idx][rule] = this.rules[rule][idx].config;
-
-                /*
-                 * Initialize errorCount to zero, since this is a config which
-                 * will be linted.
-                 */
-                this.rules[rule][idx].errorCount = 0;
-            }
-        }.bind(this);
-
-        while (ruleSets.length === idx) {
-            ruleIds.forEach(addRuleToRuleSet);
-            idx += 1;
-        }
-
-        return ruleSets;
-    }
-
-    /**
-     * Remove all items from the registry with a non-zero number of errors
-     *
-     * Note: this also removes rule configurations which were not linted
-     * (meaning, they have an undefined errorCount).
-     *
-     * @returns {void}
-     */
-    stripFailingConfigs() {
-        const ruleIds = Object.keys(this.rules),
-            newRegistry = new Registry();
-
-        newRegistry.rules = Object.assign({}, this.rules);
-        ruleIds.forEach(ruleId => {
-            const errorFreeItems = newRegistry.rules[ruleId].filter(registryItem => (registryItem.errorCount === 0));
-
-            if (errorFreeItems.length > 0) {
-                newRegistry.rules[ruleId] = errorFreeItems;
-            } else {
-                delete newRegistry.rules[ruleId];
-            }
-        });
-
-        return newRegistry;
-    }
-
-    /**
-     * Removes rule configurations which were not included in a ruleSet
-     *
-     * @returns {void}
-     */
-    stripExtraConfigs() {
-        const ruleIds = Object.keys(this.rules),
-            newRegistry = new Registry();
-
-        newRegistry.rules = Object.assign({}, this.rules);
-        ruleIds.forEach(ruleId => {
-            newRegistry.rules[ruleId] = newRegistry.rules[ruleId].filter(registryItem => (typeof registryItem.errorCount !== "undefined"));
-        });
-
-        return newRegistry;
-    }
-
-    /**
-     * Creates a registry of rules which had no error-free configs.
-     * The new registry is intended to be analyzed to determine whether its rules
-     * should be disabled or set to warning.
-     *
-     * @returns {Registry}  A registry of failing rules.
-     */
-    getFailingRulesRegistry() {
-        const ruleIds = Object.keys(this.rules),
-            failingRegistry = new Registry();
-
-        ruleIds.forEach(ruleId => {
-            const failingConfigs = this.rules[ruleId].filter(registryItem => (registryItem.errorCount > 0));
-
-            if (failingConfigs && failingConfigs.length === this.rules[ruleId].length) {
-                failingRegistry.rules[ruleId] = failingConfigs;
-            }
-        });
-
-        return failingRegistry;
-    }
-
-    /**
-     * Create an eslint config for any rules which only have one configuration
-     * in the registry.
-     *
-     * @returns {Object} An eslint config with rules section populated
-     */
-    createConfig() {
-        const ruleIds = Object.keys(this.rules),
-            config = { rules: {} };
-
-        ruleIds.forEach(ruleId => {
-            if (this.rules[ruleId].length === 1) {
-                config.rules[ruleId] = this.rules[ruleId][0].config;
-            }
-        });
-
-        return config;
-    }
-
-    /**
-     * Return a cloned registry containing only configs with a desired specificity
-     *
-     * @param   {number} specificity Only keep configs with this specificity
-     * @returns {Registry}           A registry of rules
-     */
-    filterBySpecificity(specificity) {
-        const ruleIds = Object.keys(this.rules),
-            newRegistry = new Registry();
-
-        newRegistry.rules = Object.assign({}, this.rules);
-        ruleIds.forEach(ruleId => {
-            newRegistry.rules[ruleId] = this.rules[ruleId].filter(registryItem => (registryItem.specificity === specificity));
-        });
-
-        return newRegistry;
-    }
-
-    /**
-     * Lint SourceCodes against all configurations in the registry, and record results
-     *
-     * @param   {Object[]} sourceCodes  SourceCode objects for each filename
-     * @param   {Object}   config       ESLint config object
-     * @param   {progressCallback} [cb] Optional callback for reporting execution status
-     * @returns {Registry}              New registry with errorCount populated
-     */
-    lintSourceCode(sourceCodes, config, cb) {
-        let lintedRegistry = new Registry();
-
-        lintedRegistry.rules = Object.assign({}, this.rules);
-
-        const ruleSets = lintedRegistry.buildRuleSets();
-
-        lintedRegistry = lintedRegistry.stripExtraConfigs();
-
-        debug("Linting with all possible rule combinations");
-
-        const filenames = Object.keys(sourceCodes);
-        const totalFilesLinting = filenames.length * ruleSets.length;
-
-        filenames.forEach(filename => {
-            debug(`Linting file: ${filename}`);
-
-            let ruleSetIdx = 0;
-
-            ruleSets.forEach(ruleSet => {
-                const lintConfig = Object.assign({}, config, { rules: ruleSet });
-                const lintResults = linter.verify(sourceCodes[filename], lintConfig);
-
-                lintResults.forEach(result => {
-
-                    // It is possible that the error is from a configuration comment
-                    // in a linted file, in which case there may not be a config
-                    // set in this ruleSetIdx.
-                    // (https://github.com/eslint/eslint/issues/5992)
-                    // (https://github.com/eslint/eslint/issues/7860)
-                    if (
-                        lintedRegistry.rules[result.ruleId] &&
-                        lintedRegistry.rules[result.ruleId][ruleSetIdx]
-                    ) {
-                        lintedRegistry.rules[result.ruleId][ruleSetIdx].errorCount += 1;
-                    }
-                });
-
-                ruleSetIdx += 1;
-
-                if (cb) {
-                    cb(totalFilesLinting); // eslint-disable-line callback-return
-                }
-            });
-
-            // Deallocate for GC
-            sourceCodes[filename] = null;
-        });
-
-        return lintedRegistry;
-    }
-}
-
-/**
- * Extract rule configuration into eslint:recommended where possible.
- *
- * This will return a new config with `"extends": "eslint:recommended"` and
- * only the rules which have configurations different from the recommended config.
- *
- * @param   {Object} config config object
- * @returns {Object}        config object using `"extends": "eslint:recommended"`
- */
-function extendFromRecommended(config) {
-    const newConfig = Object.assign({}, config);
-
-    ConfigOps.normalizeToStrings(newConfig);
-
-    const recRules = Object.keys(recConfig.rules).filter(ruleId => ConfigOps.isErrorSeverity(recConfig.rules[ruleId]));
-
-    recRules.forEach(ruleId => {
-        if (lodash.isEqual(recConfig.rules[ruleId], newConfig.rules[ruleId])) {
-            delete newConfig.rules[ruleId];
-        }
-    });
-    newConfig.extends = RECOMMENDED_CONFIG_NAME;
-    return newConfig;
-}
-
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = {
-    Registry,
-    extendFromRecommended
-};
Index: node_modules/eslint/lib/config/config-ops.js
===================================================================
--- node_modules/eslint/lib/config/config-ops.js	(revision )
+++ node_modules/eslint/lib/config/config-ops.js	(revision )
@@ -1,383 +0,0 @@
-/**
- * @fileoverview Config file operations. This file must be usable in the browser,
- * so no Node-specific code can be here.
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const minimatch = require("minimatch"),
-    path = require("path");
-
-const debug = require("debug")("eslint:config-ops");
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-const RULE_SEVERITY_STRINGS = ["off", "warn", "error"],
-    RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {
-        map[value] = index;
-        return map;
-    }, {}),
-    VALID_SEVERITIES = [0, 1, 2, "off", "warn", "error"];
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = {
-
-    /**
-     * Creates an empty configuration object suitable for merging as a base.
-     * @returns {Object} A configuration object.
-     */
-    createEmptyConfig() {
-        return {
-            globals: {},
-            env: {},
-            rules: {},
-            parserOptions: {}
-        };
-    },
-
-    /**
-     * Creates an environment config based on the specified environments.
-     * @param {Object<string,boolean>} env The environment settings.
-     * @param {Environments} envContext The environment context.
-     * @returns {Object} A configuration object with the appropriate rules and globals
-     *      set.
-     */
-    createEnvironmentConfig(env, envContext) {
-
-        const envConfig = this.createEmptyConfig();
-
-        if (env) {
-
-            envConfig.env = env;
-
-            Object.keys(env).filter(name => env[name]).forEach(name => {
-                const environment = envContext.get(name);
-
-                if (environment) {
-                    debug(`Creating config for environment ${name}`);
-                    if (environment.globals) {
-                        Object.assign(envConfig.globals, environment.globals);
-                    }
-
-                    if (environment.parserOptions) {
-                        Object.assign(envConfig.parserOptions, environment.parserOptions);
-                    }
-                }
-            });
-        }
-
-        return envConfig;
-    },
-
-    /**
-     * Given a config with environment settings, applies the globals and
-     * ecmaFeatures to the configuration and returns the result.
-     * @param {Object} config The configuration information.
-     * @param {Environments} envContent env context.
-     * @returns {Object} The updated configuration information.
-     */
-    applyEnvironments(config, envContent) {
-        if (config.env && typeof config.env === "object") {
-            debug("Apply environment settings to config");
-            return this.merge(this.createEnvironmentConfig(config.env, envContent), config);
-        }
-
-        return config;
-    },
-
-    /**
-     * Merges two config objects. This will not only add missing keys, but will also modify values to match.
-     * @param {Object} target config object
-     * @param {Object} src config object. Overrides in this config object will take priority over base.
-     * @param {boolean} [combine] Whether to combine arrays or not
-     * @param {boolean} [isRule] Whether its a rule
-     * @returns {Object} merged config object.
-     */
-    merge: function deepmerge(target, src, combine, isRule) {
-
-        /*
-         The MIT License (MIT)
-
-         Copyright (c) 2012 Nicholas Fisher
-
-         Permission is hereby granted, free of charge, to any person obtaining a copy
-         of this software and associated documentation files (the "Software"), to deal
-         in the Software without restriction, including without limitation the rights
-         to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-         copies of the Software, and to permit persons to whom the Software is
-         furnished to do so, subject to the following conditions:
-
-         The above copyright notice and this permission notice shall be included in
-         all copies or substantial portions of the Software.
-
-         THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-         IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-         FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-         AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-         LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-         OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-         THE SOFTWARE.
-         */
-
-        /*
-         * This code is taken from deepmerge repo
-         * (https://github.com/KyleAMathews/deepmerge)
-         * and modified to meet our needs.
-         */
-        const array = Array.isArray(src) || Array.isArray(target);
-        let dst = array && [] || {};
-
-        combine = !!combine;
-        isRule = !!isRule;
-        if (array) {
-            target = target || [];
-
-            // src could be a string, so check for array
-            if (isRule && Array.isArray(src) && src.length > 1) {
-                dst = dst.concat(src);
-            } else {
-                dst = dst.concat(target);
-            }
-            if (typeof src !== "object" && !Array.isArray(src)) {
-                src = [src];
-            }
-            Object.keys(src).forEach((e, i) => {
-                e = src[i];
-                if (typeof dst[i] === "undefined") {
-                    dst[i] = e;
-                } else if (typeof e === "object") {
-                    if (isRule) {
-                        dst[i] = e;
-                    } else {
-                        dst[i] = deepmerge(target[i], e, combine, isRule);
-                    }
-                } else {
-                    if (!combine) {
-                        dst[i] = e;
-                    } else {
-                        if (dst.indexOf(e) === -1) {
-                            dst.push(e);
-                        }
-                    }
-                }
-            });
-        } else {
-            if (target && typeof target === "object") {
-                Object.keys(target).forEach(key => {
-                    dst[key] = target[key];
-                });
-            }
-            Object.keys(src).forEach(key => {
-                if (key === "overrides") {
-                    dst[key] = (target[key] || []).concat(src[key] || []);
-                } else if (Array.isArray(src[key]) || Array.isArray(target[key])) {
-                    dst[key] = deepmerge(target[key], src[key], key === "plugins" || key === "extends", isRule);
-                } else if (typeof src[key] !== "object" || !src[key] || key === "exported" || key === "astGlobals") {
-                    dst[key] = src[key];
-                } else {
-                    dst[key] = deepmerge(target[key] || {}, src[key], combine, key === "rules");
-                }
-            });
-        }
-
-        return dst;
-    },
-
-    /**
-     * Normalizes the severity value of a rule's configuration to a number
-     * @param {(number|string|[number, ...*]|[string, ...*])} ruleConfig A rule's configuration value, generally
-     * received from the user. A valid config value is either 0, 1, 2, the string "off" (treated the same as 0),
-     * the string "warn" (treated the same as 1), the string "error" (treated the same as 2), or an array
-     * whose first element is one of the above values. Strings are matched case-insensitively.
-     * @returns {(0|1|2)} The numeric severity value if the config value was valid, otherwise 0.
-     */
-    getRuleSeverity(ruleConfig) {
-        const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
-
-        if (severityValue === 0 || severityValue === 1 || severityValue === 2) {
-            return severityValue;
-        }
-
-        if (typeof severityValue === "string") {
-            return RULE_SEVERITY[severityValue.toLowerCase()] || 0;
-        }
-
-        return 0;
-    },
-
-    /**
-     * Converts old-style severity settings (0, 1, 2) into new-style
-     * severity settings (off, warn, error) for all rules. Assumption is that severity
-     * values have already been validated as correct.
-     * @param {Object} config The config object to normalize.
-     * @returns {void}
-     */
-    normalizeToStrings(config) {
-
-        if (config.rules) {
-            Object.keys(config.rules).forEach(ruleId => {
-                const ruleConfig = config.rules[ruleId];
-
-                if (typeof ruleConfig === "number") {
-                    config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
-                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
-                    ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
-                }
-            });
-        }
-    },
-
-    /**
-     * Determines if the severity for the given rule configuration represents an error.
-     * @param {int|string|Array} ruleConfig The configuration for an individual rule.
-     * @returns {boolean} True if the rule represents an error, false if not.
-     */
-    isErrorSeverity(ruleConfig) {
-
-        let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
-
-        if (typeof severity === "string") {
-            severity = RULE_SEVERITY[severity.toLowerCase()] || 0;
-        }
-
-        return (typeof severity === "number" && severity === 2);
-    },
-
-    /**
-     * Checks whether a given config has valid severity or not.
-     * @param {number|string|Array} ruleConfig - The configuration for an individual rule.
-     * @returns {boolean} `true` if the configuration has valid severity.
-     */
-    isValidSeverity(ruleConfig) {
-        let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
-
-        if (typeof severity === "string") {
-            severity = severity.toLowerCase();
-        }
-        return VALID_SEVERITIES.indexOf(severity) !== -1;
-    },
-
-    /**
-     * Checks whether every rule of a given config has valid severity or not.
-     * @param {Object} config - The configuration for rules.
-     * @returns {boolean} `true` if the configuration has valid severity.
-     */
-    isEverySeverityValid(config) {
-        return Object.keys(config).every(ruleId => this.isValidSeverity(config[ruleId]));
-    },
-
-    /**
-     * Merges all configurations in a given config vector. A vector is an array of objects, each containing a config
-     * file path and a list of subconfig indices that match the current file path. All config data is assumed to be
-     * cached.
-     * @param {Array<Object>} vector list of config files and their subconfig indices that match the current file path
-     * @param {Object} configCache the config cache
-     * @returns {Object} config object
-     */
-    getConfigFromVector(vector, configCache) {
-
-        const cachedConfig = configCache.getMergedVectorConfig(vector);
-
-        if (cachedConfig) {
-            return cachedConfig;
-        }
-
-        debug("Using config from partial cache");
-
-        const subvector = Array.from(vector);
-        let nearestCacheIndex = subvector.length - 1,
-            partialCachedConfig;
-
-        while (nearestCacheIndex >= 0) {
-            partialCachedConfig = configCache.getMergedVectorConfig(subvector);
-            if (partialCachedConfig) {
-                break;
-            }
-            subvector.pop();
-            nearestCacheIndex--;
-        }
-
-        if (!partialCachedConfig) {
-            partialCachedConfig = {};
-        }
-
-        let finalConfig = partialCachedConfig;
-
-        // Start from entry immediately following nearest cached config (first uncached entry)
-        for (let i = nearestCacheIndex + 1; i < vector.length; i++) {
-            finalConfig = this.mergeVectorEntry(finalConfig, vector[i], configCache);
-            configCache.setMergedVectorConfig(vector.slice(0, i + 1), finalConfig);
-        }
-
-        return finalConfig;
-    },
-
-    /**
-     * Merges the config options from a single vector entry into the supplied config.
-     * @param {Object} config the base config to merge the vector entry's options into
-     * @param {Object} vectorEntry a single entry from a vector, consisting of a config file path and an array of
-     * matching override indices
-     * @param {Object} configCache the config cache
-     * @returns {Object} merged config object
-     */
-    mergeVectorEntry(config, vectorEntry, configCache) {
-        const vectorEntryConfig = Object.assign({}, configCache.getConfig(vectorEntry.filePath));
-        let mergedConfig = Object.assign({}, config),
-            overrides;
-
-        if (vectorEntryConfig.overrides) {
-            overrides = vectorEntryConfig.overrides.filter(
-                (override, overrideIndex) => vectorEntry.matchingOverrides.indexOf(overrideIndex) !== -1
-            );
-        } else {
-            overrides = [];
-        }
-
-        mergedConfig = this.merge(mergedConfig, vectorEntryConfig);
-
-        delete mergedConfig.overrides;
-
-        mergedConfig = overrides.reduce((lastConfig, override) => this.merge(lastConfig, override), mergedConfig);
-
-        if (mergedConfig.filePath) {
-            delete mergedConfig.filePath;
-            delete mergedConfig.baseDirectory;
-        } else if (mergedConfig.files) {
-            delete mergedConfig.files;
-        }
-
-        return mergedConfig;
-    },
-
-    /**
-     * Checks that the specified file path matches all of the supplied glob patterns.
-     * @param {string} filePath The file path to test patterns against
-     * @param {string|string[]} patterns One or more glob patterns, of which at least one should match the file path
-     * @param {string|string[]} [excludedPatterns] One or more glob patterns, of which none should match the file path
-     * @returns {boolean} True if all the supplied patterns match the file path, false otherwise
-     */
-    pathMatchesGlobs(filePath, patterns, excludedPatterns) {
-        const patternList = [].concat(patterns);
-        const excludedPatternList = [].concat(excludedPatterns || []);
-
-        patternList.concat(excludedPatternList).forEach(pattern => {
-            if (path.isAbsolute(pattern) || pattern.includes("..")) {
-                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);
-            }
-        });
-
-        const opts = { matchBase: true };
-
-        return patternList.some(pattern => minimatch(filePath, pattern, opts)) &&
-            !excludedPatternList.some(excludedPattern => minimatch(filePath, excludedPattern, opts));
-    }
-};
Index: node_modules/eslint/lib/config/config-file.js
===================================================================
--- node_modules/eslint/lib/config/config-file.js	(revision )
+++ node_modules/eslint/lib/config/config-file.js	(revision )
@@ -1,638 +0,0 @@
-/**
- * @fileoverview Helper to locate and load configuration files.
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const fs = require("fs"),
-    path = require("path"),
-    ConfigOps = require("./config-ops"),
-    validator = require("./config-validator"),
-    pathUtil = require("../util/path-util"),
-    ModuleResolver = require("../util/module-resolver"),
-    pathIsInside = require("path-is-inside"),
-    stripComments = require("strip-json-comments"),
-    stringify = require("json-stable-stringify"),
-    requireUncached = require("require-uncached");
-
-const debug = require("debug")("eslint:config-file");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Determines sort order for object keys for json-stable-stringify
- *
- * see: https://github.com/substack/json-stable-stringify#cmp
- *
- * @param   {Object} a The first comparison object ({key: akey, value: avalue})
- * @param   {Object} b The second comparison object ({key: bkey, value: bvalue})
- * @returns {number}   1 or -1, used in stringify cmp method
- */
-function sortByKey(a, b) {
-    return a.key > b.key ? 1 : -1;
-}
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-const CONFIG_FILES = [
-    ".eslintrc.js",
-    ".eslintrc.yaml",
-    ".eslintrc.yml",
-    ".eslintrc.json",
-    ".eslintrc",
-    "package.json"
-];
-
-const resolver = new ModuleResolver();
-
-/**
- * Convenience wrapper for synchronously reading file contents.
- * @param {string} filePath The filename to read.
- * @returns {string} The file contents, with the BOM removed.
- * @private
- */
-function readFile(filePath) {
-    return fs.readFileSync(filePath, "utf8").replace(/^\ufeff/, "");
-}
-
-/**
- * Determines if a given string represents a filepath or not using the same
- * conventions as require(), meaning that the first character must be nonalphanumeric
- * and not the @ sign which is used for scoped packages to be considered a file path.
- * @param {string} filePath The string to check.
- * @returns {boolean} True if it's a filepath, false if not.
- * @private
- */
-function isFilePath(filePath) {
-    return path.isAbsolute(filePath) || !/\w|@/.test(filePath.charAt(0));
-}
-
-/**
- * Loads a YAML configuration from a file.
- * @param {string} filePath The filename to load.
- * @returns {Object} The configuration object from the file.
- * @throws {Error} If the file cannot be read.
- * @private
- */
-function loadYAMLConfigFile(filePath) {
-    debug(`Loading YAML config file: ${filePath}`);
-
-    // lazy load YAML to improve performance when not used
-    const yaml = require("js-yaml");
-
-    try {
-
-        // empty YAML file can be null, so always use
-        return yaml.safeLoad(readFile(filePath)) || {};
-    } catch (e) {
-        debug(`Error reading YAML file: ${filePath}`);
-        e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;
-        throw e;
-    }
-}
-
-/**
- * Loads a JSON configuration from a file.
- * @param {string} filePath The filename to load.
- * @returns {Object} The configuration object from the file.
- * @throws {Error} If the file cannot be read.
- * @private
- */
-function loadJSONConfigFile(filePath) {
-    debug(`Loading JSON config file: ${filePath}`);
-
-    try {
-        return JSON.parse(stripComments(readFile(filePath)));
-    } catch (e) {
-        debug(`Error reading JSON file: ${filePath}`);
-        e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;
-        throw e;
-    }
-}
-
-/**
- * Loads a legacy (.eslintrc) configuration from a file.
- * @param {string} filePath The filename to load.
- * @returns {Object} The configuration object from the file.
- * @throws {Error} If the file cannot be read.
- * @private
- */
-function loadLegacyConfigFile(filePath) {
-    debug(`Loading config file: ${filePath}`);
-
-    // lazy load YAML to improve performance when not used
-    const yaml = require("js-yaml");
-
-    try {
-        return yaml.safeLoad(stripComments(readFile(filePath))) || /* istanbul ignore next */ {};
-    } catch (e) {
-        debug(`Error reading YAML file: ${filePath}`);
-        e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;
-        throw e;
-    }
-}
-
-/**
- * Loads a JavaScript configuration from a file.
- * @param {string} filePath The filename to load.
- * @returns {Object} The configuration object from the file.
- * @throws {Error} If the file cannot be read.
- * @private
- */
-function loadJSConfigFile(filePath) {
-    debug(`Loading JS config file: ${filePath}`);
-    try {
-        return requireUncached(filePath);
-    } catch (e) {
-        debug(`Error reading JavaScript file: ${filePath}`);
-        e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;
-        throw e;
-    }
-}
-
-/**
- * Loads a configuration from a package.json file.
- * @param {string} filePath The filename to load.
- * @returns {Object} The configuration object from the file.
- * @throws {Error} If the file cannot be read.
- * @private
- */
-function loadPackageJSONConfigFile(filePath) {
-    debug(`Loading package.json config file: ${filePath}`);
-    try {
-        return loadJSONConfigFile(filePath).eslintConfig || null;
-    } catch (e) {
-        debug(`Error reading package.json file: ${filePath}`);
-        e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;
-        throw e;
-    }
-}
-
-/**
- * Creates an error to notify about a missing config to extend from.
- * @param {string} configName The name of the missing config.
- * @returns {Error} The error object to throw
- * @private
- */
-function configMissingError(configName) {
-    const error = new Error(`Failed to load config "${configName}" to extend from.`);
-
-    error.messageTemplate = "extend-config-missing";
-    error.messageData = {
-        configName
-    };
-    return error;
-}
-
-/**
- * Loads a configuration file regardless of the source. Inspects the file path
- * to determine the correctly way to load the config file.
- * @param {Object} file The path to the configuration.
- * @returns {Object} The configuration information.
- * @private
- */
-function loadConfigFile(file) {
-    const filePath = file.filePath;
-    let config;
-
-    switch (path.extname(filePath)) {
-        case ".js":
-            config = loadJSConfigFile(filePath);
-            if (file.configName) {
-                config = config.configs[file.configName];
-                if (!config) {
-                    throw configMissingError(file.configFullName);
-                }
-            }
-            break;
-
-        case ".json":
-            if (path.basename(filePath) === "package.json") {
-                config = loadPackageJSONConfigFile(filePath);
-                if (config === null) {
-                    return null;
-                }
-            } else {
-                config = loadJSONConfigFile(filePath);
-            }
-            break;
-
-        case ".yaml":
-        case ".yml":
-            config = loadYAMLConfigFile(filePath);
-            break;
-
-        default:
-            config = loadLegacyConfigFile(filePath);
-    }
-
-    return ConfigOps.merge(ConfigOps.createEmptyConfig(), config);
-}
-
-/**
- * Writes a configuration file in JSON format.
- * @param {Object} config The configuration object to write.
- * @param {string} filePath The filename to write to.
- * @returns {void}
- * @private
- */
-function writeJSONConfigFile(config, filePath) {
-    debug(`Writing JSON config file: ${filePath}`);
-
-    const content = stringify(config, { cmp: sortByKey, space: 4 });
-
-    fs.writeFileSync(filePath, content, "utf8");
-}
-
-/**
- * Writes a configuration file in YAML format.
- * @param {Object} config The configuration object to write.
- * @param {string} filePath The filename to write to.
- * @returns {void}
- * @private
- */
-function writeYAMLConfigFile(config, filePath) {
-    debug(`Writing YAML config file: ${filePath}`);
-
-    // lazy load YAML to improve performance when not used
-    const yaml = require("js-yaml");
-
-    const content = yaml.safeDump(config, { sortKeys: true });
-
-    fs.writeFileSync(filePath, content, "utf8");
-}
-
-/**
- * Writes a configuration file in JavaScript format.
- * @param {Object} config The configuration object to write.
- * @param {string} filePath The filename to write to.
- * @returns {void}
- * @private
- */
-function writeJSConfigFile(config, filePath) {
-    debug(`Writing JS config file: ${filePath}`);
-
-    const content = `module.exports = ${stringify(config, { cmp: sortByKey, space: 4 })};`;
-
-    fs.writeFileSync(filePath, content, "utf8");
-}
-
-/**
- * Writes a configuration file.
- * @param {Object} config The configuration object to write.
- * @param {string} filePath The filename to write to.
- * @returns {void}
- * @throws {Error} When an unknown file type is specified.
- * @private
- */
-function write(config, filePath) {
-    switch (path.extname(filePath)) {
-        case ".js":
-            writeJSConfigFile(config, filePath);
-            break;
-
-        case ".json":
-            writeJSONConfigFile(config, filePath);
-            break;
-
-        case ".yaml":
-        case ".yml":
-            writeYAMLConfigFile(config, filePath);
-            break;
-
-        default:
-            throw new Error("Can't write to unknown file type.");
-    }
-}
-
-/**
- * Determines the base directory for node packages referenced in a config file.
- * This does not include node_modules in the path so it can be used for all
- * references relative to a config file.
- * @param {string} configFilePath The config file referencing the file.
- * @returns {string} The base directory for the file path.
- * @private
- */
-function getBaseDir(configFilePath) {
-
-    // calculates the path of the project including ESLint as dependency
-    const projectPath = path.resolve(__dirname, "../../../");
-
-    if (configFilePath && pathIsInside(configFilePath, projectPath)) {
-
-        // be careful of https://github.com/substack/node-resolve/issues/78
-        return path.join(path.resolve(configFilePath));
-    }
-
-    /*
-     * default to ESLint project path since it's unlikely that plugins will be
-     * in this directory
-     */
-    return path.join(projectPath);
-}
-
-/**
- * Determines the lookup path, including node_modules, for package
- * references relative to a config file.
- * @param {string} configFilePath The config file referencing the file.
- * @returns {string} The lookup path for the file path.
- * @private
- */
-function getLookupPath(configFilePath) {
-    const basedir = getBaseDir(configFilePath);
-
-    return path.join(basedir, "node_modules");
-}
-
-/**
- * Resolves a eslint core config path
- * @param {string} name The eslint config name.
- * @returns {string} The resolved path of the config.
- * @private
- */
-function getEslintCoreConfigPath(name) {
-    if (name === "eslint:recommended") {
-
-        /*
-         * Add an explicit substitution for eslint:recommended to
-         * conf/eslint-recommended.js.
-         */
-        return path.resolve(__dirname, "../../conf/eslint-recommended.js");
-    }
-
-    if (name === "eslint:all") {
-
-        /*
-         * Add an explicit substitution for eslint:all to conf/eslint-all.js
-         */
-        return path.resolve(__dirname, "../../conf/eslint-all.js");
-    }
-
-    throw configMissingError(name);
-}
-
-/**
- * Applies values from the "extends" field in a configuration file.
- * @param {Object} config The configuration information.
- * @param {Config} configContext Plugin context for the config instance
- * @param {string} filePath The file path from which the configuration information
- *      was loaded.
- * @param {string} [relativeTo] The path to resolve relative to.
- * @returns {Object} A new configuration object with all of the "extends" fields
- *      loaded and merged.
- * @private
- */
-function applyExtends(config, configContext, filePath, relativeTo) {
-    let configExtends = config.extends;
-
-    // normalize into an array for easier handling
-    if (!Array.isArray(config.extends)) {
-        configExtends = [config.extends];
-    }
-
-    // Make the last element in an array take the highest precedence
-    config = configExtends.reduceRight((previousValue, parentPath) => {
-        try {
-            if (parentPath.startsWith("eslint:")) {
-                parentPath = getEslintCoreConfigPath(parentPath);
-            } else if (isFilePath(parentPath)) {
-
-                /*
-                 * If the `extends` path is relative, use the directory of the current configuration
-                 * file as the reference point. Otherwise, use as-is.
-                 */
-                parentPath = (path.isAbsolute(parentPath)
-                    ? parentPath
-                    : path.join(relativeTo || path.dirname(filePath), parentPath)
-                );
-            }
-            debug(`Loading ${parentPath}`);
-
-            // eslint-disable-next-line no-use-before-define
-            return ConfigOps.merge(load(parentPath, configContext, relativeTo), previousValue);
-        } catch (e) {
-
-            /*
-             * If the file referenced by `extends` failed to load, add the path
-             * to the configuration file that referenced it to the error
-             * message so the user is able to see where it was referenced from,
-             * then re-throw.
-             */
-            e.message += `\nReferenced from: ${filePath}`;
-            throw e;
-        }
-
-    }, config);
-
-    return config;
-}
-
-/**
- * Brings package name to correct format based on prefix
- * @param {string} name The name of the package.
- * @param {string} prefix Can be either "eslint-plugin" or "eslint-config
- * @returns {string} Normalized name of the package
- * @private
- */
-function normalizePackageName(name, prefix) {
-
-    /*
-     * On Windows, name can come in with Windows slashes instead of Unix slashes.
-     * Normalize to Unix first to avoid errors later on.
-     * https://github.com/eslint/eslint/issues/5644
-     */
-    if (name.indexOf("\\") > -1) {
-        name = pathUtil.convertPathToPosix(name);
-    }
-
-    if (name.charAt(0) === "@") {
-
-        /*
-         * it's a scoped package
-         * package name is "eslint-config", or just a username
-         */
-        const scopedPackageShortcutRegex = new RegExp(`^(@[^/]+)(?:/(?:${prefix})?)?$`),
-            scopedPackageNameRegex = new RegExp(`^${prefix}(-|$)`);
-
-        if (scopedPackageShortcutRegex.test(name)) {
-            name = name.replace(scopedPackageShortcutRegex, `$1/${prefix}`);
-        } else if (!scopedPackageNameRegex.test(name.split("/")[1])) {
-
-            /*
-             * for scoped packages, insert the eslint-config after the first / unless
-             * the path is already @scope/eslint or @scope/eslint-config-xxx
-             */
-            name = name.replace(/^@([^/]+)\/(.*)$/, `@$1/${prefix}-$2`);
-        }
-    } else if (name.indexOf(`${prefix}-`) !== 0) {
-        name = `${prefix}-${name}`;
-    }
-
-    return name;
-}
-
-/**
- * Resolves a configuration file path into the fully-formed path, whether filename
- * or package name.
- * @param {string} filePath The filepath to resolve.
- * @param {string} [relativeTo] The path to resolve relative to.
- * @returns {Object} An object containing 3 properties:
- * - 'filePath' (required) the resolved path that can be used directly to load the configuration.
- * - 'configName' the name of the configuration inside the plugin.
- * - 'configFullName' (required) the name of the configuration as used in the eslint config(e.g. 'plugin:node/recommended'),
- *     or the absolute path to a config file. This should uniquely identify a config.
- * @private
- */
-function resolve(filePath, relativeTo) {
-    if (isFilePath(filePath)) {
-        const fullPath = path.resolve(relativeTo || "", filePath);
-
-        return { filePath: fullPath, configFullName: fullPath };
-    }
-    let normalizedPackageName;
-
-    if (filePath.startsWith("plugin:")) {
-        const configFullName = filePath;
-        const pluginName = filePath.slice(7, filePath.lastIndexOf("/"));
-        const configName = filePath.slice(filePath.lastIndexOf("/") + 1);
-
-        normalizedPackageName = normalizePackageName(pluginName, "eslint-plugin");
-        debug(`Attempting to resolve ${normalizedPackageName}`);
-        filePath = resolver.resolve(normalizedPackageName, getLookupPath(relativeTo));
-        return { filePath, configName, configFullName };
-    }
-    normalizedPackageName = normalizePackageName(filePath, "eslint-config");
-    debug(`Attempting to resolve ${normalizedPackageName}`);
-    filePath = resolver.resolve(normalizedPackageName, getLookupPath(relativeTo));
-    return { filePath, configFullName: filePath };
-
-
-}
-
-/**
- * Loads a configuration file from the given file path.
- * @param {Object} resolvedPath The value from calling resolve() on a filename or package name.
- * @param {Config} configContext Plugins context
- * @returns {Object} The configuration information.
- */
-function loadFromDisk(resolvedPath, configContext) {
-    const dirname = path.dirname(resolvedPath.filePath),
-        lookupPath = getLookupPath(dirname);
-    let config = loadConfigFile(resolvedPath);
-
-    if (config) {
-
-        // ensure plugins are properly loaded first
-        if (config.plugins) {
-            configContext.plugins.loadAll(config.plugins);
-        }
-
-        // include full path of parser if present
-        if (config.parser) {
-            if (isFilePath(config.parser)) {
-                config.parser = path.resolve(dirname || "", config.parser);
-            } else {
-                config.parser = resolver.resolve(config.parser, lookupPath);
-            }
-        }
-
-        // validate the configuration before continuing
-        validator.validate(config, resolvedPath.configFullName, configContext.linterContext.rules, configContext.linterContext.environments);
-
-        /*
-         * If an `extends` property is defined, it represents a configuration file to use as
-         * a "parent". Load the referenced file and merge the configuration recursively.
-         */
-        if (config.extends) {
-            config = applyExtends(config, configContext, resolvedPath.filePath, dirname);
-        }
-    }
-
-    return config;
-}
-
-/**
- * Loads a config object, applying extends if present.
- * @param {Object} configObject a config object to load
- * @param {Config} configContext Context for the config instance
- * @returns {Object} the config object with extends applied if present, or the passed config if not
- * @private
- */
-function loadObject(configObject, configContext) {
-    return configObject.extends ? applyExtends(configObject, configContext, "") : configObject;
-}
-
-/**
- * Loads a config object from the config cache based on its filename, falling back to the disk if the file is not yet
- * cached.
- * @param {string} filePath the path to the config file
- * @param {Config} configContext Context for the config instance
- * @param {string} [relativeTo] The path to resolve relative to.
- * @returns {Object} the parsed config object (empty object if there was a parse error)
- * @private
- */
-function load(filePath, configContext, relativeTo) {
-    const resolvedPath = resolve(filePath, relativeTo);
-
-    const cachedConfig = configContext.configCache.getConfig(resolvedPath.configFullName);
-
-    if (cachedConfig) {
-        return cachedConfig;
-    }
-
-    const config = loadFromDisk(resolvedPath, configContext);
-
-    if (config) {
-        config.filePath = resolvedPath.filePath;
-        config.baseDirectory = path.dirname(resolvedPath.filePath);
-        configContext.configCache.setConfig(resolvedPath.configFullName, config);
-    }
-
-    return config;
-}
-
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = {
-
-    getBaseDir,
-    getLookupPath,
-    load,
-    loadObject,
-    resolve,
-    write,
-    applyExtends,
-    normalizePackageName,
-    CONFIG_FILES,
-
-    /**
-     * Retrieves the configuration filename for a given directory. It loops over all
-     * of the valid configuration filenames in order to find the first one that exists.
-     * @param {string} directory The directory to check for a config file.
-     * @returns {?string} The filename of the configuration file for the directory
-     *      or null if there is no configuration file in the directory.
-     */
-    getFilenameForDirectory(directory) {
-        for (let i = 0, len = CONFIG_FILES.length; i < len; i++) {
-            const filename = path.join(directory, CONFIG_FILES[i]);
-
-            if (fs.existsSync(filename) && fs.statSync(filename).isFile()) {
-                return filename;
-            }
-        }
-
-        return null;
-    }
-};
Index: node_modules/eslint/lib/config/config-rule.js
===================================================================
--- node_modules/eslint/lib/config/config-rule.js	(revision )
+++ node_modules/eslint/lib/config/config-rule.js	(revision )
@@ -1,322 +0,0 @@
-/**
- * @fileoverview Create configurations for a rule
- * @author Ian VanSchooten
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const Rules = require("../rules"),
-    loadRules = require("../load-rules");
-
-const rules = new Rules();
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Wrap all of the elements of an array into arrays.
- * @param   {*[]}     xs Any array.
- * @returns {Array[]}    An array of arrays.
- */
-function explodeArray(xs) {
-    return xs.reduce((accumulator, x) => {
-        accumulator.push([x]);
-        return accumulator;
-    }, []);
-}
-
-/**
- * Mix two arrays such that each element of the second array is concatenated
- * onto each element of the first array.
- *
- * For example:
- * combineArrays([a, [b, c]], [x, y]); // -> [[a, x], [a, y], [b, c, x], [b, c, y]]
- *
- * @param   {array} arr1 The first array to combine.
- * @param   {array} arr2 The second array to combine.
- * @returns {array}      A mixture of the elements of the first and second arrays.
- */
-function combineArrays(arr1, arr2) {
-    const res = [];
-
-    if (arr1.length === 0) {
-        return explodeArray(arr2);
-    }
-    if (arr2.length === 0) {
-        return explodeArray(arr1);
-    }
-    arr1.forEach(x1 => {
-        arr2.forEach(x2 => {
-            res.push([].concat(x1, x2));
-        });
-    });
-    return res;
-}
-
-/**
- * Group together valid rule configurations based on object properties
- *
- * e.g.:
- * groupByProperty([
- *     {before: true},
- *     {before: false},
- *     {after: true},
- *     {after: false}
- * ]);
- *
- * will return:
- * [
- *     [{before: true}, {before: false}],
- *     [{after: true}, {after: false}]
- * ]
- *
- * @param   {Object[]} objects Array of objects, each with one property/value pair
- * @returns {Array[]}          Array of arrays of objects grouped by property
- */
-function groupByProperty(objects) {
-    const groupedObj = objects.reduce((accumulator, obj) => {
-        const prop = Object.keys(obj)[0];
-
-        accumulator[prop] = accumulator[prop] ? accumulator[prop].concat(obj) : [obj];
-        return accumulator;
-    }, {});
-
-    return Object.keys(groupedObj).map(prop => groupedObj[prop]);
-}
-
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-/**
- * Configuration settings for a rule.
- *
- * A configuration can be a single number (severity), or an array where the first
- * element in the array is the severity, and is the only required element.
- * Configs may also have one or more additional elements to specify rule
- * configuration or options.
- *
- * @typedef {array|number} ruleConfig
- * @param {number}  0  The rule's severity (0, 1, 2).
- */
-
-/**
- * Object whose keys are rule names and values are arrays of valid ruleConfig items
- * which should be linted against the target source code to determine error counts.
- * (a ruleConfigSet.ruleConfigs).
- *
- * e.g. rulesConfig = {
- *     "comma-dangle": [2, [2, "always"], [2, "always-multiline"], [2, "never"]],
- *     "no-console": [2]
- * }
- * @typedef rulesConfig
- */
-
-
-/**
- * Create valid rule configurations by combining two arrays,
- * with each array containing multiple objects each with a
- * single property/value pair and matching properties.
- *
- * e.g.:
- * combinePropertyObjects(
- *     [{before: true}, {before: false}],
- *     [{after: true}, {after: false}]
- * );
- *
- * will return:
- * [
- *     {before: true, after: true},
- *     {before: true, after: false},
- *     {before: false, after: true},
- *     {before: false, after: false}
- * ]
- *
- * @param   {Object[]} objArr1 Single key/value objects, all with the same key
- * @param   {Object[]} objArr2 Single key/value objects, all with another key
- * @returns {Object[]}         Combined objects for each combination of input properties and values
- */
-function combinePropertyObjects(objArr1, objArr2) {
-    const res = [];
-
-    if (objArr1.length === 0) {
-        return objArr2;
-    }
-    if (objArr2.length === 0) {
-        return objArr1;
-    }
-    objArr1.forEach(obj1 => {
-        objArr2.forEach(obj2 => {
-            const combinedObj = {};
-            const obj1Props = Object.keys(obj1);
-            const obj2Props = Object.keys(obj2);
-
-            obj1Props.forEach(prop1 => {
-                combinedObj[prop1] = obj1[prop1];
-            });
-            obj2Props.forEach(prop2 => {
-                combinedObj[prop2] = obj2[prop2];
-            });
-            res.push(combinedObj);
-        });
-    });
-    return res;
-}
-
-/**
- * Creates a new instance of a rule configuration set
- *
- * A rule configuration set is an array of configurations that are valid for a
- * given rule.  For example, the configuration set for the "semi" rule could be:
- *
- * ruleConfigSet.ruleConfigs // -> [[2], [2, "always"], [2, "never"]]
- *
- * Rule configuration set class
- */
-class RuleConfigSet {
-
-    /**
-     * @param {ruleConfig[]} configs Valid rule configurations
-     */
-    constructor(configs) {
-
-        /**
-        * Stored valid rule configurations for this instance
-        * @type {array}
-        */
-        this.ruleConfigs = configs || [];
-    }
-
-    /**
-    * Add a severity level to the front of all configs in the instance.
-    * This should only be called after all configs have been added to the instance.
-    *
-    * @param {number} [severity=2] The level of severity for the rule (0, 1, 2)
-    * @returns {void}
-    */
-    addErrorSeverity(severity) {
-        severity = severity || 2;
-
-        this.ruleConfigs = this.ruleConfigs.map(config => {
-            config.unshift(severity);
-            return config;
-        });
-
-        // Add a single config at the beginning consisting of only the severity
-        this.ruleConfigs.unshift(severity);
-    }
-
-    /**
-    * Add rule configs from an array of strings (schema enums)
-    * @param  {string[]} enums Array of valid rule options (e.g. ["always", "never"])
-    * @returns {void}
-    */
-    addEnums(enums) {
-        this.ruleConfigs = this.ruleConfigs.concat(combineArrays(this.ruleConfigs, enums));
-    }
-
-    /**
-    * Add rule configurations from a schema object
-    * @param  {Object} obj Schema item with type === "object"
-    * @returns {boolean} true if at least one schema for the object could be generated, false otherwise
-    */
-    addObject(obj) {
-        const objectConfigSet = {
-            objectConfigs: [],
-            add(property, values) {
-                for (let idx = 0; idx < values.length; idx++) {
-                    const optionObj = {};
-
-                    optionObj[property] = values[idx];
-                    this.objectConfigs.push(optionObj);
-                }
-            },
-
-            combine() {
-                this.objectConfigs = groupByProperty(this.objectConfigs).reduce((accumulator, objArr) => combinePropertyObjects(accumulator, objArr), []);
-            }
-        };
-
-        /*
-         * The object schema could have multiple independent properties.
-         * If any contain enums or booleans, they can be added and then combined
-         */
-        Object.keys(obj.properties).forEach(prop => {
-            if (obj.properties[prop].enum) {
-                objectConfigSet.add(prop, obj.properties[prop].enum);
-            }
-            if (obj.properties[prop].type && obj.properties[prop].type === "boolean") {
-                objectConfigSet.add(prop, [true, false]);
-            }
-        });
-        objectConfigSet.combine();
-
-        if (objectConfigSet.objectConfigs.length > 0) {
-            this.ruleConfigs = this.ruleConfigs.concat(combineArrays(this.ruleConfigs, objectConfigSet.objectConfigs));
-            return true;
-        }
-
-        return false;
-    }
-}
-
-/**
-* Generate valid rule configurations based on a schema object
-* @param   {Object} schema  A rule's schema object
-* @returns {array[]}        Valid rule configurations
-*/
-function generateConfigsFromSchema(schema) {
-    const configSet = new RuleConfigSet();
-
-    if (Array.isArray(schema)) {
-        for (const opt of schema) {
-            if (opt.enum) {
-                configSet.addEnums(opt.enum);
-            } else if (opt.type && opt.type === "object") {
-                if (!configSet.addObject(opt)) {
-                    break;
-                }
-
-            // TODO (IanVS): support oneOf
-            } else {
-
-                // If we don't know how to fill in this option, don't fill in any of the following options.
-                break;
-            }
-        }
-    }
-    configSet.addErrorSeverity();
-    return configSet.ruleConfigs;
-}
-
-/**
-* Generate possible rule configurations for all of the core rules
-* @returns {rulesConfig} Hash of rule names and arrays of possible configurations
-*/
-function createCoreRuleConfigs() {
-    const ruleList = loadRules();
-
-    return Object.keys(ruleList).reduce((accumulator, id) => {
-        const rule = rules.get(id);
-        const schema = (typeof rule === "function") ? rule.schema : rule.meta.schema;
-
-        accumulator[id] = generateConfigsFromSchema(schema);
-        return accumulator;
-    }, {});
-}
-
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = {
-    generateConfigsFromSchema,
-    createCoreRuleConfigs
-};
Index: node_modules/eslint/lib/config/config-cache.js
===================================================================
--- node_modules/eslint/lib/config/config-cache.js	(revision )
+++ node_modules/eslint/lib/config/config-cache.js	(revision )
@@ -1,130 +0,0 @@
-/**
- * @fileoverview Responsible for caching config files
- * @author Sylvan Mably
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Get a string hash for a config vector
- * @param {Array<Object>} vector config vector to hash
- * @returns {string} hash of the vector values
- * @private
- */
-function hash(vector) {
-    return JSON.stringify(vector);
-}
-
-//------------------------------------------------------------------------------
-// API
-//------------------------------------------------------------------------------
-
-/**
- * Configuration caching class
- */
-module.exports = class ConfigCache {
-
-    constructor() {
-        this.configFullNameCache = new Map();
-        this.localHierarchyCache = new Map();
-        this.mergedVectorCache = new Map();
-        this.mergedCache = new Map();
-    }
-
-    /**
-     * Gets a config object from the cache for the specified config file path.
-     * @param {string} configFullName the name of the configuration as used in the eslint config(e.g. 'plugin:node/recommended'),
-     * or the absolute path to a config file. This should uniquely identify a config.
-     * @returns {Object|null} config object, if found in the cache, otherwise null
-     * @private
-     */
-    getConfig(configFullName) {
-        return this.configFullNameCache.get(configFullName);
-    }
-
-    /**
-     * Sets a config object in the cache for the specified config file path.
-     * @param {string} configFullName the name of the configuration as used in the eslint config(e.g. 'plugin:node/recommended'),
-     * or the absolute path to a config file. This should uniquely identify a config.
-     * @param {Object} config the config object to add to the cache
-     * @returns {void}
-     * @private
-     */
-    setConfig(configFullName, config) {
-        this.configFullNameCache.set(configFullName, config);
-    }
-
-    /**
-     * Gets a list of hierarchy-local config objects that apply to the specified directory.
-     * @param {string} directory the path to the directory
-     * @returns {Object[]|null} a list of config objects, if found in the cache, otherwise null
-     * @private
-     */
-    getHierarchyLocalConfigs(directory) {
-        return this.localHierarchyCache.get(directory);
-    }
-
-    /**
-     * For each of the supplied parent directories, sets the list of config objects for that directory to the
-     * appropriate subset of the supplied parent config objects.
-     * @param {string[]} parentDirectories a list of parent directories to add to the config cache
-     * @param {Object[]} parentConfigs a list of config objects that apply to the lowest directory in parentDirectories
-     * @returns {void}
-     * @private
-     */
-    setHierarchyLocalConfigs(parentDirectories, parentConfigs) {
-        parentDirectories.forEach((localConfigDirectory, i) => {
-            const directoryParentConfigs = parentConfigs.slice(0, parentConfigs.length - i);
-
-            this.localHierarchyCache.set(localConfigDirectory, directoryParentConfigs);
-        });
-    }
-
-    /**
-     * Gets a merged config object corresponding to the supplied vector.
-     * @param {Array<Object>} vector the vector to find a merged config for
-     * @returns {Object|null} a merged config object, if found in the cache, otherwise null
-     * @private
-     */
-    getMergedVectorConfig(vector) {
-        return this.mergedVectorCache.get(hash(vector));
-    }
-
-    /**
-     * Sets a merged config object in the cache for the supplied vector.
-     * @param {Array<Object>} vector the vector to save a merged config for
-     * @param {Object} config the merged config object to add to the cache
-     * @returns {void}
-     * @private
-     */
-    setMergedVectorConfig(vector, config) {
-        this.mergedVectorCache.set(hash(vector), config);
-    }
-
-    /**
-     * Gets a merged config object corresponding to the supplied vector, including configuration options from outside
-     * the vector.
-     * @param {Array<Object>} vector the vector to find a merged config for
-     * @returns {Object|null} a merged config object, if found in the cache, otherwise null
-     * @private
-     */
-    getMergedConfig(vector) {
-        return this.mergedCache.get(hash(vector));
-    }
-
-    /**
-     * Sets a merged config object in the cache for the supplied vector, including configuration options from outside
-     * the vector.
-     * @param {Array<Object>} vector the vector to save a merged config for
-     * @param {Object} config the merged config object to add to the cache
-     * @returns {void}
-     * @private
-     */
-    setMergedConfig(vector, config) {
-        this.mergedCache.set(hash(vector), config);
-    }
-};
Index: node_modules/eslint/lib/config/environments.js
===================================================================
--- node_modules/eslint/lib/config/environments.js	(revision )
+++ node_modules/eslint/lib/config/environments.js	(revision )
@@ -1,84 +0,0 @@
-/**
- * @fileoverview Environments manager
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const envs = require("../../conf/environments");
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-class Environments {
-
-    /**
-     * create env context
-     */
-    constructor() {
-        this._environments = new Map();
-
-        this.load();
-    }
-
-    /**
-     * Loads the default environments.
-     * @returns {void}
-     * @private
-     */
-    load() {
-        Object.keys(envs).forEach(envName => {
-            this._environments.set(envName, envs[envName]);
-        });
-    }
-
-    /**
-     * Gets the environment with the given name.
-     * @param {string} name The name of the environment to retrieve.
-     * @returns {Object?} The environment object or null if not found.
-     */
-    get(name) {
-        return this._environments.get(name) || null;
-    }
-
-    /**
-     * Gets all the environment present
-     * @returns {Object} The environment object for each env name
-     */
-    getAll() {
-        return Array.from(this._environments).reduce((coll, env) => {
-            coll[env[0]] = env[1];
-            return coll;
-        }, {});
-    }
-
-    /**
-     * Defines an environment.
-     * @param {string} name The name of the environment.
-     * @param {Object} env The environment settings.
-     * @returns {void}
-     */
-    define(name, env) {
-        this._environments.set(name, env);
-    }
-
-    /**
-     * Imports all environments from a plugin.
-     * @param {Object} plugin The plugin object.
-     * @param {string} pluginName The name of the plugin.
-     * @returns {void}
-     */
-    importPlugin(plugin, pluginName) {
-        if (plugin.environments) {
-            Object.keys(plugin.environments).forEach(envName => {
-                this.define(`${pluginName}/${envName}`, plugin.environments[envName]);
-            });
-        }
-    }
-}
-
-module.exports = Environments;
Index: node_modules/eslint/lib/config/config-validator.js
===================================================================
--- node_modules/eslint/lib/config/config-validator.js	(revision )
+++ node_modules/eslint/lib/config/config-validator.js	(revision )
@@ -1,242 +0,0 @@
-/**
- * @fileoverview Validates configs.
- * @author Brandon Mills
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const ajv = require("../util/ajv"),
-    lodash = require("lodash"),
-    configSchema = require("../../conf/config-schema.js"),
-    util = require("util");
-
-const validators = {
-    rules: Object.create(null)
-};
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-let validateSchema;
-
-/**
- * Gets a complete options schema for a rule.
- * @param {string} id The rule's unique name.
- * @param {Rules} rulesContext Rule context
- * @returns {Object} JSON Schema for the rule's options.
- */
-function getRuleOptionsSchema(id, rulesContext) {
-    const rule = rulesContext.get(id),
-        schema = rule && rule.schema || rule && rule.meta && rule.meta.schema;
-
-    // Given a tuple of schemas, insert warning level at the beginning
-    if (Array.isArray(schema)) {
-        if (schema.length) {
-            return {
-                type: "array",
-                items: schema,
-                minItems: 0,
-                maxItems: schema.length
-            };
-        }
-        return {
-            type: "array",
-            minItems: 0,
-            maxItems: 0
-        };
-
-    }
-
-    // Given a full schema, leave it alone
-    return schema || null;
-}
-
-/**
-* Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
-* @param {options} options The given options for the rule.
-* @returns {number|string} The rule's severity value
-*/
-function validateRuleSeverity(options) {
-    const severity = Array.isArray(options) ? options[0] : options;
-
-    if (severity !== 0 && severity !== 1 && severity !== 2 && !(typeof severity === "string" && /^(?:off|warn|error)$/i.test(severity))) {
-        throw new Error(`\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/g, "\"").replace(/\n/g, "")}').\n`);
-    }
-
-    return severity;
-}
-
-/**
-* Validates the non-severity options passed to a rule, based on its schema.
-* @param {string} id The rule's unique name
-* @param {array} localOptions The options for the rule, excluding severity
-* @param {Rules} rulesContext Rule context
-* @returns {void}
-*/
-function validateRuleSchema(id, localOptions, rulesContext) {
-    const schema = getRuleOptionsSchema(id, rulesContext);
-
-    if (!validators.rules[id] && schema) {
-        validators.rules[id] = ajv.compile(schema);
-    }
-
-    const validateRule = validators.rules[id];
-
-    if (validateRule) {
-        validateRule(localOptions);
-        if (validateRule.errors) {
-            throw new Error(validateRule.errors.map(error => `\tValue "${error.data}" ${error.message}.\n`).join(""));
-        }
-    }
-}
-
-/**
- * Validates a rule's options against its schema.
- * @param {string} id The rule's unique name.
- * @param {array|number} options The given options for the rule.
- * @param {string} source The name of the configuration source to report in any errors.
- * @param {Rules} rulesContext Rule context
- * @returns {void}
- */
-function validateRuleOptions(id, options, source, rulesContext) {
-    try {
-        const severity = validateRuleSeverity(options);
-
-        if (severity !== 0 && !(typeof severity === "string" && severity.toLowerCase() === "off")) {
-            validateRuleSchema(id, Array.isArray(options) ? options.slice(1) : [], rulesContext);
-        }
-    } catch (err) {
-        throw new Error(`${source}:\n\tConfiguration for rule "${id}" is invalid:\n${err.message}`);
-    }
-}
-
-/**
- * Validates an environment object
- * @param {Object} environment The environment config object to validate.
- * @param {string} source The name of the configuration source to report in any errors.
- * @param {Environments} envContext Env context
- * @returns {void}
- */
-function validateEnvironment(environment, source, envContext) {
-
-    // not having an environment is ok
-    if (!environment) {
-        return;
-    }
-
-    Object.keys(environment).forEach(env => {
-        if (!envContext.get(env)) {
-            const message = `${source}:\n\tEnvironment key "${env}" is unknown\n`;
-
-            throw new Error(message);
-        }
-    });
-}
-
-/**
- * Validates a rules config object
- * @param {Object} rulesConfig The rules config object to validate.
- * @param {string} source The name of the configuration source to report in any errors.
- * @param {Rules} rulesContext Rule context
- * @returns {void}
- */
-function validateRules(rulesConfig, source, rulesContext) {
-    if (!rulesConfig) {
-        return;
-    }
-
-    Object.keys(rulesConfig).forEach(id => {
-        validateRuleOptions(id, rulesConfig[id], source, rulesContext);
-    });
-}
-
-/**
- * Formats an array of schema validation errors.
- * @param {Array} errors An array of error messages to format.
- * @returns {string} Formatted error message
- */
-function formatErrors(errors) {
-    return errors.map(error => {
-        if (error.keyword === "additionalProperties") {
-            const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;
-
-            return `Unexpected top-level property "${formattedPropertyPath}"`;
-        }
-        if (error.keyword === "type") {
-            const formattedField = error.dataPath.slice(1);
-            const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join("/") : error.schema;
-            const formattedValue = JSON.stringify(error.data);
-
-            return `Property "${formattedField}" is the wrong type (expected ${formattedExpectedType} but got \`${formattedValue}\`)`;
-        }
-
-        const field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;
-
-        return `"${field}" ${error.message}. Value: ${JSON.stringify(error.data)}`;
-    }).map(message => `\t- ${message}.\n`).join("");
-}
-
-/**
- * Emits a deprecation warning containing a given filepath. A new deprecation warning is emitted
- * for each unique file path, but repeated invocations with the same file path have no effect.
- * No warnings are emitted if the `--no-deprecation` or `--no-warnings` Node runtime flags are active.
- * @param {string} source The name of the configuration source to report the warning for.
- * @returns {void}
- */
-const emitEcmaFeaturesWarning = lodash.memoize(source => {
-
-    /*
-     * util.deprecate seems to be the only way to emit a warning in Node 4.x while respecting the --no-warnings flag.
-     * (In Node 6+, process.emitWarning could be used instead.)
-     */
-    util.deprecate(
-        () => {},
-        `[eslint] The 'ecmaFeatures' config file property is deprecated, and has no effect. (found in ${source})`
-    )();
-});
-
-/**
- * Validates the top level properties of the config object.
- * @param {Object} config The config object to validate.
- * @param {string} source The name of the configuration source to report in any errors.
- * @returns {void}
- */
-function validateConfigSchema(config, source) {
-    validateSchema = validateSchema || ajv.compile(configSchema);
-
-    if (!validateSchema(config)) {
-        throw new Error(`ESLint configuration in ${source} is invalid:\n${formatErrors(validateSchema.errors)}`);
-    }
-
-    if (Object.prototype.hasOwnProperty.call(config, "ecmaFeatures")) {
-        emitEcmaFeaturesWarning(source);
-    }
-}
-
-/**
- * Validates an entire config object.
- * @param {Object} config The config object to validate.
- * @param {string} source The name of the configuration source to report in any errors.
- * @param {Rules} rulesContext The rules context
- * @param {Environments} envContext The env context
- * @returns {void}
- */
-function validate(config, source, rulesContext, envContext) {
-    validateConfigSchema(config, source);
-    validateRules(config.rules, source, rulesContext);
-    validateEnvironment(config.env, source, envContext);
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = {
-    getRuleOptionsSchema,
-    validate,
-    validateRuleOptions
-};
Index: node_modules/eslint/lib/config/config-initializer.js
===================================================================
--- node_modules/eslint/lib/config/config-initializer.js	(revision )
+++ node_modules/eslint/lib/config/config-initializer.js	(revision )
@@ -1,601 +0,0 @@
-/**
- * @fileoverview Config initialization wizard.
- * @author Ilya Volodin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const util = require("util"),
-    inquirer = require("inquirer"),
-    ProgressBar = require("progress"),
-    semver = require("semver"),
-    autoconfig = require("./autoconfig.js"),
-    ConfigFile = require("./config-file"),
-    ConfigOps = require("./config-ops"),
-    getSourceCodeOfFiles = require("../util/source-code-util").getSourceCodeOfFiles,
-    ModuleResolver = require("../util/module-resolver"),
-    npmUtil = require("../util/npm-util"),
-    recConfig = require("../../conf/eslint-recommended"),
-    log = require("../logging");
-
-const debug = require("debug")("eslint:config-initializer");
-
-//------------------------------------------------------------------------------
-// Private
-//------------------------------------------------------------------------------
-
-/* istanbul ignore next: hard to test fs function */
-/**
- * Create .eslintrc file in the current working directory
- * @param {Object} config object that contains user's answers
- * @param {string} format The file format to write to.
- * @returns {void}
- */
-function writeFile(config, format) {
-
-    // default is .js
-    let extname = ".js";
-
-    if (format === "YAML") {
-        extname = ".yml";
-    } else if (format === "JSON") {
-        extname = ".json";
-    }
-
-    const installedESLint = config.installedESLint;
-
-    delete config.installedESLint;
-
-    ConfigFile.write(config, `./.eslintrc${extname}`);
-    log.info(`Successfully created .eslintrc${extname} file in ${process.cwd()}`);
-
-    if (installedESLint) {
-        log.info("ESLint was installed locally. We recommend using this local copy instead of your globally-installed copy.");
-    }
-}
-
-/**
- * Get the peer dependencies of the given module.
- * This adds the gotten value to cache at the first time, then reuses it.
- * In a process, this function is called twice, but `npmUtil.fetchPeerDependencies` needs to access network which is relatively slow.
- * @param {string} moduleName The module name to get.
- * @returns {Object} The peer dependencies of the given module.
- * This object is the object of `peerDependencies` field of `package.json`.
- * Returns null if npm was not found.
- */
-function getPeerDependencies(moduleName) {
-    let result = getPeerDependencies.cache.get(moduleName);
-
-    if (!result) {
-        log.info(`Checking peerDependencies of ${moduleName}`);
-
-        result = npmUtil.fetchPeerDependencies(moduleName);
-        getPeerDependencies.cache.set(moduleName, result);
-    }
-
-    return result;
-}
-getPeerDependencies.cache = new Map();
-
-/**
- * Synchronously install necessary plugins, configs, parsers, etc. based on the config
- * @param   {Object} config  config object
- * @param   {boolean} [installESLint=true]  If `false` is given, it does not install eslint.
- * @returns {void}
- */
-function installModules(config, installESLint) {
-    const modules = {};
-
-    // Create a list of modules which should be installed based on config
-    if (config.plugins) {
-        for (const plugin of config.plugins) {
-            modules[`eslint-plugin-${plugin}`] = "latest";
-        }
-    }
-    if (config.extends && config.extends.indexOf("eslint:") === -1) {
-        const moduleName = `eslint-config-${config.extends}`;
-
-        modules[moduleName] = "latest";
-        Object.assign(
-            modules,
-            getPeerDependencies(`${moduleName}@latest`)
-        );
-    }
-
-    // If no modules, do nothing.
-    if (Object.keys(modules).length === 0) {
-        return;
-    }
-
-    if (installESLint === false) {
-        delete modules.eslint;
-    } else {
-        const installStatus = npmUtil.checkDevDeps(["eslint"]);
-
-        // Mark to show messages if it's new installation of eslint.
-        if (installStatus.eslint === false) {
-            log.info("Local ESLint installation not found.");
-            modules.eslint = modules.eslint || "latest";
-            config.installedESLint = true;
-        }
-    }
-
-    // Install packages
-    const modulesToInstall = Object.keys(modules).map(name => `${name}@${modules[name]}`);
-
-    log.info(`Installing ${modulesToInstall.join(", ")}`);
-
-    npmUtil.installSyncSaveDev(modulesToInstall);
-}
-
-/**
- * Set the `rules` of a config by examining a user's source code
- *
- * Note: This clones the config object and returns a new config to avoid mutating
- * the original config parameter.
- *
- * @param   {Object} answers  answers received from inquirer
- * @param   {Object} config   config object
- * @returns {Object}          config object with configured rules
- */
-function configureRules(answers, config) {
-    const BAR_TOTAL = 20,
-        BAR_SOURCE_CODE_TOTAL = 4,
-        newConfig = Object.assign({}, config),
-        disabledConfigs = {};
-    let sourceCodes,
-        registry;
-
-    // Set up a progress bar, as this process can take a long time
-    const bar = new ProgressBar("Determining Config: :percent [:bar] :elapseds elapsed, eta :etas ", {
-        width: 30,
-        total: BAR_TOTAL
-    });
-
-    bar.tick(0); // Shows the progress bar
-
-    // Get the SourceCode of all chosen files
-    const patterns = answers.patterns.split(/[\s]+/);
-
-    try {
-        sourceCodes = getSourceCodeOfFiles(patterns, { baseConfig: newConfig, useEslintrc: false }, total => {
-            bar.tick((BAR_SOURCE_CODE_TOTAL / total));
-        });
-    } catch (e) {
-        log.info("\n");
-        throw e;
-    }
-    const fileQty = Object.keys(sourceCodes).length;
-
-    if (fileQty === 0) {
-        log.info("\n");
-        throw new Error("Automatic Configuration failed.  No files were able to be parsed.");
-    }
-
-    // Create a registry of rule configs
-    registry = new autoconfig.Registry();
-    registry.populateFromCoreRules();
-
-    // Lint all files with each rule config in the registry
-    registry = registry.lintSourceCode(sourceCodes, newConfig, total => {
-        bar.tick((BAR_TOTAL - BAR_SOURCE_CODE_TOTAL) / total); // Subtract out ticks used at beginning
-    });
-    debug(`\nRegistry: ${util.inspect(registry.rules, { depth: null })}`);
-
-    // Create a list of recommended rules, because we don't want to disable them
-    const recRules = Object.keys(recConfig.rules).filter(ruleId => ConfigOps.isErrorSeverity(recConfig.rules[ruleId]));
-
-    // Find and disable rules which had no error-free configuration
-    const failingRegistry = registry.getFailingRulesRegistry();
-
-    Object.keys(failingRegistry.rules).forEach(ruleId => {
-
-        // If the rule is recommended, set it to error, otherwise disable it
-        disabledConfigs[ruleId] = (recRules.indexOf(ruleId) !== -1) ? 2 : 0;
-    });
-
-    // Now that we know which rules to disable, strip out configs with errors
-    registry = registry.stripFailingConfigs();
-
-    // If there is only one config that results in no errors for a rule, we should use it.
-    // createConfig will only add rules that have one configuration in the registry.
-    const singleConfigs = registry.createConfig().rules;
-
-    // The "sweet spot" for number of options in a config seems to be two (severity plus one option).
-    // Very often, a third option (usually an object) is available to address
-    // edge cases, exceptions, or unique situations. We will prefer to use a config with
-    // specificity of two.
-    const specTwoConfigs = registry.filterBySpecificity(2).createConfig().rules;
-
-    // Maybe a specific combination using all three options works
-    const specThreeConfigs = registry.filterBySpecificity(3).createConfig().rules;
-
-    // If all else fails, try to use the default (severity only)
-    const defaultConfigs = registry.filterBySpecificity(1).createConfig().rules;
-
-    // Combine configs in reverse priority order (later take precedence)
-    newConfig.rules = Object.assign({}, disabledConfigs, defaultConfigs, specThreeConfigs, specTwoConfigs, singleConfigs);
-
-    // Make sure progress bar has finished (floating point rounding)
-    bar.update(BAR_TOTAL);
-
-    // Log out some stats to let the user know what happened
-    const finalRuleIds = Object.keys(newConfig.rules);
-    const totalRules = finalRuleIds.length;
-    const enabledRules = finalRuleIds.filter(ruleId => (newConfig.rules[ruleId] !== 0)).length;
-    const resultMessage = [
-        `\nEnabled ${enabledRules} out of ${totalRules}`,
-        `rules based on ${fileQty}`,
-        `file${(fileQty === 1) ? "." : "s."}`
-    ].join(" ");
-
-    log.info(resultMessage);
-
-    ConfigOps.normalizeToStrings(newConfig);
-    return newConfig;
-}
-
-/**
- * process user's answers and create config object
- * @param {Object} answers answers received from inquirer
- * @returns {Object} config object
- */
-function processAnswers(answers) {
-    let config = { rules: {}, env: {} };
-
-    if (answers.es6) {
-        config.env.es6 = true;
-        if (answers.modules) {
-            config.parserOptions = config.parserOptions || {};
-            config.parserOptions.sourceType = "module";
-        }
-    }
-    if (answers.commonjs) {
-        config.env.commonjs = true;
-    }
-    answers.env.forEach(env => {
-        config.env[env] = true;
-    });
-    if (answers.jsx) {
-        config.parserOptions = config.parserOptions || {};
-        config.parserOptions.ecmaFeatures = config.parserOptions.ecmaFeatures || {};
-        config.parserOptions.ecmaFeatures.jsx = true;
-        if (answers.react) {
-            config.plugins = ["react"];
-            config.parserOptions.ecmaFeatures.experimentalObjectRestSpread = true;
-        }
-    }
-
-    if (answers.source === "prompt") {
-        config.extends = "eslint:recommended";
-        config.rules.indent = ["error", answers.indent];
-        config.rules.quotes = ["error", answers.quotes];
-        config.rules["linebreak-style"] = ["error", answers.linebreak];
-        config.rules.semi = ["error", answers.semi ? "always" : "never"];
-    }
-
-    installModules(config);
-
-    if (answers.source === "auto") {
-        config = configureRules(answers, config);
-        config = autoconfig.extendFromRecommended(config);
-    }
-
-    ConfigOps.normalizeToStrings(config);
-    return config;
-}
-
-/**
- * process user's style guide of choice and return an appropriate config object.
- * @param {string} guide name of the chosen style guide
- * @param {boolean} [installESLint=true]  If `false` is given, it does not install eslint.
- * @returns {Object} config object
- */
-function getConfigForStyleGuide(guide, installESLint) {
-    const guides = {
-        google: { extends: "google" },
-        airbnb: { extends: "airbnb" },
-        "airbnb-base": { extends: "airbnb-base" },
-        standard: { extends: "standard" }
-    };
-
-    if (!guides[guide]) {
-        throw new Error("You referenced an unsupported guide.");
-    }
-
-    installModules(guides[guide], installESLint);
-
-    return guides[guide];
-}
-
-/**
- * Get the version of the local ESLint.
- * @returns {string|null} The version. If the local ESLint was not found, returns null.
- */
-function getLocalESLintVersion() {
-    try {
-        const resolver = new ModuleResolver();
-        const eslintPath = resolver.resolve("eslint", process.cwd());
-        const eslint = require(eslintPath);
-
-        return eslint.linter.version || null;
-    } catch (_err) {
-        return null;
-    }
-}
-
-/**
- * Get the shareable config name of the chosen style guide.
- * @param {Object} answers The answers object.
- * @returns {string} The shareable config name.
- */
-function getStyleGuideName(answers) {
-    if (answers.styleguide === "airbnb" && !answers.airbnbReact) {
-        return "airbnb-base";
-    }
-    return answers.styleguide;
-}
-
-/**
- * Check whether the local ESLint version conflicts with the required version of the chosen shareable config.
- * @param {Object} answers The answers object.
- * @returns {boolean} `true` if the local ESLint is found then it conflicts with the required version of the chosen shareable config.
- */
-function hasESLintVersionConflict(answers) {
-
-    // Get the local ESLint version.
-    const localESLintVersion = getLocalESLintVersion();
-
-    if (!localESLintVersion) {
-        return false;
-    }
-
-    // Get the required range of ESLint version.
-    const configName = getStyleGuideName(answers);
-    const moduleName = `eslint-config-${configName}@latest`;
-    const peerDependencies = getPeerDependencies(moduleName) || {};
-    const requiredESLintVersionRange = peerDependencies.eslint;
-
-    if (!requiredESLintVersionRange) {
-        return false;
-    }
-
-    answers.localESLintVersion = localESLintVersion;
-    answers.requiredESLintVersionRange = requiredESLintVersionRange;
-
-    // Check the version.
-    if (semver.satisfies(localESLintVersion, requiredESLintVersionRange)) {
-        answers.installESLint = false;
-        return false;
-    }
-
-    return true;
-}
-
-/* istanbul ignore next: no need to test inquirer*/
-/**
- * Ask use a few questions on command prompt
- * @returns {Promise} The promise with the result of the prompt
- */
-function promptUser() {
-
-    return inquirer.prompt([
-        {
-            type: "list",
-            name: "source",
-            message: "How would you like to configure ESLint?",
-            default: "prompt",
-            choices: [
-                { name: "Answer questions about your style", value: "prompt" },
-                { name: "Use a popular style guide", value: "guide" },
-                { name: "Inspect your JavaScript file(s)", value: "auto" }
-            ]
-        },
-        {
-            type: "list",
-            name: "styleguide",
-            message: "Which style guide do you want to follow?",
-            choices: [{ name: "Google", value: "google" }, { name: "Airbnb", value: "airbnb" }, { name: "Standard", value: "standard" }],
-            when(answers) {
-                answers.packageJsonExists = npmUtil.checkPackageJson();
-                return answers.source === "guide" && answers.packageJsonExists;
-            }
-        },
-        {
-            type: "confirm",
-            name: "airbnbReact",
-            message: "Do you use React?",
-            default: false,
-            when(answers) {
-                return answers.styleguide === "airbnb";
-            }
-        },
-        {
-            type: "input",
-            name: "patterns",
-            message: "Which file(s), path(s), or glob(s) should be examined?",
-            when(answers) {
-                return (answers.source === "auto");
-            },
-            validate(input) {
-                if (input.trim().length === 0 && input.trim() !== ",") {
-                    return "You must tell us what code to examine. Try again.";
-                }
-                return true;
-            }
-        },
-        {
-            type: "list",
-            name: "format",
-            message: "What format do you want your config file to be in?",
-            default: "JavaScript",
-            choices: ["JavaScript", "YAML", "JSON"],
-            when(answers) {
-                return ((answers.source === "guide" && answers.packageJsonExists) || answers.source === "auto");
-            }
-        },
-        {
-            type: "confirm",
-            name: "installESLint",
-            message(answers) {
-                const verb = semver.ltr(answers.localESLintVersion, answers.requiredESLintVersionRange)
-                    ? "upgrade"
-                    : "downgrade";
-
-                return `The style guide "${answers.styleguide}" requires eslint@${answers.requiredESLintVersionRange}. You are currently using eslint@${answers.localESLintVersion}.\n  Do you want to ${verb}?`;
-            },
-            default: true,
-            when(answers) {
-                return answers.source === "guide" && answers.packageJsonExists && hasESLintVersionConflict(answers);
-            }
-        }
-    ]).then(earlyAnswers => {
-
-        // early exit if you are using a style guide
-        if (earlyAnswers.source === "guide") {
-            if (!earlyAnswers.packageJsonExists) {
-                log.info("A package.json is necessary to install plugins such as style guides. Run `npm init` to create a package.json file and try again.");
-                return void 0;
-            }
-            if (earlyAnswers.installESLint === false && !semver.satisfies(earlyAnswers.localESLintVersion, earlyAnswers.requiredESLintVersionRange)) {
-                log.info(`Note: it might not work since ESLint's version is mismatched with the ${earlyAnswers.styleguide} config.`);
-            }
-            if (earlyAnswers.styleguide === "airbnb" && !earlyAnswers.airbnbReact) {
-                earlyAnswers.styleguide = "airbnb-base";
-            }
-
-            const config = getConfigForStyleGuide(earlyAnswers.styleguide, earlyAnswers.installESLint);
-
-            writeFile(config, earlyAnswers.format);
-
-            return void 0;
-        }
-
-        // continue with the questions otherwise...
-        return inquirer.prompt([
-            {
-                type: "confirm",
-                name: "es6",
-                message: "Are you using ECMAScript 6 features?",
-                default: false
-            },
-            {
-                type: "confirm",
-                name: "modules",
-                message: "Are you using ES6 modules?",
-                default: false,
-                when(answers) {
-                    return answers.es6 === true;
-                }
-            },
-            {
-                type: "checkbox",
-                name: "env",
-                message: "Where will your code run?",
-                default: ["browser"],
-                choices: [{ name: "Browser", value: "browser" }, { name: "Node", value: "node" }]
-            },
-            {
-                type: "confirm",
-                name: "commonjs",
-                message: "Do you use CommonJS?",
-                default: false,
-                when(answers) {
-                    return answers.env.some(env => env === "browser");
-                }
-            },
-            {
-                type: "confirm",
-                name: "jsx",
-                message: "Do you use JSX?",
-                default: false
-            },
-            {
-                type: "confirm",
-                name: "react",
-                message: "Do you use React?",
-                default: false,
-                when(answers) {
-                    return answers.jsx;
-                }
-            }
-        ]).then(secondAnswers => {
-
-            // early exit if you are using automatic style generation
-            if (earlyAnswers.source === "auto") {
-                const combinedAnswers = Object.assign({}, earlyAnswers, secondAnswers);
-
-                const config = processAnswers(combinedAnswers);
-
-                installModules(config);
-                writeFile(config, earlyAnswers.format);
-
-                return void 0;
-            }
-
-            // continue with the style questions otherwise...
-            return inquirer.prompt([
-                {
-                    type: "list",
-                    name: "indent",
-                    message: "What style of indentation do you use?",
-                    default: "tab",
-                    choices: [{ name: "Tabs", value: "tab" }, { name: "Spaces", value: 4 }]
-                },
-                {
-                    type: "list",
-                    name: "quotes",
-                    message: "What quotes do you use for strings?",
-                    default: "double",
-                    choices: [{ name: "Double", value: "double" }, { name: "Single", value: "single" }]
-                },
-                {
-                    type: "list",
-                    name: "linebreak",
-                    message: "What line endings do you use?",
-                    default: "unix",
-                    choices: [{ name: "Unix", value: "unix" }, { name: "Windows", value: "windows" }]
-                },
-                {
-                    type: "confirm",
-                    name: "semi",
-                    message: "Do you require semicolons?",
-                    default: true
-                },
-                {
-                    type: "list",
-                    name: "format",
-                    message: "What format do you want your config file to be in?",
-                    default: "JavaScript",
-                    choices: ["JavaScript", "YAML", "JSON"]
-                }
-            ]).then(answers => {
-                const totalAnswers = Object.assign({}, earlyAnswers, secondAnswers, answers);
-
-                const config = processAnswers(totalAnswers);
-
-                installModules(config);
-                writeFile(config, answers.format);
-            });
-        });
-    });
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-const init = {
-    getConfigForStyleGuide,
-    hasESLintVersionConflict,
-    processAnswers,
-    /* istanbul ignore next */initializeConfig() {
-        return promptUser();
-    }
-};
-
-module.exports = init;
Index: node_modules/eslint/lib/testers/rule-tester.js
===================================================================
--- node_modules/eslint/lib/testers/rule-tester.js	(revision )
+++ node_modules/eslint/lib/testers/rule-tester.js	(revision )
@@ -1,535 +0,0 @@
-/**
- * @fileoverview Mocha test wrapper
- * @author Ilya Volodin
- */
-"use strict";
-
-/* global describe, it */
-
-/*
- * This is a wrapper around mocha to allow for DRY unittests for eslint
- * Format:
- * RuleTester.run("{ruleName}", {
- *      valid: [
- *          "{code}",
- *          { code: "{code}", options: {options}, globals: {globals}, parser: "{parser}", settings: {settings} }
- *      ],
- *      invalid: [
- *          { code: "{code}", errors: {numErrors} },
- *          { code: "{code}", errors: ["{errorMessage}"] },
- *          { code: "{code}", options: {options}, globals: {globals}, parser: "{parser}", settings: {settings}, errors: [{ message: "{errorMessage}", type: "{errorNodeType}"}] }
- *      ]
- *  });
- *
- * Variables:
- * {code} - String that represents the code to be tested
- * {options} - Arguments that are passed to the configurable rules.
- * {globals} - An object representing a list of variables that are
- *             registered as globals
- * {parser} - String representing the parser to use
- * {settings} - An object representing global settings for all rules
- * {numErrors} - If failing case doesn't need to check error message,
- *               this integer will specify how many errors should be
- *               received
- * {errorMessage} - Message that is returned by the rule on failure
- * {errorNodeType} - AST node type that is returned by they rule as
- *                   a cause of the failure.
- */
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash"),
-    assert = require("assert"),
-    util = require("util"),
-    validator = require("../config/config-validator"),
-    ajv = require("../util/ajv"),
-    Linter = require("../linter"),
-    Environments = require("../config/environments"),
-    SourceCodeFixer = require("../util/source-code-fixer");
-
-//------------------------------------------------------------------------------
-// Private Members
-//------------------------------------------------------------------------------
-
-/*
- * testerDefaultConfig must not be modified as it allows to reset the tester to
- * the initial default configuration
- */
-const testerDefaultConfig = { rules: {} };
-let defaultConfig = { rules: {} };
-
-/*
- * List every parameters possible on a test case that are not related to eslint
- * configuration
- */
-const RuleTesterParameters = [
-    "code",
-    "filename",
-    "options",
-    "errors",
-    "output"
-];
-
-const hasOwnProperty = Function.call.bind(Object.hasOwnProperty);
-
-/**
- * Clones a given value deeply.
- * Note: This ignores `parent` property.
- *
- * @param {any} x - A value to clone.
- * @returns {any} A cloned value.
- */
-function cloneDeeplyExcludesParent(x) {
-    if (typeof x === "object" && x !== null) {
-        if (Array.isArray(x)) {
-            return x.map(cloneDeeplyExcludesParent);
-        }
-
-        const retv = {};
-
-        for (const key in x) {
-            if (key !== "parent" && hasOwnProperty(x, key)) {
-                retv[key] = cloneDeeplyExcludesParent(x[key]);
-            }
-        }
-
-        return retv;
-    }
-
-    return x;
-}
-
-/**
- * Freezes a given value deeply.
- *
- * @param {any} x - A value to freeze.
- * @returns {void}
- */
-function freezeDeeply(x) {
-    if (typeof x === "object" && x !== null) {
-        if (Array.isArray(x)) {
-            x.forEach(freezeDeeply);
-        } else {
-            for (const key in x) {
-                if (key !== "parent" && hasOwnProperty(x, key)) {
-                    freezeDeeply(x[key]);
-                }
-            }
-        }
-        Object.freeze(x);
-    }
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-// default separators for testing
-const DESCRIBE = Symbol("describe");
-const IT = Symbol("it");
-
-/**
- * This is `it` or `describe` if those don't exist.
- * @this {Mocha}
- * @param {string} text - The description of the test case.
- * @param {Function} method - The logic of the test case.
- * @returns {any} Returned value of `method`.
- */
-function defaultHandler(text, method) {
-    return method.apply(this);
-}
-
-class RuleTester {
-
-    /**
-     * Creates a new instance of RuleTester.
-     * @param {Object} [testerConfig] Optional, extra configuration for the tester
-     * @constructor
-     */
-    constructor(testerConfig) {
-
-        /**
-         * The configuration to use for this tester. Combination of the tester
-         * configuration and the default configuration.
-         * @type {Object}
-         */
-        this.testerConfig = lodash.merge(
-
-            // we have to clone because merge uses the first argument for recipient
-            lodash.cloneDeep(defaultConfig),
-            testerConfig,
-            { rules: { "rule-tester/validate-ast": "error" } }
-        );
-
-        /**
-         * Rule definitions to define before tests.
-         * @type {Object}
-         */
-        this.rules = {};
-        this.linter = new Linter();
-    }
-
-    /**
-     * Set the configuration to use for all future tests
-     * @param {Object} config the configuration to use.
-     * @returns {void}
-     */
-    static setDefaultConfig(config) {
-        if (typeof config !== "object") {
-            throw new Error("RuleTester.setDefaultConfig: config must be an object");
-        }
-        defaultConfig = config;
-
-        // Make sure the rules object exists since it is assumed to exist later
-        defaultConfig.rules = defaultConfig.rules || {};
-    }
-
-    /**
-     * Get the current configuration used for all tests
-     * @returns {Object} the current configuration
-     */
-    static getDefaultConfig() {
-        return defaultConfig;
-    }
-
-    /**
-     * Reset the configuration to the initial configuration of the tester removing
-     * any changes made until now.
-     * @returns {void}
-     */
-    static resetDefaultConfig() {
-        defaultConfig = lodash.cloneDeep(testerDefaultConfig);
-    }
-
-
-    // If people use `mocha test.js --watch` command, `describe` and `it` function
-    // instances are different for each execution. So `describe` and `it` should get fresh instance
-    // always.
-    static get describe() {
-        return (
-            this[DESCRIBE] ||
-            (typeof describe === "function" ? describe : defaultHandler)
-        );
-    }
-
-    static set describe(value) {
-        this[DESCRIBE] = value;
-    }
-
-    static get it() {
-        return (
-            this[IT] ||
-            (typeof it === "function" ? it : defaultHandler)
-        );
-    }
-
-    static set it(value) {
-        this[IT] = value;
-    }
-
-    /**
-     * Define a rule for one particular run of tests.
-     * @param {string} name The name of the rule to define.
-     * @param {Function} rule The rule definition.
-     * @returns {void}
-     */
-    defineRule(name, rule) {
-        this.rules[name] = rule;
-    }
-
-    /**
-     * Adds a new rule test to execute.
-     * @param {string} ruleName The name of the rule to run.
-     * @param {Function} rule The rule to test.
-     * @param {Object} test The collection of tests to run.
-     * @returns {void}
-     */
-    run(ruleName, rule, test) {
-
-        const testerConfig = this.testerConfig,
-            requiredScenarios = ["valid", "invalid"],
-            scenarioErrors = [],
-            linter = this.linter;
-
-        if (lodash.isNil(test) || typeof test !== "object") {
-            throw new Error(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);
-        }
-
-        requiredScenarios.forEach(scenarioType => {
-            if (lodash.isNil(test[scenarioType])) {
-                scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);
-            }
-        });
-
-        if (scenarioErrors.length > 0) {
-            throw new Error([
-                `Test Scenarios for rule ${ruleName} is invalid:`
-            ].concat(scenarioErrors).join("\n"));
-        }
-
-        /**
-         * Run the rule for the given item
-         * @param {string|Object} item Item to run the rule against
-         * @returns {Object} Eslint run result
-         * @private
-         */
-        function runRuleForItem(item) {
-            let config = lodash.cloneDeep(testerConfig),
-                code, filename, beforeAST, afterAST;
-
-            if (typeof item === "string") {
-                code = item;
-            } else {
-                code = item.code;
-
-                // Assumes everything on the item is a config except for the
-                // parameters used by this tester
-                const itemConfig = lodash.omit(item, RuleTesterParameters);
-
-                // Create the config object from the tester config and this item
-                // specific configurations.
-                config = lodash.merge(
-                    config,
-                    itemConfig
-                );
-            }
-
-            if (item.filename) {
-                filename = item.filename;
-            }
-
-            if (Object.prototype.hasOwnProperty.call(item, "options")) {
-                assert(Array.isArray(item.options), "options must be an array");
-                config.rules[ruleName] = [1].concat(item.options);
-            } else {
-                config.rules[ruleName] = 1;
-            }
-
-            linter.defineRule(ruleName, Object.assign({}, rule, {
-
-                // Create a wrapper rule that freezes the `context` properties.
-                create(context) {
-                    freezeDeeply(context.options);
-                    freezeDeeply(context.settings);
-                    freezeDeeply(context.parserOptions);
-
-                    return (typeof rule === "function" ? rule : rule.create)(context);
-                }
-            }));
-
-            const schema = validator.getRuleOptionsSchema(ruleName, linter.rules);
-
-            if (schema) {
-                ajv.validateSchema(schema);
-
-                if (ajv.errors) {
-                    const errors = ajv.errors.map(error => {
-                        const field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;
-
-                        return `\t${field}: ${error.message}`;
-                    }).join("\n");
-
-                    throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);
-                }
-            }
-
-            validator.validate(config, "rule-tester", linter.rules, new Environments());
-
-            /*
-             * Setup AST getters.
-             * The goal is to check whether or not AST was modified when
-             * running the rule under test.
-             */
-            linter.defineRule("rule-tester/validate-ast", () => ({
-                Program(node) {
-                    beforeAST = cloneDeeplyExcludesParent(node);
-                },
-                "Program:exit"(node) {
-                    afterAST = node;
-                }
-            }));
-
-            return {
-                messages: linter.verify(code, config, filename, true),
-                beforeAST,
-                afterAST: cloneDeeplyExcludesParent(afterAST)
-            };
-        }
-
-        /**
-         * Check if the AST was changed
-         * @param {ASTNode} beforeAST AST node before running
-         * @param {ASTNode} afterAST AST node after running
-         * @returns {void}
-         * @private
-         */
-        function assertASTDidntChange(beforeAST, afterAST) {
-            if (!lodash.isEqual(beforeAST, afterAST)) {
-
-                // Not using directly to avoid performance problem in node 6.1.0. See #6111
-                assert.deepEqual(beforeAST, afterAST, "Rule should not modify AST.");
-            }
-        }
-
-        /**
-         * Check if the template is valid or not
-         * all valid cases go through this
-         * @param {string|Object} item Item to run the rule against
-         * @returns {void}
-         * @private
-         */
-        function testValidTemplate(item) {
-            const result = runRuleForItem(item);
-            const messages = result.messages;
-
-            assert.equal(messages.length, 0, util.format("Should have no errors but had %d: %s",
-                messages.length, util.inspect(messages)));
-
-            assertASTDidntChange(result.beforeAST, result.afterAST);
-        }
-
-        /**
-         * Asserts that the message matches its expected value. If the expected
-         * value is a regular expression, it is checked against the actual
-         * value.
-         * @param {string} actual Actual value
-         * @param {string|RegExp} expected Expected value
-         * @returns {void}
-         * @private
-         */
-        function assertMessageMatches(actual, expected) {
-            if (expected instanceof RegExp) {
-
-                // assert.js doesn't have a built-in RegExp match function
-                assert.ok(
-                    expected.test(actual),
-                    `Expected '${actual}' to match ${expected}`
-                );
-            } else {
-                assert.equal(actual, expected);
-            }
-        }
-
-        /**
-         * Check if the template is invalid or not
-         * all invalid cases go through this.
-         * @param {string|Object} item Item to run the rule against
-         * @returns {void}
-         * @private
-         */
-        function testInvalidTemplate(item) {
-            assert.ok(item.errors || item.errors === 0,
-                `Did not specify errors for an invalid test of ${ruleName}`);
-
-            const result = runRuleForItem(item);
-            const messages = result.messages;
-
-
-            if (typeof item.errors === "number") {
-                assert.equal(messages.length, item.errors, util.format("Should have %d error%s but had %d: %s",
-                    item.errors, item.errors === 1 ? "" : "s", messages.length, util.inspect(messages)));
-            } else {
-                assert.equal(
-                    messages.length, item.errors.length,
-                    util.format(
-                        "Should have %d error%s but had %d: %s",
-                        item.errors.length, item.errors.length === 1 ? "" : "s", messages.length, util.inspect(messages)
-                    )
-                );
-
-                const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleName);
-
-                for (let i = 0, l = item.errors.length; i < l; i++) {
-                    assert(!messages[i].fatal, `A fatal parsing error occurred: ${messages[i].message}`);
-                    assert(hasMessageOfThisRule, "Error rule name should be the same as the name of the rule being tested");
-
-                    if (typeof item.errors[i] === "string" || item.errors[i] instanceof RegExp) {
-
-                        // Just an error message.
-                        assertMessageMatches(messages[i].message, item.errors[i]);
-                    } else if (typeof item.errors[i] === "object") {
-
-                        /*
-                         * Error object.
-                         * This may have a message, node type, line, and/or
-                         * column.
-                         */
-                        if (item.errors[i].message) {
-                            assertMessageMatches(messages[i].message, item.errors[i].message);
-                        }
-
-                        if (item.errors[i].type) {
-                            assert.equal(messages[i].nodeType, item.errors[i].type, `Error type should be ${item.errors[i].type}, found ${messages[i].nodeType}`);
-                        }
-
-                        if (item.errors[i].hasOwnProperty("line")) {
-                            assert.equal(messages[i].line, item.errors[i].line, `Error line should be ${item.errors[i].line}`);
-                        }
-
-                        if (item.errors[i].hasOwnProperty("column")) {
-                            assert.equal(messages[i].column, item.errors[i].column, `Error column should be ${item.errors[i].column}`);
-                        }
-
-                        if (item.errors[i].hasOwnProperty("endLine")) {
-                            assert.equal(messages[i].endLine, item.errors[i].endLine, `Error endLine should be ${item.errors[i].endLine}`);
-                        }
-
-                        if (item.errors[i].hasOwnProperty("endColumn")) {
-                            assert.equal(messages[i].endColumn, item.errors[i].endColumn, `Error endColumn should be ${item.errors[i].endColumn}`);
-                        }
-                    } else {
-
-                        // Message was an unexpected type
-                        assert.fail(messages[i], null, "Error should be a string, object, or RegExp.");
-                    }
-                }
-            }
-
-            if (item.hasOwnProperty("output")) {
-                if (item.output === null) {
-                    assert.strictEqual(
-                        messages.filter(message => message.fix).length,
-                        0,
-                        "Expected no autofixes to be suggested"
-                    );
-                } else {
-                    const fixResult = SourceCodeFixer.applyFixes(item.code, messages);
-
-                    assert.equal(fixResult.output, item.output, "Output is incorrect.");
-                }
-            }
-
-            assertASTDidntChange(result.beforeAST, result.afterAST);
-        }
-
-        /*
-         * This creates a mocha test suite and pipes all supplied info through
-         * one of the templates above.
-         */
-        RuleTester.describe(ruleName, () => {
-            RuleTester.describe("valid", () => {
-                test.valid.forEach(valid => {
-                    RuleTester.it(typeof valid === "object" ? valid.code : valid, () => {
-                        linter.defineRules(this.rules);
-                        testValidTemplate(valid);
-                    });
-                });
-            });
-
-            RuleTester.describe("invalid", () => {
-                test.invalid.forEach(invalid => {
-                    RuleTester.it(invalid.code, () => {
-                        linter.defineRules(this.rules);
-                        testInvalidTemplate(invalid);
-                    });
-                });
-            });
-        });
-    }
-}
-
-RuleTester[DESCRIBE] = RuleTester[IT] = null;
-
-module.exports = RuleTester;
Index: node_modules/eslint/lib/rules.js
===================================================================
--- node_modules/eslint/lib/rules.js	(revision )
+++ node_modules/eslint/lib/rules.js	(revision )
@@ -1,140 +0,0 @@
-/**
- * @fileoverview Defines a storage for rules.
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-const loadRules = require("./load-rules");
-const ruleReplacements = require("../conf/replacements").rules;
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Creates a stub rule that gets used when a rule with a given ID is not found.
- * @param {string} ruleId The ID of the missing rule
- * @returns {{create: function(RuleContext): Object}} A rule that reports an error at the first location
- * in the program. The report has the message `Definition for rule '${ruleId}' was not found` if the rule is unknown,
- * or `Rule '${ruleId}' was removed and replaced by: ${replacements.join(", ")}` if the rule is known to have been
- * replaced.
- */
-const createMissingRule = lodash.memoize(ruleId => {
-    const message = Object.prototype.hasOwnProperty.call(ruleReplacements, ruleId)
-        ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements[ruleId].join(", ")}`
-        : `Definition for rule '${ruleId}' was not found`;
-
-    return {
-        create: context => ({
-            Program() {
-                context.report({
-                    loc: { line: 1, column: 0 },
-                    message
-                });
-            }
-        })
-    };
-});
-
-/**
- * Normalizes a rule module to the new-style API
- * @param {(Function|{create: Function})} rule A rule object, which can either be a function
- * ("old-style") or an object with a `create` method ("new-style")
- * @returns {{create: Function}} A new-style rule.
- */
-function normalizeRule(rule) {
-    return typeof rule === "function" ? Object.assign({ create: rule }, rule) : rule;
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-class Rules {
-    constructor() {
-        this._rules = Object.create(null);
-
-        this.load();
-    }
-
-    /**
-     * Registers a rule module for rule id in storage.
-     * @param {string} ruleId Rule id (file name).
-     * @param {Function} ruleModule Rule handler.
-     * @returns {void}
-     */
-    define(ruleId, ruleModule) {
-        this._rules[ruleId] = normalizeRule(ruleModule);
-    }
-
-    /**
-     * Loads and registers all rules from passed rules directory.
-     * @param {string} [rulesDir] Path to rules directory, may be relative. Defaults to `lib/rules`.
-     * @param {string} cwd Current working directory
-     * @returns {void}
-     */
-    load(rulesDir, cwd) {
-        const newRules = loadRules(rulesDir, cwd);
-
-        Object.keys(newRules).forEach(ruleId => {
-            this.define(ruleId, newRules[ruleId]);
-        });
-    }
-
-    /**
-     * Registers all given rules of a plugin.
-     * @param {Object} plugin The plugin object to import.
-     * @param {string} pluginName The name of the plugin without prefix (`eslint-plugin-`).
-     * @returns {void}
-     */
-    importPlugin(plugin, pluginName) {
-        if (plugin.rules) {
-            Object.keys(plugin.rules).forEach(ruleId => {
-                const qualifiedRuleId = `${pluginName}/${ruleId}`,
-                    rule = plugin.rules[ruleId];
-
-                this.define(qualifiedRuleId, rule);
-            });
-        }
-    }
-
-    /**
-     * Access rule handler by id (file name).
-     * @param {string} ruleId Rule id (file name).
-     * @returns {{create: Function, schema: JsonSchema[]}}
-     * A rule. This is normalized to always have the new-style shape with a `create` method.
-     */
-    get(ruleId) {
-        if (!Object.prototype.hasOwnProperty.call(this._rules, ruleId)) {
-            return createMissingRule(ruleId);
-        }
-        if (typeof this._rules[ruleId] === "string") {
-            return normalizeRule(require(this._rules[ruleId]));
-        }
-        return this._rules[ruleId];
-
-    }
-
-    /**
-     * Get an object with all currently loaded rules
-     * @returns {Map} All loaded rules
-     */
-    getAllLoadedRules() {
-        const allRules = new Map();
-
-        Object.keys(this._rules).forEach(name => {
-            const rule = this.get(name);
-
-            allRules.set(name, rule);
-        });
-        return allRules;
-    }
-}
-
-module.exports = Rules;
Index: node_modules/eslint/lib/config.js
===================================================================
--- node_modules/eslint/lib/config.js	(revision )
+++ node_modules/eslint/lib/config.js	(revision )
@@ -1,361 +0,0 @@
-/**
- * @fileoverview Responsible for loading config files
- * @author Seth McLaughlin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const path = require("path"),
-    os = require("os"),
-    ConfigOps = require("./config/config-ops"),
-    ConfigFile = require("./config/config-file"),
-    ConfigCache = require("./config/config-cache"),
-    Plugins = require("./config/plugins"),
-    FileFinder = require("./file-finder"),
-    isResolvable = require("is-resolvable");
-
-const debug = require("debug")("eslint:config");
-
-//------------------------------------------------------------------------------
-// Constants
-//------------------------------------------------------------------------------
-
-const PERSONAL_CONFIG_DIR = os.homedir();
-const SUBCONFIG_SEP = ":";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Determines if any rules were explicitly passed in as options.
- * @param {Object} options The options used to create our configuration.
- * @returns {boolean} True if rules were passed in as options, false otherwise.
- * @private
- */
-function hasRules(options) {
-    return options.rules && Object.keys(options.rules).length > 0;
-}
-
-//------------------------------------------------------------------------------
-// API
-//------------------------------------------------------------------------------
-
-/**
- * Configuration class
- */
-class Config {
-
-    /**
-     * @param {Object} options Options to be passed in
-     * @param {Linter} linterContext Linter instance object
-     */
-    constructor(options, linterContext) {
-        options = options || {};
-
-        this.linterContext = linterContext;
-        this.plugins = new Plugins(linterContext.environments, linterContext.rules);
-
-        this.options = options;
-        this.ignore = options.ignore;
-        this.ignorePath = options.ignorePath;
-        this.parser = options.parser;
-        this.parserOptions = options.parserOptions || {};
-
-        this.configCache = new ConfigCache();
-
-        this.baseConfig = options.baseConfig
-            ? ConfigOps.merge({}, ConfigFile.loadObject(options.baseConfig, this))
-            : { rules: {} };
-        this.baseConfig.filePath = "";
-        this.baseConfig.baseDirectory = this.options.cwd;
-
-        this.configCache.setConfig(this.baseConfig.filePath, this.baseConfig);
-        this.configCache.setMergedVectorConfig(this.baseConfig.filePath, this.baseConfig);
-
-        this.useEslintrc = (options.useEslintrc !== false);
-
-        this.env = (options.envs || []).reduce((envs, name) => {
-            envs[name] = true;
-            return envs;
-        }, {});
-
-        /*
-         * Handle declared globals.
-         * For global variable foo, handle "foo:false" and "foo:true" to set
-         * whether global is writable.
-         * If user declares "foo", convert to "foo:false".
-         */
-        this.globals = (options.globals || []).reduce((globals, def) => {
-            const parts = def.split(SUBCONFIG_SEP);
-
-            globals[parts[0]] = (parts.length > 1 && parts[1] === "true");
-
-            return globals;
-        }, {});
-
-        this.loadSpecificConfig(options.configFile);
-
-        // Empty values in configs don't merge properly
-        const cliConfigOptions = {
-            env: this.env,
-            rules: this.options.rules,
-            globals: this.globals,
-            parserOptions: this.parserOptions,
-            plugins: this.options.plugins
-        };
-
-        this.cliConfig = {};
-        Object.keys(cliConfigOptions).forEach(configKey => {
-            const value = cliConfigOptions[configKey];
-
-            if (value) {
-                this.cliConfig[configKey] = value;
-            }
-        });
-    }
-
-    /**
-    * Loads the config options from a config specified on the command line.
-    * @param {string} [config] A shareable named config or path to a config file.
-    * @returns {void}
-    */
-    loadSpecificConfig(config) {
-        if (config) {
-            debug(`Using command line config ${config}`);
-            const isNamedConfig =
-                isResolvable(config) ||
-                isResolvable(`eslint-config-${config}`) ||
-                config.charAt(0) === "@";
-
-            if (!isNamedConfig) {
-                config = path.resolve(this.options.cwd, config);
-            }
-
-            this.specificConfig = ConfigFile.load(config, this);
-        }
-    }
-
-    /**
-     * Gets the personal config object from user's home directory.
-     * @returns {Object} the personal config object (null if there is no personal config)
-     * @private
-     */
-    getPersonalConfig() {
-        if (typeof this.personalConfig === "undefined") {
-            let config;
-            const filename = ConfigFile.getFilenameForDirectory(PERSONAL_CONFIG_DIR);
-
-            if (filename) {
-                debug("Using personal config");
-                config = ConfigFile.load(filename, this);
-            }
-
-            this.personalConfig = config || null;
-        }
-
-        return this.personalConfig;
-    }
-
-    /**
-     * Builds a hierarchy of config objects, including the base config, all local configs from the directory tree,
-     * and a config file specified on the command line, if applicable.
-     * @param {string} directory a file in whose directory we start looking for a local config
-     * @returns {Object[]} The config objects, in ascending order of precedence
-     * @private
-     */
-    getConfigHierarchy(directory) {
-        debug(`Constructing config file hierarchy for ${directory}`);
-
-        // Step 1: Always include baseConfig
-        let configs = [this.baseConfig];
-
-        // Step 2: Add user-specified config from .eslintrc.* and package.json files
-        if (this.useEslintrc) {
-            debug("Using .eslintrc and package.json files");
-            configs = configs.concat(this.getLocalConfigHierarchy(directory));
-        } else {
-            debug("Not using .eslintrc or package.json files");
-        }
-
-        // Step 3: Merge in command line config file
-        if (this.specificConfig) {
-            debug("Using command line config file");
-            configs.push(this.specificConfig);
-        }
-
-        return configs;
-    }
-
-    /**
-     * Gets a list of config objects extracted from local config files that apply to the current directory, in
-     * descending order, beginning with the config that is highest in the directory tree.
-     * @param {string} directory The directory to start looking in for local config files.
-     * @returns {Object[]} The shallow local config objects, in ascending order of precedence (closest to the current
-     * directory at the end), or an empty array if there are no local configs.
-     * @private
-     */
-    getLocalConfigHierarchy(directory) {
-        const localConfigFiles = this.findLocalConfigFiles(directory),
-            projectConfigPath = ConfigFile.getFilenameForDirectory(this.options.cwd),
-            searched = [],
-            configs = [];
-
-        for (const localConfigFile of localConfigFiles) {
-            const localConfigDirectory = path.dirname(localConfigFile);
-            const localConfigHierarchyCache = this.configCache.getHierarchyLocalConfigs(localConfigDirectory);
-
-            if (localConfigHierarchyCache) {
-                const localConfigHierarchy = localConfigHierarchyCache.concat(configs.reverse());
-
-                this.configCache.setHierarchyLocalConfigs(searched, localConfigHierarchy);
-                return localConfigHierarchy;
-            }
-
-            // Don't consider the personal config file in the home directory,
-            // except if the home directory is the same as the current working directory
-            if (localConfigDirectory === PERSONAL_CONFIG_DIR && localConfigFile !== projectConfigPath) {
-                continue;
-            }
-
-            debug(`Loading ${localConfigFile}`);
-            const localConfig = ConfigFile.load(localConfigFile, this);
-
-            // Ignore empty config files
-            if (!localConfig) {
-                continue;
-            }
-
-            debug(`Using ${localConfigFile}`);
-            configs.push(localConfig);
-            searched.push(localConfigDirectory);
-
-            // Stop traversing if a config is found with the root flag set
-            if (localConfig.root) {
-                break;
-            }
-        }
-
-        if (!configs.length && !this.specificConfig) {
-
-            // Fall back on the personal config from ~/.eslintrc
-            debug("Using personal config file");
-            const personalConfig = this.getPersonalConfig();
-
-            if (personalConfig) {
-                configs.push(personalConfig);
-            } else if (!hasRules(this.options) && !this.options.baseConfig) {
-
-                // No config file, no manual configuration, and no rules, so error.
-                const noConfigError = new Error("No ESLint configuration found.");
-
-                noConfigError.messageTemplate = "no-config-found";
-                noConfigError.messageData = {
-                    directory,
-                    filesExamined: localConfigFiles
-                };
-
-                throw noConfigError;
-            }
-        }
-
-        // Set the caches for the parent directories
-        this.configCache.setHierarchyLocalConfigs(searched, configs.reverse());
-
-        return configs;
-    }
-
-    /**
-     * Gets the vector of applicable configs and subconfigs from the hierarchy for a given file. A vector is an array of
-     * entries, each of which in an object specifying a config file path and an array of override indices corresponding
-     * to entries in the config file's overrides section whose glob patterns match the specified file path; e.g., the
-     * vector entry { configFile: '/home/john/app/.eslintrc', matchingOverrides: [0, 2] } would indicate that the main
-     * project .eslintrc file and its first and third override blocks apply to the current file.
-     * @param {string} filePath The file path for which to build the hierarchy and config vector.
-     * @returns {Array<Object>} config vector applicable to the specified path
-     * @private
-     */
-    getConfigVector(filePath) {
-        const directory = filePath ? path.dirname(filePath) : this.options.cwd;
-
-        return this.getConfigHierarchy(directory).map(config => {
-            const vectorEntry = {
-                filePath: config.filePath,
-                matchingOverrides: []
-            };
-
-            if (config.overrides) {
-                const relativePath = path.relative(config.baseDirectory, filePath || directory);
-
-                config.overrides.forEach((override, i) => {
-                    if (ConfigOps.pathMatchesGlobs(relativePath, override.files, override.excludedFiles)) {
-                        vectorEntry.matchingOverrides.push(i);
-                    }
-                });
-            }
-
-            return vectorEntry;
-        });
-    }
-
-    /**
-     * Finds local config files from the specified directory and its parent directories.
-     * @param {string} directory The directory to start searching from.
-     * @returns {GeneratorFunction} The paths of local config files found.
-     */
-    findLocalConfigFiles(directory) {
-        if (!this.localConfigFinder) {
-            this.localConfigFinder = new FileFinder(ConfigFile.CONFIG_FILES, this.options.cwd);
-        }
-
-        return this.localConfigFinder.findAllInDirectoryAndParents(directory);
-    }
-
-    /**
-     * Builds the authoritative config object for the specified file path by merging the hierarchy of config objects
-     * that apply to the current file, including the base config (conf/eslint-recommended), the user's personal config
-     * from their homedir, all local configs from the directory tree, any specific config file passed on the command
-     * line, any configuration overrides set directly on the command line, and finally the environment configs
-     * (conf/environments).
-     * @param {string} filePath a file in whose directory we start looking for a local config
-     * @returns {Object} config object
-     */
-    getConfig(filePath) {
-        const vector = this.getConfigVector(filePath);
-        let config = this.configCache.getMergedConfig(vector);
-
-        if (config) {
-            debug("Using config from cache");
-            return config;
-        }
-
-        // Step 1: Merge in the filesystem configurations (base, local, and personal)
-        config = ConfigOps.getConfigFromVector(vector, this.configCache);
-
-        // Step 2: Merge in command line configurations
-        config = ConfigOps.merge(config, this.cliConfig);
-
-        if (this.cliConfig.plugins) {
-            this.plugins.loadAll(this.cliConfig.plugins);
-        }
-
-        // Step 3: Override parser only if it is passed explicitly through the command line
-        // or if it's not defined yet (because the final object will at least have the parser key)
-        if (this.parser || !config.parser) {
-            config = ConfigOps.merge(config, { parser: this.parser });
-        }
-
-        // Step 4: Apply environments to the config
-        config = ConfigOps.applyEnvironments(config, this.linterContext.environments);
-
-        this.configCache.setMergedConfig(vector, config);
-
-        return config;
-    }
-}
-
-module.exports = Config;
Index: node_modules/eslint/lib/linter.js
===================================================================
--- node_modules/eslint/lib/linter.js	(revision )
+++ node_modules/eslint/lib/linter.js	(revision )
@@ -1,1138 +0,0 @@
-/**
- * @fileoverview Main Linter Class
- * @author Gyandeep Singh
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const EventEmitter = require("events").EventEmitter,
-    eslintScope = require("eslint-scope"),
-    levn = require("levn"),
-    lodash = require("lodash"),
-    blankScriptAST = require("../conf/blank-script.json"),
-    defaultConfig = require("../conf/default-config-options.js"),
-    CodePathAnalyzer = require("./code-path-analysis/code-path-analyzer"),
-    ConfigOps = require("./config/config-ops"),
-    validator = require("./config/config-validator"),
-    Environments = require("./config/environments"),
-    applyDisableDirectives = require("./util/apply-disable-directives"),
-    NodeEventGenerator = require("./util/node-event-generator"),
-    SourceCode = require("./util/source-code"),
-    Traverser = require("./util/traverser"),
-    createReportTranslator = require("./report-translator"),
-    Rules = require("./rules"),
-    timing = require("./timing"),
-    astUtils = require("./ast-utils"),
-    pkg = require("../package.json"),
-    SourceCodeFixer = require("./util/source-code-fixer");
-
-const debug = require("debug")("eslint:linter");
-const MAX_AUTOFIX_PASSES = 10;
-
-//------------------------------------------------------------------------------
-// Typedefs
-//------------------------------------------------------------------------------
-
-/**
- * The result of a parsing operation from parseForESLint()
- * @typedef {Object} CustomParseResult
- * @property {ASTNode} ast The ESTree AST Program node.
- * @property {Object} services An object containing additional services related
- *      to the parser.
- */
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Parses a list of "name:boolean_value" or/and "name" options divided by comma or
- * whitespace.
- * @param {string} string The string to parse.
- * @param {Comment} comment The comment node which has the string.
- * @returns {Object} Result map object of names and boolean values
- */
-function parseBooleanConfig(string, comment) {
-    const items = {};
-
-    // Collapse whitespace around `:` and `,` to make parsing easier
-    string = string.replace(/\s*([:,])\s*/g, "$1");
-
-    string.split(/\s|,+/).forEach(name => {
-        if (!name) {
-            return;
-        }
-        const pos = name.indexOf(":");
-        let value;
-
-        if (pos !== -1) {
-            value = name.slice(pos + 1);
-            name = name.slice(0, pos);
-        }
-
-        items[name] = {
-            value: (value === "true"),
-            comment
-        };
-
-    });
-    return items;
-}
-
-/**
- * Parses a JSON-like config.
- * @param {string} string The string to parse.
- * @param {Object} location Start line and column of comments for potential error message.
- * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object
- */
-function parseJsonConfig(string, location) {
-    let items = {};
-
-    // Parses a JSON-like comment by the same way as parsing CLI option.
-    try {
-        items = levn.parse("Object", string) || {};
-
-        // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.
-        // Also, commaless notations have invalid severity:
-        //     "no-alert: 2 no-console: 2" --> {"no-alert": "2 no-console: 2"}
-        // Should ignore that case as well.
-        if (ConfigOps.isEverySeverityValid(items)) {
-            return {
-                success: true,
-                config: items
-            };
-        }
-    } catch (ex) {
-
-        // ignore to parse the string by a fallback.
-    }
-
-    // Optionator cannot parse commaless notations.
-    // But we are supporting that. So this is a fallback for that.
-    items = {};
-    string = string.replace(/([a-zA-Z0-9\-/]+):/g, "\"$1\":").replace(/(]|[0-9])\s+(?=")/, "$1,");
-    try {
-        items = JSON.parse(`{${string}}`);
-    } catch (ex) {
-        return {
-            success: false,
-            error: {
-                ruleId: null,
-                fatal: true,
-                severity: 2,
-                source: null,
-                message: `Failed to parse JSON from '${string}': ${ex.message}`,
-                line: location.start.line,
-                column: location.start.column + 1
-            }
-        };
-
-    }
-
-    return {
-        success: true,
-        config: items
-    };
-}
-
-/**
- * Parses a config of values separated by comma.
- * @param {string} string The string to parse.
- * @returns {Object} Result map of values and true values
- */
-function parseListConfig(string) {
-    const items = {};
-
-    // Collapse whitespace around ,
-    string = string.replace(/\s*,\s*/g, ",");
-
-    string.split(/,+/).forEach(name => {
-        name = name.trim();
-        if (!name) {
-            return;
-        }
-        items[name] = true;
-    });
-    return items;
-}
-
-/**
- * Ensures that variables representing built-in properties of the Global Object,
- * and any globals declared by special block comments, are present in the global
- * scope.
- * @param {ASTNode} program The top node of the AST.
- * @param {Scope} globalScope The global scope.
- * @param {Object} config The existing configuration data.
- * @param {Environments} envContext Env context
- * @returns {void}
- */
-function addDeclaredGlobals(program, globalScope, config, envContext) {
-    const declaredGlobals = {},
-        exportedGlobals = {},
-        explicitGlobals = {},
-        builtin = envContext.get("builtin");
-
-    Object.assign(declaredGlobals, builtin);
-
-    Object.keys(config.env).filter(name => config.env[name]).forEach(name => {
-        const env = envContext.get(name),
-            environmentGlobals = env && env.globals;
-
-        if (environmentGlobals) {
-            Object.assign(declaredGlobals, environmentGlobals);
-        }
-    });
-
-    Object.assign(exportedGlobals, config.exported);
-    Object.assign(declaredGlobals, config.globals);
-    Object.assign(explicitGlobals, config.astGlobals);
-
-    Object.keys(declaredGlobals).forEach(name => {
-        let variable = globalScope.set.get(name);
-
-        if (!variable) {
-            variable = new eslintScope.Variable(name, globalScope);
-            variable.eslintExplicitGlobal = false;
-            globalScope.variables.push(variable);
-            globalScope.set.set(name, variable);
-        }
-        variable.writeable = declaredGlobals[name];
-    });
-
-    Object.keys(explicitGlobals).forEach(name => {
-        let variable = globalScope.set.get(name);
-
-        if (!variable) {
-            variable = new eslintScope.Variable(name, globalScope);
-            variable.eslintExplicitGlobal = true;
-            variable.eslintExplicitGlobalComment = explicitGlobals[name].comment;
-            globalScope.variables.push(variable);
-            globalScope.set.set(name, variable);
-        }
-        variable.writeable = explicitGlobals[name].value;
-    });
-
-    // mark all exported variables as such
-    Object.keys(exportedGlobals).forEach(name => {
-        const variable = globalScope.set.get(name);
-
-        if (variable) {
-            variable.eslintUsed = true;
-        }
-    });
-
-    /*
-     * "through" contains all references which definitions cannot be found.
-     * Since we augment the global scope using configuration, we need to update
-     * references and remove the ones that were added by configuration.
-     */
-    globalScope.through = globalScope.through.filter(reference => {
-        const name = reference.identifier.name;
-        const variable = globalScope.set.get(name);
-
-        if (variable) {
-
-            /*
-             * Links the variable and the reference.
-             * And this reference is removed from `Scope#through`.
-             */
-            reference.resolved = variable;
-            variable.references.push(reference);
-
-            return false;
-        }
-
-        return true;
-    });
-}
-
-/**
- * Creates a collection of disable directives from a comment
- * @param {("disable"|"enable"|"disable-line"|"disable-next-line")} type The type of directive comment
- * @param {{line: number, column: number}} loc The 0-based location of the comment token
- * @param {string} value The value after the directive in the comment
- * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)
- * @returns {{
- *     type: ("disable"|"enable"|"disable-line"|"disable-next-line"),
- *     line: number,
- *     column: number,
- *     ruleId: (string|null)
- * }[]} Directives from the comment
- */
-function createDisableDirectives(type, loc, value) {
-    const ruleIds = Object.keys(parseListConfig(value));
-    const directiveRules = ruleIds.length ? ruleIds : [null];
-
-    return directiveRules.map(ruleId => ({ type, line: loc.line, column: loc.column + 1, ruleId }));
-}
-
-/**
- * Parses comments in file to extract file-specific config of rules, globals
- * and environments and merges them with global config; also code blocks
- * where reporting is disabled or enabled and merges them with reporting config.
- * @param {string} filename The file being checked.
- * @param {ASTNode} ast The top node of the AST.
- * @param {Object} config The existing configuration data.
- * @param {Linter} linterContext Linter context object
- * @returns {{
- *      config: Object,
- *      problems: Problem[],
- *      disableDirectives: {
- *          type: ("disable"|"enable"|"disable-line"|"disable-next-line"),
- *          line: number,
- *          column: number,
- *          ruleId: (string|null)
- *      }[]
- * }} Modified config object, along with any problems encountered
- * while parsing config comments
- */
-function modifyConfigsFromComments(filename, ast, config, linterContext) {
-
-    let commentConfig = {
-        exported: {},
-        astGlobals: {},
-        rules: {},
-        env: {}
-    };
-    const commentRules = {};
-    const problems = [];
-    const disableDirectives = [];
-
-    ast.comments.filter(token => token.type !== "Shebang").forEach(comment => {
-
-        let value = comment.value.trim();
-        const match = /^(eslint(-\w+){0,3}|exported|globals?)(\s|$)/.exec(value);
-
-        if (match) {
-            value = value.slice(match.index + match[1].length);
-
-            if (comment.type === "Block") {
-                switch (match[1]) {
-                    case "exported":
-                        Object.assign(commentConfig.exported, parseBooleanConfig(value, comment));
-                        break;
-
-                    case "globals":
-                    case "global":
-                        Object.assign(commentConfig.astGlobals, parseBooleanConfig(value, comment));
-                        break;
-
-                    case "eslint-env":
-                        Object.assign(commentConfig.env, parseListConfig(value));
-                        break;
-
-                    case "eslint-disable":
-                        [].push.apply(disableDirectives, createDisableDirectives("disable", comment.loc.start, value));
-                        break;
-
-                    case "eslint-enable":
-                        [].push.apply(disableDirectives, createDisableDirectives("enable", comment.loc.start, value));
-                        break;
-
-                    case "eslint": {
-                        const parseResult = parseJsonConfig(value, comment.loc);
-
-                        if (parseResult.success) {
-                            Object.keys(parseResult.config).forEach(name => {
-                                const ruleValue = parseResult.config[name];
-
-                                validator.validateRuleOptions(name, ruleValue, `${filename} line ${comment.loc.start.line}`, linterContext.rules);
-                                commentRules[name] = ruleValue;
-                            });
-                        } else {
-                            problems.push(parseResult.error);
-                        }
-
-                        break;
-                    }
-
-                    // no default
-                }
-            } else { // comment.type === "Line"
-                if (match[1] === "eslint-disable-line") {
-                    [].push.apply(disableDirectives, createDisableDirectives("disable-line", comment.loc.start, value));
-                } else if (match[1] === "eslint-disable-next-line") {
-                    [].push.apply(disableDirectives, createDisableDirectives("disable-next-line", comment.loc.start, value));
-                }
-            }
-        }
-    });
-
-    // apply environment configs
-    Object.keys(commentConfig.env).forEach(name => {
-        const env = linterContext.environments.get(name);
-
-        if (env) {
-            commentConfig = ConfigOps.merge(commentConfig, env);
-        }
-    });
-    Object.assign(commentConfig.rules, commentRules);
-
-    return {
-        config: ConfigOps.merge(config, commentConfig),
-        problems,
-        disableDirectives
-    };
-}
-
-/**
- * Normalize ECMAScript version from the initial config
- * @param  {number} ecmaVersion ECMAScript version from the initial config
- * @param  {boolean} isModule Whether the source type is module or not
- * @returns {number} normalized ECMAScript version
- */
-function normalizeEcmaVersion(ecmaVersion, isModule) {
-
-    // Need at least ES6 for modules
-    if (isModule && (!ecmaVersion || ecmaVersion < 6)) {
-        ecmaVersion = 6;
-    }
-
-    // Calculate ECMAScript edition number from official year version starting with
-    // ES2015, which corresponds with ES6 (or a difference of 2009).
-    if (ecmaVersion >= 2015) {
-        ecmaVersion -= 2009;
-    }
-
-    return ecmaVersion;
-}
-
-/**
- * Process initial config to make it safe to extend by file comment config
- * @param  {Object} config Initial config
- * @param  {Environments} envContext Env context
- * @returns {Object}        Processed config
- */
-function prepareConfig(config, envContext) {
-    config.globals = config.globals || {};
-    const copiedRules = {};
-    let parserOptions = {};
-
-    if (typeof config.rules === "object") {
-        Object.keys(config.rules).forEach(k => {
-            const rule = config.rules[k];
-
-            if (rule === null) {
-                throw new Error(`Invalid config for rule '${k}'.`);
-            }
-            if (Array.isArray(rule)) {
-                copiedRules[k] = rule.slice();
-            } else {
-                copiedRules[k] = rule;
-            }
-        });
-    }
-
-    // merge in environment parserOptions
-    if (typeof config.env === "object") {
-        Object.keys(config.env).forEach(envName => {
-            const env = envContext.get(envName);
-
-            if (config.env[envName] && env && env.parserOptions) {
-                parserOptions = ConfigOps.merge(parserOptions, env.parserOptions);
-            }
-        });
-    }
-
-    const preparedConfig = {
-        rules: copiedRules,
-        parser: config.parser || defaultConfig.parser,
-        globals: ConfigOps.merge(defaultConfig.globals, config.globals),
-        env: ConfigOps.merge(defaultConfig.env, config.env || {}),
-        settings: ConfigOps.merge(defaultConfig.settings, config.settings || {}),
-        parserOptions: ConfigOps.merge(parserOptions, config.parserOptions || {})
-    };
-    const isModule = preparedConfig.parserOptions.sourceType === "module";
-
-    if (isModule) {
-
-        // can't have global return inside of modules
-        preparedConfig.parserOptions.ecmaFeatures = Object.assign({}, preparedConfig.parserOptions.ecmaFeatures, { globalReturn: false });
-    }
-
-    preparedConfig.parserOptions.ecmaVersion = normalizeEcmaVersion(preparedConfig.parserOptions.ecmaVersion, isModule);
-
-    return preparedConfig;
-}
-
-const eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)\*\//g;
-
-/**
- * Checks whether or not there is a comment which has "eslint-env *" in a given text.
- * @param {string} text - A source code text to check.
- * @returns {Object|null} A result of parseListConfig() with "eslint-env *" comment.
- */
-function findEslintEnv(text) {
-    let match, retv;
-
-    eslintEnvPattern.lastIndex = 0;
-
-    while ((match = eslintEnvPattern.exec(text))) {
-        retv = Object.assign(retv || {}, parseListConfig(match[1]));
-    }
-
-    return retv;
-}
-
-/**
- * Strips Unicode BOM from a given text.
- *
- * @param {string} text - A text to strip.
- * @returns {string} The stripped text.
- */
-function stripUnicodeBOM(text) {
-
-    /*
-     * Check Unicode BOM.
-     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.
-     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters
-     */
-    if (text.charCodeAt(0) === 0xFEFF) {
-        return text.slice(1);
-    }
-    return text;
-}
-
-/**
- * Get the options for a rule (not including severity), if any
- * @param {Array|number} ruleConfig rule configuration
- * @returns {Array} of rule options, empty Array if none
- */
-function getRuleOptions(ruleConfig) {
-    if (Array.isArray(ruleConfig)) {
-        return ruleConfig.slice(1);
-    }
-    return [];
-
-}
-
-/**
- * Parses text into an AST. Moved out here because the try-catch prevents
- * optimization of functions, so it's best to keep the try-catch as isolated
- * as possible
- * @param {string} text The text to parse.
- * @param {Object} providedParserOptions Options to pass to the parser
- * @param {string} parserName The name of the parser
- * @param {string} filePath The path to the file being parsed.
- * @returns {{success: false, error: Problem}|{success: true,ast: ASTNode, services: Object}}
- * An object containing the AST and parser services if parsing was successful, or the error if parsing failed
- * @private
- */
-function parse(text, providedParserOptions, parserName, filePath) {
-
-    const parserOptions = Object.assign({}, providedParserOptions, {
-        loc: true,
-        range: true,
-        raw: true,
-        tokens: true,
-        comment: true,
-        filePath
-    });
-
-    let parser;
-
-    try {
-        parser = require(parserName);
-    } catch (ex) {
-        return {
-            success: false,
-            error: {
-                ruleId: null,
-                fatal: true,
-                severity: 2,
-                source: null,
-                message: ex.message,
-                line: 0,
-                column: 0
-            }
-        };
-    }
-
-    /*
-     * Check for parsing errors first. If there's a parsing error, nothing
-     * else can happen. However, a parsing error does not throw an error
-     * from this method - it's just considered a fatal error message, a
-     * problem that ESLint identified just like any other.
-     */
-    try {
-        if (typeof parser.parseForESLint === "function") {
-            const parseResult = parser.parseForESLint(text, parserOptions);
-
-            return {
-                success: true,
-                ast: parseResult.ast,
-                services: parseResult.services || {}
-            };
-        }
-
-        return {
-            success: true,
-            ast: parser.parse(text, parserOptions),
-            services: {}
-        };
-    } catch (ex) {
-
-        // If the message includes a leading line number, strip it:
-        const message = `Parsing error: ${ex.message.replace(/^line \d+:/i, "").trim()}`;
-        const source = ex.lineNumber ? SourceCode.splitLines(text)[ex.lineNumber - 1] : null;
-
-        return {
-            success: false,
-            error: {
-                ruleId: null,
-                fatal: true,
-                severity: 2,
-                source,
-                message,
-                line: ex.lineNumber,
-                column: ex.column
-            }
-        };
-    }
-}
-
-/**
- * Gets the scope for the current node
- * @param {ScopeManager} scopeManager The scope manager for this AST
- * @param {ASTNode} currentNode The node to get the scope of
- * @param {number} ecmaVersion The `ecmaVersion` setting that this code was parsed with
- * @returns {eslint-scope.Scope} The scope information for this node
- */
-function getScope(scopeManager, currentNode, ecmaVersion) {
-    let initialNode;
-
-    // if current node introduces a scope, add it to the list
-    if (
-        ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(currentNode.type) >= 0 ||
-        ecmaVersion >= 6 && ["BlockStatement", "SwitchStatement", "CatchClause"].indexOf(currentNode.type) >= 0
-    ) {
-        initialNode = currentNode;
-    } else {
-        initialNode = currentNode.parent;
-    }
-
-    // Ascend the current node's parents
-    for (let node = initialNode; node; node = node.parent) {
-
-        // Get the innermost scope
-        const scope = scopeManager.acquire(node, true);
-
-        if (scope) {
-            if (scope.type === "function-expression-name") {
-                return scope.childScopes[0];
-            }
-            return scope;
-        }
-    }
-
-    return scopeManager.scopes[0];
-}
-
-/**
- * Marks a variable as used in the current scope
- * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.
- * @param {ASTNode} currentNode The node currently being traversed
- * @param {Object} parserOptions The options used to parse this text
- * @param {string} name The name of the variable that should be marked as used.
- * @returns {boolean} True if the variable was found and marked as used, false if not.
- */
-function markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {
-    const hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;
-    const specialScope = hasGlobalReturn || parserOptions.sourceType === "module";
-    const currentScope = getScope(scopeManager, currentNode, parserOptions.ecmaVersion);
-
-    // Special Node.js scope means we need to start one level deeper
-    const initialScope = currentScope.type === "global" && specialScope ? currentScope.childScopes[0] : currentScope;
-
-    for (let scope = initialScope; scope; scope = scope.upper) {
-        const variable = scope.variables.find(scopeVar => scopeVar.name === name);
-
-        if (variable) {
-            variable.eslintUsed = true;
-            return true;
-        }
-    }
-
-    return false;
-}
-
-/**
- * Gets all the ancestors of a given node
- * @param {ASTNode} node The node
- * @returns {ASTNode[]} All the ancestor nodes in the AST, not including the provided node, starting
- * from the root node and going inwards to the parent node.
- */
-function getAncestors(node) {
-    if (node.parent) {
-        const parentAncestors = getAncestors(node.parent);
-
-        parentAncestors.push(node.parent);
-        return parentAncestors;
-    }
-    return [];
-}
-
-// methods that exist on SourceCode object
-const DEPRECATED_SOURCECODE_PASSTHROUGHS = {
-    getSource: "getText",
-    getSourceLines: "getLines",
-    getAllComments: "getAllComments",
-    getNodeByRangeIndex: "getNodeByRangeIndex",
-    getComments: "getComments",
-    getCommentsBefore: "getCommentsBefore",
-    getCommentsAfter: "getCommentsAfter",
-    getCommentsInside: "getCommentsInside",
-    getJSDocComment: "getJSDocComment",
-    getFirstToken: "getFirstToken",
-    getFirstTokens: "getFirstTokens",
-    getLastToken: "getLastToken",
-    getLastTokens: "getLastTokens",
-    getTokenAfter: "getTokenAfter",
-    getTokenBefore: "getTokenBefore",
-    getTokenByRangeStart: "getTokenByRangeStart",
-    getTokens: "getTokens",
-    getTokensAfter: "getTokensAfter",
-    getTokensBefore: "getTokensBefore",
-    getTokensBetween: "getTokensBetween"
-};
-
-const BASE_TRAVERSAL_CONTEXT = Object.freeze(
-    Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(
-        (contextInfo, methodName) =>
-            Object.assign(contextInfo, {
-                [methodName]() {
-                    const sourceCode = this.getSourceCode();
-
-                    return sourceCode[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]].apply(sourceCode, arguments);
-                }
-            }),
-        {}
-    )
-);
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * Object that is responsible for verifying JavaScript text
- * @name eslint
- */
-module.exports = class Linter {
-
-    constructor() {
-        this.sourceCode = null;
-        this.version = pkg.version;
-
-        this.rules = new Rules();
-        this.environments = new Environments();
-    }
-
-    /**
-     * Configuration object for the `verify` API. A JS representation of the eslintrc files.
-     * @typedef {Object} ESLintConfig
-     * @property {Object} rules The rule configuration to verify against.
-     * @property {string} [parser] Parser to use when generatig the AST.
-     * @property {Object} [parserOptions] Options for the parsed used.
-     * @property {Object} [settings] Global settings passed to each rule.
-     * @property {Object} [env] The environment to verify in.
-     * @property {Object} [globals] Available globals to the code.
-     */
-
-    /**
-     * Same as linter.verify, except without support for processors.
-     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
-     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.
-     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.
-     *      If this is not set, the filename will default to '<input>' in the rule context. If
-     *      an object, then it has "filename", "saveState", and "allowInlineConfig" properties.
-     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.
-     *      Useful if you want to validate JS without comments overriding rules.
-     * @returns {Object[]} The results as an array of messages or null if no messages.
-     */
-    _verifyWithoutProcessors(textOrSourceCode, config, filenameOrOptions) {
-        let text,
-            parserServices,
-            allowInlineConfig,
-            providedFilename;
-
-        // evaluate arguments
-        if (typeof filenameOrOptions === "object") {
-            providedFilename = filenameOrOptions.filename;
-            allowInlineConfig = filenameOrOptions.allowInlineConfig;
-        } else {
-            providedFilename = filenameOrOptions;
-        }
-
-        const filename = typeof providedFilename === "string" ? providedFilename : "<input>";
-
-        if (typeof textOrSourceCode === "string") {
-            this.sourceCode = null;
-            text = textOrSourceCode;
-        } else {
-            this.sourceCode = textOrSourceCode;
-            text = this.sourceCode.text;
-        }
-
-        // search and apply "eslint-env *".
-        const envInFile = findEslintEnv(text);
-
-        config = Object.assign({}, config);
-
-        if (envInFile) {
-            if (config.env) {
-                config.env = Object.assign({}, config.env, envInFile);
-            } else {
-                config.env = envInFile;
-            }
-        }
-
-        // process initial config to make it safe to extend
-        config = prepareConfig(config, this.environments);
-
-        if (this.sourceCode) {
-            parserServices = {};
-        } else {
-
-            // there's no input, just exit here
-            if (text.trim().length === 0) {
-                this.sourceCode = new SourceCode(text, blankScriptAST);
-                return [];
-            }
-
-            const parseResult = parse(
-                stripUnicodeBOM(text).replace(astUtils.SHEBANG_MATCHER, (match, captured) => `//${captured}`),
-                config.parserOptions,
-                config.parser,
-                filename
-            );
-
-            if (!parseResult.success) {
-                return [parseResult.error];
-            }
-
-            parserServices = parseResult.services;
-            this.sourceCode = new SourceCode(text, parseResult.ast);
-        }
-
-        const problems = [];
-        const sourceCode = this.sourceCode;
-        let disableDirectives;
-
-        // parse global comments and modify config
-        if (allowInlineConfig !== false) {
-            const modifyConfigResult = modifyConfigsFromComments(filename, sourceCode.ast, config, this);
-
-            config = modifyConfigResult.config;
-            modifyConfigResult.problems.forEach(problem => problems.push(problem));
-            disableDirectives = modifyConfigResult.disableDirectives;
-        } else {
-            disableDirectives = [];
-        }
-
-        const emitter = new EventEmitter().setMaxListeners(Infinity);
-        const ecmaFeatures = config.parserOptions.ecmaFeatures || {};
-        const ecmaVersion = config.parserOptions.ecmaVersion || 5;
-        const scopeManager = eslintScope.analyze(sourceCode.ast, {
-            ignoreEval: true,
-            nodejsScope: ecmaFeatures.globalReturn,
-            impliedStrict: ecmaFeatures.impliedStrict,
-            ecmaVersion,
-            sourceType: config.parserOptions.sourceType || "script",
-            fallback: Traverser.getKeys
-        });
-
-        let currentNode = sourceCode.ast;
-        const nodeQueue = [];
-
-        new Traverser().traverse(sourceCode.ast, {
-            enter(node, parent) {
-                node.parent = parent;
-                nodeQueue.push({ isEntering: true, node });
-            },
-            leave(node) {
-                nodeQueue.push({ isEntering: false, node });
-            }
-        });
-
-        /*
-         * Create a frozen object with the ruleContext properties and methods that are shared by all rules.
-         * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the
-         * properties once for each rule.
-         */
-        const sharedTraversalContext = Object.freeze(
-            Object.assign(
-                Object.create(BASE_TRAVERSAL_CONTEXT),
-                {
-                    getAncestors: () => getAncestors(currentNode),
-                    getDeclaredVariables: scopeManager.getDeclaredVariables.bind(scopeManager),
-                    getFilename: () => filename,
-                    getScope: () => getScope(scopeManager, currentNode, config.parserOptions.ecmaVersion),
-                    getSourceCode: () => sourceCode,
-                    markVariableAsUsed: name => markVariableAsUsed(scopeManager, currentNode, config.parserOptions, name),
-                    parserOptions: config.parserOptions,
-                    parserPath: config.parser,
-                    parserServices,
-                    settings: config.settings,
-
-                    /**
-                     * This is used to avoid breaking rules that used to monkeypatch the `Linter#report` method
-                     * by using the `_linter` property on rule contexts.
-                     *
-                     * This should be removed in a major release after we create a better way to
-                     * lint for unused disable comments.
-                     * https://github.com/eslint/eslint/issues/9193
-                     */
-                    _linter: {
-                        report() {},
-                        on: emitter.on.bind(emitter)
-                    }
-                }
-            )
-        );
-
-        // enable appropriate rules
-        Object.keys(config.rules).forEach(ruleId => {
-            const severity = ConfigOps.getRuleSeverity(config.rules[ruleId]);
-
-            if (severity === 0) {
-                return;
-            }
-
-            const rule = this.rules.get(ruleId);
-            let reportTranslator = null;
-            const ruleContext = Object.freeze(
-                Object.assign(
-                    Object.create(sharedTraversalContext),
-                    {
-                        id: ruleId,
-                        options: getRuleOptions(config.rules[ruleId]),
-                        report() {
-
-                            /*
-                             * Create a report translator lazily.
-                             * In a vast majority of cases, any given rule reports zero errors on a given
-                             * piece of code. Creating a translator lazily avoids the performance cost of
-                             * creating a new translator function for each rule that usually doesn't get
-                             * called.
-                             *
-                             * Using lazy report translators improves end-to-end performance by about 3%
-                             * with Node 8.4.0.
-                             */
-                            if (reportTranslator === null) {
-                                reportTranslator = createReportTranslator({ ruleId, severity, sourceCode });
-                            }
-                            const problem = reportTranslator.apply(null, arguments);
-
-                            if (problem.fix && rule.meta && !rule.meta.fixable) {
-                                throw new Error("Fixable rules should export a `meta.fixable` property.");
-                            }
-                            problems.push(problem);
-
-                            /*
-                             * This is used to avoid breaking rules that used monkeypatch Linter, and relied on
-                             * `linter.report` getting called with report info every time a rule reports a problem.
-                             * To continue to support this, make sure that `context._linter.report` is called every
-                             * time a problem is reported by a rule, even though `context._linter` is no longer a
-                             * `Linter` instance.
-                             *
-                             * This should be removed in a major release after we create a better way to
-                             * lint for unused disable comments.
-                             * https://github.com/eslint/eslint/issues/9193
-                             */
-                            sharedTraversalContext._linter.report( // eslint-disable-line no-underscore-dangle
-                                problem.ruleId,
-                                problem.severity,
-                                { loc: { start: { line: problem.line, column: problem.column - 1 } } },
-                                problem.message
-                            );
-                        }
-                    }
-                )
-            );
-
-            try {
-                const ruleListeners = rule.create(ruleContext);
-
-                // add all the selectors from the rule as listeners
-                Object.keys(ruleListeners).forEach(selector => {
-                    emitter.on(
-                        selector,
-                        timing.enabled
-                            ? timing.time(ruleId, ruleListeners[selector])
-                            : ruleListeners[selector]
-                    );
-                });
-            } catch (ex) {
-                ex.message = `Error while loading rule '${ruleId}': ${ex.message}`;
-                throw ex;
-            }
-        });
-
-        // augment global scope with declared global variables
-        addDeclaredGlobals(sourceCode.ast, scopeManager.scopes[0], config, this.environments);
-
-        const eventGenerator = new CodePathAnalyzer(new NodeEventGenerator(emitter));
-
-        nodeQueue.forEach(traversalInfo => {
-            currentNode = traversalInfo.node;
-
-            if (traversalInfo.isEntering) {
-                eventGenerator.enterNode(currentNode);
-            } else {
-                eventGenerator.leaveNode(currentNode);
-            }
-        });
-
-        return applyDisableDirectives({
-            directives: disableDirectives,
-            problems: problems.sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column)
-        });
-    }
-
-    /**
-     * Verifies the text against the rules specified by the second argument.
-     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
-     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.
-     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.
-     *      If this is not set, the filename will default to '<input>' in the rule context. If
-     *      an object, then it has "filename", "saveState", and "allowInlineConfig" properties.
-     * @param {boolean} [saveState] Indicates if the state from the last run should be saved.
-     *      Mostly useful for testing purposes.
-     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.
-     *      Useful if you want to validate JS without comments overriding rules.
-     * @param {function(string): string[]} [filenameOrOptions.preprocess] preprocessor for source text. If provided,
-     *      this should accept a string of source text, and return an array of code blocks to lint.
-     * @param {function(Array<Object[]>): Object[]} [filenameOrOptions.postprocess] postprocessor for report messages. If provided,
-     *      this should accept an array of the message lists for each code block returned from the preprocessor,
-     *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages
-     * @returns {Object[]} The results as an array of messages or null if no messages.
-     */
-    verify(textOrSourceCode, config, filenameOrOptions) {
-        const preprocess = filenameOrOptions && filenameOrOptions.preprocess || (rawText => [rawText]);
-        const postprocess = filenameOrOptions && filenameOrOptions.postprocess || lodash.flatten;
-
-        return postprocess(
-            preprocess(textOrSourceCode).map(
-                textBlock => this._verifyWithoutProcessors(textBlock, config, filenameOrOptions)
-            )
-        );
-    }
-
-    /**
-     * Gets the SourceCode object representing the parsed source.
-     * @returns {SourceCode} The SourceCode object.
-     */
-    getSourceCode() {
-        return this.sourceCode;
-    }
-
-    /**
-     * Defines a new linting rule.
-     * @param {string} ruleId A unique rule identifier
-     * @param {Function} ruleModule Function from context to object mapping AST node types to event handlers
-     * @returns {void}
-     */
-    defineRule(ruleId, ruleModule) {
-        this.rules.define(ruleId, ruleModule);
-    }
-
-    /**
-     * Defines many new linting rules.
-     * @param {Object} rulesToDefine map from unique rule identifier to rule
-     * @returns {void}
-     */
-    defineRules(rulesToDefine) {
-        Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {
-            this.defineRule(ruleId, rulesToDefine[ruleId]);
-        });
-    }
-
-    /**
-     * Gets an object with all loaded rules.
-     * @returns {Map} All loaded rules
-     */
-    getRules() {
-        return this.rules.getAllLoadedRules();
-    }
-
-    /**
-     * Performs multiple autofix passes over the text until as many fixes as possible
-     * have been applied.
-     * @param {string} text The source text to apply fixes to.
-     * @param {Object} config The ESLint config object to use.
-     * @param {Object} options The ESLint options object to use.
-     * @param {string} options.filename The filename from which the text was read.
-     * @param {boolean} options.allowInlineConfig Flag indicating if inline comments
-     *      should be allowed.
-     * @param {boolean|Function} options.fix Determines whether fixes should be applied
-     * @param {Function} options.preprocess preprocessor for source text. If provided, this should
-     *      accept a string of source text, and return an array of code blocks to lint.
-     * @param {Function} options.postprocess postprocessor for report messages. If provided,
-     *      this should accept an array of the message lists for each code block returned from the preprocessor,
-     *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages
-     * @returns {Object} The result of the fix operation as returned from the
-     *      SourceCodeFixer.
-     */
-    verifyAndFix(text, config, options) {
-        let messages = [],
-            fixedResult,
-            fixed = false,
-            passNumber = 0;
-        const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;
-        const shouldFix = options && typeof options.fix !== "undefined" ? options.fix : true;
-
-        /**
-         * This loop continues until one of the following is true:
-         *
-         * 1. No more fixes have been applied.
-         * 2. Ten passes have been made.
-         *
-         * That means anytime a fix is successfully applied, there will be another pass.
-         * Essentially, guaranteeing a minimum of two passes.
-         */
-        do {
-            passNumber++;
-
-            debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);
-            messages = this.verify(text, config, options);
-
-            debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);
-            fixedResult = SourceCodeFixer.applyFixes(text, messages, shouldFix);
-
-            // stop if there are any syntax errors.
-            // 'fixedResult.output' is a empty string.
-            if (messages.length === 1 && messages[0].fatal) {
-                break;
-            }
-
-            // keep track if any fixes were ever applied - important for return value
-            fixed = fixed || fixedResult.fixed;
-
-            // update to use the fixed output instead of the original text
-            text = fixedResult.output;
-
-        } while (
-            fixedResult.fixed &&
-            passNumber < MAX_AUTOFIX_PASSES
-        );
-
-        /*
-         * If the last result had fixes, we need to lint again to be sure we have
-         * the most up-to-date information.
-         */
-        if (fixedResult.fixed) {
-            fixedResult.messages = this.verify(text, config, options);
-        }
-
-        // ensure the last result properly reflects if fixes were done
-        fixedResult.fixed = fixed;
-        fixedResult.output = text;
-
-        return fixedResult;
-    }
-};
Index: node_modules/eslint/lib/timing.js
===================================================================
--- node_modules/eslint/lib/timing.js	(revision )
+++ node_modules/eslint/lib/timing.js	(revision )
@@ -1,141 +0,0 @@
-/**
- * @fileoverview Tracks performance of individual rules.
- * @author Brandon Mills
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/* istanbul ignore next */
-/**
- * Align the string to left
- * @param {string} str string to evaluate
- * @param {int} len length of the string
- * @param {string} ch delimiter character
- * @returns {string} modified string
- * @private
- */
-function alignLeft(str, len, ch) {
-    return str + new Array(len - str.length + 1).join(ch || " ");
-}
-
-/* istanbul ignore next */
-/**
- * Align the string to right
- * @param {string} str string to evaluate
- * @param {int} len length of the string
- * @param {string} ch delimiter character
- * @returns {string} modified string
- * @private
- */
-function alignRight(str, len, ch) {
-    return new Array(len - str.length + 1).join(ch || " ") + str;
-}
-
-//------------------------------------------------------------------------------
-// Module definition
-//------------------------------------------------------------------------------
-
-const enabled = !!process.env.TIMING;
-
-const HEADERS = ["Rule", "Time (ms)", "Relative"];
-const ALIGN = [alignLeft, alignRight, alignRight];
-
-/* istanbul ignore next */
-/**
- * display the data
- * @param {Object} data Data object to be displayed
- * @returns {string} modified string
- * @private
- */
-function display(data) {
-    let total = 0;
-    const rows = Object.keys(data)
-        .map(key => {
-            const time = data[key];
-
-            total += time;
-            return [key, time];
-        })
-        .sort((a, b) => b[1] - a[1])
-        .slice(0, 10);
-
-    rows.forEach(row => {
-        row.push(`${(row[1] * 100 / total).toFixed(1)}%`);
-        row[1] = row[1].toFixed(3);
-    });
-
-    rows.unshift(HEADERS);
-
-    const widths = [];
-
-    rows.forEach(row => {
-        const len = row.length;
-
-        for (let i = 0; i < len; i++) {
-            const n = row[i].length;
-
-            if (!widths[i] || n > widths[i]) {
-                widths[i] = n;
-            }
-        }
-    });
-
-    const table = rows.map(row => (
-        row
-            .map((cell, index) => ALIGN[index](cell, widths[index]))
-            .join(" | ")
-    ));
-
-    table.splice(1, 0, widths.map((w, index) => {
-        if (index !== 0 && index !== widths.length - 1) {
-            w++;
-        }
-
-        return ALIGN[index](":", w + 1, "-");
-    }).join("|"));
-
-    console.log(table.join("\n")); // eslint-disable-line no-console
-}
-
-/* istanbul ignore next */
-module.exports = (function() {
-
-    const data = Object.create(null);
-
-    /**
-     * Time the run
-     * @param {*} key key from the data object
-     * @param {Function} fn function to be called
-     * @returns {Function} function to be executed
-     * @private
-     */
-    function time(key, fn) {
-        if (typeof data[key] === "undefined") {
-            data[key] = 0;
-        }
-
-        return function() {
-            let t = process.hrtime();
-
-            fn.apply(null, Array.prototype.slice.call(arguments));
-            t = process.hrtime(t);
-            data[key] += t[0] * 1e3 + t[1] / 1e6;
-        };
-    }
-
-    if (enabled) {
-        process.on("exit", () => {
-            display(data);
-        });
-    }
-
-    return {
-        time,
-        enabled
-    };
-
-}());
Index: node_modules/eslint/lib/formatters/tap.js
===================================================================
--- node_modules/eslint/lib/formatters/tap.js	(revision )
+++ node_modules/eslint/lib/formatters/tap.js	(revision )
@@ -1,90 +0,0 @@
-/**
- * @fileoverview TAP reporter
- * @author Jonathan Kingston
- */
-"use strict";
-
-const yaml = require("js-yaml");
-
-//------------------------------------------------------------------------------
-// Helper Functions
-//------------------------------------------------------------------------------
-
-/**
- * Returns a canonical error level string based upon the error message passed in.
- * @param {Object} message Individual error message provided by eslint
- * @returns {string} Error level string
- */
-function getMessageType(message) {
-    if (message.fatal || message.severity === 2) {
-        return "error";
-    }
-    return "warning";
-
-}
-
-/**
- * Takes in a JavaScript object and outputs a TAP diagnostics string
- * @param {Object} diagnostic JavaScript object to be embedded as YAML into output.
- * @returns {string} diagnostics string with YAML embedded - TAP version 13 compliant
- */
-function outputDiagnostics(diagnostic) {
-    const prefix = "  ";
-    let output = `${prefix}---\n`;
-
-    output += prefix + yaml.safeDump(diagnostic).split("\n").join(`\n${prefix}`);
-    output += "...\n";
-    return output;
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(results) {
-    let output = `TAP version 13\n1..${results.length}\n`;
-
-    results.forEach((result, id) => {
-        const messages = result.messages;
-        let testResult = "ok";
-        let diagnostics = {};
-
-        if (messages.length > 0) {
-            testResult = "not ok";
-
-            messages.forEach(message => {
-                const diagnostic = {
-                    message: message.message,
-                    severity: getMessageType(message),
-                    data: {
-                        line: message.line || 0,
-                        column: message.column || 0,
-                        ruleId: message.ruleId || ""
-                    }
-                };
-
-                // If we have multiple messages place them under a messages key
-                // The first error will be logged as message key
-                // This is to adhere to TAP 13 loosely defined specification of having a message key
-                if ("message" in diagnostics) {
-                    if (typeof diagnostics.messages === "undefined") {
-                        diagnostics.messages = [];
-                    }
-                    diagnostics.messages.push(diagnostic);
-                } else {
-                    diagnostics = diagnostic;
-                }
-            });
-        }
-
-        output += `${testResult} ${id + 1} - ${result.filePath}\n`;
-
-        // If we have an error include diagnostics
-        if (messages.length > 0) {
-            output += outputDiagnostics(diagnostics);
-        }
-
-    });
-
-    return output;
-};
Index: node_modules/eslint/lib/formatters/html.js
===================================================================
--- node_modules/eslint/lib/formatters/html.js	(revision )
+++ node_modules/eslint/lib/formatters/html.js	(revision )
@@ -1,126 +0,0 @@
-/**
- * @fileoverview HTML reporter
- * @author Julian Laval
- */
-"use strict";
-
-const lodash = require("lodash");
-const fs = require("fs");
-const path = require("path");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const pageTemplate = lodash.template(fs.readFileSync(path.join(__dirname, "html-template-page.html"), "utf-8"));
-const messageTemplate = lodash.template(fs.readFileSync(path.join(__dirname, "html-template-message.html"), "utf-8"));
-const resultTemplate = lodash.template(fs.readFileSync(path.join(__dirname, "html-template-result.html"), "utf-8"));
-
-/**
- * Given a word and a count, append an s if count is not one.
- * @param {string} word A word in its singular form.
- * @param {int} count A number controlling whether word should be pluralized.
- * @returns {string} The original word with an s on the end if count is not one.
- */
-function pluralize(word, count) {
-    return (count === 1 ? word : `${word}s`);
-}
-
-/**
- * Renders text along the template of x problems (x errors, x warnings)
- * @param {string} totalErrors Total errors
- * @param {string} totalWarnings Total warnings
- * @returns {string} The formatted string, pluralized where necessary
- */
-function renderSummary(totalErrors, totalWarnings) {
-    const totalProblems = totalErrors + totalWarnings;
-    let renderedText = `${totalProblems} ${pluralize("problem", totalProblems)}`;
-
-    if (totalProblems !== 0) {
-        renderedText += ` (${totalErrors} ${pluralize("error", totalErrors)}, ${totalWarnings} ${pluralize("warning", totalWarnings)})`;
-    }
-    return renderedText;
-}
-
-/**
- * Get the color based on whether there are errors/warnings...
- * @param {string} totalErrors Total errors
- * @param {string} totalWarnings Total warnings
- * @returns {int} The color code (0 = green, 1 = yellow, 2 = red)
- */
-function renderColor(totalErrors, totalWarnings) {
-    if (totalErrors !== 0) {
-        return 2;
-    } else if (totalWarnings !== 0) {
-        return 1;
-    }
-    return 0;
-}
-
-/**
- * Get HTML (table rows) describing the messages.
- * @param {Array} messages Messages.
- * @param {int} parentIndex Index of the parent HTML row.
- * @returns {string} HTML (table rows) describing the messages.
- */
-function renderMessages(messages, parentIndex) {
-
-    /**
-     * Get HTML (table row) describing a message.
-     * @param {Object} message Message.
-     * @returns {string} HTML (table row) describing a message.
-     */
-    return lodash.map(messages, message => {
-        const lineNumber = message.line || 0;
-        const columnNumber = message.column || 0;
-
-        return messageTemplate({
-            parentIndex,
-            lineNumber,
-            columnNumber,
-            severityNumber: message.severity,
-            severityName: message.severity === 1 ? "Warning" : "Error",
-            message: message.message,
-            ruleId: message.ruleId
-        });
-    }).join("\n");
-}
-
-/**
- * @param {Array} results Test results.
- * @returns {string} HTML string describing the results.
- */
-function renderResults(results) {
-    return lodash.map(results, (result, index) => resultTemplate({
-        index,
-        color: renderColor(result.errorCount, result.warningCount),
-        filePath: result.filePath,
-        summary: renderSummary(result.errorCount, result.warningCount)
-
-    }) + renderMessages(result.messages, index)).join("\n");
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(results) {
-    let totalErrors,
-        totalWarnings;
-
-    totalErrors = 0;
-    totalWarnings = 0;
-
-    // Iterate over results to get totals
-    results.forEach(result => {
-        totalErrors += result.errorCount;
-        totalWarnings += result.warningCount;
-    });
-
-    return pageTemplate({
-        date: new Date(),
-        reportColor: renderColor(totalErrors, totalWarnings),
-        reportSummary: renderSummary(totalErrors, totalWarnings),
-        results: renderResults(results)
-    });
-};
Index: node_modules/eslint/lib/formatters/json.js
===================================================================
--- node_modules/eslint/lib/formatters/json.js	(revision )
+++ node_modules/eslint/lib/formatters/json.js	(revision )
@@ -1,13 +0,0 @@
-/**
- * @fileoverview JSON reporter
- * @author Burak Yigit Kaya aka BYK
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(results) {
-    return JSON.stringify(results);
-};
Index: node_modules/eslint/lib/formatters/unix.js
===================================================================
--- node_modules/eslint/lib/formatters/unix.js	(revision )
+++ node_modules/eslint/lib/formatters/unix.js	(revision )
@@ -1,58 +0,0 @@
-/**
- * @fileoverview unix-style formatter.
- * @author oshi-shinobu
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helper Functions
-//------------------------------------------------------------------------------
-
-/**
- * Returns a canonical error level string based upon the error message passed in.
- * @param {Object} message Individual error message provided by eslint
- * @returns {string} Error level string
- */
-function getMessageType(message) {
-    if (message.fatal || message.severity === 2) {
-        return "Error";
-    }
-    return "Warning";
-
-}
-
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(results) {
-
-    let output = "",
-        total = 0;
-
-    results.forEach(result => {
-
-        const messages = result.messages;
-
-        total += messages.length;
-
-        messages.forEach(message => {
-
-            output += `${result.filePath}:`;
-            output += `${message.line || 0}:`;
-            output += `${message.column || 0}:`;
-            output += ` ${message.message} `;
-            output += `[${getMessageType(message)}${message.ruleId ? `/${message.ruleId}` : ""}]`;
-            output += "\n";
-
-        });
-
-    });
-
-    if (total > 0) {
-        output += `\n${total} problem${total !== 1 ? "s" : ""}`;
-    }
-
-    return output;
-};
Index: node_modules/eslint/lib/formatters/junit.js
===================================================================
--- node_modules/eslint/lib/formatters/junit.js	(revision )
+++ node_modules/eslint/lib/formatters/junit.js	(revision )
@@ -1,64 +0,0 @@
-/**
- * @fileoverview jUnit Reporter
- * @author Jamund Ferguson
- */
-"use strict";
-
-const xmlEscape = require("../util/xml-escape");
-
-//------------------------------------------------------------------------------
-// Helper Functions
-//------------------------------------------------------------------------------
-
-/**
- * Returns the severity of warning or error
- * @param {Object} message message object to examine
- * @returns {string} severity level
- * @private
- */
-function getMessageType(message) {
-    if (message.fatal || message.severity === 2) {
-        return "Error";
-    }
-    return "Warning";
-
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(results) {
-
-    let output = "";
-
-    output += "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
-    output += "<testsuites>\n";
-
-    results.forEach(result => {
-
-        const messages = result.messages;
-
-        output += `<testsuite package="org.eslint" time="0" tests="${messages.length}" errors="${messages.length}" name="${result.filePath}">\n`;
-        messages.forEach(message => {
-            const type = message.fatal ? "error" : "failure";
-
-            output += `<testcase time="0" name="org.eslint.${message.ruleId || "unknown"}">`;
-            output += `<${type} message="${xmlEscape(message.message || "")}">`;
-            output += "<![CDATA[";
-            output += `line ${message.line || 0}, col `;
-            output += `${message.column || 0}, ${getMessageType(message)}`;
-            output += ` - ${xmlEscape(message.message || "")}`;
-            output += (message.ruleId ? ` (${message.ruleId})` : "");
-            output += "]]>";
-            output += `</${type}>`;
-            output += "</testcase>\n";
-        });
-        output += "</testsuite>\n";
-
-    });
-
-    output += "</testsuites>\n";
-
-    return output;
-};
Index: node_modules/eslint/lib/formatters/table.js
===================================================================
--- node_modules/eslint/lib/formatters/table.js	(revision )
+++ node_modules/eslint/lib/formatters/table.js	(revision )
@@ -1,150 +0,0 @@
-/**
- * @fileoverview "table reporter.
- * @author Gajus Kuizinas <gajus@gajus.com>
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const chalk = require("chalk"),
-    table = require("table").table,
-    pluralize = require("pluralize");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Draws text table.
- * @param {Array<Object>} messages Error messages relating to a specific file.
- * @returns {string} A text table.
- */
-function drawTable(messages) {
-    const rows = [];
-
-    if (messages.length === 0) {
-        return "";
-    }
-
-    rows.push([
-        chalk.bold("Line"),
-        chalk.bold("Column"),
-        chalk.bold("Type"),
-        chalk.bold("Message"),
-        chalk.bold("Rule ID")
-    ]);
-
-    messages.forEach(message => {
-        let messageType;
-
-        if (message.fatal || message.severity === 2) {
-            messageType = chalk.red("error");
-        } else {
-            messageType = chalk.yellow("warning");
-        }
-
-        rows.push([
-            message.line || 0,
-            message.column || 0,
-            messageType,
-            message.message,
-            message.ruleId || ""
-        ]);
-    });
-
-    return table(rows, {
-        columns: {
-            0: {
-                width: 8,
-                wrapWord: true
-            },
-            1: {
-                width: 8,
-                wrapWord: true
-            },
-            2: {
-                width: 8,
-                wrapWord: true
-            },
-            3: {
-                paddingRight: 5,
-                width: 50,
-                wrapWord: true
-            },
-            4: {
-                width: 20,
-                wrapWord: true
-            }
-        },
-        drawHorizontalLine(index) {
-            return index === 1;
-        }
-    });
-}
-
-/**
- * Draws a report (multiple tables).
- * @param {Array} results Report results for every file.
- * @returns {string} A column of text tables.
- */
-function drawReport(results) {
-    let files;
-
-    files = results.map(result => {
-        if (!result.messages.length) {
-            return "";
-        }
-
-        return `\n${result.filePath}\n\n${drawTable(result.messages)}`;
-    });
-
-    files = files.filter(content => content.trim());
-
-    return files.join("");
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(report) {
-    let result,
-        errorCount,
-        warningCount;
-
-    result = "";
-    errorCount = 0;
-    warningCount = 0;
-
-    report.forEach(fileReport => {
-        errorCount += fileReport.errorCount;
-        warningCount += fileReport.warningCount;
-    });
-
-    if (errorCount || warningCount) {
-        result = drawReport(report);
-    }
-
-    result += `\n${table([
-        [
-            chalk.red(pluralize("Error", errorCount, true))
-        ],
-        [
-            chalk.yellow(pluralize("Warning", warningCount, true))
-        ]
-    ], {
-        columns: {
-            0: {
-                width: 110,
-                wrapWord: true
-            }
-        },
-        drawHorizontalLine() {
-            return true;
-        }
-    })}`;
-
-    return result;
-};
Index: node_modules/eslint/lib/formatters/compact.js
===================================================================
--- node_modules/eslint/lib/formatters/compact.js	(revision )
+++ node_modules/eslint/lib/formatters/compact.js	(revision )
@@ -1,60 +0,0 @@
-/**
- * @fileoverview Compact reporter
- * @author Nicholas C. Zakas
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helper Functions
-//------------------------------------------------------------------------------
-
-/**
- * Returns the severity of warning or error
- * @param {Object} message message object to examine
- * @returns {string} severity level
- * @private
- */
-function getMessageType(message) {
-    if (message.fatal || message.severity === 2) {
-        return "Error";
-    }
-    return "Warning";
-
-}
-
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(results) {
-
-    let output = "",
-        total = 0;
-
-    results.forEach(result => {
-
-        const messages = result.messages;
-
-        total += messages.length;
-
-        messages.forEach(message => {
-
-            output += `${result.filePath}: `;
-            output += `line ${message.line || 0}`;
-            output += `, col ${message.column || 0}`;
-            output += `, ${getMessageType(message)}`;
-            output += ` - ${message.message}`;
-            output += message.ruleId ? ` (${message.ruleId})` : "";
-            output += "\n";
-
-        });
-
-    });
-
-    if (total > 0) {
-        output += `\n${total} problem${total !== 1 ? "s" : ""}`;
-    }
-
-    return output;
-};
Index: node_modules/eslint/lib/formatters/stylish.js
===================================================================
--- node_modules/eslint/lib/formatters/stylish.js	(revision )
+++ node_modules/eslint/lib/formatters/stylish.js	(revision )
@@ -1,100 +0,0 @@
-/**
- * @fileoverview Stylish reporter
- * @author Sindre Sorhus
- */
-"use strict";
-
-const chalk = require("chalk"),
-    stripAnsi = require("strip-ansi"),
-    table = require("text-table");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Given a word and a count, append an s if count is not one.
- * @param {string} word A word in its singular form.
- * @param {int} count A number controlling whether word should be pluralized.
- * @returns {string} The original word with an s on the end if count is not one.
- */
-function pluralize(word, count) {
-    return (count === 1 ? word : `${word}s`);
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(results) {
-
-    let output = "\n",
-        errorCount = 0,
-        warningCount = 0,
-        fixableErrorCount = 0,
-        fixableWarningCount = 0,
-        summaryColor = "yellow";
-
-    results.forEach(result => {
-        const messages = result.messages;
-
-        if (messages.length === 0) {
-            return;
-        }
-
-        errorCount += result.errorCount;
-        warningCount += result.warningCount;
-        fixableErrorCount += result.fixableErrorCount;
-        fixableWarningCount += result.fixableWarningCount;
-
-        output += `${chalk.underline(result.filePath)}\n`;
-
-        output += `${table(
-            messages.map(message => {
-                let messageType;
-
-                if (message.fatal || message.severity === 2) {
-                    messageType = chalk.red("error");
-                    summaryColor = "red";
-                } else {
-                    messageType = chalk.yellow("warning");
-                }
-
-                return [
-                    "",
-                    message.line || 0,
-                    message.column || 0,
-                    messageType,
-                    message.message.replace(/([^ ])\.$/, "$1"),
-                    chalk.dim(message.ruleId || "")
-                ];
-            }),
-            {
-                align: ["", "r", "l"],
-                stringLength(str) {
-                    return stripAnsi(str).length;
-                }
-            }
-        ).split("\n").map(el => el.replace(/(\d+)\s+(\d+)/, (m, p1, p2) => chalk.dim(`${p1}:${p2}`))).join("\n")}\n\n`;
-    });
-
-    const total = errorCount + warningCount;
-
-    if (total > 0) {
-        output += chalk[summaryColor].bold([
-            "\u2716 ", total, pluralize(" problem", total),
-            " (", errorCount, pluralize(" error", errorCount), ", ",
-            warningCount, pluralize(" warning", warningCount), ")\n"
-        ].join(""));
-
-        if (fixableErrorCount > 0 || fixableWarningCount > 0) {
-            output += chalk[summaryColor].bold([
-                "  ", fixableErrorCount, pluralize(" error", fixableErrorCount), ", ",
-                fixableWarningCount, pluralize(" warning", fixableWarningCount),
-                " potentially fixable with the `--fix` option.\n"
-            ].join(""));
-        }
-    }
-
-    return total > 0 ? output : "";
-};
Index: node_modules/eslint/lib/formatters/codeframe.js
===================================================================
--- node_modules/eslint/lib/formatters/codeframe.js	(revision )
+++ node_modules/eslint/lib/formatters/codeframe.js	(revision )
@@ -1,138 +0,0 @@
-/**
- * @fileoverview Codeframe reporter
- * @author Vitor Balocco
- */
-"use strict";
-
-const chalk = require("chalk");
-const codeFrame = require("babel-code-frame");
-const path = require("path");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Given a word and a count, append an s if count is not one.
- * @param   {string} word  A word in its singular form.
- * @param   {number} count A number controlling whether word should be pluralized.
- * @returns {string}       The original word with an s on the end if count is not one.
- */
-function pluralize(word, count) {
-    return (count === 1 ? word : `${word}s`);
-}
-
-/**
- * Gets a formatted relative file path from an absolute path and a line/column in the file.
- * @param   {string} filePath The absolute file path to format.
- * @param   {number} line     The line from the file to use for formatting.
- * @param   {number} column   The column from the file to use for formatting.
- * @returns {string}          The formatted file path.
- */
-function formatFilePath(filePath, line, column) {
-    let relPath = path.relative(process.cwd(), filePath);
-
-    if (line && column) {
-        relPath += `:${line}:${column}`;
-    }
-
-    return chalk.green(relPath);
-}
-
-/**
- * Gets the formatted output for a given message.
- * @param   {Object} message      The object that represents this message.
- * @param   {Object} parentResult The result object that this message belongs to.
- * @returns {string}              The formatted output.
- */
-function formatMessage(message, parentResult) {
-    const type = (message.fatal || message.severity === 2) ? chalk.red("error") : chalk.yellow("warning");
-    const msg = `${chalk.bold(message.message.replace(/([^ ])\.$/, "$1"))}`;
-    const ruleId = message.fatal ? "" : chalk.dim(`(${message.ruleId})`);
-    const filePath = formatFilePath(parentResult.filePath, message.line, message.column);
-    const sourceCode = parentResult.output ? parentResult.output : parentResult.source;
-
-    const firstLine = [
-        `${type}:`,
-        `${msg}`,
-        ruleId ? `${ruleId}` : "",
-        sourceCode ? `at ${filePath}:` : `at ${filePath}`
-    ].filter(String).join(" ");
-
-    const result = [firstLine];
-
-    if (sourceCode) {
-        result.push(
-            codeFrame(sourceCode, message.line, message.column, { highlightCode: false })
-        );
-    }
-
-    return result.join("\n");
-}
-
-/**
- * Gets the formatted output summary for a given number of errors and warnings.
- * @param   {number} errors   The number of errors.
- * @param   {number} warnings The number of warnings.
- * @param   {number} fixableErrors The number of fixable errors.
- * @param   {number} fixableWarnings The number of fixable warnings.
- * @returns {string}          The formatted output summary.
- */
-function formatSummary(errors, warnings, fixableErrors, fixableWarnings) {
-    const summaryColor = errors > 0 ? "red" : "yellow";
-    const summary = [];
-    const fixablesSummary = [];
-
-    if (errors > 0) {
-        summary.push(`${errors} ${pluralize("error", errors)}`);
-    }
-
-    if (warnings > 0) {
-        summary.push(`${warnings} ${pluralize("warning", warnings)}`);
-    }
-
-    if (fixableErrors > 0) {
-        fixablesSummary.push(`${fixableErrors} ${pluralize("error", fixableErrors)}`);
-    }
-
-    if (fixableWarnings > 0) {
-        fixablesSummary.push(`${fixableWarnings} ${pluralize("warning", fixableWarnings)}`);
-    }
-
-    let output = chalk[summaryColor].bold(`${summary.join(" and ")} found.`);
-
-    if (fixableErrors || fixableWarnings) {
-        output += chalk[summaryColor].bold(`\n${fixablesSummary.join(" and ")} potentially fixable with the \`--fix\` option.`);
-    }
-
-    return output;
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(results) {
-    let errors = 0;
-    let warnings = 0;
-    let fixableErrors = 0;
-    let fixableWarnings = 0;
-
-    const resultsWithMessages = results.filter(result => result.messages.length > 0);
-
-    let output = resultsWithMessages.reduce((resultsOutput, result) => {
-        const messages = result.messages.map(message => `${formatMessage(message, result)}\n\n`);
-
-        errors += result.errorCount;
-        warnings += result.warningCount;
-        fixableErrors += result.fixableErrorCount;
-        fixableWarnings += result.fixableWarningCount;
-
-        return resultsOutput.concat(messages);
-    }, []).join("\n");
-
-    output += "\n";
-    output += formatSummary(errors, warnings, fixableErrors, fixableWarnings);
-
-    return (errors + warnings) > 0 ? output : "";
-};
Index: node_modules/eslint/lib/formatters/checkstyle.js
===================================================================
--- node_modules/eslint/lib/formatters/checkstyle.js	(revision )
+++ node_modules/eslint/lib/formatters/checkstyle.js	(revision )
@@ -1,60 +0,0 @@
-/**
- * @fileoverview CheckStyle XML reporter
- * @author Ian Christian Myers
- */
-"use strict";
-
-const xmlEscape = require("../util/xml-escape");
-
-//------------------------------------------------------------------------------
-// Helper Functions
-//------------------------------------------------------------------------------
-
-/**
- * Returns the severity of warning or error
- * @param {Object} message message object to examine
- * @returns {string} severity level
- * @private
- */
-function getMessageType(message) {
-    if (message.fatal || message.severity === 2) {
-        return "error";
-    }
-    return "warning";
-
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(results) {
-
-    let output = "";
-
-    output += "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
-    output += "<checkstyle version=\"4.3\">";
-
-    results.forEach(result => {
-        const messages = result.messages;
-
-        output += `<file name="${xmlEscape(result.filePath)}">`;
-
-        messages.forEach(message => {
-            output += [
-                `<error line="${xmlEscape(message.line)}"`,
-                `column="${xmlEscape(message.column)}"`,
-                `severity="${xmlEscape(getMessageType(message))}"`,
-                `message="${xmlEscape(message.message)}${message.ruleId ? ` (${message.ruleId})` : ""}"`,
-                `source="${message.ruleId ? xmlEscape(`eslint.rules.${message.ruleId}`) : ""}" />`
-            ].join(" ");
-        });
-
-        output += "</file>";
-
-    });
-
-    output += "</checkstyle>";
-
-    return output;
-};
Index: node_modules/eslint/lib/formatters/jslint-xml.js
===================================================================
--- node_modules/eslint/lib/formatters/jslint-xml.js	(revision )
+++ node_modules/eslint/lib/formatters/jslint-xml.js	(revision )
@@ -1,41 +0,0 @@
-/**
- * @fileoverview JSLint XML reporter
- * @author Ian Christian Myers
- */
-"use strict";
-
-const xmlEscape = require("../util/xml-escape");
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(results) {
-
-    let output = "";
-
-    output += "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
-    output += "<jslint>";
-
-    results.forEach(result => {
-        const messages = result.messages;
-
-        output += `<file name="${result.filePath}">`;
-
-        messages.forEach(message => {
-            output += [
-                `<issue line="${message.line}"`,
-                `char="${message.column}"`,
-                `evidence="${xmlEscape(message.source || "")}"`,
-                `reason="${xmlEscape(message.message || "")}${message.ruleId ? ` (${message.ruleId})` : ""}" />`
-            ].join(" ");
-        });
-
-        output += "</file>";
-
-    });
-
-    output += "</jslint>";
-
-    return output;
-};
Index: node_modules/eslint/lib/formatters/visualstudio.js
===================================================================
--- node_modules/eslint/lib/formatters/visualstudio.js	(revision )
+++ node_modules/eslint/lib/formatters/visualstudio.js	(revision )
@@ -1,63 +0,0 @@
-/**
- * @fileoverview Visual Studio compatible formatter
- * @author Ronald Pijnacker
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helper Functions
-//------------------------------------------------------------------------------
-
-/**
- * Returns the severity of warning or error
- * @param {Object} message message object to examine
- * @returns {string} severity level
- * @private
- */
-function getMessageType(message) {
-    if (message.fatal || message.severity === 2) {
-        return "error";
-    }
-    return "warning";
-
-}
-
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = function(results) {
-
-    let output = "",
-        total = 0;
-
-    results.forEach(result => {
-
-        const messages = result.messages;
-
-        total += messages.length;
-
-        messages.forEach(message => {
-
-            output += result.filePath;
-            output += `(${message.line || 0}`;
-            output += message.column ? `,${message.column}` : "";
-            output += `): ${getMessageType(message)}`;
-            output += message.ruleId ? ` ${message.ruleId}` : "";
-            output += ` : ${message.message}`;
-            output += "\n";
-
-        });
-
-    });
-
-    if (total === 0) {
-        output += "no problems";
-    } else {
-        output += `\n${total} problem${total !== 1 ? "s" : ""}`;
-    }
-
-    return output;
-};
Index: node_modules/eslint/lib/formatters/html-template-page.html
===================================================================
--- node_modules/eslint/lib/formatters/html-template-page.html	(revision )
+++ node_modules/eslint/lib/formatters/html-template-page.html	(revision )
@@ -1,113 +0,0 @@
-<!DOCTYPE html>
-    <head>
-        <title>ESLint Report</title>
-        <style>
-            body {
-                font-family:Arial, "Helvetica Neue", Helvetica, sans-serif;
-                font-size:16px;
-                font-weight:normal;
-                margin:0;
-                padding:0;
-                color:#333
-            }
-            #overview {
-                padding:20px 30px
-            }
-            td, th {
-                padding:5px 10px
-            }
-            h1 {
-                margin:0
-            }
-            table {
-                margin:30px;
-                width:calc(100% - 60px);
-                max-width:1000px;
-                border-radius:5px;
-                border:1px solid #ddd;
-                border-spacing:0px;
-            }
-            th {
-                font-weight:400;
-                font-size:normal;
-                text-align:left;
-                cursor:pointer
-            }
-            td.clr-1, td.clr-2, th span {
-                font-weight:700
-            }
-            th span {
-                float:right;
-                margin-left:20px
-            }
-            th span:after {
-                content:"";
-                clear:both;
-                display:block
-            }
-            tr:last-child td {
-                border-bottom:none
-            }
-            tr td:first-child, tr td:last-child {
-                color:#9da0a4
-            }
-            #overview.bg-0, tr.bg-0 th {
-                color:#468847;
-                background:#dff0d8;
-                border-bottom:1px solid #d6e9c6
-            }
-            #overview.bg-1, tr.bg-1 th {
-                color:#f0ad4e;
-                background:#fcf8e3;
-                border-bottom:1px solid #fbeed5
-            }
-            #overview.bg-2, tr.bg-2 th {
-                color:#b94a48;
-                background:#f2dede;
-                border-bottom:1px solid #eed3d7
-            }
-            td {
-                border-bottom:1px solid #ddd
-            }
-            td.clr-1 {
-                color:#f0ad4e
-            }
-            td.clr-2 {
-                color:#b94a48
-            }
-            td a {
-                color:#3a33d1;
-                text-decoration:none
-            }
-            td a:hover {
-                color:#272296;
-                text-decoration:underline
-            }
-        </style>
-    </head>
-    <body>
-        <div id="overview" class="bg-<%= reportColor %>">
-            <h1>ESLint Report</h1>
-            <div>
-                <span><%= reportSummary %></span> - Generated on <%= date %>
-            </div>
-        </div>
-        <table>
-            <tbody>
-                <%= results %>
-            </tbody>
-        </table>
-        <script type="text/javascript">
-            var groups = document.querySelectorAll("tr[data-group]");
-            for (i = 0; i < groups.length; i++) {
-                groups[i].addEventListener("click", function() {
-                    var inGroup = document.getElementsByClassName(this.getAttribute("data-group"));
-                    this.innerHTML = (this.innerHTML.indexOf("+") > -1) ? this.innerHTML.replace("+", "-") : this.innerHTML.replace("-", "+");
-                    for (var j = 0; j < inGroup.length; j++) {
-                        inGroup[j].style.display = (inGroup[j].style.display !== "none") ? "none" : "table-row";
-                    }
-                });
-            }
-        </script>
-    </body>
-</html>
Index: node_modules/eslint/lib/formatters/html-template-result.html
===================================================================
--- node_modules/eslint/lib/formatters/html-template-result.html	(revision )
+++ node_modules/eslint/lib/formatters/html-template-result.html	(revision )
@@ -1,6 +0,0 @@
-<tr class="bg-<%- color %>" data-group="f-<%- index %>">
-    <th colspan="4">
-        [+] <%- filePath %>
-        <span><%- summary %></span>
-    </th>
-</tr>
Index: node_modules/eslint/lib/formatters/html-template-message.html
===================================================================
--- node_modules/eslint/lib/formatters/html-template-message.html	(revision )
+++ node_modules/eslint/lib/formatters/html-template-message.html	(revision )
@@ -1,8 +0,0 @@
-<tr style="display:none" class="f-<%= parentIndex %>">
-    <td><%= lineNumber %>:<%= columnNumber %></td>
-    <td class="clr-<%= severityNumber %>"><%= severityName %></td>
-    <td><%- message %></td>
-    <td>
-        <a href="http://eslint.org/docs/rules/<%= ruleId %>" target="_blank"><%= ruleId %></a>
-    </td>
-</tr>
Index: node_modules/eslint/lib/logging.js
===================================================================
--- node_modules/eslint/lib/logging.js	(revision )
+++ node_modules/eslint/lib/logging.js	(revision )
@@ -1,28 +0,0 @@
-/**
- * @fileoverview Handle logging for ESLint
- * @author Gyandeep Singh
- */
-
-"use strict";
-
-/* eslint no-console: "off" */
-
-/* istanbul ignore next */
-module.exports = {
-
-    /**
-     * Cover for console.log
-     * @returns {void}
-     */
-    info() {
-        console.log.apply(console, Array.prototype.slice.call(arguments));
-    },
-
-    /**
-     * Cover for console.error
-     * @returns {void}
-     */
-    error() {
-        console.error.apply(console, Array.prototype.slice.call(arguments));
-    }
-};
Index: node_modules/eslint/lib/options.js
===================================================================
--- node_modules/eslint/lib/options.js	(revision )
+++ node_modules/eslint/lib/options.js	(revision )
@@ -1,223 +0,0 @@
-/**
- * @fileoverview Options configuration for optionator.
- * @author George Zahariev
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const optionator = require("optionator");
-
-//------------------------------------------------------------------------------
-// Initialization and Public Interface
-//------------------------------------------------------------------------------
-
-// exports "parse(args)", "generateHelp()", and "generateHelpForOption(optionName)"
-module.exports = optionator({
-    prepend: "eslint [options] file.js [file.js] [dir]",
-    defaults: {
-        concatRepeatedArrays: true,
-        mergeRepeatedObjects: true
-    },
-    options: [
-        {
-            heading: "Basic configuration"
-        },
-        {
-            option: "config",
-            alias: "c",
-            type: "path::String",
-            description: "Use configuration from this file or shareable config"
-        },
-        {
-            option: "eslintrc",
-            type: "Boolean",
-            default: "true",
-            description: "Disable use of configuration from .eslintrc"
-        },
-        {
-            option: "env",
-            type: "[String]",
-            description: "Specify environments"
-        },
-        {
-            option: "ext",
-            type: "[String]",
-            default: ".js",
-            description: "Specify JavaScript file extensions"
-        },
-        {
-            option: "global",
-            type: "[String]",
-            description: "Define global variables"
-        },
-        {
-            option: "parser",
-            type: "String",
-            description: "Specify the parser to be used"
-        },
-        {
-            option: "parser-options",
-            type: "Object",
-            description: "Specify parser options"
-        },
-        {
-            heading: "Caching"
-        },
-        {
-            option: "cache",
-            type: "Boolean",
-            default: "false",
-            description: "Only check changed files"
-        },
-        {
-            option: "cache-file",
-            type: "path::String",
-            default: ".eslintcache",
-            description: "Path to the cache file. Deprecated: use --cache-location"
-        },
-        {
-            option: "cache-location",
-            type: "path::String",
-            description: "Path to the cache file or directory"
-        },
-        {
-            heading: "Specifying rules and plugins"
-        },
-        {
-            option: "rulesdir",
-            type: "[path::String]",
-            description: "Use additional rules from this directory"
-        },
-        {
-            option: "plugin",
-            type: "[String]",
-            description: "Specify plugins"
-        },
-        {
-            option: "rule",
-            type: "Object",
-            description: "Specify rules"
-        },
-        {
-            heading: "Ignoring files"
-        },
-        {
-            option: "ignore-path",
-            type: "path::String",
-            description: "Specify path of ignore file"
-        },
-        {
-            option: "ignore",
-            type: "Boolean",
-            default: "true",
-            description: "Disable use of ignore files and patterns"
-        },
-        {
-            option: "ignore-pattern",
-            type: "[String]",
-            description: "Pattern of files to ignore (in addition to those in .eslintignore)",
-            concatRepeatedArrays: [true, {
-                oneValuePerFlag: true
-            }]
-        },
-        {
-            heading: "Using stdin"
-        },
-        {
-            option: "stdin",
-            type: "Boolean",
-            default: "false",
-            description: "Lint code provided on <STDIN>"
-        },
-        {
-            option: "stdin-filename",
-            type: "String",
-            description: "Specify filename to process STDIN as"
-        },
-        {
-            heading: "Handling warnings"
-        },
-        {
-            option: "quiet",
-            type: "Boolean",
-            default: "false",
-            description: "Report errors only"
-        },
-        {
-            option: "max-warnings",
-            type: "Int",
-            default: "-1",
-            description: "Number of warnings to trigger nonzero exit code"
-        },
-        {
-            heading: "Output"
-        },
-        {
-            option: "output-file",
-            alias: "o",
-            type: "path::String",
-            description: "Specify file to write report to"
-        },
-        {
-            option: "format",
-            alias: "f",
-            type: "String",
-            default: "stylish",
-            description: "Use a specific output format"
-        },
-        {
-            option: "color",
-            type: "Boolean",
-            alias: "no-color",
-            description: "Force enabling/disabling of color"
-        },
-        {
-            heading: "Miscellaneous"
-        },
-        {
-            option: "init",
-            type: "Boolean",
-            default: "false",
-            description: "Run config initialization wizard"
-        },
-        {
-            option: "fix",
-            type: "Boolean",
-            default: false,
-            description: "Automatically fix problems"
-        },
-        {
-            option: "debug",
-            type: "Boolean",
-            default: false,
-            description: "Output debugging information"
-        },
-        {
-            option: "help",
-            alias: "h",
-            type: "Boolean",
-            description: "Show help"
-        },
-        {
-            option: "version",
-            alias: "v",
-            type: "Boolean",
-            description: "Output the version number"
-        },
-        {
-            option: "inline-config",
-            type: "Boolean",
-            default: "true",
-            description: "Prevent comments from changing config or rules"
-        },
-        {
-            option: "print-config",
-            type: "path::String",
-            description: "Print the configuration for the given file"
-        }
-    ]
-});
Index: node_modules/eslint/lib/token-store/index.js
===================================================================
--- node_modules/eslint/lib/token-store/index.js	(revision )
+++ node_modules/eslint/lib/token-store/index.js	(revision )
@@ -1,633 +0,0 @@
-/**
- * @fileoverview Object to handle access and retrieval of tokens.
- * @author Brandon Mills
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const assert = require("assert");
-const cursors = require("./cursors");
-const ForwardTokenCursor = require("./forward-token-cursor");
-const PaddedTokenCursor = require("./padded-token-cursor");
-const utils = require("./utils");
-const astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const TOKENS = Symbol("tokens");
-const COMMENTS = Symbol("comments");
-const INDEX_MAP = Symbol("indexMap");
-
-/**
- * Creates the map from locations to indices in `tokens`.
- *
- * The first/last location of tokens is mapped to the index of the token.
- * The first/last location of comments is mapped to the index of the next token of each comment.
- *
- * @param {Token[]} tokens - The array of tokens.
- * @param {Comment[]} comments - The array of comments.
- * @returns {Object} The map from locations to indices in `tokens`.
- * @private
- */
-function createIndexMap(tokens, comments) {
-    const map = Object.create(null);
-    let tokenIndex = 0;
-    let commentIndex = 0;
-    let nextStart = 0;
-    let range = null;
-
-    while (tokenIndex < tokens.length || commentIndex < comments.length) {
-        nextStart = (commentIndex < comments.length) ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;
-        while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {
-            map[range[0]] = tokenIndex;
-            map[range[1] - 1] = tokenIndex;
-            tokenIndex += 1;
-        }
-
-        nextStart = (tokenIndex < tokens.length) ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;
-        while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {
-            map[range[0]] = tokenIndex;
-            map[range[1] - 1] = tokenIndex;
-            commentIndex += 1;
-        }
-    }
-
-    return map;
-}
-
-/**
- * Creates the cursor iterates tokens with options.
- *
- * @param {CursorFactory} factory - The cursor factory to initialize cursor.
- * @param {Token[]} tokens - The array of tokens.
- * @param {Comment[]} comments - The array of comments.
- * @param {Object} indexMap - The map from locations to indices in `tokens`.
- * @param {number} startLoc - The start location of the iteration range.
- * @param {number} endLoc - The end location of the iteration range.
- * @param {number|Function|Object} [opts=0] - The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.
- * @param {boolean} [opts.includeComments=false] - The flag to iterate comments as well.
- * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.
- * @param {number} [opts.skip=0] - The count of tokens the cursor skips.
- * @returns {Cursor} The created cursor.
- * @private
- */
-function createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
-    let includeComments = false;
-    let skip = 0;
-    let filter = null;
-
-    if (typeof opts === "number") {
-        skip = opts | 0;
-    } else if (typeof opts === "function") {
-        filter = opts;
-    } else if (opts) {
-        includeComments = !!opts.includeComments;
-        skip = opts.skip | 0;
-        filter = opts.filter || null;
-    }
-    assert(skip >= 0, "options.skip should be zero or a positive integer.");
-    assert(!filter || typeof filter === "function", "options.filter should be a function.");
-
-    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);
-}
-
-/**
- * Creates the cursor iterates tokens with options.
- *
- * @param {CursorFactory} factory - The cursor factory to initialize cursor.
- * @param {Token[]} tokens - The array of tokens.
- * @param {Comment[]} comments - The array of comments.
- * @param {Object} indexMap - The map from locations to indices in `tokens`.
- * @param {number} startLoc - The start location of the iteration range.
- * @param {number} endLoc - The end location of the iteration range.
- * @param {number|Function|Object} [opts=0] - The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.
- * @param {boolean} [opts.includeComments] - The flag to iterate comments as well.
- * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.
- * @param {number} [opts.count=0] - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.
- * @returns {Cursor} The created cursor.
- * @private
- */
-function createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
-    let includeComments = false;
-    let count = 0;
-    let countExists = false;
-    let filter = null;
-
-    if (typeof opts === "number") {
-        count = opts | 0;
-        countExists = true;
-    } else if (typeof opts === "function") {
-        filter = opts;
-    } else if (opts) {
-        includeComments = !!opts.includeComments;
-        count = opts.count | 0;
-        countExists = typeof opts.count === "number";
-        filter = opts.filter || null;
-    }
-    assert(count >= 0, "options.count should be zero or a positive integer.");
-    assert(!filter || typeof filter === "function", "options.filter should be a function.");
-
-    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);
-}
-
-/**
- * Creates the cursor iterates tokens with options.
- * This is overload function of the below.
- *
- * @param {Token[]} tokens - The array of tokens.
- * @param {Comment[]} comments - The array of comments.
- * @param {Object} indexMap - The map from locations to indices in `tokens`.
- * @param {number} startLoc - The start location of the iteration range.
- * @param {number} endLoc - The end location of the iteration range.
- * @param {Function|Object} opts - The option object. If this is a function then it's `opts.filter`.
- * @param {boolean} [opts.includeComments] - The flag to iterate comments as well.
- * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.
- * @param {number} [opts.count=0] - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.
- * @returns {Cursor} The created cursor.
- * @private
- */
-/**
- * Creates the cursor iterates tokens with options.
- *
- * @param {Token[]} tokens - The array of tokens.
- * @param {Comment[]} comments - The array of comments.
- * @param {Object} indexMap - The map from locations to indices in `tokens`.
- * @param {number} startLoc - The start location of the iteration range.
- * @param {number} endLoc - The end location of the iteration range.
- * @param {number} [beforeCount=0] - The number of tokens before the node to retrieve.
- * @param {boolean} [afterCount=0] - The number of tokens after the node to retrieve.
- * @returns {Cursor} The created cursor.
- * @private
- */
-function createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
-    if (typeof beforeCount === "undefined" && typeof afterCount === "undefined") {
-        return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);
-    }
-    if (typeof beforeCount === "number" || typeof beforeCount === "undefined") {
-        return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);
-    }
-    return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);
-}
-
-/**
- * Gets comment tokens that are adjacent to the current cursor position.
- * @param {Cursor} cursor - A cursor instance.
- * @returns {Array} An array of comment tokens adjacent to the current cursor position.
- * @private
- */
-function getAdjacentCommentTokensFromCursor(cursor) {
-    const tokens = [];
-    let currentToken = cursor.getOneToken();
-
-    while (currentToken && astUtils.isCommentToken(currentToken)) {
-        tokens.push(currentToken);
-        currentToken = cursor.getOneToken();
-    }
-
-    return tokens;
-}
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * The token store.
- *
- * This class provides methods to get tokens by locations as fast as possible.
- * The methods are a part of public API, so we should be careful if it changes this class.
- *
- * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.
- * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.
- * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.
- * This uses binary-searching instead for comments.
- */
-module.exports = class TokenStore {
-
-    /**
-     * Initializes this token store.
-     * @param {Token[]} tokens - The array of tokens.
-     * @param {Comment[]} comments - The array of comments.
-     */
-    constructor(tokens, comments) {
-        this[TOKENS] = tokens;
-        this[COMMENTS] = comments;
-        this[INDEX_MAP] = createIndexMap(tokens, comments);
-    }
-
-    //--------------------------------------------------------------------------
-    // Gets single token.
-    //--------------------------------------------------------------------------
-
-    /**
-     * Gets the token starting at the specified index.
-     * @param {number} offset - Index of the start of the token's range.
-     * @param {Object} [options=0] - The option object.
-     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.
-     * @returns {Token|null} The token starting at index, or null if no such token.
-     */
-    getTokenByRangeStart(offset, options) {
-        const includeComments = options && options.includeComments;
-        const token = cursors.forward.createBaseCursor(
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            offset,
-            -1,
-            includeComments
-        ).getOneToken();
-
-        if (token && token.range[0] === offset) {
-            return token;
-        }
-        return null;
-    }
-
-    /**
-     * Gets the first token of the given node.
-     * @param {ASTNode} node - The AST node.
-     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.
-     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.
-     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.
-     * @param {number} [options.skip=0] - The count of tokens the cursor skips.
-     * @returns {Token|null} An object representing the token.
-     */
-    getFirstToken(node, options) {
-        return createCursorWithSkip(
-            cursors.forward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            node.range[0],
-            node.range[1],
-            options
-        ).getOneToken();
-    }
-
-    /**
-     * Gets the last token of the given node.
-     * @param {ASTNode} node - The AST node.
-     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()
-     * @returns {Token|null} An object representing the token.
-     */
-    getLastToken(node, options) {
-        return createCursorWithSkip(
-            cursors.backward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            node.range[0],
-            node.range[1],
-            options
-        ).getOneToken();
-    }
-
-    /**
-     * Gets the token that precedes a given node or token.
-     * @param {ASTNode|Token|Comment} node - The AST node or token.
-     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()
-     * @returns {Token|null} An object representing the token.
-     */
-    getTokenBefore(node, options) {
-        return createCursorWithSkip(
-            cursors.backward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            -1,
-            node.range[0],
-            options
-        ).getOneToken();
-    }
-
-    /**
-     * Gets the token that follows a given node or token.
-     * @param {ASTNode|Token|Comment} node - The AST node or token.
-     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()
-     * @returns {Token|null} An object representing the token.
-     */
-    getTokenAfter(node, options) {
-        return createCursorWithSkip(
-            cursors.forward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            node.range[1],
-            -1,
-            options
-        ).getOneToken();
-    }
-
-    /**
-     * Gets the first token between two non-overlapping nodes.
-     * @param {ASTNode|Token|Comment} left - Node before the desired token range.
-     * @param {ASTNode|Token|Comment} right - Node after the desired token range.
-     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()
-     * @returns {Token|null} An object representing the token.
-     */
-    getFirstTokenBetween(left, right, options) {
-        return createCursorWithSkip(
-            cursors.forward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            left.range[1],
-            right.range[0],
-            options
-        ).getOneToken();
-    }
-
-    /**
-     * Gets the last token between two non-overlapping nodes.
-     * @param {ASTNode|Token|Comment} left Node before the desired token range.
-     * @param {ASTNode|Token|Comment} right Node after the desired token range.
-     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()
-     * @returns {Token|null} An object representing the token.
-     */
-    getLastTokenBetween(left, right, options) {
-        return createCursorWithSkip(
-            cursors.backward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            left.range[1],
-            right.range[0],
-            options
-        ).getOneToken();
-    }
-
-    /**
-     * Gets the token that precedes a given node or token in the token stream.
-     * This is defined for backward compatibility. Use `includeComments` option instead.
-     * TODO: We have a plan to remove this in a future major version.
-     * @param {ASTNode|Token|Comment} node The AST node or token.
-     * @param {number} [skip=0] A number of tokens to skip.
-     * @returns {Token|null} An object representing the token.
-     * @deprecated
-     */
-    getTokenOrCommentBefore(node, skip) {
-        return this.getTokenBefore(node, { includeComments: true, skip });
-    }
-
-    /**
-     * Gets the token that follows a given node or token in the token stream.
-     * This is defined for backward compatibility. Use `includeComments` option instead.
-     * TODO: We have a plan to remove this in a future major version.
-     * @param {ASTNode|Token|Comment} node The AST node or token.
-     * @param {number} [skip=0] A number of tokens to skip.
-     * @returns {Token|null} An object representing the token.
-     * @deprecated
-     */
-    getTokenOrCommentAfter(node, skip) {
-        return this.getTokenAfter(node, { includeComments: true, skip });
-    }
-
-    //--------------------------------------------------------------------------
-    // Gets multiple tokens.
-    //--------------------------------------------------------------------------
-
-    /**
-     * Gets the first `count` tokens of the given node.
-     * @param {ASTNode} node - The AST node.
-     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.
-     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.
-     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.
-     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.
-     * @returns {Token[]} Tokens.
-     */
-    getFirstTokens(node, options) {
-        return createCursorWithCount(
-            cursors.forward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            node.range[0],
-            node.range[1],
-            options
-        ).getAllTokens();
-    }
-
-    /**
-     * Gets the last `count` tokens of the given node.
-     * @param {ASTNode} node - The AST node.
-     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()
-     * @returns {Token[]} Tokens.
-     */
-    getLastTokens(node, options) {
-        return createCursorWithCount(
-            cursors.backward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            node.range[0],
-            node.range[1],
-            options
-        ).getAllTokens().reverse();
-    }
-
-    /**
-     * Gets the `count` tokens that precedes a given node or token.
-     * @param {ASTNode|Token|Comment} node - The AST node or token.
-     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()
-     * @returns {Token[]} Tokens.
-     */
-    getTokensBefore(node, options) {
-        return createCursorWithCount(
-            cursors.backward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            -1,
-            node.range[0],
-            options
-        ).getAllTokens().reverse();
-    }
-
-    /**
-     * Gets the `count` tokens that follows a given node or token.
-     * @param {ASTNode|Token|Comment} node - The AST node or token.
-     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()
-     * @returns {Token[]} Tokens.
-     */
-    getTokensAfter(node, options) {
-        return createCursorWithCount(
-            cursors.forward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            node.range[1],
-            -1,
-            options
-        ).getAllTokens();
-    }
-
-    /**
-     * Gets the first `count` tokens between two non-overlapping nodes.
-     * @param {ASTNode|Token|Comment} left - Node before the desired token range.
-     * @param {ASTNode|Token|Comment} right - Node after the desired token range.
-     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()
-     * @returns {Token[]} Tokens between left and right.
-     */
-    getFirstTokensBetween(left, right, options) {
-        return createCursorWithCount(
-            cursors.forward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            left.range[1],
-            right.range[0],
-            options
-        ).getAllTokens();
-    }
-
-    /**
-     * Gets the last `count` tokens between two non-overlapping nodes.
-     * @param {ASTNode|Token|Comment} left Node before the desired token range.
-     * @param {ASTNode|Token|Comment} right Node after the desired token range.
-     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()
-     * @returns {Token[]} Tokens between left and right.
-     */
-    getLastTokensBetween(left, right, options) {
-        return createCursorWithCount(
-            cursors.backward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            left.range[1],
-            right.range[0],
-            options
-        ).getAllTokens().reverse();
-    }
-
-    /**
-     * Gets all tokens that are related to the given node.
-     * @param {ASTNode} node - The AST node.
-     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.
-     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.
-     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.
-     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.
-     * @returns {Token[]} Array of objects representing tokens.
-     */
-    /**
-     * Gets all tokens that are related to the given node.
-     * @param {ASTNode} node - The AST node.
-     * @param {int} [beforeCount=0] - The number of tokens before the node to retrieve.
-     * @param {int} [afterCount=0] - The number of tokens after the node to retrieve.
-     * @returns {Token[]} Array of objects representing tokens.
-     */
-    getTokens(node, beforeCount, afterCount) {
-        return createCursorWithPadding(
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            node.range[0],
-            node.range[1],
-            beforeCount,
-            afterCount
-        ).getAllTokens();
-    }
-
-    /**
-     * Gets all of the tokens between two non-overlapping nodes.
-     * @param {ASTNode|Token|Comment} left Node before the desired token range.
-     * @param {ASTNode|Token|Comment} right Node after the desired token range.
-     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.
-     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.
-     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.
-     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.
-     * @returns {Token[]} Tokens between left and right.
-     */
-    /**
-     * Gets all of the tokens between two non-overlapping nodes.
-     * @param {ASTNode|Token|Comment} left Node before the desired token range.
-     * @param {ASTNode|Token|Comment} right Node after the desired token range.
-     * @param {int} [padding=0] Number of extra tokens on either side of center.
-     * @returns {Token[]} Tokens between left and right.
-     */
-    getTokensBetween(left, right, padding) {
-        return createCursorWithPadding(
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            left.range[1],
-            right.range[0],
-            padding,
-            padding
-        ).getAllTokens();
-    }
-
-    //--------------------------------------------------------------------------
-    // Others.
-    //--------------------------------------------------------------------------
-
-    /**
-     * Checks whether any comments exist or not between the given 2 nodes.
-     *
-     * @param {ASTNode} left - The node to check.
-     * @param {ASTNode} right - The node to check.
-     * @returns {boolean} `true` if one or more comments exist.
-     */
-    commentsExistBetween(left, right) {
-        const index = utils.search(this[COMMENTS], left.range[1]);
-
-        return (
-            index < this[COMMENTS].length &&
-            this[COMMENTS][index].range[1] <= right.range[0]
-        );
-    }
-
-    /**
-     * Gets all comment tokens directly before the given node or token.
-     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.
-     * @returns {Array} An array of comments in occurrence order.
-     */
-    getCommentsBefore(nodeOrToken) {
-        const cursor = createCursorWithCount(
-            cursors.backward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            -1,
-            nodeOrToken.range[0],
-            { includeComments: true }
-        );
-
-        return getAdjacentCommentTokensFromCursor(cursor).reverse();
-    }
-
-    /**
-     * Gets all comment tokens directly after the given node or token.
-     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.
-     * @returns {Array} An array of comments in occurrence order.
-     */
-    getCommentsAfter(nodeOrToken) {
-        const cursor = createCursorWithCount(
-            cursors.forward,
-            this[TOKENS],
-            this[COMMENTS],
-            this[INDEX_MAP],
-            nodeOrToken.range[1],
-            -1,
-            { includeComments: true }
-        );
-
-        return getAdjacentCommentTokensFromCursor(cursor);
-    }
-
-    /**
-     * Gets all comment tokens inside the given node.
-     * @param {ASTNode} node The AST node to get the comments for.
-     * @returns {Array} An array of comments in occurrence order.
-     */
-    getCommentsInside(node) {
-        return this.getTokens(node, {
-            includeComments: true,
-            filter: astUtils.isCommentToken
-        });
-    }
-};
Index: node_modules/eslint/lib/token-store/utils.js
===================================================================
--- node_modules/eslint/lib/token-store/utils.js	(revision )
+++ node_modules/eslint/lib/token-store/utils.js	(revision )
@@ -1,100 +0,0 @@
-/**
- * @fileoverview Define utilify functions for token store.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const lodash = require("lodash");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Gets `token.range[0]` from the given token.
- *
- * @param {Node|Token|Comment} token - The token to get.
- * @returns {number} The start location.
- * @private
- */
-function getStartLocation(token) {
-    return token.range[0];
-}
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * Binary-searches the index of the first token which is after the given location.
- * If it was not found, this returns `tokens.length`.
- *
- * @param {(Token|Comment)[]} tokens - It searches the token in this list.
- * @param {number} location - The location to search.
- * @returns {number} The found index or `tokens.length`.
- */
-exports.search = function search(tokens, location) {
-    return lodash.sortedIndexBy(
-        tokens,
-        { range: [location] },
-        getStartLocation
-    );
-};
-
-/**
- * Gets the index of the `startLoc` in `tokens`.
- * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.
- *
- * @param {(Token|Comment)[]} tokens - The tokens to find an index.
- * @param {Object} indexMap - The map from locations to indices.
- * @param {number} startLoc - The location to get an index.
- * @returns {number} The index.
- */
-exports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {
-    if (startLoc in indexMap) {
-        return indexMap[startLoc];
-    }
-    if ((startLoc - 1) in indexMap) {
-        const index = indexMap[startLoc - 1];
-        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;
-
-        // For the map of "comment's location -> token's index", it points the next token of a comment.
-        // In that case, +1 is unnecessary.
-        if (token && token.range[0] >= startLoc) {
-            return index;
-        }
-        return index + 1;
-    }
-    return 0;
-};
-
-/**
- * Gets the index of the `endLoc` in `tokens`.
- * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.
- *
- * @param {(Token|Comment)[]} tokens - The tokens to find an index.
- * @param {Object} indexMap - The map from locations to indices.
- * @param {number} endLoc - The location to get an index.
- * @returns {number} The index.
- */
-exports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {
-    if (endLoc in indexMap) {
-        return indexMap[endLoc] - 1;
-    }
-    if ((endLoc - 1) in indexMap) {
-        const index = indexMap[endLoc - 1];
-        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;
-
-        // For the map of "comment's location -> token's index", it points the next token of a comment.
-        // In that case, -1 is necessary.
-        if (token && token.range[1] > endLoc) {
-            return index - 1;
-        }
-        return index;
-    }
-    return tokens.length - 1;
-};
Index: node_modules/eslint/lib/token-store/cursor.js
===================================================================
--- node_modules/eslint/lib/token-store/cursor.js	(revision )
+++ node_modules/eslint/lib/token-store/cursor.js	(revision )
@@ -1,76 +0,0 @@
-/**
- * @fileoverview Define the abstract class about cursors which iterate tokens.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * The abstract class about cursors which iterate tokens.
- *
- * This class has 2 abstract methods.
- *
- * - `current: Token | Comment | null` ... The current token.
- * - `moveNext(): boolean` ... Moves this cursor to the next token. If the next token didn't exist, it returns `false`.
- *
- * This is similar to ES2015 Iterators.
- * However, Iterators were slow (at 2017-01), so I created this class as similar to C# IEnumerable.
- *
- * There are the following known sub classes.
- *
- * - ForwardTokenCursor .......... The cursor which iterates tokens only.
- * - BackwardTokenCursor ......... The cursor which iterates tokens only in reverse.
- * - ForwardTokenCommentCursor ... The cursor which iterates tokens and comments.
- * - BackwardTokenCommentCursor .. The cursor which iterates tokens and comments in reverse.
- * - DecorativeCursor
- *     - FilterCursor ............ The cursor which ignores the specified tokens.
- *     - SkipCursor .............. The cursor which ignores the first few tokens.
- *     - LimitCursor ............. The cursor which limits the count of tokens.
- *
- */
-module.exports = class Cursor {
-
-    /**
-     * Initializes this cursor.
-     */
-    constructor() {
-        this.current = null;
-    }
-
-    /**
-     * Gets the first token.
-     * This consumes this cursor.
-     * @returns {Token|Comment} The first token or null.
-     */
-    getOneToken() {
-        return this.moveNext() ? this.current : null;
-    }
-
-    /**
-     * Gets the first tokens.
-     * This consumes this cursor.
-     * @returns {(Token|Comment)[]} All tokens.
-     */
-    getAllTokens() {
-        const tokens = [];
-
-        while (this.moveNext()) {
-            tokens.push(this.current);
-        }
-
-        return tokens;
-    }
-
-    /**
-     * Moves this cursor to the next token.
-     * @returns {boolean} `true` if the next token exists.
-     * @abstract
-     */
-    /* istanbul ignore next */
-    moveNext() { // eslint-disable-line class-methods-use-this
-        throw new Error("Not implemented.");
-    }
-};
Index: node_modules/eslint/lib/token-store/cursors.js
===================================================================
--- node_modules/eslint/lib/token-store/cursors.js	(revision )
+++ node_modules/eslint/lib/token-store/cursors.js	(revision )
@@ -1,92 +0,0 @@
-/**
- * @fileoverview Define 2 token factories; forward and backward.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const BackwardTokenCommentCursor = require("./backward-token-comment-cursor");
-const BackwardTokenCursor = require("./backward-token-cursor");
-const FilterCursor = require("./filter-cursor");
-const ForwardTokenCommentCursor = require("./forward-token-comment-cursor");
-const ForwardTokenCursor = require("./forward-token-cursor");
-const LimitCursor = require("./limit-cursor");
-const SkipCursor = require("./skip-cursor");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * The cursor factory.
- * @private
- */
-class CursorFactory {
-
-    /**
-     * Initializes this cursor.
-     * @param {Function} TokenCursor - The class of the cursor which iterates tokens only.
-     * @param {Function} TokenCommentCursor - The class of the cursor which iterates the mix of tokens and comments.
-     */
-    constructor(TokenCursor, TokenCommentCursor) {
-        this.TokenCursor = TokenCursor;
-        this.TokenCommentCursor = TokenCommentCursor;
-    }
-
-    /**
-     * Creates a base cursor instance that can be decorated by createCursor.
-     *
-     * @param {Token[]} tokens - The array of tokens.
-     * @param {Comment[]} comments - The array of comments.
-     * @param {Object} indexMap - The map from locations to indices in `tokens`.
-     * @param {number} startLoc - The start location of the iteration range.
-     * @param {number} endLoc - The end location of the iteration range.
-     * @param {boolean} includeComments - The flag to iterate comments as well.
-     * @returns {Cursor} The created base cursor.
-     */
-    createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {
-        const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;
-
-        return new Cursor(tokens, comments, indexMap, startLoc, endLoc);
-    }
-
-    /**
-     * Creates a cursor that iterates tokens with normalized options.
-     *
-     * @param {Token[]} tokens - The array of tokens.
-     * @param {Comment[]} comments - The array of comments.
-     * @param {Object} indexMap - The map from locations to indices in `tokens`.
-     * @param {number} startLoc - The start location of the iteration range.
-     * @param {number} endLoc - The end location of the iteration range.
-     * @param {boolean} includeComments - The flag to iterate comments as well.
-     * @param {Function|null} filter - The predicate function to choose tokens.
-     * @param {number} skip - The count of tokens the cursor skips.
-     * @param {number} count - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.
-     * @returns {Cursor} The created cursor.
-     */
-    createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {
-        let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);
-
-        if (filter) {
-            cursor = new FilterCursor(cursor, filter);
-        }
-        if (skip >= 1) {
-            cursor = new SkipCursor(cursor, skip);
-        }
-        if (count >= 0) {
-            cursor = new LimitCursor(cursor, count);
-        }
-
-        return cursor;
-    }
-}
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-exports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);
-exports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);
Index: node_modules/eslint/lib/token-store/skip-cursor.js
===================================================================
--- node_modules/eslint/lib/token-store/skip-cursor.js	(revision )
+++ node_modules/eslint/lib/token-store/skip-cursor.js	(revision )
@@ -1,42 +0,0 @@
-/**
- * @fileoverview Define the cursor which ignores the first few tokens.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const DecorativeCursor = require("./decorative-cursor");
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * The decorative cursor which ignores the first few tokens.
- */
-module.exports = class SkipCursor extends DecorativeCursor {
-
-    /**
-     * Initializes this cursor.
-     * @param {Cursor} cursor - The cursor to be decorated.
-     * @param {number} count - The count of tokens this cursor skips.
-     */
-    constructor(cursor, count) {
-        super(cursor);
-        this.count = count;
-    }
-
-    /** @inheritdoc */
-    moveNext() {
-        while (this.count > 0) {
-            this.count -= 1;
-            if (!super.moveNext()) {
-                return false;
-            }
-        }
-        return super.moveNext();
-    }
-};
Index: node_modules/eslint/lib/token-store/limit-cursor.js
===================================================================
--- node_modules/eslint/lib/token-store/limit-cursor.js	(revision )
+++ node_modules/eslint/lib/token-store/limit-cursor.js	(revision )
@@ -1,40 +0,0 @@
-/**
- * @fileoverview Define the cursor which limits the number of tokens.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const DecorativeCursor = require("./decorative-cursor");
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * The decorative cursor which limits the number of tokens.
- */
-module.exports = class LimitCursor extends DecorativeCursor {
-
-    /**
-     * Initializes this cursor.
-     * @param {Cursor} cursor - The cursor to be decorated.
-     * @param {number} count - The count of tokens this cursor iterates.
-     */
-    constructor(cursor, count) {
-        super(cursor);
-        this.count = count;
-    }
-
-    /** @inheritdoc */
-    moveNext() {
-        if (this.count > 0) {
-            this.count -= 1;
-            return super.moveNext();
-        }
-        return false;
-    }
-};
Index: node_modules/eslint/lib/token-store/filter-cursor.js
===================================================================
--- node_modules/eslint/lib/token-store/filter-cursor.js	(revision )
+++ node_modules/eslint/lib/token-store/filter-cursor.js	(revision )
@@ -1,43 +0,0 @@
-/**
- * @fileoverview Define the cursor which ignores specified tokens.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const DecorativeCursor = require("./decorative-cursor");
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * The decorative cursor which ignores specified tokens.
- */
-module.exports = class FilterCursor extends DecorativeCursor {
-
-    /**
-     * Initializes this cursor.
-     * @param {Cursor} cursor - The cursor to be decorated.
-     * @param {Function} predicate - The predicate function to decide tokens this cursor iterates.
-     */
-    constructor(cursor, predicate) {
-        super(cursor);
-        this.predicate = predicate;
-    }
-
-    /** @inheritdoc */
-    moveNext() {
-        const predicate = this.predicate;
-
-        while (super.moveNext()) {
-            if (predicate(this.current)) {
-                return true;
-            }
-        }
-        return false;
-    }
-};
Index: node_modules/eslint/lib/token-store/decorative-cursor.js
===================================================================
--- node_modules/eslint/lib/token-store/decorative-cursor.js	(revision )
+++ node_modules/eslint/lib/token-store/decorative-cursor.js	(revision )
@@ -1,39 +0,0 @@
-/**
- * @fileoverview Define the abstract class about cursors which manipulate another cursor.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const Cursor = require("./cursor");
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * The abstract class about cursors which manipulate another cursor.
- */
-module.exports = class DecorativeCursor extends Cursor {
-
-    /**
-     * Initializes this cursor.
-     * @param {Cursor} cursor - The cursor to be decorated.
-     */
-    constructor(cursor) {
-        super();
-        this.cursor = cursor;
-    }
-
-    /** @inheritdoc */
-    moveNext() {
-        const retv = this.cursor.moveNext();
-
-        this.current = this.cursor.current;
-
-        return retv;
-    }
-};
Index: node_modules/eslint/lib/token-store/padded-token-cursor.js
===================================================================
--- node_modules/eslint/lib/token-store/padded-token-cursor.js	(revision )
+++ node_modules/eslint/lib/token-store/padded-token-cursor.js	(revision )
@@ -1,38 +0,0 @@
-/**
- * @fileoverview Define the cursor which iterates tokens only, with inflated range.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const ForwardTokenCursor = require("./forward-token-cursor");
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * The cursor which iterates tokens only, with inflated range.
- * This is for the backward compatibility of padding options.
- */
-module.exports = class PaddedTokenCursor extends ForwardTokenCursor {
-
-    /**
-     * Initializes this cursor.
-     * @param {Token[]} tokens - The array of tokens.
-     * @param {Comment[]} comments - The array of comments.
-     * @param {Object} indexMap - The map from locations to indices in `tokens`.
-     * @param {number} startLoc - The start location of the iteration range.
-     * @param {number} endLoc - The end location of the iteration range.
-     * @param {number} beforeCount - The number of tokens this cursor iterates before start.
-     * @param {number} afterCount - The number of tokens this cursor iterates after end.
-     */
-    constructor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
-        super(tokens, comments, indexMap, startLoc, endLoc);
-        this.index = Math.max(0, this.index - beforeCount);
-        this.indexEnd = Math.min(tokens.length - 1, this.indexEnd + afterCount);
-    }
-};
Index: node_modules/eslint/lib/token-store/forward-token-cursor.js
===================================================================
--- node_modules/eslint/lib/token-store/forward-token-cursor.js	(revision )
+++ node_modules/eslint/lib/token-store/forward-token-cursor.js	(revision )
@@ -1,61 +0,0 @@
-/**
- * @fileoverview Define the cursor which iterates tokens only.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const Cursor = require("./cursor");
-const utils = require("./utils");
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * The cursor which iterates tokens only.
- */
-module.exports = class ForwardTokenCursor extends Cursor {
-
-    /**
-     * Initializes this cursor.
-     * @param {Token[]} tokens - The array of tokens.
-     * @param {Comment[]} comments - The array of comments.
-     * @param {Object} indexMap - The map from locations to indices in `tokens`.
-     * @param {number} startLoc - The start location of the iteration range.
-     * @param {number} endLoc - The end location of the iteration range.
-     */
-    constructor(tokens, comments, indexMap, startLoc, endLoc) {
-        super();
-        this.tokens = tokens;
-        this.index = utils.getFirstIndex(tokens, indexMap, startLoc);
-        this.indexEnd = utils.getLastIndex(tokens, indexMap, endLoc);
-    }
-
-    /** @inheritdoc */
-    moveNext() {
-        if (this.index <= this.indexEnd) {
-            this.current = this.tokens[this.index];
-            this.index += 1;
-            return true;
-        }
-        return false;
-    }
-
-    //
-    // Shorthand for performance.
-    //
-
-    /** @inheritdoc */
-    getOneToken() {
-        return (this.index <= this.indexEnd) ? this.tokens[this.index] : null;
-    }
-
-    /** @inheritdoc */
-    getAllTokens() {
-        return this.tokens.slice(this.index, this.indexEnd + 1);
-    }
-};
Index: node_modules/eslint/lib/token-store/backward-token-cursor.js
===================================================================
--- node_modules/eslint/lib/token-store/backward-token-cursor.js	(revision )
+++ node_modules/eslint/lib/token-store/backward-token-cursor.js	(revision )
@@ -1,56 +0,0 @@
-/**
- * @fileoverview Define the cursor which iterates tokens only in reverse.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const Cursor = require("./cursor");
-const utils = require("./utils");
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * The cursor which iterates tokens only in reverse.
- */
-module.exports = class BackwardTokenCursor extends Cursor {
-
-    /**
-     * Initializes this cursor.
-     * @param {Token[]} tokens - The array of tokens.
-     * @param {Comment[]} comments - The array of comments.
-     * @param {Object} indexMap - The map from locations to indices in `tokens`.
-     * @param {number} startLoc - The start location of the iteration range.
-     * @param {number} endLoc - The end location of the iteration range.
-     */
-    constructor(tokens, comments, indexMap, startLoc, endLoc) {
-        super();
-        this.tokens = tokens;
-        this.index = utils.getLastIndex(tokens, indexMap, endLoc);
-        this.indexEnd = utils.getFirstIndex(tokens, indexMap, startLoc);
-    }
-
-    /** @inheritdoc */
-    moveNext() {
-        if (this.index >= this.indexEnd) {
-            this.current = this.tokens[this.index];
-            this.index -= 1;
-            return true;
-        }
-        return false;
-    }
-
-    //
-    // Shorthand for performance.
-    //
-
-    /** @inheritdoc */
-    getOneToken() {
-        return (this.index >= this.indexEnd) ? this.tokens[this.index] : null;
-    }
-};
Index: node_modules/eslint/lib/token-store/forward-token-comment-cursor.js
===================================================================
--- node_modules/eslint/lib/token-store/forward-token-comment-cursor.js	(revision )
+++ node_modules/eslint/lib/token-store/forward-token-comment-cursor.js	(revision )
@@ -1,57 +0,0 @@
-/**
- * @fileoverview Define the cursor which iterates tokens and comments.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const Cursor = require("./cursor");
-const utils = require("./utils");
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * The cursor which iterates tokens and comments.
- */
-module.exports = class ForwardTokenCommentCursor extends Cursor {
-
-    /**
-     * Initializes this cursor.
-     * @param {Token[]} tokens - The array of tokens.
-     * @param {Comment[]} comments - The array of comments.
-     * @param {Object} indexMap - The map from locations to indices in `tokens`.
-     * @param {number} startLoc - The start location of the iteration range.
-     * @param {number} endLoc - The end location of the iteration range.
-     */
-    constructor(tokens, comments, indexMap, startLoc, endLoc) {
-        super();
-        this.tokens = tokens;
-        this.comments = comments;
-        this.tokenIndex = utils.getFirstIndex(tokens, indexMap, startLoc);
-        this.commentIndex = utils.search(comments, startLoc);
-        this.border = endLoc;
-    }
-
-    /** @inheritdoc */
-    moveNext() {
-        const token = (this.tokenIndex < this.tokens.length) ? this.tokens[this.tokenIndex] : null;
-        const comment = (this.commentIndex < this.comments.length) ? this.comments[this.commentIndex] : null;
-
-        if (token && (!comment || token.range[0] < comment.range[0])) {
-            this.current = token;
-            this.tokenIndex += 1;
-        } else if (comment) {
-            this.current = comment;
-            this.commentIndex += 1;
-        } else {
-            this.current = null;
-        }
-
-        return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);
-    }
-};
Index: node_modules/eslint/lib/token-store/backward-token-comment-cursor.js
===================================================================
--- node_modules/eslint/lib/token-store/backward-token-comment-cursor.js	(revision )
+++ node_modules/eslint/lib/token-store/backward-token-comment-cursor.js	(revision )
@@ -1,57 +0,0 @@
-/**
- * @fileoverview Define the cursor which iterates tokens and comments in reverse.
- * @author Toru Nagashima
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const Cursor = require("./cursor");
-const utils = require("./utils");
-
-//------------------------------------------------------------------------------
-// Exports
-//------------------------------------------------------------------------------
-
-/**
- * The cursor which iterates tokens and comments in reverse.
- */
-module.exports = class BackwardTokenCommentCursor extends Cursor {
-
-    /**
-     * Initializes this cursor.
-     * @param {Token[]} tokens - The array of tokens.
-     * @param {Comment[]} comments - The array of comments.
-     * @param {Object} indexMap - The map from locations to indices in `tokens`.
-     * @param {number} startLoc - The start location of the iteration range.
-     * @param {number} endLoc - The end location of the iteration range.
-     */
-    constructor(tokens, comments, indexMap, startLoc, endLoc) {
-        super();
-        this.tokens = tokens;
-        this.comments = comments;
-        this.tokenIndex = utils.getLastIndex(tokens, indexMap, endLoc);
-        this.commentIndex = utils.search(comments, endLoc) - 1;
-        this.border = startLoc;
-    }
-
-    /** @inheritdoc */
-    moveNext() {
-        const token = (this.tokenIndex >= 0) ? this.tokens[this.tokenIndex] : null;
-        const comment = (this.commentIndex >= 0) ? this.comments[this.commentIndex] : null;
-
-        if (token && (!comment || token.range[1] > comment.range[1])) {
-            this.current = token;
-            this.tokenIndex -= 1;
-        } else if (comment) {
-            this.current = comment;
-            this.commentIndex -= 1;
-        } else {
-            this.current = null;
-        }
-
-        return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);
-    }
-};
Index: node_modules/eslint/lib/ast-utils.js
===================================================================
--- node_modules/eslint/lib/ast-utils.js	(revision )
+++ node_modules/eslint/lib/ast-utils.js	(revision )
@@ -1,1309 +0,0 @@
-/**
- * @fileoverview Common utils for AST.
- * @author Gyandeep Singh
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const esutils = require("esutils");
-const espree = require("espree");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;
-const anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/;
-const arrayOrTypedArrayPattern = /Array$/;
-const arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;
-const bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;
-const breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/;
-const thisTagPattern = /^[\s*]*@this/m;
-
-
-const COMMENTS_IGNORE_PATTERN = /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/;
-const LINEBREAKS = new Set(["\r\n", "\r", "\n", "\u2028", "\u2029"]);
-const LINEBREAK_MATCHER = /\r\n|[\r\n\u2028\u2029]/;
-const SHEBANG_MATCHER = /^#!([^\r\n]+)/;
-
-// A set of node types that can contain a list of statements
-const STATEMENT_LIST_PARENTS = new Set(["Program", "BlockStatement", "SwitchCase"]);
-
-/**
- * Checks reference if is non initializer and writable.
- * @param {Reference} reference - A reference to check.
- * @param {int} index - The index of the reference in the references.
- * @param {Reference[]} references - The array that the reference belongs to.
- * @returns {boolean} Success/Failure
- * @private
- */
-function isModifyingReference(reference, index, references) {
-    const identifier = reference.identifier;
-
-    /*
-     * Destructuring assignments can have multiple default value, so
-     * possibly there are multiple writeable references for the same
-     * identifier.
-     */
-    const modifyingDifferentIdentifier = index === 0 ||
-        references[index - 1].identifier !== identifier;
-
-    return (identifier &&
-        reference.init === false &&
-        reference.isWrite() &&
-        modifyingDifferentIdentifier
-    );
-}
-
-/**
- * Checks whether the given string starts with uppercase or not.
- *
- * @param {string} s - The string to check.
- * @returns {boolean} `true` if the string starts with uppercase.
- */
-function startsWithUpperCase(s) {
-    return s[0] !== s[0].toLocaleLowerCase();
-}
-
-/**
- * Checks whether or not a node is a constructor.
- * @param {ASTNode} node - A function node to check.
- * @returns {boolean} Wehether or not a node is a constructor.
- */
-function isES5Constructor(node) {
-    return (node.id && startsWithUpperCase(node.id.name));
-}
-
-/**
- * Finds a function node from ancestors of a node.
- * @param {ASTNode} node - A start node to find.
- * @returns {Node|null} A found function node.
- */
-function getUpperFunction(node) {
-    while (node) {
-        if (anyFunctionPattern.test(node.type)) {
-            return node;
-        }
-        node = node.parent;
-    }
-    return null;
-}
-
-/**
- * Checks whether a given node is a function node or not.
- * The following types are function nodes:
- *
- * - ArrowFunctionExpression
- * - FunctionDeclaration
- * - FunctionExpression
- *
- * @param {ASTNode|null} node - A node to check.
- * @returns {boolean} `true` if the node is a function node.
- */
-function isFunction(node) {
-    return Boolean(node && anyFunctionPattern.test(node.type));
-}
-
-/**
- * Checks whether a given node is a loop node or not.
- * The following types are loop nodes:
- *
- * - DoWhileStatement
- * - ForInStatement
- * - ForOfStatement
- * - ForStatement
- * - WhileStatement
- *
- * @param {ASTNode|null} node - A node to check.
- * @returns {boolean} `true` if the node is a loop node.
- */
-function isLoop(node) {
-    return Boolean(node && anyLoopPattern.test(node.type));
-}
-
-/**
- * Checks whether the given node is in a loop or not.
- *
- * @param {ASTNode} node - The node to check.
- * @returns {boolean} `true` if the node is in a loop.
- */
-function isInLoop(node) {
-    while (node && !isFunction(node)) {
-        if (isLoop(node)) {
-            return true;
-        }
-
-        node = node.parent;
-    }
-
-    return false;
-}
-
-/**
- * Checks whether or not a node is `null` or `undefined`.
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} Whether or not the node is a `null` or `undefined`.
- * @public
- */
-function isNullOrUndefined(node) {
-    return (
-        module.exports.isNullLiteral(node) ||
-        (node.type === "Identifier" && node.name === "undefined") ||
-        (node.type === "UnaryExpression" && node.operator === "void")
-    );
-}
-
-/**
- * Checks whether or not a node is callee.
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} Whether or not the node is callee.
- */
-function isCallee(node) {
-    return node.parent.type === "CallExpression" && node.parent.callee === node;
-}
-
-/**
- * Checks whether or not a node is `Reflect.apply`.
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} Whether or not the node is a `Reflect.apply`.
- */
-function isReflectApply(node) {
-    return (
-        node.type === "MemberExpression" &&
-        node.object.type === "Identifier" &&
-        node.object.name === "Reflect" &&
-        node.property.type === "Identifier" &&
-        node.property.name === "apply" &&
-        node.computed === false
-    );
-}
-
-/**
- * Checks whether or not a node is `Array.from`.
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} Whether or not the node is a `Array.from`.
- */
-function isArrayFromMethod(node) {
-    return (
-        node.type === "MemberExpression" &&
-        node.object.type === "Identifier" &&
-        arrayOrTypedArrayPattern.test(node.object.name) &&
-        node.property.type === "Identifier" &&
-        node.property.name === "from" &&
-        node.computed === false
-    );
-}
-
-/**
- * Checks whether or not a node is a method which has `thisArg`.
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} Whether or not the node is a method which has `thisArg`.
- */
-function isMethodWhichHasThisArg(node) {
-    while (node) {
-        if (node.type === "Identifier") {
-            return arrayMethodPattern.test(node.name);
-        }
-        if (node.type === "MemberExpression" && !node.computed) {
-            node = node.property;
-            continue;
-        }
-
-        break;
-    }
-
-    return false;
-}
-
-/**
- * Creates the negate function of the given function.
- * @param {Function} f - The function to negate.
- * @returns {Function} Negated function.
- */
-function negate(f) {
-    return token => !f(token);
-}
-
-/**
- * Checks whether or not a node has a `@this` tag in its comments.
- * @param {ASTNode} node - A node to check.
- * @param {SourceCode} sourceCode - A SourceCode instance to get comments.
- * @returns {boolean} Whether or not the node has a `@this` tag in its comments.
- */
-function hasJSDocThisTag(node, sourceCode) {
-    const jsdocComment = sourceCode.getJSDocComment(node);
-
-    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
-        return true;
-    }
-
-    // Checks `@this` in its leading comments for callbacks,
-    // because callbacks don't have its JSDoc comment.
-    // e.g.
-    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });
-    return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));
-}
-
-/**
- * Determines if a node is surrounded by parentheses.
- * @param {SourceCode} sourceCode The ESLint source code object
- * @param {ASTNode} node The node to be checked.
- * @returns {boolean} True if the node is parenthesised.
- * @private
- */
-function isParenthesised(sourceCode, node) {
-    const previousToken = sourceCode.getTokenBefore(node),
-        nextToken = sourceCode.getTokenAfter(node);
-
-    return Boolean(previousToken && nextToken) &&
-        previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
-        nextToken.value === ")" && nextToken.range[0] >= node.range[1];
-}
-
-/**
- * Checks if the given token is an arrow token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is an arrow token.
- */
-function isArrowToken(token) {
-    return token.value === "=>" && token.type === "Punctuator";
-}
-
-/**
- * Checks if the given token is a comma token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is a comma token.
- */
-function isCommaToken(token) {
-    return token.value === "," && token.type === "Punctuator";
-}
-
-/**
- * Checks if the given token is a semicolon token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is a semicolon token.
- */
-function isSemicolonToken(token) {
-    return token.value === ";" && token.type === "Punctuator";
-}
-
-/**
- * Checks if the given token is a colon token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is a colon token.
- */
-function isColonToken(token) {
-    return token.value === ":" && token.type === "Punctuator";
-}
-
-/**
- * Checks if the given token is an opening parenthesis token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is an opening parenthesis token.
- */
-function isOpeningParenToken(token) {
-    return token.value === "(" && token.type === "Punctuator";
-}
-
-/**
- * Checks if the given token is a closing parenthesis token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is a closing parenthesis token.
- */
-function isClosingParenToken(token) {
-    return token.value === ")" && token.type === "Punctuator";
-}
-
-/**
- * Checks if the given token is an opening square bracket token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is an opening square bracket token.
- */
-function isOpeningBracketToken(token) {
-    return token.value === "[" && token.type === "Punctuator";
-}
-
-/**
- * Checks if the given token is a closing square bracket token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is a closing square bracket token.
- */
-function isClosingBracketToken(token) {
-    return token.value === "]" && token.type === "Punctuator";
-}
-
-/**
- * Checks if the given token is an opening brace token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is an opening brace token.
- */
-function isOpeningBraceToken(token) {
-    return token.value === "{" && token.type === "Punctuator";
-}
-
-/**
- * Checks if the given token is a closing brace token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is a closing brace token.
- */
-function isClosingBraceToken(token) {
-    return token.value === "}" && token.type === "Punctuator";
-}
-
-/**
- * Checks if the given token is a comment token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is a comment token.
- */
-function isCommentToken(token) {
-    return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
-}
-
-/**
- * Checks if the given token is a keyword token or not.
- *
- * @param {Token} token - The token to check.
- * @returns {boolean} `true` if the token is a keyword token.
- */
-function isKeywordToken(token) {
-    return token.type === "Keyword";
-}
-
-/**
- * Gets the `(` token of the given function node.
- *
- * @param {ASTNode} node - The function node to get.
- * @param {SourceCode} sourceCode - The source code object to get tokens.
- * @returns {Token} `(` token.
- */
-function getOpeningParenOfParams(node, sourceCode) {
-    return node.id
-        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)
-        : sourceCode.getFirstToken(node, isOpeningParenToken);
-}
-
-/**
- * Creates a version of the LINEBREAK_MATCHER regex with the global flag.
- * Global regexes are mutable, so this needs to be a function instead of a constant.
- * @returns {RegExp} A global regular expression that matches line terminators
- */
-function createGlobalLinebreakMatcher() {
-    return new RegExp(LINEBREAK_MATCHER.source, "g");
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = {
-    COMMENTS_IGNORE_PATTERN,
-    LINEBREAKS,
-    LINEBREAK_MATCHER,
-    SHEBANG_MATCHER,
-    STATEMENT_LIST_PARENTS,
-
-    /**
-     * Determines whether two adjacent tokens are on the same line.
-     * @param {Object} left - The left token object.
-     * @param {Object} right - The right token object.
-     * @returns {boolean} Whether or not the tokens are on the same line.
-     * @public
-     */
-    isTokenOnSameLine(left, right) {
-        return left.loc.end.line === right.loc.start.line;
-    },
-
-    isNullOrUndefined,
-    isCallee,
-    isES5Constructor,
-    getUpperFunction,
-    isFunction,
-    isLoop,
-    isInLoop,
-    isArrayFromMethod,
-    isParenthesised,
-    createGlobalLinebreakMatcher,
-
-    isArrowToken,
-    isClosingBraceToken,
-    isClosingBracketToken,
-    isClosingParenToken,
-    isColonToken,
-    isCommaToken,
-    isCommentToken,
-    isKeywordToken,
-    isNotClosingBraceToken: negate(isClosingBraceToken),
-    isNotClosingBracketToken: negate(isClosingBracketToken),
-    isNotClosingParenToken: negate(isClosingParenToken),
-    isNotColonToken: negate(isColonToken),
-    isNotCommaToken: negate(isCommaToken),
-    isNotOpeningBraceToken: negate(isOpeningBraceToken),
-    isNotOpeningBracketToken: negate(isOpeningBracketToken),
-    isNotOpeningParenToken: negate(isOpeningParenToken),
-    isNotSemicolonToken: negate(isSemicolonToken),
-    isOpeningBraceToken,
-    isOpeningBracketToken,
-    isOpeningParenToken,
-    isSemicolonToken,
-
-    /**
-     * Checks whether or not a given node is a string literal.
-     * @param {ASTNode} node - A node to check.
-     * @returns {boolean} `true` if the node is a string literal.
-     */
-    isStringLiteral(node) {
-        return (
-            (node.type === "Literal" && typeof node.value === "string") ||
-            node.type === "TemplateLiteral"
-        );
-    },
-
-    /**
-     * Checks whether a given node is a breakable statement or not.
-     * The node is breakable if the node is one of the following type:
-     *
-     * - DoWhileStatement
-     * - ForInStatement
-     * - ForOfStatement
-     * - ForStatement
-     * - SwitchStatement
-     * - WhileStatement
-     *
-     * @param {ASTNode} node - A node to check.
-     * @returns {boolean} `true` if the node is breakable.
-     */
-    isBreakableStatement(node) {
-        return breakableTypePattern.test(node.type);
-    },
-
-    /**
-     * Gets the label if the parent node of a given node is a LabeledStatement.
-     *
-     * @param {ASTNode} node - A node to get.
-     * @returns {string|null} The label or `null`.
-     */
-    getLabel(node) {
-        if (node.parent.type === "LabeledStatement") {
-            return node.parent.label.name;
-        }
-        return null;
-    },
-
-    /**
-     * Gets references which are non initializer and writable.
-     * @param {Reference[]} references - An array of references.
-     * @returns {Reference[]} An array of only references which are non initializer and writable.
-     * @public
-     */
-    getModifyingReferences(references) {
-        return references.filter(isModifyingReference);
-    },
-
-    /**
-     * Validate that a string passed in is surrounded by the specified character
-     * @param  {string} val The text to check.
-     * @param  {string} character The character to see if it's surrounded by.
-     * @returns {boolean} True if the text is surrounded by the character, false if not.
-     * @private
-     */
-    isSurroundedBy(val, character) {
-        return val[0] === character && val[val.length - 1] === character;
-    },
-
-    /**
-     * Returns whether the provided node is an ESLint directive comment or not
-     * @param {Line|Block} node The comment token to be checked
-     * @returns {boolean} `true` if the node is an ESLint directive comment
-     */
-    isDirectiveComment(node) {
-        const comment = node.value.trim();
-
-        return (
-            node.type === "Line" && comment.indexOf("eslint-") === 0 ||
-            node.type === "Block" && (
-                comment.indexOf("global ") === 0 ||
-                comment.indexOf("eslint ") === 0 ||
-                comment.indexOf("eslint-") === 0
-            )
-        );
-    },
-
-    /**
-     * Gets the trailing statement of a given node.
-     *
-     *     if (code)
-     *         consequent;
-     *
-     * When taking this `IfStatement`, returns `consequent;` statement.
-     *
-     * @param {ASTNode} A node to get.
-     * @returns {ASTNode|null} The trailing statement's node.
-     */
-    getTrailingStatement: esutils.ast.trailingStatement,
-
-    /**
-     * Finds the variable by a given name in a given scope and its upper scopes.
-     *
-     * @param {eslint-scope.Scope} initScope - A scope to start find.
-     * @param {string} name - A variable name to find.
-     * @returns {eslint-scope.Variable|null} A found variable or `null`.
-     */
-    getVariableByName(initScope, name) {
-        let scope = initScope;
-
-        while (scope) {
-            const variable = scope.set.get(name);
-
-            if (variable) {
-                return variable;
-            }
-
-            scope = scope.upper;
-        }
-
-        return null;
-    },
-
-    /**
-     * Checks whether or not a given function node is the default `this` binding.
-     *
-     * First, this checks the node:
-     *
-     * - The function name does not start with uppercase (it's a constructor).
-     * - The function does not have a JSDoc comment that has a @this tag.
-     *
-     * Next, this checks the location of the node.
-     * If the location is below, this judges `this` is valid.
-     *
-     * - The location is not on an object literal.
-     * - The location is not assigned to a variable which starts with an uppercase letter.
-     * - The location is not on an ES2015 class.
-     * - Its `bind`/`call`/`apply` method is not called directly.
-     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.
-     *
-     * @param {ASTNode} node - A function node to check.
-     * @param {SourceCode} sourceCode - A SourceCode instance to get comments.
-     * @returns {boolean} The function node is the default `this` binding.
-     */
-    isDefaultThisBinding(node, sourceCode) {
-        if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
-            return false;
-        }
-        const isAnonymous = node.id === null;
-
-        while (node) {
-            const parent = node.parent;
-
-            switch (parent.type) {
-
-                /*
-                 * Looks up the destination.
-                 * e.g., obj.foo = nativeFoo || function foo() { ... };
-                 */
-                case "LogicalExpression":
-                case "ConditionalExpression":
-                    node = parent;
-                    break;
-
-                // If the upper function is IIFE, checks the destination of the return value.
-                // e.g.
-                //   obj.foo = (function() {
-                //     // setup...
-                //     return function foo() { ... };
-                //   })();
-                //   obj.foo = (() =>
-                //     function foo() { ... }
-                //   )();
-                case "ReturnStatement": {
-                    const func = getUpperFunction(parent);
-
-                    if (func === null || !isCallee(func)) {
-                        return true;
-                    }
-                    node = func.parent;
-                    break;
-                }
-                case "ArrowFunctionExpression":
-                    if (node !== parent.body || !isCallee(parent)) {
-                        return true;
-                    }
-                    node = parent.parent;
-                    break;
-
-                // e.g.
-                //   var obj = { foo() { ... } };
-                //   var obj = { foo: function() { ... } };
-                //   class A { constructor() { ... } }
-                //   class A { foo() { ... } }
-                //   class A { get foo() { ... } }
-                //   class A { set foo() { ... } }
-                //   class A { static foo() { ... } }
-                case "Property":
-                case "MethodDefinition":
-                    return parent.value !== node;
-
-                // e.g.
-                //   obj.foo = function foo() { ... };
-                //   Foo = function() { ... };
-                //   [obj.foo = function foo() { ... }] = a;
-                //   [Foo = function() { ... }] = a;
-                case "AssignmentExpression":
-                case "AssignmentPattern":
-                    if (parent.left.type === "MemberExpression") {
-                        return false;
-                    }
-                    if (
-                        isAnonymous &&
-                        parent.left.type === "Identifier" &&
-                        startsWithUpperCase(parent.left.name)
-                    ) {
-                        return false;
-                    }
-                    return true;
-
-                // e.g.
-                //   var Foo = function() { ... };
-                case "VariableDeclarator":
-                    return !(
-                        isAnonymous &&
-                        parent.init === node &&
-                        parent.id.type === "Identifier" &&
-                        startsWithUpperCase(parent.id.name)
-                    );
-
-                // e.g.
-                //   var foo = function foo() { ... }.bind(obj);
-                //   (function foo() { ... }).call(obj);
-                //   (function foo() { ... }).apply(obj, []);
-                case "MemberExpression":
-                    return (
-                        parent.object !== node ||
-                        parent.property.type !== "Identifier" ||
-                        !bindOrCallOrApplyPattern.test(parent.property.name) ||
-                        !isCallee(parent) ||
-                        parent.parent.arguments.length === 0 ||
-                        isNullOrUndefined(parent.parent.arguments[0])
-                    );
-
-                // e.g.
-                //   Reflect.apply(function() {}, obj, []);
-                //   Array.from([], function() {}, obj);
-                //   list.forEach(function() {}, obj);
-                case "CallExpression":
-                    if (isReflectApply(parent.callee)) {
-                        return (
-                            parent.arguments.length !== 3 ||
-                            parent.arguments[0] !== node ||
-                            isNullOrUndefined(parent.arguments[1])
-                        );
-                    }
-                    if (isArrayFromMethod(parent.callee)) {
-                        return (
-                            parent.arguments.length !== 3 ||
-                            parent.arguments[1] !== node ||
-                            isNullOrUndefined(parent.arguments[2])
-                        );
-                    }
-                    if (isMethodWhichHasThisArg(parent.callee)) {
-                        return (
-                            parent.arguments.length !== 2 ||
-                            parent.arguments[0] !== node ||
-                            isNullOrUndefined(parent.arguments[1])
-                        );
-                    }
-                    return true;
-
-                // Otherwise `this` is default.
-                default:
-                    return true;
-            }
-        }
-
-        /* istanbul ignore next */
-        return true;
-    },
-
-    /**
-     * Get the precedence level based on the node type
-     * @param {ASTNode} node node to evaluate
-     * @returns {int} precedence level
-     * @private
-     */
-    getPrecedence(node) {
-        switch (node.type) {
-            case "SequenceExpression":
-                return 0;
-
-            case "AssignmentExpression":
-            case "ArrowFunctionExpression":
-            case "YieldExpression":
-                return 1;
-
-            case "ConditionalExpression":
-                return 3;
-
-            case "LogicalExpression":
-                switch (node.operator) {
-                    case "||":
-                        return 4;
-                    case "&&":
-                        return 5;
-
-                    // no default
-                }
-
-                /* falls through */
-
-            case "BinaryExpression":
-
-                switch (node.operator) {
-                    case "|":
-                        return 6;
-                    case "^":
-                        return 7;
-                    case "&":
-                        return 8;
-                    case "==":
-                    case "!=":
-                    case "===":
-                    case "!==":
-                        return 9;
-                    case "<":
-                    case "<=":
-                    case ">":
-                    case ">=":
-                    case "in":
-                    case "instanceof":
-                        return 10;
-                    case "<<":
-                    case ">>":
-                    case ">>>":
-                        return 11;
-                    case "+":
-                    case "-":
-                        return 12;
-                    case "*":
-                    case "/":
-                    case "%":
-                        return 13;
-                    case "**":
-                        return 15;
-
-                    // no default
-                }
-
-                /* falls through */
-
-            case "UnaryExpression":
-            case "AwaitExpression":
-                return 16;
-
-            case "UpdateExpression":
-                return 17;
-
-            case "CallExpression":
-                return 18;
-
-            case "NewExpression":
-                return 19;
-
-            default:
-                return 20;
-        }
-    },
-
-    /**
-     * Checks whether the given node is an empty block node or not.
-     *
-     * @param {ASTNode|null} node - The node to check.
-     * @returns {boolean} `true` if the node is an empty block.
-     */
-    isEmptyBlock(node) {
-        return Boolean(node && node.type === "BlockStatement" && node.body.length === 0);
-    },
-
-    /**
-     * Checks whether the given node is an empty function node or not.
-     *
-     * @param {ASTNode|null} node - The node to check.
-     * @returns {boolean} `true` if the node is an empty function.
-     */
-    isEmptyFunction(node) {
-        return isFunction(node) && module.exports.isEmptyBlock(node.body);
-    },
-
-    /**
-     * Gets the property name of a given node.
-     * The node can be a MemberExpression, a Property, or a MethodDefinition.
-     *
-     * If the name is dynamic, this returns `null`.
-     *
-     * For examples:
-     *
-     *     a.b           // => "b"
-     *     a["b"]        // => "b"
-     *     a['b']        // => "b"
-     *     a[`b`]        // => "b"
-     *     a[100]        // => "100"
-     *     a[b]          // => null
-     *     a["a" + "b"]  // => null
-     *     a[tag`b`]     // => null
-     *     a[`${b}`]     // => null
-     *
-     *     let a = {b: 1}            // => "b"
-     *     let a = {["b"]: 1}        // => "b"
-     *     let a = {['b']: 1}        // => "b"
-     *     let a = {[`b`]: 1}        // => "b"
-     *     let a = {[100]: 1}        // => "100"
-     *     let a = {[b]: 1}          // => null
-     *     let a = {["a" + "b"]: 1}  // => null
-     *     let a = {[tag`b`]: 1}     // => null
-     *     let a = {[`${b}`]: 1}     // => null
-     *
-     * @param {ASTNode} node - The node to get.
-     * @returns {string|null} The property name if static. Otherwise, null.
-     */
-    getStaticPropertyName(node) {
-        let prop;
-
-        switch (node && node.type) {
-            case "Property":
-            case "MethodDefinition":
-                prop = node.key;
-                break;
-
-            case "MemberExpression":
-                prop = node.property;
-                break;
-
-            // no default
-        }
-
-        switch (prop && prop.type) {
-            case "Literal":
-                return String(prop.value);
-
-            case "TemplateLiteral":
-                if (prop.expressions.length === 0 && prop.quasis.length === 1) {
-                    return prop.quasis[0].value.cooked;
-                }
-                break;
-
-            case "Identifier":
-                if (!node.computed) {
-                    return prop.name;
-                }
-                break;
-
-            // no default
-        }
-
-        return null;
-    },
-
-    /**
-     * Get directives from directive prologue of a Program or Function node.
-     * @param {ASTNode} node - The node to check.
-     * @returns {ASTNode[]} The directives found in the directive prologue.
-     */
-    getDirectivePrologue(node) {
-        const directives = [];
-
-        // Directive prologues only occur at the top of files or functions.
-        if (
-            node.type === "Program" ||
-            node.type === "FunctionDeclaration" ||
-            node.type === "FunctionExpression" ||
-
-            // Do not check arrow functions with implicit return.
-            // `() => "use strict";` returns the string `"use strict"`.
-            (node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement")
-        ) {
-            const statements = node.type === "Program" ? node.body : node.body.body;
-
-            for (const statement of statements) {
-                if (
-                    statement.type === "ExpressionStatement" &&
-                    statement.expression.type === "Literal"
-                ) {
-                    directives.push(statement);
-                } else {
-                    break;
-                }
-            }
-        }
-
-        return directives;
-    },
-
-
-    /**
-     * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added
-     after the node will be parsed as a decimal point, rather than a property-access dot.
-     * @param {ASTNode} node - The node to check.
-     * @returns {boolean} `true` if this node is a decimal integer.
-     * @example
-     *
-     * 5       // true
-     * 5.      // false
-     * 5.0     // false
-     * 05      // false
-     * 0x5     // false
-     * 0b101   // false
-     * 0o5     // false
-     * 5e0     // false
-     * '5'     // false
-     */
-    isDecimalInteger(node) {
-        return node.type === "Literal" && typeof node.value === "number" && /^(0|[1-9]\d*)$/.test(node.raw);
-    },
-
-    /**
-     * Gets the name and kind of the given function node.
-     *
-     * - `function foo() {}`  .................... `function 'foo'`
-     * - `(function foo() {})`  .................. `function 'foo'`
-     * - `(function() {})`  ...................... `function`
-     * - `function* foo() {}`  ................... `generator function 'foo'`
-     * - `(function* foo() {})`  ................. `generator function 'foo'`
-     * - `(function*() {})`  ..................... `generator function`
-     * - `() => {}`  ............................. `arrow function`
-     * - `async () => {}`  ....................... `async arrow function`
-     * - `({ foo: function foo() {} })`  ......... `method 'foo'`
-     * - `({ foo: function() {} })`  ............. `method 'foo'`
-     * - `({ ['foo']: function() {} })`  ......... `method 'foo'`
-     * - `({ [foo]: function() {} })`  ........... `method`
-     * - `({ foo() {} })`  ....................... `method 'foo'`
-     * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`
-     * - `({ foo: function*() {} })`  ............ `generator method 'foo'`
-     * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`
-     * - `({ [foo]: function*() {} })`  .......... `generator method`
-     * - `({ *foo() {} })`  ...................... `generator method 'foo'`
-     * - `({ foo: async function foo() {} })`  ... `async method 'foo'`
-     * - `({ foo: async function() {} })`  ....... `async method 'foo'`
-     * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`
-     * - `({ [foo]: async function() {} })`  ..... `async method`
-     * - `({ async foo() {} })`  ................. `async method 'foo'`
-     * - `({ get foo() {} })`  ................... `getter 'foo'`
-     * - `({ set foo(a) {} })`  .................. `setter 'foo'`
-     * - `class A { constructor() {} }`  ......... `constructor`
-     * - `class A { foo() {} }`  ................. `method 'foo'`
-     * - `class A { *foo() {} }`  ................ `generator method 'foo'`
-     * - `class A { async foo() {} }`  ........... `async method 'foo'`
-     * - `class A { ['foo']() {} }`  ............. `method 'foo'`
-     * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`
-     * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`
-     * - `class A { [foo]() {} }`  ............... `method`
-     * - `class A { *[foo]() {} }`  .............. `generator method`
-     * - `class A { async [foo]() {} }`  ......... `async method`
-     * - `class A { get foo() {} }`  ............. `getter 'foo'`
-     * - `class A { set foo(a) {} }`  ............ `setter 'foo'`
-     * - `class A { static foo() {} }`  .......... `static method 'foo'`
-     * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`
-     * - `class A { static async foo() {} }`  .... `static async method 'foo'`
-     * - `class A { static get foo() {} }`  ...... `static getter 'foo'`
-     * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`
-     *
-     * @param {ASTNode} node - The function node to get.
-     * @returns {string} The name and kind of the function node.
-     */
-    getFunctionNameWithKind(node) {
-        const parent = node.parent;
-        const tokens = [];
-
-        if (parent.type === "MethodDefinition" && parent.static) {
-            tokens.push("static");
-        }
-        if (node.async) {
-            tokens.push("async");
-        }
-        if (node.generator) {
-            tokens.push("generator");
-        }
-
-        if (node.type === "ArrowFunctionExpression") {
-            tokens.push("arrow", "function");
-        } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
-            if (parent.kind === "constructor") {
-                return "constructor";
-            } else if (parent.kind === "get") {
-                tokens.push("getter");
-            } else if (parent.kind === "set") {
-                tokens.push("setter");
-            } else {
-                tokens.push("method");
-            }
-        } else {
-            tokens.push("function");
-        }
-
-        if (node.id) {
-            tokens.push(`'${node.id.name}'`);
-        } else {
-            const name = module.exports.getStaticPropertyName(parent);
-
-            if (name) {
-                tokens.push(`'${name}'`);
-            }
-        }
-
-        return tokens.join(" ");
-    },
-
-    /**
-     * Gets the location of the given function node for reporting.
-     *
-     * - `function foo() {}`
-     *    ^^^^^^^^^^^^
-     * - `(function foo() {})`
-     *     ^^^^^^^^^^^^
-     * - `(function() {})`
-     *     ^^^^^^^^
-     * - `function* foo() {}`
-     *    ^^^^^^^^^^^^^
-     * - `(function* foo() {})`
-     *     ^^^^^^^^^^^^^
-     * - `(function*() {})`
-     *     ^^^^^^^^^
-     * - `() => {}`
-     *       ^^
-     * - `async () => {}`
-     *             ^^
-     * - `({ foo: function foo() {} })`
-     *       ^^^^^^^^^^^^^^^^^
-     * - `({ foo: function() {} })`
-     *       ^^^^^^^^^^^^^
-     * - `({ ['foo']: function() {} })`
-     *       ^^^^^^^^^^^^^^^^^
-     * - `({ [foo]: function() {} })`
-     *       ^^^^^^^^^^^^^^^
-     * - `({ foo() {} })`
-     *       ^^^
-     * - `({ foo: function* foo() {} })`
-     *       ^^^^^^^^^^^^^^^^^^
-     * - `({ foo: function*() {} })`
-     *       ^^^^^^^^^^^^^^
-     * - `({ ['foo']: function*() {} })`
-     *       ^^^^^^^^^^^^^^^^^^
-     * - `({ [foo]: function*() {} })`
-     *       ^^^^^^^^^^^^^^^^
-     * - `({ *foo() {} })`
-     *       ^^^^
-     * - `({ foo: async function foo() {} })`
-     *       ^^^^^^^^^^^^^^^^^^^^^^^
-     * - `({ foo: async function() {} })`
-     *       ^^^^^^^^^^^^^^^^^^^
-     * - `({ ['foo']: async function() {} })`
-     *       ^^^^^^^^^^^^^^^^^^^^^^^
-     * - `({ [foo]: async function() {} })`
-     *       ^^^^^^^^^^^^^^^^^^^^^
-     * - `({ async foo() {} })`
-     *       ^^^^^^^^^
-     * - `({ get foo() {} })`
-     *       ^^^^^^^
-     * - `({ set foo(a) {} })`
-     *       ^^^^^^^
-     * - `class A { constructor() {} }`
-     *              ^^^^^^^^^^^
-     * - `class A { foo() {} }`
-     *              ^^^
-     * - `class A { *foo() {} }`
-     *              ^^^^
-     * - `class A { async foo() {} }`
-     *              ^^^^^^^^^
-     * - `class A { ['foo']() {} }`
-     *              ^^^^^^^
-     * - `class A { *['foo']() {} }`
-     *              ^^^^^^^^
-     * - `class A { async ['foo']() {} }`
-     *              ^^^^^^^^^^^^^
-     * - `class A { [foo]() {} }`
-     *              ^^^^^
-     * - `class A { *[foo]() {} }`
-     *              ^^^^^^
-     * - `class A { async [foo]() {} }`
-     *              ^^^^^^^^^^^
-     * - `class A { get foo() {} }`
-     *              ^^^^^^^
-     * - `class A { set foo(a) {} }`
-     *              ^^^^^^^
-     * - `class A { static foo() {} }`
-     *              ^^^^^^^^^^
-     * - `class A { static *foo() {} }`
-     *              ^^^^^^^^^^^
-     * - `class A { static async foo() {} }`
-     *              ^^^^^^^^^^^^^^^^
-     * - `class A { static get foo() {} }`
-     *              ^^^^^^^^^^^^^^
-     * - `class A { static set foo(a) {} }`
-     *              ^^^^^^^^^^^^^^
-     *
-     * @param {ASTNode} node - The function node to get.
-     * @param {SourceCode} sourceCode - The source code object to get tokens.
-     * @returns {string} The location of the function node for reporting.
-     */
-    getFunctionHeadLoc(node, sourceCode) {
-        const parent = node.parent;
-        let start = null;
-        let end = null;
-
-        if (node.type === "ArrowFunctionExpression") {
-            const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);
-
-            start = arrowToken.loc.start;
-            end = arrowToken.loc.end;
-        } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
-            start = parent.loc.start;
-            end = getOpeningParenOfParams(node, sourceCode).loc.start;
-        } else {
-            start = node.loc.start;
-            end = getOpeningParenOfParams(node, sourceCode).loc.start;
-        }
-
-        return {
-            start: Object.assign({}, start),
-            end: Object.assign({}, end)
-        };
-    },
-
-    /**
-    * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses
-    * surrounding the node.
-    * @param {SourceCode} sourceCode The source code object
-    * @param {ASTNode} node An expression node
-    * @returns {string} The text representing the node, with all surrounding parentheses included
-    */
-    getParenthesisedText(sourceCode, node) {
-        let leftToken = sourceCode.getFirstToken(node);
-        let rightToken = sourceCode.getLastToken(node);
-
-        while (
-            sourceCode.getTokenBefore(leftToken) &&
-            sourceCode.getTokenBefore(leftToken).type === "Punctuator" &&
-            sourceCode.getTokenBefore(leftToken).value === "(" &&
-            sourceCode.getTokenAfter(rightToken) &&
-            sourceCode.getTokenAfter(rightToken).type === "Punctuator" &&
-            sourceCode.getTokenAfter(rightToken).value === ")"
-        ) {
-            leftToken = sourceCode.getTokenBefore(leftToken);
-            rightToken = sourceCode.getTokenAfter(rightToken);
-        }
-
-        return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);
-    },
-
-    /*
-     * Determine if a node has a possiblity to be an Error object
-     * @param  {ASTNode} node  ASTNode to check
-     * @returns {boolean} True if there is a chance it contains an Error obj
-     */
-    couldBeError(node) {
-        switch (node.type) {
-            case "Identifier":
-            case "CallExpression":
-            case "NewExpression":
-            case "MemberExpression":
-            case "TaggedTemplateExpression":
-            case "YieldExpression":
-            case "AwaitExpression":
-                return true; // possibly an error object.
-
-            case "AssignmentExpression":
-                return module.exports.couldBeError(node.right);
-
-            case "SequenceExpression": {
-                const exprs = node.expressions;
-
-                return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);
-            }
-
-            case "LogicalExpression":
-                return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);
-
-            case "ConditionalExpression":
-                return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);
-
-            default:
-                return false;
-        }
-    },
-
-    /**
-     * Determines whether the given node is a `null` literal.
-     * @param {ASTNode} node The node to check
-     * @returns {boolean} `true` if the node is a `null` literal
-     */
-    isNullLiteral(node) {
-
-        /*
-         * Checking `node.value === null` does not guarantee that a literal is a null literal.
-         * When parsing values that cannot be represented in the current environment (e.g. unicode
-         * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to
-         * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check
-         * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020
-         */
-        return node.type === "Literal" && node.value === null && !node.regex;
-    },
-
-    /**
-     * Determines whether two tokens can safely be placed next to each other without merging into a single token
-     * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.
-     * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.
-     * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed
-     * next to each other, behavior is undefined (although it should return `true` in most cases).
-     */
-    canTokensBeAdjacent(leftValue, rightValue) {
-        let leftToken;
-
-        if (typeof leftValue === "string") {
-            const leftTokens = espree.tokenize(leftValue, { ecmaVersion: 2015 });
-
-            leftToken = leftTokens[leftTokens.length - 1];
-        } else {
-            leftToken = leftValue;
-        }
-
-        const rightToken = typeof rightValue === "string" ? espree.tokenize(rightValue, { ecmaVersion: 2015 })[0] : rightValue;
-
-        if (leftToken.type === "Punctuator" || rightToken.type === "Punctuator") {
-            if (leftToken.type === "Punctuator" && rightToken.type === "Punctuator") {
-                const PLUS_TOKENS = new Set(["+", "++"]);
-                const MINUS_TOKENS = new Set(["-", "--"]);
-
-                return !(
-                    PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) ||
-                    MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value)
-                );
-            }
-            return true;
-        }
-
-        if (
-            leftToken.type === "String" || rightToken.type === "String" ||
-            leftToken.type === "Template" || rightToken.type === "Template"
-        ) {
-            return true;
-        }
-
-        if (leftToken.type !== "Numeric" && rightToken.type === "Numeric" && rightToken.value.startsWith(".")) {
-            return true;
-        }
-
-        return false;
-    }
-};
Index: node_modules/eslint/lib/cli-engine.js
===================================================================
--- node_modules/eslint/lib/cli-engine.js	(revision )
+++ node_modules/eslint/lib/cli-engine.js	(revision )
@@ -1,679 +0,0 @@
-/**
- * @fileoverview Main CLI object.
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-/*
- * The CLI object should *not* call process.exit() directly. It should only return
- * exit codes. This allows other programs to use the CLI object and still control
- * when the program exits.
- */
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const fs = require("fs"),
-    path = require("path"),
-    defaultOptions = require("../conf/default-cli-options"),
-    Linter = require("./linter"),
-    IgnoredPaths = require("./ignored-paths"),
-    Config = require("./config"),
-    fileEntryCache = require("file-entry-cache"),
-    globUtil = require("./util/glob-util"),
-    validator = require("./config/config-validator"),
-    stringify = require("json-stable-stringify"),
-    hash = require("./util/hash"),
-    pkg = require("../package.json");
-
-const debug = require("debug")("eslint:cli-engine");
-
-//------------------------------------------------------------------------------
-// Typedefs
-//------------------------------------------------------------------------------
-
-/**
- * The options to configure a CLI engine with.
- * @typedef {Object} CLIEngineOptions
- * @property {boolean} allowInlineConfig Enable or disable inline configuration comments.
- * @property {boolean|Object} baseConfig Base config object. True enables recommend rules and environments.
- * @property {boolean} cache Enable result caching.
- * @property {string} cacheLocation The cache file to use instead of .eslintcache.
- * @property {string} configFile The configuration file to use.
- * @property {string} cwd The value to use for the current working directory.
- * @property {string[]} envs An array of environments to load.
- * @property {string[]} extensions An array of file extensions to check.
- * @property {boolean|Function} fix Execute in autofix mode. If a function, should return a boolean.
- * @property {string[]} globals An array of global variables to declare.
- * @property {boolean} ignore False disables use of .eslintignore.
- * @property {string} ignorePath The ignore file to use instead of .eslintignore.
- * @property {string} ignorePattern A glob pattern of files to ignore.
- * @property {boolean} useEslintrc False disables looking for .eslintrc
- * @property {string} parser The name of the parser to use.
- * @property {Object} parserOptions An object of parserOption settings to use.
- * @property {string[]} plugins An array of plugins to load.
- * @property {Object<string,*>} rules An object of rules to use.
- * @property {string[]} rulePaths An array of directories to load custom rules from.
- */
-
-/**
- * A linting warning or error.
- * @typedef {Object} LintMessage
- * @property {string} message The message to display to the user.
- */
-
-/**
- * A linting result.
- * @typedef {Object} LintResult
- * @property {string} filePath The path to the file that was linted.
- * @property {LintMessage[]} messages All of the messages for the result.
- * @property {number} errorCount Number of errors for the result.
- * @property {number} warningCount Number of warnings for the result.
- * @property {number} fixableErrorCount Number of fixable errors for the result.
- * @property {number} fixableWarningCount Number of fixable warnings for the result.
- * @property {string=} [source] The source code of the file that was linted.
- * @property {string=} [output] The source code of the file that was linted, with as many fixes applied as possible.
- */
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * It will calculate the error and warning count for collection of messages per file
- * @param {Object[]} messages - Collection of messages
- * @returns {Object} Contains the stats
- * @private
- */
-function calculateStatsPerFile(messages) {
-    return messages.reduce((stat, message) => {
-        if (message.fatal || message.severity === 2) {
-            stat.errorCount++;
-            if (message.fix) {
-                stat.fixableErrorCount++;
-            }
-        } else {
-            stat.warningCount++;
-            if (message.fix) {
-                stat.fixableWarningCount++;
-            }
-        }
-        return stat;
-    }, {
-        errorCount: 0,
-        warningCount: 0,
-        fixableErrorCount: 0,
-        fixableWarningCount: 0
-    });
-}
-
-/**
- * It will calculate the error and warning count for collection of results from all files
- * @param {Object[]} results - Collection of messages from all the files
- * @returns {Object} Contains the stats
- * @private
- */
-function calculateStatsPerRun(results) {
-    return results.reduce((stat, result) => {
-        stat.errorCount += result.errorCount;
-        stat.warningCount += result.warningCount;
-        stat.fixableErrorCount += result.fixableErrorCount;
-        stat.fixableWarningCount += result.fixableWarningCount;
-        return stat;
-    }, {
-        errorCount: 0,
-        warningCount: 0,
-        fixableErrorCount: 0,
-        fixableWarningCount: 0
-    });
-}
-
-/**
- * Processes an source code using ESLint.
- * @param {string} text The source code to check.
- * @param {Object} configHelper The configuration options for ESLint.
- * @param {string} filename An optional string representing the texts filename.
- * @param {boolean|Function} fix Indicates if fixes should be processed.
- * @param {boolean} allowInlineConfig Allow/ignore comments that change config.
- * @param {Linter} linter Linter context
- * @returns {LintResult} The results for linting on this text.
- * @private
- */
-function processText(text, configHelper, filename, fix, allowInlineConfig, linter) {
-    let filePath,
-        fileExtension,
-        processor;
-
-    if (filename) {
-        filePath = path.resolve(filename);
-        fileExtension = path.extname(filename);
-    }
-
-    filename = filename || "<text>";
-    debug(`Linting ${filename}`);
-    const config = configHelper.getConfig(filePath);
-
-    if (config.plugins) {
-        configHelper.plugins.loadAll(config.plugins);
-    }
-
-    const loadedPlugins = configHelper.plugins.getAll();
-
-    for (const plugin in loadedPlugins) {
-        if (loadedPlugins[plugin].processors && Object.keys(loadedPlugins[plugin].processors).indexOf(fileExtension) >= 0) {
-            processor = loadedPlugins[plugin].processors[fileExtension];
-            break;
-        }
-    }
-
-    const autofixingEnabled = typeof fix !== "undefined" && (!processor || processor.supportsAutofix);
-
-    const fixedResult = linter.verifyAndFix(text, config, {
-        filename,
-        allowInlineConfig,
-        fix: !!autofixingEnabled && fix,
-        preprocess: processor && (rawText => processor.preprocess(rawText, filename)),
-        postprocess: processor && (problemLists => processor.postprocess(problemLists, filename))
-    });
-
-    const stats = calculateStatsPerFile(fixedResult.messages);
-
-    const result = {
-        filePath: filename,
-        messages: fixedResult.messages,
-        errorCount: stats.errorCount,
-        warningCount: stats.warningCount,
-        fixableErrorCount: stats.fixableErrorCount,
-        fixableWarningCount: stats.fixableWarningCount
-    };
-
-    if (fixedResult.fixed) {
-        result.output = fixedResult.output;
-    }
-
-    if (result.errorCount + result.warningCount > 0 && typeof result.output === "undefined") {
-        result.source = text;
-    }
-
-    return result;
-}
-
-/**
- * Processes an individual file using ESLint. Files used here are known to
- * exist, so no need to check that here.
- * @param {string} filename The filename of the file being checked.
- * @param {Object} configHelper The configuration options for ESLint.
- * @param {Object} options The CLIEngine options object.
- * @param {Linter} linter Linter context
- * @returns {LintResult} The results for linting on this file.
- * @private
- */
-function processFile(filename, configHelper, options, linter) {
-
-    const text = fs.readFileSync(path.resolve(filename), "utf8"),
-        result = processText(text, configHelper, filename, options.fix, options.allowInlineConfig, linter);
-
-    return result;
-
-}
-
-/**
- * Returns result with warning by ignore settings
- * @param {string} filePath - File path of checked code
- * @param {string} baseDir  - Absolute path of base directory
- * @returns {LintResult} Result with single warning
- * @private
- */
-function createIgnoreResult(filePath, baseDir) {
-    let message;
-    const isHidden = /^\./.test(path.basename(filePath));
-    const isInNodeModules = baseDir && /^node_modules/.test(path.relative(baseDir, filePath));
-    const isInBowerComponents = baseDir && /^bower_components/.test(path.relative(baseDir, filePath));
-
-    if (isHidden) {
-        message = "File ignored by default.  Use a negated ignore pattern (like \"--ignore-pattern '!<relative/path/to/filename>'\") to override.";
-    } else if (isInNodeModules) {
-        message = "File ignored by default. Use \"--ignore-pattern '!node_modules/*'\" to override.";
-    } else if (isInBowerComponents) {
-        message = "File ignored by default. Use \"--ignore-pattern '!bower_components/*'\" to override.";
-    } else {
-        message = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to override.";
-    }
-
-    return {
-        filePath: path.resolve(filePath),
-        messages: [
-            {
-                fatal: false,
-                severity: 1,
-                message
-            }
-        ],
-        errorCount: 0,
-        warningCount: 1,
-        fixableErrorCount: 0,
-        fixableWarningCount: 0
-    };
-}
-
-
-/**
- * Checks if the given message is an error message.
- * @param {Object} message The message to check.
- * @returns {boolean} Whether or not the message is an error message.
- * @private
- */
-function isErrorMessage(message) {
-    return message.severity === 2;
-}
-
-
-/**
- * return the cacheFile to be used by eslint, based on whether the provided parameter is
- * a directory or looks like a directory (ends in `path.sep`), in which case the file
- * name will be the `cacheFile/.cache_hashOfCWD`
- *
- * if cacheFile points to a file or looks like a file then in will just use that file
- *
- * @param {string} cacheFile The name of file to be used to store the cache
- * @param {string} cwd Current working directory
- * @returns {string} the resolved path to the cache file
- */
-function getCacheFile(cacheFile, cwd) {
-
-    /*
-     * make sure the path separators are normalized for the environment/os
-     * keeping the trailing path separator if present
-     */
-    cacheFile = path.normalize(cacheFile);
-
-    const resolvedCacheFile = path.resolve(cwd, cacheFile);
-    const looksLikeADirectory = cacheFile[cacheFile.length - 1] === path.sep;
-
-    /**
-     * return the name for the cache file in case the provided parameter is a directory
-     * @returns {string} the resolved path to the cacheFile
-     */
-    function getCacheFileForDirectory() {
-        return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);
-    }
-
-    let fileStats;
-
-    try {
-        fileStats = fs.lstatSync(resolvedCacheFile);
-    } catch (ex) {
-        fileStats = null;
-    }
-
-
-    /*
-     * in case the file exists we need to verify if the provided path
-     * is a directory or a file. If it is a directory we want to create a file
-     * inside that directory
-     */
-    if (fileStats) {
-
-        /*
-         * is a directory or is a file, but the original file the user provided
-         * looks like a directory but `path.resolve` removed the `last path.sep`
-         * so we need to still treat this like a directory
-         */
-        if (fileStats.isDirectory() || looksLikeADirectory) {
-            return getCacheFileForDirectory();
-        }
-
-        // is file so just use that file
-        return resolvedCacheFile;
-    }
-
-    /*
-     * here we known the file or directory doesn't exist,
-     * so we will try to infer if its a directory if it looks like a directory
-     * for the current operating system.
-     */
-
-    // if the last character passed is a path separator we assume is a directory
-    if (looksLikeADirectory) {
-        return getCacheFileForDirectory();
-    }
-
-    return resolvedCacheFile;
-}
-
-const configHashCache = new WeakMap();
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-class CLIEngine {
-
-    /**
-     * Creates a new instance of the core CLI engine.
-     * @param {CLIEngineOptions} options The options for this instance.
-     * @constructor
-     */
-    constructor(options) {
-
-        options = Object.assign(
-            Object.create(null),
-            defaultOptions,
-            { cwd: process.cwd() },
-            options
-        );
-
-        /**
-         * Stored options for this instance
-         * @type {Object}
-         */
-        this.options = options;
-        this.linter = new Linter();
-
-        if (options.cache) {
-            const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);
-
-            /**
-             * Cache used to avoid operating on files that haven't changed since the
-             * last successful execution (e.g., file passed linting with no errors and
-             * no warnings).
-             * @type {Object}
-             */
-            this._fileCache = fileEntryCache.create(cacheFile);
-        }
-
-        // load in additional rules
-        if (this.options.rulePaths) {
-            const cwd = this.options.cwd;
-
-            this.options.rulePaths.forEach(rulesdir => {
-                debug(`Loading rules from ${rulesdir}`);
-                this.linter.rules.load(rulesdir, cwd);
-            });
-        }
-
-        Object.keys(this.options.rules || {}).forEach(name => {
-            validator.validateRuleOptions(name, this.options.rules[name], "CLI", this.linter.rules);
-        });
-
-        this.config = new Config(this.options, this.linter);
-    }
-
-    /**
-     * Returns results that only contains errors.
-     * @param {LintResult[]} results The results to filter.
-     * @returns {LintResult[]} The filtered results.
-     */
-    static getErrorResults(results) {
-        const filtered = [];
-
-        results.forEach(result => {
-            const filteredMessages = result.messages.filter(isErrorMessage);
-
-            if (filteredMessages.length > 0) {
-                filtered.push(
-                    Object.assign(result, {
-                        messages: filteredMessages,
-                        errorCount: filteredMessages.length,
-                        warningCount: 0,
-                        fixableErrorCount: result.fixableErrorCount,
-                        fixableWarningCount: 0
-                    })
-                );
-            }
-        });
-
-        return filtered;
-    }
-
-    /**
-     * Outputs fixes from the given results to files.
-     * @param {Object} report The report object created by CLIEngine.
-     * @returns {void}
-     */
-    static outputFixes(report) {
-        report.results.filter(result => result.hasOwnProperty("output")).forEach(result => {
-            fs.writeFileSync(result.filePath, result.output);
-        });
-    }
-
-
-    /**
-     * Add a plugin by passing its configuration
-     * @param {string} name Name of the plugin.
-     * @param {Object} pluginobject Plugin configuration object.
-     * @returns {void}
-     */
-    addPlugin(name, pluginobject) {
-        this.config.plugins.define(name, pluginobject);
-    }
-
-    /**
-     * Resolves the patterns passed into executeOnFiles() into glob-based patterns
-     * for easier handling.
-     * @param {string[]} patterns The file patterns passed on the command line.
-     * @returns {string[]} The equivalent glob patterns.
-     */
-    resolveFileGlobPatterns(patterns) {
-        return globUtil.resolveFileGlobPatterns(patterns, this.options);
-    }
-
-    /**
-     * Executes the current configuration on an array of file and directory names.
-     * @param {string[]} patterns An array of file and directory names.
-     * @returns {Object} The results for all files that were linted.
-     */
-    executeOnFiles(patterns) {
-        const options = this.options,
-            fileCache = this._fileCache,
-            configHelper = this.config;
-        const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);
-
-        if (!options.cache && fs.existsSync(cacheFile)) {
-            fs.unlinkSync(cacheFile);
-        }
-
-        /**
-         * Calculates the hash of the config file used to validate a given file
-         * @param  {string} filename The path of the file to retrieve a config object for to calculate the hash
-         * @returns {string}         the hash of the config
-         */
-        function hashOfConfigFor(filename) {
-            const config = configHelper.getConfig(filename);
-
-            if (!configHashCache.has(config)) {
-                configHashCache.set(config, hash(`${pkg.version}_${stringify(config)}`));
-            }
-
-            return configHashCache.get(config);
-        }
-
-        const startTime = Date.now();
-        const fileList = globUtil.listFilesToProcess(this.resolveFileGlobPatterns(patterns), options);
-        const results = fileList.map(fileInfo => {
-            if (fileInfo.ignored) {
-                return createIgnoreResult(fileInfo.filename, options.cwd);
-            }
-
-            if (options.cache) {
-
-                /*
-                 * get the descriptor for this file
-                 * with the metadata and the flag that determines if
-                 * the file has changed
-                 */
-                const descriptor = fileCache.getFileDescriptor(fileInfo.filename);
-                const hashOfConfig = hashOfConfigFor(fileInfo.filename);
-                const changed = descriptor.changed || descriptor.meta.hashOfConfig !== hashOfConfig;
-
-                if (!changed) {
-                    debug(`Skipping file since hasn't changed: ${fileInfo.filename}`);
-
-                    /*
-                     * Add the the cached results (always will be 0 error and
-                     * 0 warnings). We should not cache results for files that
-                     * failed, in order to guarantee that next execution will
-                     * process those files as well.
-                     */
-                    return descriptor.meta.results;
-                }
-            }
-
-            debug(`Processing ${fileInfo.filename}`);
-
-            return processFile(fileInfo.filename, configHelper, options, this.linter);
-        });
-
-        if (options.cache) {
-            results.forEach(result => {
-                if (result.messages.length) {
-
-                    /*
-                    * if a file contains errors or warnings we don't want to
-                    * store the file in the cache so we can guarantee that
-                    * next execution will also operate on this file
-                    */
-                    fileCache.removeEntry(result.filePath);
-                } else {
-
-                    /*
-                     * since the file passed we store the result here
-                     * TODO: it might not be necessary to store the results list in the cache,
-                     * since it should always be 0 errors/warnings
-                     */
-                    const descriptor = fileCache.getFileDescriptor(result.filePath);
-
-                    descriptor.meta.hashOfConfig = hashOfConfigFor(result.filePath);
-                    descriptor.meta.results = result;
-                }
-            });
-
-            // persist the cache to disk
-            fileCache.reconcile();
-        }
-
-        const stats = calculateStatsPerRun(results);
-
-        debug(`Linting complete in: ${Date.now() - startTime}ms`);
-
-        return {
-            results,
-            errorCount: stats.errorCount,
-            warningCount: stats.warningCount,
-            fixableErrorCount: stats.fixableErrorCount,
-            fixableWarningCount: stats.fixableWarningCount
-        };
-    }
-
-    /**
-     * Executes the current configuration on text.
-     * @param {string} text A string of JavaScript code to lint.
-     * @param {string} filename An optional string representing the texts filename.
-     * @param {boolean} warnIgnored Always warn when a file is ignored
-     * @returns {Object} The results for the linting.
-     */
-    executeOnText(text, filename, warnIgnored) {
-
-        const results = [],
-            options = this.options,
-            configHelper = this.config,
-            ignoredPaths = new IgnoredPaths(options);
-
-        // resolve filename based on options.cwd (for reporting, ignoredPaths also resolves)
-        if (filename && !path.isAbsolute(filename)) {
-            filename = path.resolve(options.cwd, filename);
-        }
-
-        if (filename && ignoredPaths.contains(filename)) {
-            if (warnIgnored) {
-                results.push(createIgnoreResult(filename, options.cwd));
-            }
-        } else {
-            results.push(processText(text, configHelper, filename, options.fix, options.allowInlineConfig, this.linter));
-        }
-
-        const stats = calculateStatsPerRun(results);
-
-        return {
-            results,
-            errorCount: stats.errorCount,
-            warningCount: stats.warningCount,
-            fixableErrorCount: stats.fixableErrorCount,
-            fixableWarningCount: stats.fixableWarningCount
-        };
-    }
-
-    /**
-     * Returns a configuration object for the given file based on the CLI options.
-     * This is the same logic used by the ESLint CLI executable to determine
-     * configuration for each file it processes.
-     * @param {string} filePath The path of the file to retrieve a config object for.
-     * @returns {Object} A configuration object for the file.
-     */
-    getConfigForFile(filePath) {
-        const configHelper = this.config;
-
-        return configHelper.getConfig(filePath);
-    }
-
-    /**
-     * Checks if a given path is ignored by ESLint.
-     * @param {string} filePath The path of the file to check.
-     * @returns {boolean} Whether or not the given path is ignored.
-     */
-    isPathIgnored(filePath) {
-        const resolvedPath = path.resolve(this.options.cwd, filePath);
-        const ignoredPaths = new IgnoredPaths(this.options);
-
-        return ignoredPaths.contains(resolvedPath);
-    }
-
-    /**
-     * Returns the formatter representing the given format or null if no formatter
-     * with the given name can be found.
-     * @param {string} [format] The name of the format to load or the path to a
-     *      custom formatter.
-     * @returns {Function} The formatter function or null if not found.
-     */
-    getFormatter(format) {
-
-
-        // default is stylish
-        format = format || "stylish";
-
-        // only strings are valid formatters
-        if (typeof format === "string") {
-
-            // replace \ with / for Windows compatibility
-            format = format.replace(/\\/g, "/");
-
-            let formatterPath;
-
-            // if there's a slash, then it's a file
-            if (format.indexOf("/") > -1) {
-                const cwd = this.options ? this.options.cwd : process.cwd();
-
-                formatterPath = path.resolve(cwd, format);
-            } else {
-                formatterPath = `./formatters/${format}`;
-            }
-
-            try {
-                return require(formatterPath);
-            } catch (ex) {
-                ex.message = `There was a problem loading formatter: ${formatterPath}\nError: ${ex.message}`;
-                throw ex;
-            }
-
-        } else {
-            return null;
-        }
-    }
-}
-
-CLIEngine.version = pkg.version;
-CLIEngine.getFormatter = CLIEngine.prototype.getFormatter;
-
-module.exports = CLIEngine;
Index: node_modules/eslint/lib/load-rules.js
===================================================================
--- node_modules/eslint/lib/load-rules.js	(revision )
+++ node_modules/eslint/lib/load-rules.js	(revision )
@@ -1,50 +0,0 @@
-/**
- * @fileoverview Module for loading rules from files and directories.
- * @author Michael Ficarra
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const fs = require("fs"),
-    path = require("path");
-
-const rulesDirCache = {};
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * Load all rule modules from specified directory.
- * @param {string} [rulesDir] Path to rules directory, may be relative. Defaults to `lib/rules`.
- * @param {string} cwd Current working directory
- * @returns {Object} Loaded rule modules by rule ids (file names).
- */
-module.exports = function(rulesDir, cwd) {
-    if (!rulesDir) {
-        rulesDir = path.join(__dirname, "rules");
-    } else {
-        rulesDir = path.resolve(cwd, rulesDir);
-    }
-
-    // cache will help performance as IO operation are expensive
-    if (rulesDirCache[rulesDir]) {
-        return rulesDirCache[rulesDir];
-    }
-
-    const rules = Object.create(null);
-
-    fs.readdirSync(rulesDir).forEach(file => {
-        if (path.extname(file) !== ".js") {
-            return;
-        }
-        rules[file.slice(0, -3)] = path.join(rulesDir, file);
-    });
-    rulesDirCache[rulesDir] = rules;
-
-    return rules;
-};
Index: node_modules/eslint/lib/file-finder.js
===================================================================
--- node_modules/eslint/lib/file-finder.js	(revision )
+++ node_modules/eslint/lib/file-finder.js	(revision )
@@ -1,145 +0,0 @@
-/**
- * @fileoverview Util class to find config files.
- * @author Aliaksei Shytkin
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const fs = require("fs"),
-    path = require("path");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Get the entries for a directory. Including a try-catch may be detrimental to
- * function performance, so move it out here a separate function.
- * @param {string} directory The directory to search in.
- * @returns {string[]} The entries in the directory or an empty array on error.
- * @private
- */
-function getDirectoryEntries(directory) {
-    try {
-
-        return fs.readdirSync(directory);
-    } catch (ex) {
-        return [];
-    }
-}
-
-/**
- * Create a hash of filenames from a directory listing
- * @param {string[]} entries Array of directory entries.
- * @param {string} directory Path to a current directory.
- * @param {string[]} supportedConfigs List of support filenames.
- * @returns {Object} Hashmap of filenames
- */
-function normalizeDirectoryEntries(entries, directory, supportedConfigs) {
-    const fileHash = {};
-
-    entries.forEach(entry => {
-        if (supportedConfigs.indexOf(entry) >= 0) {
-            const resolvedEntry = path.resolve(directory, entry);
-
-            if (fs.statSync(resolvedEntry).isFile()) {
-                fileHash[entry] = resolvedEntry;
-            }
-        }
-    });
-    return fileHash;
-}
-
-//------------------------------------------------------------------------------
-// API
-//------------------------------------------------------------------------------
-
-/**
- * FileFinder class
- */
-class FileFinder {
-
-    /**
-     * @param {string[]} files The basename(s) of the file(s) to find.
-     * @param {stirng} cwd Current working directory
-     */
-    constructor(files, cwd) {
-        this.fileNames = Array.isArray(files) ? files : [files];
-        this.cwd = cwd || process.cwd();
-        this.cache = {};
-    }
-
-    /**
-     * Find all instances of files with the specified file names, in directory and
-     * parent directories. Cache the results.
-     * Does not check if a matching directory entry is a file.
-     * Searches for all the file names in this.fileNames.
-     * Is currently used by lib/config.js to find .eslintrc and package.json files.
-     * @param  {string} directory The directory to start the search from.
-     * @returns {GeneratorFunction} to iterate the file paths found
-     */
-    *findAllInDirectoryAndParents(directory) {
-        const cache = this.cache;
-
-        if (directory) {
-            directory = path.resolve(this.cwd, directory);
-        } else {
-            directory = this.cwd;
-        }
-
-        if (cache.hasOwnProperty(directory)) {
-            yield* cache[directory];
-            return; // to avoid doing the normal loop afterwards
-        }
-
-        const dirs = [];
-        const fileNames = this.fileNames;
-        let searched = 0;
-
-        do {
-            dirs[searched++] = directory;
-            cache[directory] = [];
-
-            const filesMap = normalizeDirectoryEntries(getDirectoryEntries(directory), directory, fileNames);
-
-            if (Object.keys(filesMap).length) {
-                for (let k = 0; k < fileNames.length; k++) {
-
-                    if (filesMap[fileNames[k]]) {
-                        const filePath = filesMap[fileNames[k]];
-
-                        // Add the file path to the cache of each directory searched.
-                        for (let j = 0; j < searched; j++) {
-                            cache[dirs[j]].push(filePath);
-                        }
-                        yield filePath;
-                        break;
-                    }
-                }
-            }
-
-            const child = directory;
-
-            // Assign parent directory to directory.
-            directory = path.dirname(directory);
-
-            if (directory === child) {
-                return;
-            }
-
-        } while (!cache.hasOwnProperty(directory));
-
-        // Add what has been cached previously to the cache of each directory searched.
-        for (let i = 0; i < searched; i++) {
-            dirs.push.apply(cache[dirs[i]], cache[directory]);
-        }
-
-        yield* cache[dirs[0]];
-    }
-}
-
-module.exports = FileFinder;
Index: node_modules/eslint/lib/internal-rules/internal-no-invalid-meta.js
===================================================================
--- node_modules/eslint/lib/internal-rules/internal-no-invalid-meta.js	(revision )
+++ node_modules/eslint/lib/internal-rules/internal-no-invalid-meta.js	(revision )
@@ -1,188 +0,0 @@
-/**
- * @fileoverview Internal rule to prevent missing or invalid meta property in core rules.
- * @author Vitor Balocco
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Gets the property of the Object node passed in that has the name specified.
- *
- * @param {string} property Name of the property to return.
- * @param {ASTNode} node The ObjectExpression node.
- * @returns {ASTNode} The Property node or null if not found.
- */
-function getPropertyFromObject(property, node) {
-    const properties = node.properties;
-
-    for (let i = 0; i < properties.length; i++) {
-        if (properties[i].key.name === property) {
-            return properties[i];
-        }
-    }
-
-    return null;
-}
-
-/**
- * Extracts the `meta` property from the ObjectExpression that all rules export.
- *
- * @param {ASTNode} exportsNode ObjectExpression node that the rule exports.
- * @returns {ASTNode} The `meta` Property node or null if not found.
- */
-function getMetaPropertyFromExportsNode(exportsNode) {
-    return getPropertyFromObject("meta", exportsNode);
-}
-
-/**
- * Whether this `meta` ObjectExpression has a `docs` property defined or not.
- *
- * @param {ASTNode} metaPropertyNode The `meta` ObjectExpression for this rule.
- * @returns {boolean} `true` if a `docs` property exists.
- */
-function hasMetaDocs(metaPropertyNode) {
-    return Boolean(getPropertyFromObject("docs", metaPropertyNode.value));
-}
-
-/**
- * Whether this `meta` ObjectExpression has a `docs.description` property defined or not.
- *
- * @param {ASTNode} metaPropertyNode The `meta` ObjectExpression for this rule.
- * @returns {boolean} `true` if a `docs.description` property exists.
- */
-function hasMetaDocsDescription(metaPropertyNode) {
-    const metaDocs = getPropertyFromObject("docs", metaPropertyNode.value);
-
-    return metaDocs && getPropertyFromObject("description", metaDocs.value);
-}
-
-/**
- * Whether this `meta` ObjectExpression has a `docs.category` property defined or not.
- *
- * @param {ASTNode} metaPropertyNode The `meta` ObjectExpression for this rule.
- * @returns {boolean} `true` if a `docs.category` property exists.
- */
-function hasMetaDocsCategory(metaPropertyNode) {
-    const metaDocs = getPropertyFromObject("docs", metaPropertyNode.value);
-
-    return metaDocs && getPropertyFromObject("category", metaDocs.value);
-}
-
-/**
- * Whether this `meta` ObjectExpression has a `docs.recommended` property defined or not.
- *
- * @param {ASTNode} metaPropertyNode The `meta` ObjectExpression for this rule.
- * @returns {boolean} `true` if a `docs.recommended` property exists.
- */
-function hasMetaDocsRecommended(metaPropertyNode) {
-    const metaDocs = getPropertyFromObject("docs", metaPropertyNode.value);
-
-    return metaDocs && getPropertyFromObject("recommended", metaDocs.value);
-}
-
-/**
- * Whether this `meta` ObjectExpression has a `schema` property defined or not.
- *
- * @param {ASTNode} metaPropertyNode The `meta` ObjectExpression for this rule.
- * @returns {boolean} `true` if a `schema` property exists.
- */
-function hasMetaSchema(metaPropertyNode) {
-    return getPropertyFromObject("schema", metaPropertyNode.value);
-}
-
-/**
- * Checks the validity of the meta definition of this rule and reports any errors found.
- *
- * @param {RuleContext} context The ESLint rule context.
- * @param {ASTNode} exportsNode ObjectExpression node that the rule exports.
- * @param {boolean} ruleIsFixable whether the rule is fixable or not.
- * @returns {void}
- */
-function checkMetaValidity(context, exportsNode) {
-    const metaProperty = getMetaPropertyFromExportsNode(exportsNode);
-
-    if (!metaProperty) {
-        context.report(exportsNode, "Rule is missing a meta property.");
-        return;
-    }
-
-    if (!hasMetaDocs(metaProperty)) {
-        context.report(metaProperty, "Rule is missing a meta.docs property.");
-        return;
-    }
-
-    if (!hasMetaDocsDescription(metaProperty)) {
-        context.report(metaProperty, "Rule is missing a meta.docs.description property.");
-        return;
-    }
-
-    if (!hasMetaDocsCategory(metaProperty)) {
-        context.report(metaProperty, "Rule is missing a meta.docs.category property.");
-        return;
-    }
-
-    if (!hasMetaDocsRecommended(metaProperty)) {
-        context.report(metaProperty, "Rule is missing a meta.docs.recommended property.");
-        return;
-    }
-
-    if (!hasMetaSchema(metaProperty)) {
-        context.report(metaProperty, "Rule is missing a meta.schema property.");
-    }
-}
-
-/**
- * Whether this node is the correct format for a rule definition or not.
- *
- * @param {ASTNode} node node that the rule exports.
- * @returns {boolean} `true` if the exported node is the correct format for a rule definition
- */
-function isCorrectExportsFormat(node) {
-    return node.type === "ObjectExpression";
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce correct use of `meta` property in core rules",
-            category: "Internal",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        let exportsNode;
-
-        return {
-            AssignmentExpression(node) {
-                if (node.left &&
-                    node.right &&
-                    node.left.type === "MemberExpression" &&
-                    node.left.object.name === "module" &&
-                    node.left.property.name === "exports") {
-
-                    exportsNode = node.right;
-                }
-            },
-
-            "Program:exit"() {
-                if (!isCorrectExportsFormat(exportsNode)) {
-                    context.report({ node: exportsNode, message: "Rule does not export an Object. Make sure the rule follows the new rule format." });
-                    return;
-                }
-
-                checkMetaValidity(context, exportsNode);
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/internal-rules/internal-consistent-docs-description.js
===================================================================
--- node_modules/eslint/lib/internal-rules/internal-consistent-docs-description.js	(revision )
+++ node_modules/eslint/lib/internal-rules/internal-consistent-docs-description.js	(revision )
@@ -1,130 +0,0 @@
-/**
- * @fileoverview Internal rule to enforce meta.docs.description conventions.
- * @author Vitor Balocco
- */
-
-"use strict";
-
-const ALLOWED_FIRST_WORDS = [
-    "enforce",
-    "require",
-    "disallow"
-];
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Gets the property of the Object node passed in that has the name specified.
- *
- * @param {string} property Name of the property to return.
- * @param {ASTNode} node The ObjectExpression node.
- * @returns {ASTNode} The Property node or null if not found.
- */
-function getPropertyFromObject(property, node) {
-    const properties = node.properties;
-
-    for (let i = 0; i < properties.length; i++) {
-        if (properties[i].key.name === property) {
-            return properties[i];
-        }
-    }
-
-    return null;
-}
-
-/**
- * Verifies that the meta.docs.description property follows our internal conventions.
- *
- * @param {RuleContext} context The ESLint rule context.
- * @param {ASTNode} exportsNode ObjectExpression node that the rule exports.
- * @returns {void}
- */
-function checkMetaDocsDescription(context, exportsNode) {
-    if (exportsNode.type !== "ObjectExpression") {
-
-        // if the exported node is not the correct format, "internal-no-invalid-meta" will already report this.
-        return;
-    }
-
-    const metaProperty = getPropertyFromObject("meta", exportsNode);
-    const metaDocs = metaProperty && getPropertyFromObject("docs", metaProperty.value);
-    const metaDocsDescription = metaDocs && getPropertyFromObject("description", metaDocs.value);
-
-    if (!metaDocsDescription) {
-
-        // if there is no `meta.docs.description` property, "internal-no-invalid-meta" will already report this.
-        return;
-    }
-
-    const description = metaDocsDescription.value.value;
-
-    if (typeof description !== "string") {
-        context.report({
-            node: metaDocsDescription.value,
-            message: "`meta.docs.description` should be a string."
-        });
-        return;
-    }
-
-    if (description === "") {
-        context.report({
-            node: metaDocsDescription.value,
-            message: "`meta.docs.description` should not be empty."
-        });
-        return;
-    }
-
-    if (description.indexOf(" ") === 0) {
-        context.report({
-            node: metaDocsDescription.value,
-            message: "`meta.docs.description` should not start with whitespace."
-        });
-        return;
-    }
-
-    const firstWord = description.split(" ")[0];
-
-    if (ALLOWED_FIRST_WORDS.indexOf(firstWord) === -1) {
-        context.report({
-            node: metaDocsDescription.value,
-            message: "`meta.docs.description` should start with one of the following words: {{ allowedWords }}. Started with \"{{ firstWord }}\" instead.",
-            data: {
-                allowedWords: ALLOWED_FIRST_WORDS.join(", "),
-                firstWord
-            }
-        });
-    }
-}
-
-//------------------------------------------------------------------------------
-// Rule Definition
-//------------------------------------------------------------------------------
-
-module.exports = {
-    meta: {
-        docs: {
-            description: "enforce correct conventions of `meta.docs.description` property in core rules",
-            category: "Internal",
-            recommended: false
-        },
-
-        schema: []
-    },
-
-    create(context) {
-        return {
-            AssignmentExpression(node) {
-                if (node.left &&
-                    node.right &&
-                    node.left.type === "MemberExpression" &&
-                    node.left.object.name === "module" &&
-                    node.left.property.name === "exports") {
-
-                    checkMetaDocsDescription(context, node.right);
-                }
-            }
-        };
-    }
-};
Index: node_modules/eslint/lib/ignored-paths.js
===================================================================
--- node_modules/eslint/lib/ignored-paths.js	(revision )
+++ node_modules/eslint/lib/ignored-paths.js	(revision )
@@ -1,287 +0,0 @@
-/**
- * @fileoverview Responsible for loading ignore config files and managing ignore patterns
- * @author Jonathan Rajavuori
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const fs = require("fs"),
-    path = require("path"),
-    ignore = require("ignore"),
-    pathUtil = require("./util/path-util");
-
-const debug = require("debug")("eslint:ignored-paths");
-
-//------------------------------------------------------------------------------
-// Constants
-//------------------------------------------------------------------------------
-
-const ESLINT_IGNORE_FILENAME = ".eslintignore";
-
-/**
- * Adds `"*"` at the end of `"node_modules/"`,
- * so that subtle directories could be re-included by .gitignore patterns
- * such as `"!node_modules/should_not_ignored"`
- */
-const DEFAULT_IGNORE_DIRS = [
-    "/node_modules/*",
-    "/bower_components/*"
-];
-const DEFAULT_OPTIONS = {
-    dotfiles: false,
-    cwd: process.cwd()
-};
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Find a file in the current directory.
- * @param {string} cwd Current working directory
- * @param {string} name File name
- * @returns {string} Path of ignore file or an empty string.
- */
-function findFile(cwd, name) {
-    const ignoreFilePath = path.resolve(cwd, name);
-
-    return fs.existsSync(ignoreFilePath) && fs.statSync(ignoreFilePath).isFile() ? ignoreFilePath : "";
-}
-
-/**
- * Find an ignore file in the current directory.
- * @param {string} cwd Current working directory
- * @returns {string} Path of ignore file or an empty string.
- */
-function findIgnoreFile(cwd) {
-    return findFile(cwd, ESLINT_IGNORE_FILENAME);
-}
-
-/**
- * Find an package.json file in the current directory.
- * @param {string} cwd Current working directory
- * @returns {string} Path of package.json file or an empty string.
- */
-function findPackageJSONFile(cwd) {
-    return findFile(cwd, "package.json");
-}
-
-/**
- * Merge options with defaults
- * @param {Object} options Options to merge with DEFAULT_OPTIONS constant
- * @returns {Object} Merged options
- */
-function mergeDefaultOptions(options) {
-    options = (options || {});
-    return Object.assign({}, DEFAULT_OPTIONS, options);
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * IgnoredPaths class
- */
-class IgnoredPaths {
-
-    /**
-     * @param {Object} options object containing 'ignore', 'ignorePath' and 'patterns' properties
-     */
-    constructor(options) {
-        options = mergeDefaultOptions(options);
-        this.cache = {};
-
-        /**
-         * add pattern to node-ignore instance
-         * @param {Object} ig, instance of node-ignore
-         * @param {string} pattern, pattern do add to ig
-         * @returns {array} raw ignore rules
-         */
-        function addPattern(ig, pattern) {
-            return ig.addPattern(pattern);
-        }
-
-        this.defaultPatterns = [].concat(DEFAULT_IGNORE_DIRS, options.patterns || []);
-        this.baseDir = options.cwd;
-
-        this.ig = {
-            custom: ignore(),
-            default: ignore()
-        };
-
-        // Add a way to keep track of ignored files.  This was present in node-ignore
-        // 2.x, but dropped for now as of 3.0.10.
-        this.ig.custom.ignoreFiles = [];
-        this.ig.default.ignoreFiles = [];
-
-        if (options.dotfiles !== true) {
-
-            /*
-             * ignore files beginning with a dot, but not files in a parent or
-             * ancestor directory (which in relative format will begin with `../`).
-             */
-            addPattern(this.ig.default, [".*", "!../"]);
-        }
-
-        addPattern(this.ig.default, this.defaultPatterns);
-
-        if (options.ignore !== false) {
-            let ignorePath;
-
-            if (options.ignorePath) {
-                debug("Using specific ignore file");
-
-                try {
-                    fs.statSync(options.ignorePath);
-                    ignorePath = options.ignorePath;
-                } catch (e) {
-                    e.message = `Cannot read ignore file: ${options.ignorePath}\nError: ${e.message}`;
-                    throw e;
-                }
-            } else {
-                debug(`Looking for ignore file in ${options.cwd}`);
-                ignorePath = findIgnoreFile(options.cwd);
-
-                try {
-                    fs.statSync(ignorePath);
-                    debug(`Loaded ignore file ${ignorePath}`);
-                } catch (e) {
-                    debug("Could not find ignore file in cwd");
-                    this.options = options;
-                }
-            }
-
-            if (ignorePath) {
-                debug(`Adding ${ignorePath}`);
-                this.baseDir = path.dirname(path.resolve(options.cwd, ignorePath));
-                this.addIgnoreFile(this.ig.custom, ignorePath);
-                this.addIgnoreFile(this.ig.default, ignorePath);
-            } else {
-                try {
-
-                    // if the ignoreFile does not exist, check package.json for eslintIgnore
-                    const packageJSONPath = findPackageJSONFile(options.cwd);
-
-                    if (packageJSONPath) {
-                        let packageJSONOptions;
-
-                        try {
-                            packageJSONOptions = JSON.parse(fs.readFileSync(packageJSONPath, "utf8"));
-                        } catch (e) {
-                            debug("Could not read package.json file to check eslintIgnore property");
-                            throw e;
-                        }
-
-                        if (packageJSONOptions.eslintIgnore) {
-                            if (Array.isArray(packageJSONOptions.eslintIgnore)) {
-                                packageJSONOptions.eslintIgnore.forEach(pattern => {
-                                    addPattern(this.ig.custom, pattern);
-                                    addPattern(this.ig.default, pattern);
-                                });
-                            } else {
-                                throw new Error("Package.json eslintIgnore property requires an array of paths");
-                            }
-                        }
-                    }
-                } catch (e) {
-                    debug("Could not find package.json to check eslintIgnore property");
-                    throw e;
-                }
-            }
-
-            if (options.ignorePattern) {
-                addPattern(this.ig.custom, options.ignorePattern);
-                addPattern(this.ig.default, options.ignorePattern);
-            }
-        }
-
-        this.options = options;
-    }
-
-    /**
-     * read ignore filepath
-     * @param {string} filePath, file to add to ig
-     * @returns {array} raw ignore rules
-     */
-    readIgnoreFile(filePath) {
-        if (typeof this.cache[filePath] === "undefined") {
-            this.cache[filePath] = fs.readFileSync(filePath, "utf8");
-        }
-        return this.cache[filePath];
-    }
-
-    /**
-     * add ignore file to node-ignore instance
-     * @param {Object} ig, instance of node-ignore
-     * @param {string} filePath, file to add to ig
-     * @returns {array} raw ignore rules
-     */
-    addIgnoreFile(ig, filePath) {
-        ig.ignoreFiles.push(filePath);
-        return ig.add(this.readIgnoreFile(filePath));
-    }
-
-    /**
-     * Determine whether a file path is included in the default or custom ignore patterns
-     * @param {string} filepath Path to check
-     * @param {string} [category=null] check 'default', 'custom' or both (null)
-     * @returns {boolean} true if the file path matches one or more patterns, false otherwise
-     */
-    contains(filepath, category) {
-
-        let result = false;
-        const absolutePath = path.resolve(this.options.cwd, filepath);
-        const relativePath = pathUtil.getRelativePath(absolutePath, this.baseDir);
-
-        if ((typeof category === "undefined") || (category === "default")) {
-            result = result || (this.ig.default.filter([relativePath]).length === 0);
-        }
-
-        if ((typeof category === "undefined") || (category === "custom")) {
-            result = result || (this.ig.custom.filter([relativePath]).length === 0);
-        }
-
-        return result;
-
-    }
-
-    /**
-     * Returns a list of dir patterns for glob to ignore
-     * @returns {function()} method to check whether a folder should be ignored by glob.
-     */
-    getIgnoredFoldersGlobChecker() {
-
-        const ig = ignore().add(DEFAULT_IGNORE_DIRS);
-
-        if (this.options.dotfiles !== true) {
-
-            // Ignore hidden folders.  (This cannot be ".*", or else it's not possible to unignore hidden files)
-            ig.add([".*/*", "!../"]);
-        }
-
-        if (this.options.ignore) {
-            ig.add(this.ig.custom);
-        }
-
-        const filter = ig.createFilter();
-
-        const base = this.baseDir;
-
-        return function(absolutePath) {
-            const relative = pathUtil.getRelativePath(absolutePath, base);
-
-            if (!relative) {
-                return false;
-            }
-
-            return !filter(relative);
-        };
-    }
-}
-
-module.exports = IgnoredPaths;
Index: node_modules/eslint/lib/code-path-analysis/code-path.js
===================================================================
--- node_modules/eslint/lib/code-path-analysis/code-path.js	(revision )
+++ node_modules/eslint/lib/code-path-analysis/code-path.js	(revision )
@@ -1,234 +0,0 @@
-/**
- * @fileoverview A class of the code path.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const CodePathState = require("./code-path-state");
-const IdGenerator = require("./id-generator");
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * A code path.
- */
-class CodePath {
-
-    /**
-     * @param {string} id - An identifier.
-     * @param {CodePath|null} upper - The code path of the upper function scope.
-     * @param {Function} onLooped - A callback function to notify looping.
-     */
-    constructor(id, upper, onLooped) {
-
-        /**
-         * The identifier of this code path.
-         * Rules use it to store additional information of each rule.
-         * @type {string}
-         */
-        this.id = id;
-
-        /**
-         * The code path of the upper function scope.
-         * @type {CodePath|null}
-         */
-        this.upper = upper;
-
-        /**
-         * The code paths of nested function scopes.
-         * @type {CodePath[]}
-         */
-        this.childCodePaths = [];
-
-        // Initializes internal state.
-        Object.defineProperty(
-            this,
-            "internal",
-            { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) }
-        );
-
-        // Adds this into `childCodePaths` of `upper`.
-        if (upper) {
-            upper.childCodePaths.push(this);
-        }
-    }
-
-    /**
-     * Gets the state of a given code path.
-     *
-     * @param {CodePath} codePath - A code path to get.
-     * @returns {CodePathState} The state of the code path.
-     */
-    static getState(codePath) {
-        return codePath.internal;
-    }
-
-    /**
-     * The initial code path segment.
-     * @type {CodePathSegment}
-     */
-    get initialSegment() {
-        return this.internal.initialSegment;
-    }
-
-    /**
-     * Final code path segments.
-     * This array is a mix of `returnedSegments` and `thrownSegments`.
-     * @type {CodePathSegment[]}
-     */
-    get finalSegments() {
-        return this.internal.finalSegments;
-    }
-
-    /**
-     * Final code path segments which is with `return` statements.
-     * This array contains the last path segment if it's reachable.
-     * Since the reachable last path returns `undefined`.
-     * @type {CodePathSegment[]}
-     */
-    get returnedSegments() {
-        return this.internal.returnedForkContext;
-    }
-
-    /**
-     * Final code path segments which is with `throw` statements.
-     * @type {CodePathSegment[]}
-     */
-    get thrownSegments() {
-        return this.internal.thrownForkContext;
-    }
-
-    /**
-     * Current code path segments.
-     * @type {CodePathSegment[]}
-     */
-    get currentSegments() {
-        return this.internal.currentSegments;
-    }
-
-    /**
-     * Traverses all segments in this code path.
-     *
-     *     codePath.traverseSegments(function(segment, controller) {
-     *         // do something.
-     *     });
-     *
-     * This method enumerates segments in order from the head.
-     *
-     * The `controller` object has two methods.
-     *
-     * - `controller.skip()` - Skip the following segments in this branch.
-     * - `controller.break()` - Skip all following segments.
-     *
-     * @param {Object} [options] - Omittable.
-     * @param {CodePathSegment} [options.first] - The first segment to traverse.
-     * @param {CodePathSegment} [options.last] - The last segment to traverse.
-     * @param {Function} callback - A callback function.
-     * @returns {void}
-     */
-    traverseSegments(options, callback) {
-        if (typeof options === "function") {
-            callback = options;
-            options = null;
-        }
-
-        options = options || {};
-        const startSegment = options.first || this.internal.initialSegment;
-        const lastSegment = options.last;
-
-        let item = null;
-        let index = 0;
-        let end = 0;
-        let segment = null;
-        const visited = Object.create(null);
-        const stack = [[startSegment, 0]];
-        let skippedSegment = null;
-        let broken = false;
-        const controller = {
-            skip() {
-                if (stack.length <= 1) {
-                    broken = true;
-                } else {
-                    skippedSegment = stack[stack.length - 2][0];
-                }
-            },
-            break() {
-                broken = true;
-            }
-        };
-
-        /**
-         * Checks a given previous segment has been visited.
-         * @param {CodePathSegment} prevSegment - A previous segment to check.
-         * @returns {boolean} `true` if the segment has been visited.
-         */
-        function isVisited(prevSegment) {
-            return (
-                visited[prevSegment.id] ||
-                segment.isLoopedPrevSegment(prevSegment)
-            );
-        }
-
-        while (stack.length > 0) {
-            item = stack[stack.length - 1];
-            segment = item[0];
-            index = item[1];
-
-            if (index === 0) {
-
-                // Skip if this segment has been visited already.
-                if (visited[segment.id]) {
-                    stack.pop();
-                    continue;
-                }
-
-                // Skip if all previous segments have not been visited.
-                if (segment !== startSegment &&
-                    segment.prevSegments.length > 0 &&
-                    !segment.prevSegments.every(isVisited)
-                ) {
-                    stack.pop();
-                    continue;
-                }
-
-                // Reset the flag of skipping if all branches have been skipped.
-                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {
-                    skippedSegment = null;
-                }
-                visited[segment.id] = true;
-
-                // Call the callback when the first time.
-                if (!skippedSegment) {
-                    callback.call(this, segment, controller);
-                    if (segment === lastSegment) {
-                        controller.skip();
-                    }
-                    if (broken) {
-                        break;
-                    }
-                }
-            }
-
-            // Update the stack.
-            end = segment.nextSegments.length - 1;
-            if (index < end) {
-                item[1] += 1;
-                stack.push([segment.nextSegments[index], 0]);
-            } else if (index === end) {
-                item[0] = segment.nextSegments[index];
-                item[1] = 0;
-            } else {
-                stack.pop();
-            }
-        }
-    }
-}
-
-module.exports = CodePath;
Index: node_modules/eslint/lib/code-path-analysis/fork-context.js
===================================================================
--- node_modules/eslint/lib/code-path-analysis/fork-context.js	(revision )
+++ node_modules/eslint/lib/code-path-analysis/fork-context.js	(revision )
@@ -1,262 +0,0 @@
-/**
- * @fileoverview A class to operate forking.
- *
- * This is state of forking.
- * This has a fork list and manages it.
- *
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const assert = require("assert"),
-    CodePathSegment = require("./code-path-segment");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Gets whether or not a given segment is reachable.
- *
- * @param {CodePathSegment} segment - A segment to get.
- * @returns {boolean} `true` if the segment is reachable.
- */
-function isReachable(segment) {
-    return segment.reachable;
-}
-
-/**
- * Creates new segments from the specific range of `context.segmentsList`.
- *
- * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and
- * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.
- * This `h` is from `b`, `d`, and `f`.
- *
- * @param {ForkContext} context - An instance.
- * @param {number} begin - The first index of the previous segments.
- * @param {number} end - The last index of the previous segments.
- * @param {Function} create - A factory function of new segments.
- * @returns {CodePathSegment[]} New segments.
- */
-function makeSegments(context, begin, end, create) {
-    const list = context.segmentsList;
-
-    if (begin < 0) {
-        begin = list.length + begin;
-    }
-    if (end < 0) {
-        end = list.length + end;
-    }
-
-    const segments = [];
-
-    for (let i = 0; i < context.count; ++i) {
-        const allPrevSegments = [];
-
-        for (let j = begin; j <= end; ++j) {
-            allPrevSegments.push(list[j][i]);
-        }
-
-        segments.push(create(context.idGenerator.next(), allPrevSegments));
-    }
-
-    return segments;
-}
-
-/**
- * `segments` becomes doubly in a `finally` block. Then if a code path exits by a
- * control statement (such as `break`, `continue`) from the `finally` block, the
- * destination's segments may be half of the source segments. In that case, this
- * merges segments.
- *
- * @param {ForkContext} context - An instance.
- * @param {CodePathSegment[]} segments - Segments to merge.
- * @returns {CodePathSegment[]} The merged segments.
- */
-function mergeExtraSegments(context, segments) {
-    while (segments.length > context.count) {
-        const merged = [];
-
-        for (let i = 0, length = segments.length / 2 | 0; i < length; ++i) {
-            merged.push(CodePathSegment.newNext(
-                context.idGenerator.next(),
-                [segments[i], segments[i + length]]
-            ));
-        }
-        segments = merged;
-    }
-    return segments;
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * A class to manage forking.
- */
-class ForkContext {
-
-    /**
-     * @param {IdGenerator} idGenerator - An identifier generator for segments.
-     * @param {ForkContext|null} upper - An upper fork context.
-     * @param {number} count - A number of parallel segments.
-     */
-    constructor(idGenerator, upper, count) {
-        this.idGenerator = idGenerator;
-        this.upper = upper;
-        this.count = count;
-        this.segmentsList = [];
-    }
-
-    /**
-     * The head segments.
-     * @type {CodePathSegment[]}
-     */
-    get head() {
-        const list = this.segmentsList;
-
-        return list.length === 0 ? [] : list[list.length - 1];
-    }
-
-    /**
-     * A flag which shows empty.
-     * @type {boolean}
-     */
-    get empty() {
-        return this.segmentsList.length === 0;
-    }
-
-    /**
-     * A flag which shows reachable.
-     * @type {boolean}
-     */
-    get reachable() {
-        const segments = this.head;
-
-        return segments.length > 0 && segments.some(isReachable);
-    }
-
-    /**
-     * Creates new segments from this context.
-     *
-     * @param {number} begin - The first index of previous segments.
-     * @param {number} end - The last index of previous segments.
-     * @returns {CodePathSegment[]} New segments.
-     */
-    makeNext(begin, end) {
-        return makeSegments(this, begin, end, CodePathSegment.newNext);
-    }
-
-    /**
-     * Creates new segments from this context.
-     * The new segments is always unreachable.
-     *
-     * @param {number} begin - The first index of previous segments.
-     * @param {number} end - The last index of previous segments.
-     * @returns {CodePathSegment[]} New segments.
-     */
-    makeUnreachable(begin, end) {
-        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);
-    }
-
-    /**
-     * Creates new segments from this context.
-     * The new segments don't have connections for previous segments.
-     * But these inherit the reachable flag from this context.
-     *
-     * @param {number} begin - The first index of previous segments.
-     * @param {number} end - The last index of previous segments.
-     * @returns {CodePathSegment[]} New segments.
-     */
-    makeDisconnected(begin, end) {
-        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);
-    }
-
-    /**
-     * Adds segments into this context.
-     * The added segments become the head.
-     *
-     * @param {CodePathSegment[]} segments - Segments to add.
-     * @returns {void}
-     */
-    add(segments) {
-        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
-
-        this.segmentsList.push(mergeExtraSegments(this, segments));
-    }
-
-    /**
-     * Replaces the head segments with given segments.
-     * The current head segments are removed.
-     *
-     * @param {CodePathSegment[]} segments - Segments to add.
-     * @returns {void}
-     */
-    replaceHead(segments) {
-        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
-
-        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));
-    }
-
-    /**
-     * Adds all segments of a given fork context into this context.
-     *
-     * @param {ForkContext} context - A fork context to add.
-     * @returns {void}
-     */
-    addAll(context) {
-        assert(context.count === this.count);
-
-        const source = context.segmentsList;
-
-        for (let i = 0; i < source.length; ++i) {
-            this.segmentsList.push(source[i]);
-        }
-    }
-
-    /**
-     * Clears all secments in this context.
-     *
-     * @returns {void}
-     */
-    clear() {
-        this.segmentsList = [];
-    }
-
-    /**
-     * Creates the root fork context.
-     *
-     * @param {IdGenerator} idGenerator - An identifier generator for segments.
-     * @returns {ForkContext} New fork context.
-     */
-    static newRoot(idGenerator) {
-        const context = new ForkContext(idGenerator, null, 1);
-
-        context.add([CodePathSegment.newRoot(idGenerator.next())]);
-
-        return context;
-    }
-
-    /**
-     * Creates an empty fork context preceded by a given context.
-     *
-     * @param {ForkContext} parentContext - The parent fork context.
-     * @param {boolean} forkLeavingPath - A flag which shows inside of `finally` block.
-     * @returns {ForkContext} New fork context.
-     */
-    static newEmpty(parentContext, forkLeavingPath) {
-        return new ForkContext(
-            parentContext.idGenerator,
-            parentContext,
-            (forkLeavingPath ? 2 : 1) * parentContext.count
-        );
-    }
-}
-
-module.exports = ForkContext;
Index: node_modules/eslint/lib/code-path-analysis/id-generator.js
===================================================================
--- node_modules/eslint/lib/code-path-analysis/id-generator.js	(revision )
+++ node_modules/eslint/lib/code-path-analysis/id-generator.js	(revision )
@@ -1,46 +0,0 @@
-/**
- * @fileoverview A class of identifiers generator for code path segments.
- *
- * Each rule uses the identifier of code path segments to store additional
- * information of the code path.
- *
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * A generator for unique ids.
- */
-class IdGenerator {
-
-    /**
-     * @param {string} prefix - Optional. A prefix of generated ids.
-     */
-    constructor(prefix) {
-        this.prefix = String(prefix);
-        this.n = 0;
-    }
-
-    /**
-     * Generates id.
-     *
-     * @returns {string} A generated id.
-     */
-    next() {
-        this.n = 1 + this.n | 0;
-
-        /* istanbul ignore if */
-        if (this.n < 0) {
-            this.n = 1;
-        }
-
-        return this.prefix + this.n;
-    }
-}
-
-module.exports = IdGenerator;
Index: node_modules/eslint/lib/code-path-analysis/debug-helpers.js
===================================================================
--- node_modules/eslint/lib/code-path-analysis/debug-helpers.js	(revision )
+++ node_modules/eslint/lib/code-path-analysis/debug-helpers.js	(revision )
@@ -1,200 +0,0 @@
-/**
- * @fileoverview Helpers to debug for code path analysis.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const debug = require("debug")("eslint:code-path");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Gets id of a given segment.
- * @param {CodePathSegment} segment - A segment to get.
- * @returns {string} Id of the segment.
- */
-/* istanbul ignore next */
-function getId(segment) { // eslint-disable-line require-jsdoc
-    return segment.id + (segment.reachable ? "" : "!");
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = {
-
-    /**
-     * A flag that debug dumping is enabled or not.
-     * @type {boolean}
-     */
-    enabled: debug.enabled,
-
-    /**
-     * Dumps given objects.
-     *
-     * @param {...any} args - objects to dump.
-     * @returns {void}
-     */
-    dump: debug,
-
-    /**
-     * Dumps the current analyzing state.
-     *
-     * @param {ASTNode} node - A node to dump.
-     * @param {CodePathState} state - A state to dump.
-     * @param {boolean} leaving - A flag whether or not it's leaving
-     * @returns {void}
-     */
-    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {
-        for (let i = 0; i < state.currentSegments.length; ++i) {
-            const segInternal = state.currentSegments[i].internal;
-
-            if (leaving) {
-                segInternal.exitNodes.push(node);
-            } else {
-                segInternal.nodes.push(node);
-            }
-        }
-
-        debug([
-            `${state.currentSegments.map(getId).join(",")})`,
-            `${node.type}${leaving ? ":exit" : ""}`
-        ].join(" "));
-    },
-
-    /**
-     * Dumps a DOT code of a given code path.
-     * The DOT code can be visialized with Graphvis.
-     *
-     * @param {CodePath} codePath - A code path to dump.
-     * @returns {void}
-     * @see http://www.graphviz.org
-     * @see http://www.webgraphviz.com
-     */
-    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {
-        let text =
-            "\n" +
-            "digraph {\n" +
-            "node[shape=box,style=\"rounded,filled\",fillcolor=white];\n" +
-            "initial[label=\"\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
-
-        if (codePath.returnedSegments.length > 0) {
-            text += "final[label=\"\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
-        }
-        if (codePath.thrownSegments.length > 0) {
-            text += "thrown[label=\"✘\",shape=circle,width=0.3,height=0.3,fixedsize];\n";
-        }
-
-        const traceMap = Object.create(null);
-        const arrows = this.makeDotArrows(codePath, traceMap);
-
-        for (const id in traceMap) { // eslint-disable-line guard-for-in
-            const segment = traceMap[id];
-
-            text += `${id}[`;
-
-            if (segment.reachable) {
-                text += "label=\"";
-            } else {
-                text += "style=\"rounded,dashed,filled\",fillcolor=\"#FF9800\",label=\"<<unreachable>>\\n";
-            }
-
-            if (segment.internal.nodes.length > 0 || segment.internal.exitNodes.length > 0) {
-                text += [].concat(
-                    segment.internal.nodes.map(node => {
-                        switch (node.type) {
-                            case "Identifier": return `${node.type} (${node.name})`;
-                            case "Literal": return `${node.type} (${node.value})`;
-                            default: return node.type;
-                        }
-                    }),
-                    segment.internal.exitNodes.map(node => {
-                        switch (node.type) {
-                            case "Identifier": return `${node.type}:exit (${node.name})`;
-                            case "Literal": return `${node.type}:exit (${node.value})`;
-                            default: return `${node.type}:exit`;
-                        }
-                    })
-                ).join("\\n");
-            } else {
-                text += "????";
-            }
-
-            text += "\"];\n";
-        }
-
-        text += `${arrows}\n`;
-        text += "}";
-        debug("DOT", text);
-    },
-
-    /**
-     * Makes a DOT code of a given code path.
-     * The DOT code can be visialized with Graphvis.
-     *
-     * @param {CodePath} codePath - A code path to make DOT.
-     * @param {Object} traceMap - Optional. A map to check whether or not segments had been done.
-     * @returns {string} A DOT code of the code path.
-     */
-    makeDotArrows(codePath, traceMap) {
-        const stack = [[codePath.initialSegment, 0]];
-        const done = traceMap || Object.create(null);
-        let lastId = codePath.initialSegment.id;
-        let text = `initial->${codePath.initialSegment.id}`;
-
-        while (stack.length > 0) {
-            const item = stack.pop();
-            const segment = item[0];
-            const index = item[1];
-
-            if (done[segment.id] && index === 0) {
-                continue;
-            }
-            done[segment.id] = segment;
-
-            const nextSegment = segment.allNextSegments[index];
-
-            if (!nextSegment) {
-                continue;
-            }
-
-            if (lastId === segment.id) {
-                text += `->${nextSegment.id}`;
-            } else {
-                text += `;\n${segment.id}->${nextSegment.id}`;
-            }
-            lastId = nextSegment.id;
-
-            stack.unshift([segment, 1 + index]);
-            stack.push([nextSegment, 0]);
-        }
-
-        codePath.returnedSegments.forEach(finalSegment => {
-            if (lastId === finalSegment.id) {
-                text += "->final";
-            } else {
-                text += `;\n${finalSegment.id}->final`;
-            }
-            lastId = null;
-        });
-
-        codePath.thrownSegments.forEach(finalSegment => {
-            if (lastId === finalSegment.id) {
-                text += "->thrown";
-            } else {
-                text += `;\n${finalSegment.id}->thrown`;
-            }
-            lastId = null;
-        });
-
-        return `${text};`;
-    }
-};
Index: node_modules/eslint/lib/code-path-analysis/code-path-state.js
===================================================================
--- node_modules/eslint/lib/code-path-analysis/code-path-state.js	(revision )
+++ node_modules/eslint/lib/code-path-analysis/code-path-state.js	(revision )
@@ -1,1435 +0,0 @@
-/**
- * @fileoverview A class to manage state of generating a code path.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const CodePathSegment = require("./code-path-segment"),
-    ForkContext = require("./fork-context");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Adds given segments into the `dest` array.
- * If the `others` array does not includes the given segments, adds to the `all`
- * array as well.
- *
- * This adds only reachable and used segments.
- *
- * @param {CodePathSegment[]} dest - A destination array (`returnedSegments` or `thrownSegments`).
- * @param {CodePathSegment[]} others - Another destination array (`returnedSegments` or `thrownSegments`).
- * @param {CodePathSegment[]} all - The unified destination array (`finalSegments`).
- * @param {CodePathSegment[]} segments - Segments to add.
- * @returns {void}
- */
-function addToReturnedOrThrown(dest, others, all, segments) {
-    for (let i = 0; i < segments.length; ++i) {
-        const segment = segments[i];
-
-        dest.push(segment);
-        if (others.indexOf(segment) === -1) {
-            all.push(segment);
-        }
-    }
-}
-
-/**
- * Gets a loop-context for a `continue` statement.
- *
- * @param {CodePathState} state - A state to get.
- * @param {string} label - The label of a `continue` statement.
- * @returns {LoopContext} A loop-context for a `continue` statement.
- */
-function getContinueContext(state, label) {
-    if (!label) {
-        return state.loopContext;
-    }
-
-    let context = state.loopContext;
-
-    while (context) {
-        if (context.label === label) {
-            return context;
-        }
-        context = context.upper;
-    }
-
-    /* istanbul ignore next: foolproof (syntax error) */
-    return null;
-}
-
-/**
- * Gets a context for a `break` statement.
- *
- * @param {CodePathState} state - A state to get.
- * @param {string} label - The label of a `break` statement.
- * @returns {LoopContext|SwitchContext} A context for a `break` statement.
- */
-function getBreakContext(state, label) {
-    let context = state.breakContext;
-
-    while (context) {
-        if (label ? context.label === label : context.breakable) {
-            return context;
-        }
-        context = context.upper;
-    }
-
-    /* istanbul ignore next: foolproof (syntax error) */
-    return null;
-}
-
-/**
- * Gets a context for a `return` statement.
- *
- * @param {CodePathState} state - A state to get.
- * @returns {TryContext|CodePathState} A context for a `return` statement.
- */
-function getReturnContext(state) {
-    let context = state.tryContext;
-
-    while (context) {
-        if (context.hasFinalizer && context.position !== "finally") {
-            return context;
-        }
-        context = context.upper;
-    }
-
-    return state;
-}
-
-/**
- * Gets a context for a `throw` statement.
- *
- * @param {CodePathState} state - A state to get.
- * @returns {TryContext|CodePathState} A context for a `throw` statement.
- */
-function getThrowContext(state) {
-    let context = state.tryContext;
-
-    while (context) {
-        if (context.position === "try" ||
-            (context.hasFinalizer && context.position === "catch")
-        ) {
-            return context;
-        }
-        context = context.upper;
-    }
-
-    return state;
-}
-
-/**
- * Removes a given element from a given array.
- *
- * @param {any[]} xs - An array to remove the specific element.
- * @param {any} x - An element to be removed.
- * @returns {void}
- */
-function remove(xs, x) {
-    xs.splice(xs.indexOf(x), 1);
-}
-
-/**
- * Disconnect given segments.
- *
- * This is used in a process for switch statements.
- * If there is the "default" chunk before other cases, the order is different
- * between node's and running's.
- *
- * @param {CodePathSegment[]} prevSegments - Forward segments to disconnect.
- * @param {CodePathSegment[]} nextSegments - Backward segments to disconnect.
- * @returns {void}
- */
-function removeConnection(prevSegments, nextSegments) {
-    for (let i = 0; i < prevSegments.length; ++i) {
-        const prevSegment = prevSegments[i];
-        const nextSegment = nextSegments[i];
-
-        remove(prevSegment.nextSegments, nextSegment);
-        remove(prevSegment.allNextSegments, nextSegment);
-        remove(nextSegment.prevSegments, prevSegment);
-        remove(nextSegment.allPrevSegments, prevSegment);
-    }
-}
-
-/**
- * Creates looping path.
- *
- * @param {CodePathState} state - The instance.
- * @param {CodePathSegment[]} fromSegments - Segments which are source.
- * @param {CodePathSegment[]} toSegments - Segments which are destination.
- * @returns {void}
- */
-function makeLooped(state, fromSegments, toSegments) {
-    const end = Math.min(fromSegments.length, toSegments.length);
-
-    for (let i = 0; i < end; ++i) {
-        const fromSegment = fromSegments[i];
-        const toSegment = toSegments[i];
-
-        if (toSegment.reachable) {
-            fromSegment.nextSegments.push(toSegment);
-        }
-        if (fromSegment.reachable) {
-            toSegment.prevSegments.push(fromSegment);
-        }
-        fromSegment.allNextSegments.push(toSegment);
-        toSegment.allPrevSegments.push(fromSegment);
-
-        if (toSegment.allPrevSegments.length >= 2) {
-            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
-        }
-
-        state.notifyLooped(fromSegment, toSegment);
-    }
-}
-
-/**
- * Finalizes segments of `test` chunk of a ForStatement.
- *
- * - Adds `false` paths to paths which are leaving from the loop.
- * - Sets `true` paths to paths which go to the body.
- *
- * @param {LoopContext} context - A loop context to modify.
- * @param {ChoiceContext} choiceContext - A choice context of this loop.
- * @param {CodePathSegment[]} head - The current head paths.
- * @returns {void}
- */
-function finalizeTestSegmentsOfFor(context, choiceContext, head) {
-    if (!choiceContext.processed) {
-        choiceContext.trueForkContext.add(head);
-        choiceContext.falseForkContext.add(head);
-    }
-
-    if (context.test !== true) {
-        context.brokenForkContext.addAll(choiceContext.falseForkContext);
-    }
-    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * A class which manages state to analyze code paths.
- */
-class CodePathState {
-
-    /**
-     * @param {IdGenerator} idGenerator - An id generator to generate id for code
-     *   path segments.
-     * @param {Function} onLooped - A callback function to notify looping.
-     */
-    constructor(idGenerator, onLooped) {
-        this.idGenerator = idGenerator;
-        this.notifyLooped = onLooped;
-        this.forkContext = ForkContext.newRoot(idGenerator);
-        this.choiceContext = null;
-        this.switchContext = null;
-        this.tryContext = null;
-        this.loopContext = null;
-        this.breakContext = null;
-
-        this.currentSegments = [];
-        this.initialSegment = this.forkContext.head[0];
-
-        // returnedSegments and thrownSegments push elements into finalSegments also.
-        const final = this.finalSegments = [];
-        const returned = this.returnedForkContext = [];
-        const thrown = this.thrownForkContext = [];
-
-        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
-        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
-    }
-
-    /**
-     * The head segments.
-     * @type {CodePathSegment[]}
-     */
-    get headSegments() {
-        return this.forkContext.head;
-    }
-
-    /**
-     * The parent forking context.
-     * This is used for the root of new forks.
-     * @type {ForkContext}
-     */
-    get parentForkContext() {
-        const current = this.forkContext;
-
-        return current && current.upper;
-    }
-
-    /**
-     * Creates and stacks new forking context.
-     *
-     * @param {boolean} forkLeavingPath - A flag which shows being in a
-     *   "finally" block.
-     * @returns {ForkContext} The created context.
-     */
-    pushForkContext(forkLeavingPath) {
-        this.forkContext = ForkContext.newEmpty(
-            this.forkContext,
-            forkLeavingPath
-        );
-
-        return this.forkContext;
-    }
-
-    /**
-     * Pops and merges the last forking context.
-     * @returns {ForkContext} The last context.
-     */
-    popForkContext() {
-        const lastContext = this.forkContext;
-
-        this.forkContext = lastContext.upper;
-        this.forkContext.replaceHead(lastContext.makeNext(0, -1));
-
-        return lastContext;
-    }
-
-    /**
-     * Creates a new path.
-     * @returns {void}
-     */
-    forkPath() {
-        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
-    }
-
-    /**
-     * Creates a bypass path.
-     * This is used for such as IfStatement which does not have "else" chunk.
-     *
-     * @returns {void}
-     */
-    forkBypassPath() {
-        this.forkContext.add(this.parentForkContext.head);
-    }
-
-    //--------------------------------------------------------------------------
-    // ConditionalExpression, LogicalExpression, IfStatement
-    //--------------------------------------------------------------------------
-
-    /**
-     * Creates a context for ConditionalExpression, LogicalExpression,
-     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.
-     *
-     * LogicalExpressions have cases that it goes different paths between the
-     * `true` case and the `false` case.
-     *
-     * For Example:
-     *
-     *     if (a || b) {
-     *         foo();
-     *     } else {
-     *         bar();
-     *     }
-     *
-     * In this case, `b` is evaluated always in the code path of the `else`
-     * block, but it's not so in the code path of the `if` block.
-     * So there are 3 paths.
-     *
-     *     a -> foo();
-     *     a -> b -> foo();
-     *     a -> b -> bar();
-     *
-     * @param {string} kind - A kind string.
-     *   If the new context is LogicalExpression's, this is `"&&"` or `"||"`.
-     *   If it's IfStatement's or ConditionalExpression's, this is `"test"`.
-     *   Otherwise, this is `"loop"`.
-     * @param {boolean} isForkingAsResult - A flag that shows that goes different
-     *   paths between `true` and `false`.
-     * @returns {void}
-     */
-    pushChoiceContext(kind, isForkingAsResult) {
-        this.choiceContext = {
-            upper: this.choiceContext,
-            kind,
-            isForkingAsResult,
-            trueForkContext: ForkContext.newEmpty(this.forkContext),
-            falseForkContext: ForkContext.newEmpty(this.forkContext),
-            processed: false
-        };
-    }
-
-    /**
-     * Pops the last choice context and finalizes it.
-     *
-     * @returns {ChoiceContext} The popped context.
-     */
-    popChoiceContext() {
-        const context = this.choiceContext;
-
-        this.choiceContext = context.upper;
-
-        const forkContext = this.forkContext;
-        const headSegments = forkContext.head;
-
-        switch (context.kind) {
-            case "&&":
-            case "||":
-
-                /*
-                 * If any result were not transferred from child contexts,
-                 * this sets the head segments to both cases.
-                 * The head segments are the path of the right-hand operand.
-                 */
-                if (!context.processed) {
-                    context.trueForkContext.add(headSegments);
-                    context.falseForkContext.add(headSegments);
-                }
-
-                /*
-                 * Transfers results to upper context if this context is in
-                 * test chunk.
-                 */
-                if (context.isForkingAsResult) {
-                    const parentContext = this.choiceContext;
-
-                    parentContext.trueForkContext.addAll(context.trueForkContext);
-                    parentContext.falseForkContext.addAll(context.falseForkContext);
-                    parentContext.processed = true;
-
-                    return context;
-                }
-
-                break;
-
-            case "test":
-                if (!context.processed) {
-
-                    /*
-                     * The head segments are the path of the `if` block here.
-                     * Updates the `true` path with the end of the `if` block.
-                     */
-                    context.trueForkContext.clear();
-                    context.trueForkContext.add(headSegments);
-                } else {
-
-                    /*
-                     * The head segments are the path of the `else` block here.
-                     * Updates the `false` path with the end of the `else`
-                     * block.
-                     */
-                    context.falseForkContext.clear();
-                    context.falseForkContext.add(headSegments);
-                }
-
-                break;
-
-            case "loop":
-
-                /*
-                 * Loops are addressed in popLoopContext().
-                 * This is called from popLoopContext().
-                 */
-                return context;
-
-            /* istanbul ignore next */
-            default:
-                throw new Error("unreachable");
-        }
-
-        // Merges all paths.
-        const prevForkContext = context.trueForkContext;
-
-        prevForkContext.addAll(context.falseForkContext);
-        forkContext.replaceHead(prevForkContext.makeNext(0, -1));
-
-        return context;
-    }
-
-    /**
-     * Makes a code path segment of the right-hand operand of a logical
-     * expression.
-     *
-     * @returns {void}
-     */
-    makeLogicalRight() {
-        const context = this.choiceContext;
-        const forkContext = this.forkContext;
-
-        if (context.processed) {
-
-            /*
-             * This got segments already from the child choice context.
-             * Creates the next path from own true/false fork context.
-             */
-            const prevForkContext =
-                context.kind === "&&" ? context.trueForkContext
-                /* kind === "||" */ : context.falseForkContext;
-
-            forkContext.replaceHead(prevForkContext.makeNext(0, -1));
-            prevForkContext.clear();
-
-            context.processed = false;
-        } else {
-
-            /*
-             * This did not get segments from the child choice context.
-             * So addresses the head segments.
-             * The head segments are the path of the left-hand operand.
-             */
-            if (context.kind === "&&") {
-
-                // The path does short-circuit if false.
-                context.falseForkContext.add(forkContext.head);
-            } else {
-
-                // The path does short-circuit if true.
-                context.trueForkContext.add(forkContext.head);
-            }
-
-            forkContext.replaceHead(forkContext.makeNext(-1, -1));
-        }
-    }
-
-    /**
-     * Makes a code path segment of the `if` block.
-     *
-     * @returns {void}
-     */
-    makeIfConsequent() {
-        const context = this.choiceContext;
-        const forkContext = this.forkContext;
-
-        /*
-         * If any result were not transferred from child contexts,
-         * this sets the head segments to both cases.
-         * The head segments are the path of the test expression.
-         */
-        if (!context.processed) {
-            context.trueForkContext.add(forkContext.head);
-            context.falseForkContext.add(forkContext.head);
-        }
-
-        context.processed = false;
-
-        // Creates new path from the `true` case.
-        forkContext.replaceHead(
-            context.trueForkContext.makeNext(0, -1)
-        );
-    }
-
-    /**
-     * Makes a code path segment of the `else` block.
-     *
-     * @returns {void}
-     */
-    makeIfAlternate() {
-        const context = this.choiceContext;
-        const forkContext = this.forkContext;
-
-        /*
-         * The head segments are the path of the `if` block.
-         * Updates the `true` path with the end of the `if` block.
-         */
-        context.trueForkContext.clear();
-        context.trueForkContext.add(forkContext.head);
-        context.processed = true;
-
-        // Creates new path from the `false` case.
-        forkContext.replaceHead(
-            context.falseForkContext.makeNext(0, -1)
-        );
-    }
-
-    //--------------------------------------------------------------------------
-    // SwitchStatement
-    //--------------------------------------------------------------------------
-
-    /**
-     * Creates a context object of SwitchStatement and stacks it.
-     *
-     * @param {boolean} hasCase - `true` if the switch statement has one or more
-     *   case parts.
-     * @param {string|null} label - The label text.
-     * @returns {void}
-     */
-    pushSwitchContext(hasCase, label) {
-        this.switchContext = {
-            upper: this.switchContext,
-            hasCase,
-            defaultSegments: null,
-            defaultBodySegments: null,
-            foundDefault: false,
-            lastIsDefault: false,
-            countForks: 0
-        };
-
-        this.pushBreakContext(true, label);
-    }
-
-    /**
-     * Pops the last context of SwitchStatement and finalizes it.
-     *
-     * - Disposes all forking stack for `case` and `default`.
-     * - Creates the next code path segment from `context.brokenForkContext`.
-     * - If the last `SwitchCase` node is not a `default` part, creates a path
-     *   to the `default` body.
-     *
-     * @returns {void}
-     */
-    popSwitchContext() {
-        const context = this.switchContext;
-
-        this.switchContext = context.upper;
-
-        const forkContext = this.forkContext;
-        const brokenForkContext = this.popBreakContext().brokenForkContext;
-
-        if (context.countForks === 0) {
-
-            /*
-             * When there is only one `default` chunk and there is one or more
-             * `break` statements, even if forks are nothing, it needs to merge
-             * those.
-             */
-            if (!brokenForkContext.empty) {
-                brokenForkContext.add(forkContext.makeNext(-1, -1));
-                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
-            }
-
-            return;
-        }
-
-        const lastSegments = forkContext.head;
-
-        this.forkBypassPath();
-        const lastCaseSegments = forkContext.head;
-
-        /*
-         * `brokenForkContext` is used to make the next segment.
-         * It must add the last segment into `brokenForkContext`.
-         */
-        brokenForkContext.add(lastSegments);
-
-        /*
-         * A path which is failed in all case test should be connected to path
-         * of `default` chunk.
-         */
-        if (!context.lastIsDefault) {
-            if (context.defaultBodySegments) {
-
-                /*
-                 * Remove a link from `default` label to its chunk.
-                 * It's false route.
-                 */
-                removeConnection(context.defaultSegments, context.defaultBodySegments);
-                makeLooped(this, lastCaseSegments, context.defaultBodySegments);
-            } else {
-
-                /*
-                 * It handles the last case body as broken if `default` chunk
-                 * does not exist.
-                 */
-                brokenForkContext.add(lastCaseSegments);
-            }
-        }
-
-        // Pops the segment context stack until the entry segment.
-        for (let i = 0; i < context.countForks; ++i) {
-            this.forkContext = this.forkContext.upper;
-        }
-
-        /*
-         * Creates a path from all brokenForkContext paths.
-         * This is a path after switch statement.
-         */
-        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
-    }
-
-    /**
-     * Makes a code path segment for a `SwitchCase` node.
-     *
-     * @param {boolean} isEmpty - `true` if the body is empty.
-     * @param {boolean} isDefault - `true` if the body is the default case.
-     * @returns {void}
-     */
-    makeSwitchCaseBody(isEmpty, isDefault) {
-        const context = this.switchContext;
-
-        if (!context.hasCase) {
-            return;
-        }
-
-        /*
-         * Merge forks.
-         * The parent fork context has two segments.
-         * Those are from the current case and the body of the previous case.
-         */
-        const parentForkContext = this.forkContext;
-        const forkContext = this.pushForkContext();
-
-        forkContext.add(parentForkContext.makeNext(0, -1));
-
-        /*
-         * Save `default` chunk info.
-         * If the `default` label is not at the last, we must make a path from
-         * the last `case` to the `default` chunk.
-         */
-        if (isDefault) {
-            context.defaultSegments = parentForkContext.head;
-            if (isEmpty) {
-                context.foundDefault = true;
-            } else {
-                context.defaultBodySegments = forkContext.head;
-            }
-        } else {
-            if (!isEmpty && context.foundDefault) {
-                context.foundDefault = false;
-                context.defaultBodySegments = forkContext.head;
-            }
-        }
-
-        context.lastIsDefault = isDefault;
-        context.countForks += 1;
-    }
-
-    //--------------------------------------------------------------------------
-    // TryStatement
-    //--------------------------------------------------------------------------
-
-    /**
-     * Creates a context object of TryStatement and stacks it.
-     *
-     * @param {boolean} hasFinalizer - `true` if the try statement has a
-     *   `finally` block.
-     * @returns {void}
-     */
-    pushTryContext(hasFinalizer) {
-        this.tryContext = {
-            upper: this.tryContext,
-            position: "try",
-            hasFinalizer,
-
-            returnedForkContext: hasFinalizer
-                ? ForkContext.newEmpty(this.forkContext)
-                : null,
-
-            thrownForkContext: ForkContext.newEmpty(this.forkContext),
-            lastOfTryIsReachable: false,
-            lastOfCatchIsReachable: false
-        };
-    }
-
-    /**
-     * Pops the last context of TryStatement and finalizes it.
-     *
-     * @returns {void}
-     */
-    popTryContext() {
-        const context = this.tryContext;
-
-        this.tryContext = context.upper;
-
-        if (context.position === "catch") {
-
-            // Merges two paths from the `try` block and `catch` block merely.
-            this.popForkContext();
-            return;
-        }
-
-        /*
-         * The following process is executed only when there is the `finally`
-         * block.
-         */
-
-        const returned = context.returnedForkContext;
-        const thrown = context.thrownForkContext;
-
-        if (returned.empty && thrown.empty) {
-            return;
-        }
-
-        // Separate head to normal paths and leaving paths.
-        const headSegments = this.forkContext.head;
-
-        this.forkContext = this.forkContext.upper;
-        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
-        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);
-
-        // Forwards the leaving path to upper contexts.
-        if (!returned.empty) {
-            getReturnContext(this).returnedForkContext.add(leavingSegments);
-        }
-        if (!thrown.empty) {
-            getThrowContext(this).thrownForkContext.add(leavingSegments);
-        }
-
-        // Sets the normal path as the next.
-        this.forkContext.replaceHead(normalSegments);
-
-        // If both paths of the `try` block and the `catch` block are
-        // unreachable, the next path becomes unreachable as well.
-        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
-            this.forkContext.makeUnreachable();
-        }
-    }
-
-    /**
-     * Makes a code path segment for a `catch` block.
-     *
-     * @returns {void}
-     */
-    makeCatchBlock() {
-        const context = this.tryContext;
-        const forkContext = this.forkContext;
-        const thrown = context.thrownForkContext;
-
-        // Update state.
-        context.position = "catch";
-        context.thrownForkContext = ForkContext.newEmpty(forkContext);
-        context.lastOfTryIsReachable = forkContext.reachable;
-
-        // Merge thrown paths.
-        thrown.add(forkContext.head);
-        const thrownSegments = thrown.makeNext(0, -1);
-
-        // Fork to a bypass and the merged thrown path.
-        this.pushForkContext();
-        this.forkBypassPath();
-        this.forkContext.add(thrownSegments);
-    }
-
-    /**
-     * Makes a code path segment for a `finally` block.
-     *
-     * In the `finally` block, parallel paths are created. The parallel paths
-     * are used as leaving-paths. The leaving-paths are paths from `return`
-     * statements and `throw` statements in a `try` block or a `catch` block.
-     *
-     * @returns {void}
-     */
-    makeFinallyBlock() {
-        const context = this.tryContext;
-        let forkContext = this.forkContext;
-        const returned = context.returnedForkContext;
-        const thrown = context.thrownForkContext;
-        const headOfLeavingSegments = forkContext.head;
-
-        // Update state.
-        if (context.position === "catch") {
-
-            // Merges two paths from the `try` block and `catch` block.
-            this.popForkContext();
-            forkContext = this.forkContext;
-
-            context.lastOfCatchIsReachable = forkContext.reachable;
-        } else {
-            context.lastOfTryIsReachable = forkContext.reachable;
-        }
-        context.position = "finally";
-
-        if (returned.empty && thrown.empty) {
-
-            // This path does not leave.
-            return;
-        }
-
-        /*
-         * Create a parallel segment from merging returned and thrown.
-         * This segment will leave at the end of this finally block.
-         */
-        const segments = forkContext.makeNext(-1, -1);
-
-        for (let i = 0; i < forkContext.count; ++i) {
-            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];
-
-            for (let j = 0; j < returned.segmentsList.length; ++j) {
-                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
-            }
-            for (let j = 0; j < thrown.segmentsList.length; ++j) {
-                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);
-            }
-
-            segments.push(
-                CodePathSegment.newNext(
-                    this.idGenerator.next(),
-                    prevSegsOfLeavingSegment
-                )
-            );
-        }
-
-        this.pushForkContext(true);
-        this.forkContext.add(segments);
-    }
-
-    /**
-     * Makes a code path segment from the first throwable node to the `catch`
-     * block or the `finally` block.
-     *
-     * @returns {void}
-     */
-    makeFirstThrowablePathInTryBlock() {
-        const forkContext = this.forkContext;
-
-        if (!forkContext.reachable) {
-            return;
-        }
-
-        const context = getThrowContext(this);
-
-        if (context === this ||
-            context.position !== "try" ||
-            !context.thrownForkContext.empty
-        ) {
-            return;
-        }
-
-        context.thrownForkContext.add(forkContext.head);
-        forkContext.replaceHead(forkContext.makeNext(-1, -1));
-    }
-
-    //--------------------------------------------------------------------------
-    // Loop Statements
-    //--------------------------------------------------------------------------
-
-    /**
-     * Creates a context object of a loop statement and stacks it.
-     *
-     * @param {string} type - The type of the node which was triggered. One of
-     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,
-     *   and `ForStatement`.
-     * @param {string|null} label - A label of the node which was triggered.
-     * @returns {void}
-     */
-    pushLoopContext(type, label) {
-        const forkContext = this.forkContext;
-        const breakContext = this.pushBreakContext(true, label);
-
-        switch (type) {
-            case "WhileStatement":
-                this.pushChoiceContext("loop", false);
-                this.loopContext = {
-                    upper: this.loopContext,
-                    type,
-                    label,
-                    test: void 0,
-                    continueDestSegments: null,
-                    brokenForkContext: breakContext.brokenForkContext
-                };
-                break;
-
-            case "DoWhileStatement":
-                this.pushChoiceContext("loop", false);
-                this.loopContext = {
-                    upper: this.loopContext,
-                    type,
-                    label,
-                    test: void 0,
-                    entrySegments: null,
-                    continueForkContext: ForkContext.newEmpty(forkContext),
-                    brokenForkContext: breakContext.brokenForkContext
-                };
-                break;
-
-            case "ForStatement":
-                this.pushChoiceContext("loop", false);
-                this.loopContext = {
-                    upper: this.loopContext,
-                    type,
-                    label,
-                    test: void 0,
-                    endOfInitSegments: null,
-                    testSegments: null,
-                    endOfTestSegments: null,
-                    updateSegments: null,
-                    endOfUpdateSegments: null,
-                    continueDestSegments: null,
-                    brokenForkContext: breakContext.brokenForkContext
-                };
-                break;
-
-            case "ForInStatement":
-            case "ForOfStatement":
-                this.loopContext = {
-                    upper: this.loopContext,
-                    type,
-                    label,
-                    prevSegments: null,
-                    leftSegments: null,
-                    endOfLeftSegments: null,
-                    continueDestSegments: null,
-                    brokenForkContext: breakContext.brokenForkContext
-                };
-                break;
-
-            /* istanbul ignore next */
-            default:
-                throw new Error(`unknown type: "${type}"`);
-        }
-    }
-
-    /**
-     * Pops the last context of a loop statement and finalizes it.
-     *
-     * @returns {void}
-     */
-    popLoopContext() {
-        const context = this.loopContext;
-
-        this.loopContext = context.upper;
-
-        const forkContext = this.forkContext;
-        const brokenForkContext = this.popBreakContext().brokenForkContext;
-
-        // Creates a looped path.
-        switch (context.type) {
-            case "WhileStatement":
-            case "ForStatement":
-                this.popChoiceContext();
-                makeLooped(
-                    this,
-                    forkContext.head,
-                    context.continueDestSegments
-                );
-                break;
-
-            case "DoWhileStatement": {
-                const choiceContext = this.popChoiceContext();
-
-                if (!choiceContext.processed) {
-                    choiceContext.trueForkContext.add(forkContext.head);
-                    choiceContext.falseForkContext.add(forkContext.head);
-                }
-                if (context.test !== true) {
-                    brokenForkContext.addAll(choiceContext.falseForkContext);
-                }
-
-                // `true` paths go to looping.
-                const segmentsList = choiceContext.trueForkContext.segmentsList;
-
-                for (let i = 0; i < segmentsList.length; ++i) {
-                    makeLooped(
-                        this,
-                        segmentsList[i],
-                        context.entrySegments
-                    );
-                }
-                break;
-            }
-
-            case "ForInStatement":
-            case "ForOfStatement":
-                brokenForkContext.add(forkContext.head);
-                makeLooped(
-                    this,
-                    forkContext.head,
-                    context.leftSegments
-                );
-                break;
-
-            /* istanbul ignore next */
-            default:
-                throw new Error("unreachable");
-        }
-
-        // Go next.
-        if (brokenForkContext.empty) {
-            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
-        } else {
-            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
-        }
-    }
-
-    /**
-     * Makes a code path segment for the test part of a WhileStatement.
-     *
-     * @param {boolean|undefined} test - The test value (only when constant).
-     * @returns {void}
-     */
-    makeWhileTest(test) {
-        const context = this.loopContext;
-        const forkContext = this.forkContext;
-        const testSegments = forkContext.makeNext(0, -1);
-
-        // Update state.
-        context.test = test;
-        context.continueDestSegments = testSegments;
-        forkContext.replaceHead(testSegments);
-    }
-
-    /**
-     * Makes a code path segment for the body part of a WhileStatement.
-     *
-     * @returns {void}
-     */
-    makeWhileBody() {
-        const context = this.loopContext;
-        const choiceContext = this.choiceContext;
-        const forkContext = this.forkContext;
-
-        if (!choiceContext.processed) {
-            choiceContext.trueForkContext.add(forkContext.head);
-            choiceContext.falseForkContext.add(forkContext.head);
-        }
-
-        // Update state.
-        if (context.test !== true) {
-            context.brokenForkContext.addAll(choiceContext.falseForkContext);
-        }
-        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
-    }
-
-    /**
-     * Makes a code path segment for the body part of a DoWhileStatement.
-     *
-     * @returns {void}
-     */
-    makeDoWhileBody() {
-        const context = this.loopContext;
-        const forkContext = this.forkContext;
-        const bodySegments = forkContext.makeNext(-1, -1);
-
-        // Update state.
-        context.entrySegments = bodySegments;
-        forkContext.replaceHead(bodySegments);
-    }
-
-    /**
-     * Makes a code path segment for the test part of a DoWhileStatement.
-     *
-     * @param {boolean|undefined} test - The test value (only when constant).
-     * @returns {void}
-     */
-    makeDoWhileTest(test) {
-        const context = this.loopContext;
-        const forkContext = this.forkContext;
-
-        context.test = test;
-
-        // Creates paths of `continue` statements.
-        if (!context.continueForkContext.empty) {
-            context.continueForkContext.add(forkContext.head);
-            const testSegments = context.continueForkContext.makeNext(0, -1);
-
-            forkContext.replaceHead(testSegments);
-        }
-    }
-
-    /**
-     * Makes a code path segment for the test part of a ForStatement.
-     *
-     * @param {boolean|undefined} test - The test value (only when constant).
-     * @returns {void}
-     */
-    makeForTest(test) {
-        const context = this.loopContext;
-        const forkContext = this.forkContext;
-        const endOfInitSegments = forkContext.head;
-        const testSegments = forkContext.makeNext(-1, -1);
-
-        // Update state.
-        context.test = test;
-        context.endOfInitSegments = endOfInitSegments;
-        context.continueDestSegments = context.testSegments = testSegments;
-        forkContext.replaceHead(testSegments);
-    }
-
-    /**
-     * Makes a code path segment for the update part of a ForStatement.
-     *
-     * @returns {void}
-     */
-    makeForUpdate() {
-        const context = this.loopContext;
-        const choiceContext = this.choiceContext;
-        const forkContext = this.forkContext;
-
-        // Make the next paths of the test.
-        if (context.testSegments) {
-            finalizeTestSegmentsOfFor(
-                context,
-                choiceContext,
-                forkContext.head
-            );
-        } else {
-            context.endOfInitSegments = forkContext.head;
-        }
-
-        // Update state.
-        const updateSegments = forkContext.makeDisconnected(-1, -1);
-
-        context.continueDestSegments = context.updateSegments = updateSegments;
-        forkContext.replaceHead(updateSegments);
-    }
-
-    /**
-     * Makes a code path segment for the body part of a ForStatement.
-     *
-     * @returns {void}
-     */
-    makeForBody() {
-        const context = this.loopContext;
-        const choiceContext = this.choiceContext;
-        const forkContext = this.forkContext;
-
-        // Update state.
-        if (context.updateSegments) {
-            context.endOfUpdateSegments = forkContext.head;
-
-            // `update` -> `test`
-            if (context.testSegments) {
-                makeLooped(
-                    this,
-                    context.endOfUpdateSegments,
-                    context.testSegments
-                );
-            }
-        } else if (context.testSegments) {
-            finalizeTestSegmentsOfFor(
-                context,
-                choiceContext,
-                forkContext.head
-            );
-        } else {
-            context.endOfInitSegments = forkContext.head;
-        }
-
-        let bodySegments = context.endOfTestSegments;
-
-        if (!bodySegments) {
-
-            /*
-             * If there is not the `test` part, the `body` path comes from the
-             * `init` part and the `update` part.
-             */
-            const prevForkContext = ForkContext.newEmpty(forkContext);
-
-            prevForkContext.add(context.endOfInitSegments);
-            if (context.endOfUpdateSegments) {
-                prevForkContext.add(context.endOfUpdateSegments);
-            }
-
-            bodySegments = prevForkContext.makeNext(0, -1);
-        }
-        context.continueDestSegments = context.continueDestSegments || bodySegments;
-        forkContext.replaceHead(bodySegments);
-    }
-
-    /**
-     * Makes a code path segment for the left part of a ForInStatement and a
-     * ForOfStatement.
-     *
-     * @returns {void}
-     */
-    makeForInOfLeft() {
-        const context = this.loopContext;
-        const forkContext = this.forkContext;
-        const leftSegments = forkContext.makeDisconnected(-1, -1);
-
-        // Update state.
-        context.prevSegments = forkContext.head;
-        context.leftSegments = context.continueDestSegments = leftSegments;
-        forkContext.replaceHead(leftSegments);
-    }
-
-    /**
-     * Makes a code path segment for the right part of a ForInStatement and a
-     * ForOfStatement.
-     *
-     * @returns {void}
-     */
-    makeForInOfRight() {
-        const context = this.loopContext;
-        const forkContext = this.forkContext;
-        const temp = ForkContext.newEmpty(forkContext);
-
-        temp.add(context.prevSegments);
-        const rightSegments = temp.makeNext(-1, -1);
-
-        // Update state.
-        context.endOfLeftSegments = forkContext.head;
-        forkContext.replaceHead(rightSegments);
-    }
-
-    /**
-     * Makes a code path segment for the body part of a ForInStatement and a
-     * ForOfStatement.
-     *
-     * @returns {void}
-     */
-    makeForInOfBody() {
-        const context = this.loopContext;
-        const forkContext = this.forkContext;
-        const temp = ForkContext.newEmpty(forkContext);
-
-        temp.add(context.endOfLeftSegments);
-        const bodySegments = temp.makeNext(-1, -1);
-
-        // Make a path: `right` -> `left`.
-        makeLooped(this, forkContext.head, context.leftSegments);
-
-        // Update state.
-        context.brokenForkContext.add(forkContext.head);
-        forkContext.replaceHead(bodySegments);
-    }
-
-    //--------------------------------------------------------------------------
-    // Control Statements
-    //--------------------------------------------------------------------------
-
-    /**
-     * Creates new context for BreakStatement.
-     *
-     * @param {boolean} breakable - The flag to indicate it can break by
-     *      an unlabeled BreakStatement.
-     * @param {string|null} label - The label of this context.
-     * @returns {Object} The new context.
-     */
-    pushBreakContext(breakable, label) {
-        this.breakContext = {
-            upper: this.breakContext,
-            breakable,
-            label,
-            brokenForkContext: ForkContext.newEmpty(this.forkContext)
-        };
-        return this.breakContext;
-    }
-
-    /**
-     * Removes the top item of the break context stack.
-     *
-     * @returns {Object} The removed context.
-     */
-    popBreakContext() {
-        const context = this.breakContext;
-        const forkContext = this.forkContext;
-
-        this.breakContext = context.upper;
-
-        // Process this context here for other than switches and loops.
-        if (!context.breakable) {
-            const brokenForkContext = context.brokenForkContext;
-
-            if (!brokenForkContext.empty) {
-                brokenForkContext.add(forkContext.head);
-                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
-            }
-        }
-
-        return context;
-    }
-
-    /**
-     * Makes a path for a `break` statement.
-     *
-     * It registers the head segment to a context of `break`.
-     * It makes new unreachable segment, then it set the head with the segment.
-     *
-     * @param {string} label - A label of the break statement.
-     * @returns {void}
-     */
-    makeBreak(label) {
-        const forkContext = this.forkContext;
-
-        if (!forkContext.reachable) {
-            return;
-        }
-
-        const context = getBreakContext(this, label);
-
-        /* istanbul ignore else: foolproof (syntax error) */
-        if (context) {
-            context.brokenForkContext.add(forkContext.head);
-        }
-
-        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
-    }
-
-    /**
-     * Makes a path for a `continue` statement.
-     *
-     * It makes a looping path.
-     * It makes new unreachable segment, then it set the head with the segment.
-     *
-     * @param {string} label - A label of the continue statement.
-     * @returns {void}
-     */
-    makeContinue(label) {
-        const forkContext = this.forkContext;
-
-        if (!forkContext.reachable) {
-            return;
-        }
-
-        const context = getContinueContext(this, label);
-
-        /* istanbul ignore else: foolproof (syntax error) */
-        if (context) {
-            if (context.continueDestSegments) {
-                makeLooped(this, forkContext.head, context.continueDestSegments);
-
-                // If the context is a for-in/of loop, this effects a break also.
-                if (context.type === "ForInStatement" ||
-                    context.type === "ForOfStatement"
-                ) {
-                    context.brokenForkContext.add(forkContext.head);
-                }
-            } else {
-                context.continueForkContext.add(forkContext.head);
-            }
-        }
-        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
-    }
-
-    /**
-     * Makes a path for a `return` statement.
-     *
-     * It registers the head segment to a context of `return`.
-     * It makes new unreachable segment, then it set the head with the segment.
-     *
-     * @returns {void}
-     */
-    makeReturn() {
-        const forkContext = this.forkContext;
-
-        if (forkContext.reachable) {
-            getReturnContext(this).returnedForkContext.add(forkContext.head);
-            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
-        }
-    }
-
-    /**
-     * Makes a path for a `throw` statement.
-     *
-     * It registers the head segment to a context of `throw`.
-     * It makes new unreachable segment, then it set the head with the segment.
-     *
-     * @returns {void}
-     */
-    makeThrow() {
-        const forkContext = this.forkContext;
-
-        if (forkContext.reachable) {
-            getThrowContext(this).thrownForkContext.add(forkContext.head);
-            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
-        }
-    }
-
-    /**
-     * Makes the final path.
-     * @returns {void}
-     */
-    makeFinal() {
-        const segments = this.currentSegments;
-
-        if (segments.length > 0 && segments[0].reachable) {
-            this.returnedForkContext.add(segments);
-        }
-    }
-}
-
-module.exports = CodePathState;
Index: node_modules/eslint/lib/code-path-analysis/code-path-segment.js
===================================================================
--- node_modules/eslint/lib/code-path-analysis/code-path-segment.js	(revision )
+++ node_modules/eslint/lib/code-path-analysis/code-path-segment.js	(revision )
@@ -1,243 +0,0 @@
-/**
- * @fileoverview A class of the code path segment.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const debug = require("./debug-helpers");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Replaces unused segments with the previous segments of each unused segment.
- *
- * @param {CodePathSegment[]} segments - An array of segments to replace.
- * @returns {CodePathSegment[]} The replaced array.
- */
-function flattenUnusedSegments(segments) {
-    const done = Object.create(null);
-    const retv = [];
-
-    for (let i = 0; i < segments.length; ++i) {
-        const segment = segments[i];
-
-        // Ignores duplicated.
-        if (done[segment.id]) {
-            continue;
-        }
-
-        // Use previous segments if unused.
-        if (!segment.internal.used) {
-            for (let j = 0; j < segment.allPrevSegments.length; ++j) {
-                const prevSegment = segment.allPrevSegments[j];
-
-                if (!done[prevSegment.id]) {
-                    done[prevSegment.id] = true;
-                    retv.push(prevSegment);
-                }
-            }
-        } else {
-            done[segment.id] = true;
-            retv.push(segment);
-        }
-    }
-
-    return retv;
-}
-
-/**
- * Checks whether or not a given segment is reachable.
- *
- * @param {CodePathSegment} segment - A segment to check.
- * @returns {boolean} `true` if the segment is reachable.
- */
-function isReachable(segment) {
-    return segment.reachable;
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * A code path segment.
- */
-class CodePathSegment {
-
-    /**
-     * @param {string} id - An identifier.
-     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
-     *   This array includes unreachable segments.
-     * @param {boolean} reachable - A flag which shows this is reachable.
-     */
-    constructor(id, allPrevSegments, reachable) {
-
-        /**
-         * The identifier of this code path.
-         * Rules use it to store additional information of each rule.
-         * @type {string}
-         */
-        this.id = id;
-
-        /**
-         * An array of the next segments.
-         * @type {CodePathSegment[]}
-         */
-        this.nextSegments = [];
-
-        /**
-         * An array of the previous segments.
-         * @type {CodePathSegment[]}
-         */
-        this.prevSegments = allPrevSegments.filter(isReachable);
-
-        /**
-         * An array of the next segments.
-         * This array includes unreachable segments.
-         * @type {CodePathSegment[]}
-         */
-        this.allNextSegments = [];
-
-        /**
-         * An array of the previous segments.
-         * This array includes unreachable segments.
-         * @type {CodePathSegment[]}
-         */
-        this.allPrevSegments = allPrevSegments;
-
-        /**
-         * A flag which shows this is reachable.
-         * @type {boolean}
-         */
-        this.reachable = reachable;
-
-        // Internal data.
-        Object.defineProperty(this, "internal", {
-            value: {
-                used: false,
-                loopedPrevSegments: []
-            }
-        });
-
-        /* istanbul ignore if */
-        if (debug.enabled) {
-            this.internal.nodes = [];
-            this.internal.exitNodes = [];
-        }
-    }
-
-    /**
-     * Checks a given previous segment is coming from the end of a loop.
-     *
-     * @param {CodePathSegment} segment - A previous segment to check.
-     * @returns {boolean} `true` if the segment is coming from the end of a loop.
-     */
-    isLoopedPrevSegment(segment) {
-        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
-    }
-
-    /**
-     * Creates the root segment.
-     *
-     * @param {string} id - An identifier.
-     * @returns {CodePathSegment} The created segment.
-     */
-    static newRoot(id) {
-        return new CodePathSegment(id, [], true);
-    }
-
-    /**
-     * Creates a segment that follows given segments.
-     *
-     * @param {string} id - An identifier.
-     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
-     * @returns {CodePathSegment} The created segment.
-     */
-    static newNext(id, allPrevSegments) {
-        return new CodePathSegment(
-            id,
-            flattenUnusedSegments(allPrevSegments),
-            allPrevSegments.some(isReachable)
-        );
-    }
-
-    /**
-     * Creates an unreachable segment that follows given segments.
-     *
-     * @param {string} id - An identifier.
-     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
-     * @returns {CodePathSegment} The created segment.
-     */
-    static newUnreachable(id, allPrevSegments) {
-        const segment = new CodePathSegment(id, flattenUnusedSegments(allPrevSegments), false);
-
-        // In `if (a) return a; foo();` case, the unreachable segment preceded by
-        // the return statement is not used but must not be remove.
-        CodePathSegment.markUsed(segment);
-
-        return segment;
-    }
-
-    /**
-     * Creates a segment that follows given segments.
-     * This factory method does not connect with `allPrevSegments`.
-     * But this inherits `reachable` flag.
-     *
-     * @param {string} id - An identifier.
-     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
-     * @returns {CodePathSegment} The created segment.
-     */
-    static newDisconnected(id, allPrevSegments) {
-        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
-    }
-
-    /**
-     * Makes a given segment being used.
-     *
-     * And this function registers the segment into the previous segments as a next.
-     *
-     * @param {CodePathSegment} segment - A segment to mark.
-     * @returns {void}
-     */
-    static markUsed(segment) {
-        if (segment.internal.used) {
-            return;
-        }
-        segment.internal.used = true;
-
-        let i;
-
-        if (segment.reachable) {
-            for (i = 0; i < segment.allPrevSegments.length; ++i) {
-                const prevSegment = segment.allPrevSegments[i];
-
-                prevSegment.allNextSegments.push(segment);
-                prevSegment.nextSegments.push(segment);
-            }
-        } else {
-            for (i = 0; i < segment.allPrevSegments.length; ++i) {
-                segment.allPrevSegments[i].allNextSegments.push(segment);
-            }
-        }
-    }
-
-    /**
-     * Marks a previous segment as looped.
-     *
-     * @param {CodePathSegment} segment - A segment.
-     * @param {CodePathSegment} prevSegment - A previous segment to mark.
-     * @returns {void}
-     */
-    static markPrevSegmentAsLooped(segment, prevSegment) {
-        segment.internal.loopedPrevSegments.push(prevSegment);
-    }
-}
-
-module.exports = CodePathSegment;
Index: node_modules/eslint/lib/code-path-analysis/code-path-analyzer.js
===================================================================
--- node_modules/eslint/lib/code-path-analysis/code-path-analyzer.js	(revision )
+++ node_modules/eslint/lib/code-path-analysis/code-path-analyzer.js	(revision )
@@ -1,655 +0,0 @@
-/**
- * @fileoverview A class of the code path analyzer.
- * @author Toru Nagashima
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const assert = require("assert"),
-    CodePath = require("./code-path"),
-    CodePathSegment = require("./code-path-segment"),
-    IdGenerator = require("./id-generator"),
-    debug = require("./debug-helpers"),
-    astUtils = require("../ast-utils");
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Checks whether or not a given node is a `case` node (not `default` node).
- *
- * @param {ASTNode} node - A `SwitchCase` node to check.
- * @returns {boolean} `true` if the node is a `case` node (not `default` node).
- */
-function isCaseNode(node) {
-    return Boolean(node.test);
-}
-
-/**
- * Checks whether or not a given logical expression node goes different path
- * between the `true` case and the `false` case.
- *
- * @param {ASTNode} node - A node to check.
- * @returns {boolean} `true` if the node is a test of a choice statement.
- */
-function isForkingByTrueOrFalse(node) {
-    const parent = node.parent;
-
-    switch (parent.type) {
-        case "ConditionalExpression":
-        case "IfStatement":
-        case "WhileStatement":
-        case "DoWhileStatement":
-        case "ForStatement":
-            return parent.test === node;
-
-        case "LogicalExpression":
-            return true;
-
-        default:
-            return false;
-    }
-}
-
-/**
- * Gets the boolean value of a given literal node.
- *
- * This is used to detect infinity loops (e.g. `while (true) {}`).
- * Statements preceded by an infinity loop are unreachable if the loop didn't
- * have any `break` statement.
- *
- * @param {ASTNode} node - A node to get.
- * @returns {boolean|undefined} a boolean value if the node is a Literal node,
- *   otherwise `undefined`.
- */
-function getBooleanValueIfSimpleConstant(node) {
-    if (node.type === "Literal") {
-        return Boolean(node.value);
-    }
-    return void 0;
-}
-
-/**
- * Checks that a given identifier node is a reference or not.
- *
- * This is used to detect the first throwable node in a `try` block.
- *
- * @param {ASTNode} node - An Identifier node to check.
- * @returns {boolean} `true` if the node is a reference.
- */
-function isIdentifierReference(node) {
-    const parent = node.parent;
-
-    switch (parent.type) {
-        case "LabeledStatement":
-        case "BreakStatement":
-        case "ContinueStatement":
-        case "ArrayPattern":
-        case "RestElement":
-        case "ImportSpecifier":
-        case "ImportDefaultSpecifier":
-        case "ImportNamespaceSpecifier":
-        case "CatchClause":
-            return false;
-
-        case "FunctionDeclaration":
-        case "FunctionExpression":
-        case "ArrowFunctionExpression":
-        case "ClassDeclaration":
-        case "ClassExpression":
-        case "VariableDeclarator":
-            return parent.id !== node;
-
-        case "Property":
-        case "MethodDefinition":
-            return (
-                parent.key !== node ||
-                parent.computed ||
-                parent.shorthand
-            );
-
-        case "AssignmentPattern":
-            return parent.key !== node;
-
-        default:
-            return true;
-    }
-}
-
-/**
- * Updates the current segment with the head segment.
- * This is similar to local branches and tracking branches of git.
- *
- * To separate the current and the head is in order to not make useless segments.
- *
- * In this process, both "onCodePathSegmentStart" and "onCodePathSegmentEnd"
- * events are fired.
- *
- * @param {CodePathAnalyzer} analyzer - The instance.
- * @param {ASTNode} node - The current AST node.
- * @returns {void}
- */
-function forwardCurrentToHead(analyzer, node) {
-    const codePath = analyzer.codePath;
-    const state = CodePath.getState(codePath);
-    const currentSegments = state.currentSegments;
-    const headSegments = state.headSegments;
-    const end = Math.max(currentSegments.length, headSegments.length);
-    let i, currentSegment, headSegment;
-
-    // Fires leaving events.
-    for (i = 0; i < end; ++i) {
-        currentSegment = currentSegments[i];
-        headSegment = headSegments[i];
-
-        if (currentSegment !== headSegment && currentSegment) {
-            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
-
-            if (currentSegment.reachable) {
-                analyzer.emitter.emit(
-                    "onCodePathSegmentEnd",
-                    currentSegment,
-                    node
-                );
-            }
-        }
-    }
-
-    // Update state.
-    state.currentSegments = headSegments;
-
-    // Fires entering events.
-    for (i = 0; i < end; ++i) {
-        currentSegment = currentSegments[i];
-        headSegment = headSegments[i];
-
-        if (currentSegment !== headSegment && headSegment) {
-            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);
-
-            CodePathSegment.markUsed(headSegment);
-            if (headSegment.reachable) {
-                analyzer.emitter.emit(
-                    "onCodePathSegmentStart",
-                    headSegment,
-                    node
-                );
-            }
-        }
-    }
-
-}
-
-/**
- * Updates the current segment with empty.
- * This is called at the last of functions or the program.
- *
- * @param {CodePathAnalyzer} analyzer - The instance.
- * @param {ASTNode} node - The current AST node.
- * @returns {void}
- */
-function leaveFromCurrentSegment(analyzer, node) {
-    const state = CodePath.getState(analyzer.codePath);
-    const currentSegments = state.currentSegments;
-
-    for (let i = 0; i < currentSegments.length; ++i) {
-        const currentSegment = currentSegments[i];
-
-        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
-        if (currentSegment.reachable) {
-            analyzer.emitter.emit(
-                "onCodePathSegmentEnd",
-                currentSegment,
-                node
-            );
-        }
-    }
-
-    state.currentSegments = [];
-}
-
-/**
- * Updates the code path due to the position of a given node in the parent node
- * thereof.
- *
- * For example, if the node is `parent.consequent`, this creates a fork from the
- * current path.
- *
- * @param {CodePathAnalyzer} analyzer - The instance.
- * @param {ASTNode} node - The current AST node.
- * @returns {void}
- */
-function preprocess(analyzer, node) {
-    const codePath = analyzer.codePath;
-    const state = CodePath.getState(codePath);
-    const parent = node.parent;
-
-    switch (parent.type) {
-        case "LogicalExpression":
-            if (parent.right === node) {
-                state.makeLogicalRight();
-            }
-            break;
-
-        case "ConditionalExpression":
-        case "IfStatement":
-
-            /*
-             * Fork if this node is at `consequent`/`alternate`.
-             * `popForkContext()` exists at `IfStatement:exit` and
-             * `ConditionalExpression:exit`.
-             */
-            if (parent.consequent === node) {
-                state.makeIfConsequent();
-            } else if (parent.alternate === node) {
-                state.makeIfAlternate();
-            }
-            break;
-
-        case "SwitchCase":
-            if (parent.consequent[0] === node) {
-                state.makeSwitchCaseBody(false, !parent.test);
-            }
-            break;
-
-        case "TryStatement":
-            if (parent.handler === node) {
-                state.makeCatchBlock();
-            } else if (parent.finalizer === node) {
-                state.makeFinallyBlock();
-            }
-            break;
-
-        case "WhileStatement":
-            if (parent.test === node) {
-                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
-            } else {
-                assert(parent.body === node);
-                state.makeWhileBody();
-            }
-            break;
-
-        case "DoWhileStatement":
-            if (parent.body === node) {
-                state.makeDoWhileBody();
-            } else {
-                assert(parent.test === node);
-                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
-            }
-            break;
-
-        case "ForStatement":
-            if (parent.test === node) {
-                state.makeForTest(getBooleanValueIfSimpleConstant(node));
-            } else if (parent.update === node) {
-                state.makeForUpdate();
-            } else if (parent.body === node) {
-                state.makeForBody();
-            }
-            break;
-
-        case "ForInStatement":
-        case "ForOfStatement":
-            if (parent.left === node) {
-                state.makeForInOfLeft();
-            } else if (parent.right === node) {
-                state.makeForInOfRight();
-            } else {
-                assert(parent.body === node);
-                state.makeForInOfBody();
-            }
-            break;
-
-        case "AssignmentPattern":
-
-            /*
-             * Fork if this node is at `right`.
-             * `left` is executed always, so it uses the current path.
-             * `popForkContext()` exists at `AssignmentPattern:exit`.
-             */
-            if (parent.right === node) {
-                state.pushForkContext();
-                state.forkBypassPath();
-                state.forkPath();
-            }
-            break;
-
-        default:
-            break;
-    }
-}
-
-/**
- * Updates the code path due to the type of a given node in entering.
- *
- * @param {CodePathAnalyzer} analyzer - The instance.
- * @param {ASTNode} node - The current AST node.
- * @returns {void}
- */
-function processCodePathToEnter(analyzer, node) {
-    let codePath = analyzer.codePath;
-    let state = codePath && CodePath.getState(codePath);
-    const parent = node.parent;
-
-    switch (node.type) {
-        case "Program":
-        case "FunctionDeclaration":
-        case "FunctionExpression":
-        case "ArrowFunctionExpression":
-            if (codePath) {
-
-                // Emits onCodePathSegmentStart events if updated.
-                forwardCurrentToHead(analyzer, node);
-                debug.dumpState(node, state, false);
-            }
-
-            // Create the code path of this scope.
-            codePath = analyzer.codePath = new CodePath(
-                analyzer.idGenerator.next(),
-                codePath,
-                analyzer.onLooped
-            );
-            state = CodePath.getState(codePath);
-
-            // Emits onCodePathStart events.
-            debug.dump(`onCodePathStart ${codePath.id}`);
-            analyzer.emitter.emit("onCodePathStart", codePath, node);
-            break;
-
-        case "LogicalExpression":
-            state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));
-            break;
-
-        case "ConditionalExpression":
-        case "IfStatement":
-            state.pushChoiceContext("test", false);
-            break;
-
-        case "SwitchStatement":
-            state.pushSwitchContext(
-                node.cases.some(isCaseNode),
-                astUtils.getLabel(node)
-            );
-            break;
-
-        case "TryStatement":
-            state.pushTryContext(Boolean(node.finalizer));
-            break;
-
-        case "SwitchCase":
-
-            /*
-             * Fork if this node is after the 2st node in `cases`.
-             * It's similar to `else` blocks.
-             * The next `test` node is processed in this path.
-             */
-            if (parent.discriminant !== node && parent.cases[0] !== node) {
-                state.forkPath();
-            }
-            break;
-
-        case "WhileStatement":
-        case "DoWhileStatement":
-        case "ForStatement":
-        case "ForInStatement":
-        case "ForOfStatement":
-            state.pushLoopContext(node.type, astUtils.getLabel(node));
-            break;
-
-        case "LabeledStatement":
-            if (!astUtils.isBreakableStatement(node.body)) {
-                state.pushBreakContext(false, node.label.name);
-            }
-            break;
-
-        default:
-            break;
-    }
-
-    // Emits onCodePathSegmentStart events if updated.
-    forwardCurrentToHead(analyzer, node);
-    debug.dumpState(node, state, false);
-}
-
-/**
- * Updates the code path due to the type of a given node in leaving.
- *
- * @param {CodePathAnalyzer} analyzer - The instance.
- * @param {ASTNode} node - The current AST node.
- * @returns {void}
- */
-function processCodePathToExit(analyzer, node) {
-    const codePath = analyzer.codePath;
-    const state = CodePath.getState(codePath);
-    let dontForward = false;
-
-    switch (node.type) {
-        case "IfStatement":
-        case "ConditionalExpression":
-        case "LogicalExpression":
-            state.popChoiceContext();
-            break;
-
-        case "SwitchStatement":
-            state.popSwitchContext();
-            break;
-
-        case "SwitchCase":
-
-            /*
-             * This is the same as the process at the 1st `consequent` node in
-             * `preprocess` function.
-             * Must do if this `consequent` is empty.
-             */
-            if (node.consequent.length === 0) {
-                state.makeSwitchCaseBody(true, !node.test);
-            }
-            if (state.forkContext.reachable) {
-                dontForward = true;
-            }
-            break;
-
-        case "TryStatement":
-            state.popTryContext();
-            break;
-
-        case "BreakStatement":
-            forwardCurrentToHead(analyzer, node);
-            state.makeBreak(node.label && node.label.name);
-            dontForward = true;
-            break;
-
-        case "ContinueStatement":
-            forwardCurrentToHead(analyzer, node);
-            state.makeContinue(node.label && node.label.name);
-            dontForward = true;
-            break;
-
-        case "ReturnStatement":
-            forwardCurrentToHead(analyzer, node);
-            state.makeReturn();
-            dontForward = true;
-            break;
-
-        case "ThrowStatement":
-            forwardCurrentToHead(analyzer, node);
-            state.makeThrow();
-            dontForward = true;
-            break;
-
-        case "Identifier":
-            if (isIdentifierReference(node)) {
-                state.makeFirstThrowablePathInTryBlock();
-                dontForward = true;
-            }
-            break;
-
-        case "CallExpression":
-        case "MemberExpression":
-        case "NewExpression":
-            state.makeFirstThrowablePathInTryBlock();
-            break;
-
-        case "WhileStatement":
-        case "DoWhileStatement":
-        case "ForStatement":
-        case "ForInStatement":
-        case "ForOfStatement":
-            state.popLoopContext();
-            break;
-
-        case "AssignmentPattern":
-            state.popForkContext();
-            break;
-
-        case "LabeledStatement":
-            if (!astUtils.isBreakableStatement(node.body)) {
-                state.popBreakContext();
-            }
-            break;
-
-        default:
-            break;
-    }
-
-    // Emits onCodePathSegmentStart events if updated.
-    if (!dontForward) {
-        forwardCurrentToHead(analyzer, node);
-    }
-    debug.dumpState(node, state, true);
-}
-
-/**
- * Updates the code path to finalize the current code path.
- *
- * @param {CodePathAnalyzer} analyzer - The instance.
- * @param {ASTNode} node - The current AST node.
- * @returns {void}
- */
-function postprocess(analyzer, node) {
-    switch (node.type) {
-        case "Program":
-        case "FunctionDeclaration":
-        case "FunctionExpression":
-        case "ArrowFunctionExpression": {
-            let codePath = analyzer.codePath;
-
-            // Mark the current path as the final node.
-            CodePath.getState(codePath).makeFinal();
-
-            // Emits onCodePathSegmentEnd event of the current segments.
-            leaveFromCurrentSegment(analyzer, node);
-
-            // Emits onCodePathEnd event of this code path.
-            debug.dump(`onCodePathEnd ${codePath.id}`);
-            analyzer.emitter.emit("onCodePathEnd", codePath, node);
-            debug.dumpDot(codePath);
-
-            codePath = analyzer.codePath = analyzer.codePath.upper;
-            if (codePath) {
-                debug.dumpState(node, CodePath.getState(codePath), true);
-            }
-            break;
-        }
-
-        default:
-            break;
-    }
-}
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-/**
- * The class to analyze code paths.
- * This class implements the EventGenerator interface.
- */
-class CodePathAnalyzer {
-
-    /**
-     * @param {EventGenerator} eventGenerator - An event generator to wrap.
-     */
-    constructor(eventGenerator) {
-        this.original = eventGenerator;
-        this.emitter = eventGenerator.emitter;
-        this.codePath = null;
-        this.idGenerator = new IdGenerator("s");
-        this.currentNode = null;
-        this.onLooped = this.onLooped.bind(this);
-    }
-
-    /**
-     * Does the process to enter a given AST node.
-     * This updates state of analysis and calls `enterNode` of the wrapped.
-     *
-     * @param {ASTNode} node - A node which is entering.
-     * @returns {void}
-     */
-    enterNode(node) {
-        this.currentNode = node;
-
-        // Updates the code path due to node's position in its parent node.
-        if (node.parent) {
-            preprocess(this, node);
-        }
-
-        // Updates the code path.
-        // And emits onCodePathStart/onCodePathSegmentStart events.
-        processCodePathToEnter(this, node);
-
-        // Emits node events.
-        this.original.enterNode(node);
-
-        this.currentNode = null;
-    }
-
-    /**
-     * Does the process to leave a given AST node.
-     * This updates state of analysis and calls `leaveNode` of the wrapped.
-     *
-     * @param {ASTNode} node - A node which is leaving.
-     * @returns {void}
-     */
-    leaveNode(node) {
-        this.currentNode = node;
-
-        // Updates the code path.
-        // And emits onCodePathStart/onCodePathSegmentStart events.
-        processCodePathToExit(this, node);
-
-        // Emits node events.
-        this.original.leaveNode(node);
-
-        // Emits the last onCodePathStart/onCodePathSegmentStart events.
-        postprocess(this, node);
-
-        this.currentNode = null;
-    }
-
-    /**
-     * This is called on a code path looped.
-     * Then this raises a looped event.
-     *
-     * @param {CodePathSegment} fromSegment - A segment of prev.
-     * @param {CodePathSegment} toSegment - A segment of next.
-     * @returns {void}
-     */
-    onLooped(fromSegment, toSegment) {
-        if (fromSegment.reachable && toSegment.reachable) {
-            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);
-            this.emitter.emit(
-                "onCodePathSegmentLoop",
-                fromSegment,
-                toSegment,
-                this.currentNode
-            );
-        }
-    }
-}
-
-module.exports = CodePathAnalyzer;
Index: node_modules/eslint/lib/report-translator.js
===================================================================
--- node_modules/eslint/lib/report-translator.js	(revision )
+++ node_modules/eslint/lib/report-translator.js	(revision )
@@ -1,274 +0,0 @@
-/**
- * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects
- * @author Teddy Katz
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const assert = require("assert");
-const ruleFixer = require("./util/rule-fixer");
-
-//------------------------------------------------------------------------------
-// Typedefs
-//------------------------------------------------------------------------------
-
-/**
- * An error message description
- * @typedef {Object} MessageDescriptor
- * @property {ASTNode} [node] The reported node
- * @property {Location} loc The location of the problem.
- * @property {string} message The problem message.
- * @property {Object} [data] Optional data to use to fill in placeholders in the
- *      message.
- * @property {Function} [fix] The function to call that creates a fix command.
- */
-
-//------------------------------------------------------------------------------
-// Module Definition
-//------------------------------------------------------------------------------
-
-
-/**
- * Translates a multi-argument context.report() call into a single object argument call
- * @param {...*} arguments A list of arguments passed to `context.report`
- * @returns {MessageDescriptor} A normalized object containing report information
- */
-function normalizeMultiArgReportCall() {
-
-    // If there is one argument, it is considered to be a new-style call already.
-    if (arguments.length === 1) {
-        return arguments[0];
-    }
-
-    // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].
-    if (typeof arguments[1] === "string") {
-        return {
-            node: arguments[0],
-            message: arguments[1],
-            data: arguments[2],
-            fix: arguments[3]
-        };
-    }
-
-    // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].
-    return {
-        node: arguments[0],
-        loc: arguments[1],
-        message: arguments[2],
-        data: arguments[3],
-        fix: arguments[4]
-    };
-}
-
-/**
- * Asserts that either a loc or a node was provided, and the node is valid if it was provided.
- * @param {MessageDescriptor} descriptor A descriptor to validate
- * @returns {void}
- * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object
- */
-function assertValidNodeInfo(descriptor) {
-    if (descriptor.node) {
-        assert(typeof descriptor.node === "object", "Node must be an object");
-    } else {
-        assert(descriptor.loc, "Node must be provided when reporting error if location is not provided");
-    }
-}
-
-/**
- * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties
- * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.
- * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties
- * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.
- */
-function normalizeReportLoc(descriptor) {
-    if (descriptor.loc) {
-        if (descriptor.loc.start) {
-            return descriptor.loc;
-        }
-        return { start: descriptor.loc, end: null };
-    }
-    return descriptor.node.loc;
-}
-
-/**
- * Interpolates data placeholders in report messages
- * @param {MessageDescriptor} descriptor The report message descriptor.
- * @returns {string} The interpolated message for the descriptor
- */
-function normalizeMessagePlaceholders(descriptor) {
-    if (!descriptor.data) {
-        return descriptor.message;
-    }
-    return descriptor.message.replace(/\{\{\s*([^{}]+?)\s*\}\}/g, (fullMatch, term) => {
-        if (term in descriptor.data) {
-            return descriptor.data[term];
-        }
-
-        return fullMatch;
-    });
-}
-
-/**
- * Compares items in a fixes array by range.
- * @param {Fix} a The first message.
- * @param {Fix} b The second message.
- * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.
- * @private
- */
-function compareFixesByRange(a, b) {
-    return a.range[0] - b.range[0] || a.range[1] - b.range[1];
-}
-
-/**
- * Merges the given fixes array into one.
- * @param {Fix[]} fixes The fixes to merge.
- * @param {SourceCode} sourceCode The source code object to get the text between fixes.
- * @returns {{text: string, range: [number, number]}} The merged fixes
- */
-function mergeFixes(fixes, sourceCode) {
-    if (fixes.length === 0) {
-        return null;
-    }
-    if (fixes.length === 1) {
-        return fixes[0];
-    }
-
-    fixes.sort(compareFixesByRange);
-
-    const originalText = sourceCode.text;
-    const start = fixes[0].range[0];
-    const end = fixes[fixes.length - 1].range[1];
-    let text = "";
-    let lastPos = Number.MIN_SAFE_INTEGER;
-
-    for (const fix of fixes) {
-        assert(fix.range[0] >= lastPos, "Fix objects must not be overlapped in a report.");
-
-        if (fix.range[0] >= 0) {
-            text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);
-        }
-        text += fix.text;
-        lastPos = fix.range[1];
-    }
-    text += originalText.slice(Math.max(0, start, lastPos), end);
-
-    return { range: [start, end], text };
-}
-
-/**
- * Gets one fix object from the given descriptor.
- * If the descriptor retrieves multiple fixes, this merges those to one.
- * @param {MessageDescriptor} descriptor The report descriptor.
- * @param {SourceCode} sourceCode The source code object to get text between fixes.
- * @returns {({text: string, range: [number, number]}|null)} The fix for the descriptor
- */
-function normalizeFixes(descriptor, sourceCode) {
-    if (typeof descriptor.fix !== "function") {
-        return null;
-    }
-
-    // @type {null | Fix | Fix[] | IterableIterator<Fix>}
-    const fix = descriptor.fix(ruleFixer);
-
-    // Merge to one.
-    if (fix && Symbol.iterator in fix) {
-        return mergeFixes(Array.from(fix), sourceCode);
-    }
-    return fix;
-}
-
-/**
- * Creates information about the report from a descriptor
- * @param {{
- *     ruleId: string,
- *     severity: (0|1|2),
- *     node: (ASTNode|null),
- *     message: string,
- *     loc: {start: SourceLocation, end: (SourceLocation|null)},
- *     fix: ({text: string, range: [number, number]}|null),
- *     sourceLines: string[]
- * }} options Information about the problem
- * @returns {function(...args): {
- *      ruleId: string,
- *      severity: (0|1|2),
- *      message: string,
- *      line: number,
- *      column: number,
- *      endLine: (number|undefined),
- *      endColumn: (number|undefined),
- *      nodeType: (string|null),
- *      source: string,
- *      fix: ({text: string, range: [number, number]}|null)
- * }} Information about the report
- */
-function createProblem(options) {
-    const problem = {
-        ruleId: options.ruleId,
-        severity: options.severity,
-        message: options.message,
-        line: options.loc.start.line,
-        column: options.loc.start.column + 1,
-        nodeType: options.node && options.node.type || null,
-        source: options.sourceLines[options.loc.start.line - 1] || ""
-    };
-
-    if (options.loc.end) {
-        problem.endLine = options.loc.end.line;
-        problem.endColumn = options.loc.end.column + 1;
-    }
-
-    if (options.fix) {
-        problem.fix = options.fix;
-    }
-
-    return problem;
-}
-
-/**
- * Returns a function that converts the arguments of a `context.report` call from a rule into a reported
- * problem for the Node.js API.
- * @param {{ruleId: string, severity: number, sourceCode: SourceCode}} metadata Metadata for the reported problem
- * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted
- * @returns {function(...args): {
- *      ruleId: string,
- *      severity: (0|1|2),
- *      message: string,
- *      line: number,
- *      column: number,
- *      endLine: (number|undefined),
- *      endColumn: (number|undefined),
- *      nodeType: (string|null),
- *      source: string,
- *      fix: ({text: string, range: [number, number]}|null)
- * }}
- * Information about the report
- */
-
-module.exports = function createReportTranslator(metadata) {
-
-    /*
-     * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.
-     * The report translator itself (i.e. the function that `createReportTranslator` returns) gets
-     * called every time a rule reports a problem, which happens much less frequently (usually, the vast
-     * majority of rules don't report any problems for a given file).
-     */
-    return function() {
-        const descriptor = normalizeMultiArgReportCall.apply(null, arguments);
-
-        assertValidNodeInfo(descriptor);
-
-        return createProblem({
-            ruleId: metadata.ruleId,
-            severity: metadata.severity,
-            node: descriptor.node,
-            message: normalizeMessagePlaceholders(descriptor),
-            loc: normalizeReportLoc(descriptor),
-            fix: normalizeFixes(descriptor, metadata.sourceCode),
-            sourceLines: metadata.sourceCode.lines
-        });
-    };
-};
Index: node_modules/eslint/conf/eslint-all.js
===================================================================
--- node_modules/eslint/conf/eslint-all.js	(revision )
+++ node_modules/eslint/conf/eslint-all.js	(revision )
@@ -1,31 +0,0 @@
-/**
- * @fileoverview Config to enable all rules.
- * @author Robert Fletcher
- */
-
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const load = require("../lib/load-rules"),
-    Rules = require("../lib/rules");
-const rules = new Rules();
-
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-const enabledRules = Object.keys(load()).reduce((result, ruleId) => {
-    if (!rules.get(ruleId).meta.deprecated) {
-        result[ruleId] = "error";
-    }
-    return result;
-}, {});
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = { rules: enabledRules };
Index: node_modules/eslint/conf/environments.js
===================================================================
--- node_modules/eslint/conf/environments.js	(revision )
+++ node_modules/eslint/conf/environments.js	(revision )
@@ -1,107 +0,0 @@
-/**
- * @fileoverview Defines environment settings and globals.
- * @author Elan Shanker
- */
-"use strict";
-
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const globals = require("globals");
-
-//------------------------------------------------------------------------------
-// Public Interface
-//------------------------------------------------------------------------------
-
-module.exports = {
-    builtin: globals.es5,
-    browser: {
-        globals: globals.browser
-    },
-    node: {
-        globals: globals.node,
-        parserOptions: {
-            ecmaFeatures: {
-                globalReturn: true
-            }
-        }
-    },
-    commonjs: {
-        globals: globals.commonjs,
-        parserOptions: {
-            ecmaFeatures: {
-                globalReturn: true
-            }
-        }
-    },
-    "shared-node-browser": {
-        globals: globals["shared-node-browser"]
-    },
-    worker: {
-        globals: globals.worker
-    },
-    amd: {
-        globals: globals.amd
-    },
-    mocha: {
-        globals: globals.mocha
-    },
-    jasmine: {
-        globals: globals.jasmine
-    },
-    jest: {
-        globals: globals.jest
-    },
-    phantomjs: {
-        globals: globals.phantomjs
-    },
-    jquery: {
-        globals: globals.jquery
-    },
-    qunit: {
-        globals: globals.qunit
-    },
-    prototypejs: {
-        globals: globals.prototypejs
-    },
-    shelljs: {
-        globals: globals.shelljs
-    },
-    meteor: {
-        globals: globals.meteor
-    },
-    mongo: {
-        globals: globals.mongo
-    },
-    protractor: {
-        globals: globals.protractor
-    },
-    applescript: {
-        globals: globals.applescript
-    },
-    nashorn: {
-        globals: globals.nashorn
-    },
-    serviceworker: {
-        globals: globals.serviceworker
-    },
-    atomtest: {
-        globals: globals.atomtest
-    },
-    embertest: {
-        globals: globals.embertest
-    },
-    webextensions: {
-        globals: globals.webextensions
-    },
-    es6: {
-        globals: globals.es6,
-        parserOptions: {
-            ecmaVersion: 6
-        }
-    },
-    greasemonkey: {
-        globals: globals.greasemonkey
-    }
-};
Index: node_modules/eslint/conf/config-schema.js
===================================================================
--- node_modules/eslint/conf/config-schema.js	(revision )
+++ node_modules/eslint/conf/config-schema.js	(revision )
@@ -1,70 +0,0 @@
-/**
- * @fileoverview Defines a schema for configs.
- * @author Sylvan Mably
- */
-
-"use strict";
-
-const baseConfigProperties = {
-    env: { type: "object" },
-    globals: { type: "object" },
-    parser: { type: ["string", "null"] },
-    parserOptions: { type: "object" },
-    plugins: { type: "array" },
-    rules: { type: "object" },
-    settings: { type: "object" },
-
-    ecmaFeatures: { type: "object" } // deprecated; logs a warning when used
-};
-
-const overrideProperties = Object.assign(
-    {},
-    baseConfigProperties,
-    {
-        files: {
-            oneOf: [
-                { type: "string" },
-                {
-                    type: "array",
-                    items: { type: "string" },
-                    minItems: 1
-                }
-            ]
-        },
-        excludedFiles: {
-            oneOf: [
-                { type: "string" },
-                {
-                    type: "array",
-                    items: { type: "string" }
-                }
-            ]
-        }
-    }
-);
-
-const topLevelConfigProperties = Object.assign(
-    {},
-    baseConfigProperties,
-    {
-        extends: { type: ["string", "array"] },
-        root: { type: "boolean" },
-        overrides: {
-            type: "array",
-            items: {
-                type: "object",
-                properties: overrideProperties,
-                required: ["files"],
-                additionalProperties: false
-            }
-        }
-    }
-);
-
-const configSchema = {
-    type: "object",
-    properties: topLevelConfigProperties,
-    additionalProperties: false
-};
-
-module.exports = configSchema;
Index: node_modules/eslint/conf/blank-script.json
===================================================================
--- node_modules/eslint/conf/blank-script.json	(revision )
+++ node_modules/eslint/conf/blank-script.json	(revision )
@@ -1,21 +0,0 @@
-{
-  "type": "Program",
-  "body": [],
-  "sourceType": "script",
-  "range": [
-    0,
-    0
-  ],
-  "loc": {
-    "start": {
-      "line": 0,
-      "column": 0
-    },
-    "end": {
-      "line": 0,
-      "column": 0
-    }
-  },
-  "comments": [],
-  "tokens": []
-}
Index: node_modules/eslint/conf/replacements.json
===================================================================
--- node_modules/eslint/conf/replacements.json	(revision )
+++ node_modules/eslint/conf/replacements.json	(revision )
@@ -1,22 +0,0 @@
-{
-    "rules": {
-        "generator-star": ["generator-star-spacing"],
-        "global-strict": ["strict"],
-        "no-arrow-condition": ["no-confusing-arrow", "no-constant-condition"],
-        "no-comma-dangle": ["comma-dangle"],
-        "no-empty-class": ["no-empty-character-class"],
-        "no-empty-label": ["no-labels"],
-        "no-extra-strict": ["strict"],
-        "no-reserved-keys": ["quote-props"],
-        "no-space-before-semi": ["semi-spacing"],
-        "no-wrap-func": ["no-extra-parens"],
-        "space-after-function-name": ["space-before-function-paren"],
-        "space-after-keywords": ["keyword-spacing"],
-        "space-before-function-parentheses": ["space-before-function-paren"],
-        "space-before-keywords": ["keyword-spacing"],
-        "space-in-brackets": ["object-curly-spacing", "array-bracket-spacing", "computed-property-spacing"],
-        "space-return-throw-case": ["keyword-spacing"],
-        "space-unary-word-ops": ["space-unary-ops"],
-        "spaced-line-comment": ["spaced-comment"]
-    }
-}
Index: node_modules/eslint/conf/category-list.json
===================================================================
--- node_modules/eslint/conf/category-list.json	(revision )
+++ node_modules/eslint/conf/category-list.json	(revision )
@@ -1,40 +0,0 @@
-{
-    "categories": [
-        { "name": "Possible Errors", "description": "These rules relate to possible syntax or logic errors in JavaScript code:" },
-        { "name": "Best Practices", "description": "These rules relate to better ways of doing things to help you avoid problems:" },
-        { "name": "Strict Mode", "description": "These rules relate to strict mode directives:" },
-        { "name": "Variables", "description": "These rules relate to variable declarations:" },
-        { "name": "Node.js and CommonJS", "description": "These rules relate to code running in Node.js, or in browsers with CommonJS:" },
-        { "name": "Stylistic Issues", "description": "These rules relate to style guidelines, and are therefore quite subjective:" },
-        { "name": "ECMAScript 6", "description": "These rules relate to ES6, also known as ES2015:" }
-    ],
-    "deprecated": {
-        "name": "Deprecated",
-        "description": "These rules have been deprecated in accordance with the [deprecation policy](/docs/user-guide/rule-deprecation), and replaced by newer rules:",
-        "rules": []
-    },
-    "removed": {
-        "name": "Removed",
-        "description": "These rules from older versions of ESLint (before the [deprecation policy](/docs/user-guide/rule-deprecation) existed) have been replaced by newer rules:",
-        "rules": [
-            { "removed": "generator-star", "replacedBy": ["generator-star-spacing"] },
-            { "removed": "global-strict", "replacedBy": ["strict"] },
-            { "removed": "no-arrow-condition", "replacedBy": ["no-confusing-arrow", "no-constant-condition"] },
-            { "removed": "no-comma-dangle", "replacedBy": ["comma-dangle"] },
-            { "removed": "no-empty-class", "replacedBy": ["no-empty-character-class"] },
-            { "removed": "no-empty-label", "replacedBy": ["no-labels"] },
-            { "removed": "no-extra-strict", "replacedBy": ["strict"] },
-            { "removed": "no-reserved-keys", "replacedBy": ["quote-props"] },
-            { "removed": "no-space-before-semi", "replacedBy": ["semi-spacing"] },
-            { "removed": "no-wrap-func", "replacedBy": ["no-extra-parens"] },
-            { "removed": "space-after-function-name", "replacedBy": ["space-before-function-paren"] },
-            { "removed": "space-after-keywords", "replacedBy": ["keyword-spacing"] },
-            { "removed": "space-before-function-parentheses", "replacedBy": ["space-before-function-paren"] },
-            { "removed": "space-before-keywords", "replacedBy": ["keyword-spacing"] },
-            { "removed": "space-in-brackets", "replacedBy": ["object-curly-spacing", "array-bracket-spacing"] },
-            { "removed": "space-return-throw-case", "replacedBy": ["keyword-spacing"] },
-            { "removed": "space-unary-word-ops", "replacedBy": ["space-unary-ops"] },
-            { "removed": "spaced-line-comment", "replacedBy": ["spaced-comment"] }
-        ]
-    }
-}
Index: node_modules/eslint/conf/eslint-recommended.js
===================================================================
--- node_modules/eslint/conf/eslint-recommended.js	(revision )
+++ node_modules/eslint/conf/eslint-recommended.js	(revision )
@@ -1,268 +0,0 @@
-/**
- * @fileoverview Configuration applied when a user configuration extends from
- * eslint:recommended.
- * @author Nicholas C. Zakas
- */
-
-"use strict";
-
-/* eslint sort-keys: ["error", "asc"] */
-
-module.exports = {
-    rules: {
-        "accessor-pairs": "off",
-        "array-bracket-newline": "off",
-        "array-bracket-spacing": "off",
-        "array-callback-return": "off",
-        "array-element-newline": "off",
-        "arrow-body-style": "off",
-        "arrow-parens": "off",
-        "arrow-spacing": "off",
-        "block-scoped-var": "off",
-        "block-spacing": "off",
-        "brace-style": "off",
-        "callback-return": "off",
-        camelcase: "off",
-        "capitalized-comments": "off",
-        "class-methods-use-this": "off",
-        "comma-dangle": "off",
-        "comma-spacing": "off",
-        "comma-style": "off",
-        complexity: "off",
-        "computed-property-spacing": "off",
-        "consistent-return": "off",
-        "consistent-this": "off",
-        "constructor-super": "error",
-        curly: "off",
-        "default-case": "off",
-        "dot-location": "off",
-        "dot-notation": "off",
-        "eol-last": "off",
-        eqeqeq: "off",
-        "for-direction": "off",
-        "func-call-spacing": "off",
-        "func-name-matching": "off",
-        "func-names": "off",
-        "func-style": "off",
-        "function-paren-newline": "off",
-        "generator-star-spacing": "off",
-        "getter-return": "off",
-        "global-require": "off",
-        "guard-for-in": "off",
-        "handle-callback-err": "off",
-        "id-blacklist": "off",
-        "id-length": "off",
-        "id-match": "off",
-        indent: "off",
-        "indent-legacy": "off",
-        "init-declarations": "off",
-        "jsx-quotes": "off",
-        "key-spacing": "off",
-        "keyword-spacing": "off",
-        "line-comment-position": "off",
-        "linebreak-style": "off",
-        "lines-around-comment": "off",
-        "lines-around-directive": "off",
-        "max-depth": "off",
-        "max-len": "off",
-        "max-lines": "off",
-        "max-nested-callbacks": "off",
-        "max-params": "off",
-        "max-statements": "off",
-        "max-statements-per-line": "off",
-        "multiline-ternary": "off",
-        "new-cap": "off",
-        "new-parens": "off",
-        "newline-after-var": "off",
-        "newline-before-return": "off",
-        "newline-per-chained-call": "off",
-        "no-alert": "off",
-        "no-array-constructor": "off",
-        "no-await-in-loop": "off",
-        "no-bitwise": "off",
-        "no-buffer-constructor": "off",
-        "no-caller": "off",
-        "no-case-declarations": "error",
-        "no-catch-shadow": "off",
-        "no-class-assign": "error",
-        "no-compare-neg-zero": "error",
-        "no-cond-assign": "error",
-        "no-confusing-arrow": "off",
-        "no-console": "error",
-        "no-const-assign": "error",
-        "no-constant-condition": "error",
-        "no-continue": "off",
-        "no-control-regex": "error",
-        "no-debugger": "error",
-        "no-delete-var": "error",
-        "no-div-regex": "off",
-        "no-dupe-args": "error",
-        "no-dupe-class-members": "error",
-        "no-dupe-keys": "error",
-        "no-duplicate-case": "error",
-        "no-duplicate-imports": "off",
-        "no-else-return": "off",
-        "no-empty": "error",
-        "no-empty-character-class": "error",
-        "no-empty-function": "off",
-        "no-empty-pattern": "error",
-        "no-eq-null": "off",
-        "no-eval": "off",
-        "no-ex-assign": "error",
-        "no-extend-native": "off",
-        "no-extra-bind": "off",
-        "no-extra-boolean-cast": "error",
-        "no-extra-label": "off",
-        "no-extra-parens": "off",
-        "no-extra-semi": "error",
-        "no-fallthrough": "error",
-        "no-floating-decimal": "off",
-        "no-func-assign": "error",
-        "no-global-assign": "error",
-        "no-implicit-coercion": "off",
-        "no-implicit-globals": "off",
-        "no-implied-eval": "off",
-        "no-inline-comments": "off",
-        "no-inner-declarations": "error",
-        "no-invalid-regexp": "error",
-        "no-invalid-this": "off",
-        "no-irregular-whitespace": "error",
-        "no-iterator": "off",
-        "no-label-var": "off",
-        "no-labels": "off",
-        "no-lone-blocks": "off",
-        "no-lonely-if": "off",
-        "no-loop-func": "off",
-        "no-magic-numbers": "off",
-        "no-mixed-operators": "off",
-        "no-mixed-requires": "off",
-        "no-mixed-spaces-and-tabs": "error",
-        "no-multi-assign": "off",
-        "no-multi-spaces": "off",
-        "no-multi-str": "off",
-        "no-multiple-empty-lines": "off",
-        "no-native-reassign": "off",
-        "no-negated-condition": "off",
-        "no-negated-in-lhs": "off",
-        "no-nested-ternary": "off",
-        "no-new": "off",
-        "no-new-func": "off",
-        "no-new-object": "off",
-        "no-new-require": "off",
-        "no-new-symbol": "error",
-        "no-new-wrappers": "off",
-        "no-obj-calls": "error",
-        "no-octal": "error",
-        "no-octal-escape": "off",
-        "no-param-reassign": "off",
-        "no-path-concat": "off",
-        "no-plusplus": "off",
-        "no-process-env": "off",
-        "no-process-exit": "off",
-        "no-proto": "off",
-        "no-prototype-builtins": "off",
-        "no-redeclare": "error",
-        "no-regex-spaces": "error",
-        "no-restricted-globals": "off",
-        "no-restricted-imports": "off",
-        "no-restricted-modules": "off",
-        "no-restricted-properties": "off",
-        "no-restricted-syntax": "off",
-        "no-return-assign": "off",
-        "no-return-await": "off",
-        "no-script-url": "off",
-        "no-self-assign": "error",
-        "no-self-compare": "off",
-        "no-sequences": "off",
-        "no-shadow": "off",
-        "no-shadow-restricted-names": "off",
-        "no-spaced-func": "off",
-        "no-sparse-arrays": "error",
-        "no-sync": "off",
-        "no-tabs": "off",
-        "no-template-curly-in-string": "off",
-        "no-ternary": "off",
-        "no-this-before-super": "error",
-        "no-throw-literal": "off",
-        "no-trailing-spaces": "off",
-        "no-undef": "error",
-        "no-undef-init": "off",
-        "no-undefined": "off",
-        "no-underscore-dangle": "off",
-        "no-unexpected-multiline": "error",
-        "no-unmodified-loop-condition": "off",
-        "no-unneeded-ternary": "off",
-        "no-unreachable": "error",
-        "no-unsafe-finally": "error",
-        "no-unsafe-negation": "error",
-        "no-unused-expressions": "off",
-        "no-unused-labels": "error",
-        "no-unused-vars": "error",
-        "no-use-before-define": "off",
-        "no-useless-call": "off",
-        "no-useless-computed-key": "off",
-        "no-useless-concat": "off",
-        "no-useless-constructor": "off",
-        "no-useless-escape": "error",
-        "no-useless-rename": "off",
-        "no-useless-return": "off",
-        "no-var": "off",
-        "no-void": "off",
-        "no-warning-comments": "off",
-        "no-whitespace-before-property": "off",
-        "no-with": "off",
-        "nonblock-statement-body-position": "off",
-        "object-curly-newline": "off",
-        "object-curly-spacing": "off",
-        "object-property-newline": "off",
-        "object-shorthand": "off",
-        "one-var": "off",
-        "one-var-declaration-per-line": "off",
-        "operator-assignment": "off",
-        "operator-linebreak": "off",
-        "padded-blocks": "off",
-        "padding-line-between-statements": "off",
-        "prefer-arrow-callback": "off",
-        "prefer-const": "off",
-        "prefer-destructuring": "off",
-        "prefer-numeric-literals": "off",
-        "prefer-promise-reject-errors": "off",
-        "prefer-reflect": "off",
-        "prefer-rest-params": "off",
-        "prefer-spread": "off",
-        "prefer-template": "off",
-        "quote-props": "off",
-        quotes: "off",
-        radix: "off",
-        "require-await": "off",
-        "require-jsdoc": "off",
-        "require-yield": "error",
-        "rest-spread-spacing": "off",
-        semi: "off",
-        "semi-spacing": "off",
-        "semi-style": "off",
-        "sort-imports": "off",
-        "sort-keys": "off",
-        "sort-vars": "off",
-        "space-before-blocks": "off",
-        "space-before-function-paren": "off",
-        "space-in-parens": "off",
-        "space-infix-ops": "off",
-        "space-unary-ops": "off",
-        "spaced-comment": "off",
-        strict: "off",
-        "switch-colon-spacing": "off",
-        "symbol-description": "off",
-        "template-curly-spacing": "off",
-        "template-tag-spacing": "off",
-        "unicode-bom": "off",
-        "use-isnan": "error",
-        "valid-jsdoc": "off",
-        "valid-typeof": "error",
-        "vars-on-top": "off",
-        "wrap-iife": "off",
-        "wrap-regex": "off",
-        "yield-star-spacing": "off",
-        yoda: "off"
-    }
-};
Index: node_modules/eslint/conf/default-cli-options.js
===================================================================
--- node_modules/eslint/conf/default-cli-options.js	(revision )
+++ node_modules/eslint/conf/default-cli-options.js	(revision )
@@ -1,27 +0,0 @@
-/**
- * @fileoverview Default CLIEngineOptions.
- * @author Ian VanSchooten
- */
-
-"use strict";
-
-module.exports = {
-    configFile: null,
-    baseConfig: false,
-    rulePaths: [],
-    useEslintrc: true,
-    envs: [],
-    globals: [],
-    extensions: [".js"],
-    ignore: true,
-    ignorePath: null,
-    cache: false,
-
-    // in order to honor the cacheFile option if specified
-    // this option should not have a default value otherwise
-    // it will always be used
-    cacheLocation: "",
-    cacheFile: ".eslintcache",
-    fix: false,
-    allowInlineConfig: true
-};
Index: node_modules/eslint/conf/default-config-options.js
===================================================================
--- node_modules/eslint/conf/default-config-options.js	(revision )
+++ node_modules/eslint/conf/default-config-options.js	(revision )
@@ -1,29 +0,0 @@
-/**
- * @fileoverview Default config options
- * @author Teddy Katz
- */
-
-"use strict";
-
-/**
- * Freezes an object and all its nested properties
- * @param {Object} obj The object to deeply freeze
- * @returns {Object} `obj` after freezing it
- */
-function deepFreeze(obj) {
-    if (obj === null || typeof obj !== "object") {
-        return obj;
-    }
-
-    Object.keys(obj).map(key => obj[key]).forEach(deepFreeze);
-    return Object.freeze(obj);
-}
-
-module.exports = deepFreeze({
-    env: {},
-    globals: {},
-    rules: {},
-    settings: {},
-    parser: "espree",
-    parserOptions: {}
-});
Index: node_modules/eslint/LICENSE
===================================================================
--- node_modules/eslint/LICENSE	(revision )
+++ node_modules/eslint/LICENSE	(revision )
@@ -1,19 +0,0 @@
-Copyright JS Foundation and other contributors, https://js.foundation
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
Index: node_modules/eslint/messages/plugin-missing.txt
===================================================================
--- node_modules/eslint/messages/plugin-missing.txt	(revision )
+++ node_modules/eslint/messages/plugin-missing.txt	(revision )
@@ -1,9 +0,0 @@
-ESLint couldn't find the plugin "<%- pluginName %>". This can happen for a couple different reasons:
-
-1. If ESLint is installed globally, then make sure <%- pluginName %> is also installed globally. A globally-installed ESLint cannot find a locally-installed plugin.
-
-2. If ESLint is installed locally, then it's likely that the plugin isn't installed correctly. Try reinstalling by running the following:
-
-    npm i <%- pluginName %>@latest --save-dev
-
-If you still can't figure out the problem, please stop by https://gitter.im/eslint/eslint to chat with the team.
Index: node_modules/eslint/messages/no-config-found.txt
===================================================================
--- node_modules/eslint/messages/no-config-found.txt	(revision )
+++ node_modules/eslint/messages/no-config-found.txt	(revision )
@@ -1,7 +0,0 @@
-ESLint couldn't find a configuration file. To set up a configuration file for this project, please run:
-
-    eslint --init
-
-ESLint looked for configuration files in <%= directory %> and its ancestors.
-
-If you think you already have a configuration file or if you need more help, please stop by the ESLint chat room: https://gitter.im/eslint/eslint
Index: node_modules/eslint/messages/whitespace-found.txt
===================================================================
--- node_modules/eslint/messages/whitespace-found.txt	(revision )
+++ node_modules/eslint/messages/whitespace-found.txt	(revision )
@@ -1,3 +0,0 @@
-ESLint couldn't find the plugin "<%- pluginName %>". because there is whitespace in the name. Please check your configuration and remove all whitespace from the plugin name.
-
-If you still can't figure out the problem, please stop by https://gitter.im/eslint/eslint to chat with the team.
Index: node_modules/eslint/messages/extend-config-missing.txt
===================================================================
--- node_modules/eslint/messages/extend-config-missing.txt	(revision )
+++ node_modules/eslint/messages/extend-config-missing.txt	(revision )
@@ -1,3 +0,0 @@
-ESLint couldn't find the config "<%- configName %>" to extend from. Please check that the name of the config is correct.
-
-If you still have problems, please stop by https://gitter.im/eslint/eslint to chat with the team.
Index: node_modules/eslint/package.json
===================================================================
--- node_modules/eslint/package.json	(revision )
+++ node_modules/eslint/package.json	(revision )
@@ -1,126 +0,0 @@
-{
-  "name": "eslint",
-  "version": "4.7.1",
-  "author": "Nicholas C. Zakas <nicholas+npm@nczconsulting.com>",
-  "description": "An AST-based pattern checker for JavaScript.",
-  "bin": {
-    "eslint": "./bin/eslint.js"
-  },
-  "main": "./lib/api.js",
-  "scripts": {
-    "test": "node Makefile.js test",
-    "lint": "node Makefile.js lint",
-    "fuzz": "node Makefile.js fuzz",
-    "release": "node Makefile.js release",
-    "ci-release": "node Makefile.js ciRelease",
-    "alpharelease": "node Makefile.js prerelease -- alpha",
-    "betarelease": "node Makefile.js prerelease -- beta",
-    "docs": "node Makefile.js docs",
-    "gensite": "node Makefile.js gensite",
-    "browserify": "node Makefile.js browserify",
-    "perf": "node Makefile.js perf",
-    "profile": "beefy tests/bench/bench.js --open -- -t brfs -t ./tests/bench/xform-rules.js -r espree",
-    "coveralls": "cat ./coverage/lcov.info | coveralls",
-    "check-commit": "node Makefile.js checkGitCommit"
-  },
-  "files": [
-    "LICENSE",
-    "README.md",
-    "bin",
-    "conf",
-    "lib",
-    "messages"
-  ],
-  "repository": "eslint/eslint",
-  "homepage": "http://eslint.org",
-  "bugs": "https://github.com/eslint/eslint/issues/",
-  "dependencies": {
-    "ajv": "^5.2.0",
-    "babel-code-frame": "^6.22.0",
-    "chalk": "^2.1.0",
-    "concat-stream": "^1.6.0",
-    "cross-spawn": "^5.1.0",
-    "debug": "^3.0.1",
-    "doctrine": "^2.0.0",
-    "eslint-scope": "^3.7.1",
-    "espree": "^3.5.1",
-    "esquery": "^1.0.0",
-    "estraverse": "^4.2.0",
-    "esutils": "^2.0.2",
-    "file-entry-cache": "^2.0.0",
-    "functional-red-black-tree": "^1.0.1",
-    "glob": "^7.1.2",
-    "globals": "^9.17.0",
-    "ignore": "^3.3.3",
-    "imurmurhash": "^0.1.4",
-    "inquirer": "^3.0.6",
-    "is-resolvable": "^1.0.0",
-    "js-yaml": "^3.9.1",
-    "json-stable-stringify": "^1.0.1",
-    "levn": "^0.3.0",
-    "lodash": "^4.17.4",
-    "minimatch": "^3.0.2",
-    "mkdirp": "^0.5.1",
-    "natural-compare": "^1.4.0",
-    "optionator": "^0.8.2",
-    "path-is-inside": "^1.0.2",
-    "pluralize": "^7.0.0",
-    "progress": "^2.0.0",
-    "require-uncached": "^1.0.3",
-    "semver": "^5.3.0",
-    "strip-ansi": "^4.0.0",
-    "strip-json-comments": "~2.0.1",
-    "table": "^4.0.1",
-    "text-table": "~0.2.0"
-  },
-  "devDependencies": {
-    "babel-polyfill": "^6.23.0",
-    "babel-preset-es2015": "^6.24.1",
-    "babelify": "^7.3.0",
-    "beefy": "^2.1.8",
-    "brfs": "1.4.3",
-    "browserify": "^14.4.0",
-    "chai": "^4.0.1",
-    "cheerio": "^0.22.0",
-    "coveralls": "^2.13.1",
-    "dateformat": "^2.0.0",
-    "ejs": "^2.5.6",
-    "eslint-plugin-eslint-plugin": "^1.2.0",
-    "eslint-plugin-node": "^5.1.0",
-    "eslint-release": "^0.10.1",
-    "eslump": "1.6.0",
-    "esprima": "^4.0.0",
-    "esprima-fb": "^15001.1001.0-dev-harmony-fb",
-    "istanbul": "^0.4.5",
-    "jsdoc": "^3.4.3",
-    "karma": "^1.7.0",
-    "karma-babel-preprocessor": "^6.0.1",
-    "karma-mocha": "^1.3.0",
-    "karma-mocha-reporter": "^2.2.3",
-    "karma-phantomjs-launcher": "^1.0.4",
-    "leche": "^2.1.2",
-    "load-perf": "^0.2.0",
-    "markdownlint": "^0.6.1",
-    "mocha": "^3.4.2",
-    "mock-fs": "^4.3.0",
-    "npm-license": "^0.3.3",
-    "phantomjs-prebuilt": "^2.1.14",
-    "proxyquire": "^1.8.0",
-    "shelljs": "^0.7.7",
-    "shelljs-nodecli": "~0.1.1",
-    "sinon": "^3.2.1",
-    "temp": "^0.8.3",
-    "through": "^2.3.8"
-  },
-  "keywords": [
-    "ast",
-    "lint",
-    "javascript",
-    "ecmascript",
-    "espree"
-  ],
-  "license": "MIT",
-  "engines": {
-    "node": ">=4"
-  }
-}
Index: node_modules/browser-sync/bin/browser-sync.js
===================================================================
--- node_modules/browser-sync/bin/browser-sync.js	(revision )
+++ node_modules/browser-sync/bin/browser-sync.js	(revision )
@@ -1,91 +0,0 @@
-#!/usr/bin/env node
-var startOpts  = require("../lib/cli/opts.start.json");
-var reloadOpts = require("../lib/cli/opts.reload.json");
-var recipeOpts = require("../lib/cli/opts.recipe.json");
-var pkg        = require("../package.json");
-var utils      = require("../lib/utils");
-
-/**
- * Handle cli input
- */
-if (!module.parent) {
-    var yargs = require("yargs")
-        .command("start", "Start the server")
-        .command("init", "Create a configuration file")
-        .command("reload", "Send a reload event over HTTP protocol")
-        .command("recipe", "Generate the files for a recipe")
-        .version(function () {
-            return pkg.version;
-        })
-        .epilogue("For help running a certain command, type <command> --help\neg: $0 start --help");
-
-    var argv    = yargs.argv;
-    var command = argv._[0];
-    var valid   = ["start", "init", "reload", "recipe"];
-
-    if (valid.indexOf(command) > -1) {
-        handleIncoming(command, yargs.reset());
-    } else {
-        yargs.showHelp();
-    }
-}
-
-/**
- * @param {{cli: object, [whitelist]: array, [cb]: function}} opts
- * @returns {*}
- */
-function handleCli(opts) {
-
-    opts.cb = opts.cb || utils.defaultCallback;
-    return require("../lib/cli/command." + opts.cli.input[0])(opts);
-}
-
-module.exports = handleCli;
-
-/**
- * @param {string} command
- * @param {object} yargs
- */
-function handleIncoming(command, yargs) {
-    var out;
-    if (command === "start") {
-        out = yargs
-            .usage("Usage: $0 start [options]")
-            .options(startOpts)
-            .example("$0 start -s app", "- Use the App directory to serve files")
-            .example("$0 start -p www.bbc.co.uk", "- Proxy an existing website")
-            .help()
-            .argv;
-    }
-    if (command === "init") {
-        out = yargs
-            .usage("Usage: $0 init")
-            .example("$0 init")
-            .help()
-            .argv;
-    }
-    if (command === "reload") {
-        out = yargs
-            .usage("Usage: $0 reload")
-            .options(reloadOpts)
-            .example("$0 reload")
-            .example("$0 reload --port 4000")
-            .help()
-            .argv;
-    }
-    if (command === "recipe") {
-        out = yargs
-            .usage("Usage: $0 recipe <recipe-name>")
-            .option(recipeOpts)
-            .example("$0 recipe ls", "list the recipes")
-            .example("$0 recipe gulp.sass", "use the gulp.sass recipe")
-            .help()
-            .argv;
-    }
-
-    if (out.help) {
-        return yargs.showHelp();
-    }
-
-    handleCli({cli: {flags: out, input: out._}});
-}
Index: node_modules/browser-sync/lib/cli/help.txt
===================================================================
--- node_modules/browser-sync/lib/cli/help.txt	(revision )
+++ node_modules/browser-sync/lib/cli/help.txt	(revision )
@@ -1,11 +0,0 @@
-{cyan:Server Example:}
-{gray:---------------}
-Use current directory as root & watch CSS files
-
-    {gray:$} browser-sync start --server --files="css/*.css"
-
-{cyan:Proxy Example:}
-{gray:---------------}
-Proxy `localhost:8080` & watch CSS/HTML files
-
-    {gray:$} browser-sync start --proxy="localhost:8080" --files="*.html, css/*.css"
\ No newline at end of file
Index: node_modules/browser-sync/lib/cli/cli-info.js
===================================================================
--- node_modules/browser-sync/lib/cli/cli-info.js	(revision )
+++ node_modules/browser-sync/lib/cli/cli-info.js	(revision )
@@ -1,59 +0,0 @@
-"use strict";
-
-var config = require("../config");
-var logger = require("../logger").logger;
-
-var fs     = require("fs");
-var _      = require("../../lodash.custom");
-var path   = require("path");
-
-var info = {
-    /**
-     * Version info
-     * @param {Object} pjson
-     * @returns {String}
-     */
-    getVersion: function (pjson) {
-        console.log(pjson.version);
-        return pjson.version;
-    },
-    /**
-     * Retrieve the config file
-     * @returns {*}
-     * @private
-     * @param filePath
-     */
-    getConfigFile: function (filePath) {
-        return require(path.resolve(filePath));
-    },
-    /**
-     * Generate an example Config file.
-     */
-    makeConfig: function (cwd, cb) {
-
-        var opts = require(path.join(__dirname, "..", config.configFile));
-        var userOpts = {};
-
-        var ignore = ["excludedFileTypes", "injectFileTypes", "snippetOptions"];
-
-        Object.keys(opts).forEach(function (key) {
-            if (!_.includes(ignore, key)) {
-                userOpts[key] = opts[key];
-            }
-        });
-
-        var file = fs.readFileSync(path.join(__dirname, config.template), "utf8");
-        file = file.replace("//OPTS", JSON.stringify(userOpts, null, 4));
-
-        fs.writeFile(path.resolve(cwd, config.userFile), file, function () {
-            logger.info("Config file created {magenta:%s}", config.userFile);
-            logger.info(
-              "To use it, in the same directory run: " +
-              "{cyan:browser-sync start --config bs-config.js}"
-            );
-            cb();
-        });
-    }
-};
-
-module.exports = info;
Index: node_modules/browser-sync/lib/cli/cli-options.js
===================================================================
--- node_modules/browser-sync/lib/cli/cli-options.js	(revision )
+++ node_modules/browser-sync/lib/cli/cli-options.js	(revision )
@@ -1,317 +0,0 @@
-"use strict";
-
-var path = require("path");
-var url = require("url");
-var _    = require("../../lodash.custom");
-var Immutable = require("immutable");
-var isList = Immutable.List.isList;
-var isMap = Immutable.Map.isMap;
-var defaultConfig = require("../default-config");
-var immDefs = Immutable.fromJS(defaultConfig);
-
-var opts = exports;
-
-/**
- * @type {{wrapPattern: Function}}
- */
-opts.utils = {
-
-    /**
-     * Transform a string arg such as "*.html, css/*.css" into array
-     * @param string
-     * @returns {Array}
-     */
-    explodeFilesArg: function (string) {
-        return string.split(",").map(function (item) {
-            return item.trim();
-        });
-    },
-    /**
-     * @param pattern
-     * @returns {*|string}
-     * @private
-     */
-    wrapPattern: function (pattern) {
-        var prefix = "!";
-        var suffix = "/**";
-        var lastChar = pattern.charAt(pattern.length - 1);
-        var extName = path.extname(pattern);
-
-        // If there's a file ext, don't append any suffix
-        if (extName.length) {
-            suffix = "";
-        } else {
-
-            if (lastChar === "/") {
-                suffix = "**";
-            }
-
-            if (lastChar === "*") {
-                suffix = "";
-            }
-        }
-
-        return [prefix, pattern, suffix].join("");
-    }
-};
-
-opts.callbacks = {
-
-    /**
-     * Merge server options
-     * @param {String|Boolean|Object} value
-     * @param [argv]
-     * @returns {*}
-     */
-    server: function (value, argv) {
-
-        if (value === false) {
-            if (!argv || !argv.server) {
-                return false;
-            }
-        }
-
-        var obj = {
-            baseDir: "./"
-        };
-
-        if (_.isString(value) || isList(value)) {
-            obj.baseDir = value;
-        } else {
-            if (value && value !== true) {
-                if (value.get("baseDir")) {
-                    return value;
-                }
-            }
-        }
-
-        if (argv) {
-
-            if (argv.index) {
-                obj.index = argv.index;
-            }
-
-            if (argv.directory) {
-                obj.directory = true;
-            }
-        }
-
-        return Immutable.fromJS(obj);
-    },
-    /**
-     * @param value
-     * @param argv
-     * @returns {*}
-     */
-    proxy: function (value) {
-
-        var mw;
-        var target;
-
-        if (!value || value === true) {
-            return false;
-        }
-
-        if (typeof value !== "string") {
-            target = value.get("target");
-            mw     = value.get("middleware");
-        } else {
-            target = value;
-            value = Immutable.Map({});
-        }
-
-        if (!target.match(/^(https?):\/\//)) {
-            target = "http://" + target;
-        }
-
-        var parsedUrl = url.parse(target);
-
-        if (!parsedUrl.port) {
-            parsedUrl.port = 80;
-        }
-
-        var out = {
-            target: parsedUrl.protocol + "//" + parsedUrl.host,
-            url: Immutable.Map(parsedUrl)
-        };
-
-        if (mw) {
-            out.middleware = mw;
-        }
-
-        return value.mergeDeep(out);
-    },
-    /**
-     * @param value
-     * @private
-     */
-    ports: function (value) {
-
-        var segs;
-        var obj = {};
-
-        if (typeof value === "string") {
-
-            if (~value.indexOf(",")) {
-                segs = value.split(",");
-                obj.min = parseInt(segs[0], 10);
-                obj.max = parseInt(segs[1], 10);
-            } else {
-                obj.min = parseInt(value, 10);
-                obj.max = null;
-            }
-
-        } else {
-
-            obj.min = value.get("min");
-            obj.max = value.get("max") || null;
-        }
-
-        return Immutable.Map(obj);
-    },
-    /**
-     * @param value
-     * @param argv
-     * @returns {*}
-     */
-    ghostMode: function (value, argv) {
-
-        var trueAll = {
-            clicks: true,
-            scroll: true,
-            forms: {
-                submit: true,
-                inputs: true,
-                toggles: true
-            }
-        };
-
-        var falseAll = {
-            clicks: false,
-            scroll: false,
-            forms: {
-                submit: false,
-                inputs: false,
-                toggles: false
-            }
-        };
-
-        if (value === false || value === "false" || argv && argv.ghost === false) {
-            return Immutable.fromJS(falseAll);
-        }
-
-        if (value === true || value === "true" || argv && argv.ghost === true) {
-            return Immutable.fromJS(trueAll);
-        }
-
-        if (value.get("forms") === false) {
-            return value.withMutations(function (map) {
-                map.set("forms", Immutable.fromJS({
-                    submit: false,
-                    inputs: false,
-                    toggles: false
-                }));
-            });
-        }
-
-        if (value.get("forms") === true) {
-            return value.withMutations(function (map) {
-                map.set("forms", Immutable.fromJS({
-                    submit: true,
-                    inputs: true,
-                    toggles: true
-                }));
-            });
-        }
-
-        return value;
-    },
-    /**
-     * @param value
-     * @returns {*}
-     */
-    files: function (value) {
-
-        var namespaces = {core: {}};
-
-        namespaces.core.globs = [];
-        namespaces.core.objs  = [];
-
-        var processed = opts.makeFilesArg(value);
-
-        if (processed.globs.length) {
-            namespaces.core.globs = processed.globs;
-        }
-
-        if (processed.objs.length) {
-            namespaces.core.objs = processed.objs;
-        }
-
-        return Immutable.fromJS(namespaces);
-    },
-    /**
-     * @param value
-     */
-    extensions: function (value) {
-        if (_.isString(value)) {
-            var split = opts.utils.explodeFilesArg(value);
-            if (split.length) {
-                return Immutable.List(split);
-            }
-        }
-        if (Immutable.List.isList(value)) {
-            return value;
-        }
-        return value;
-    }
-};
-
-/**
- * @param {Object} values
- * @param {Object} [argv]
- * @returns {Map}
- */
-opts.merge = function (values, argv) {
-    return immDefs
-        .mergeDeep(values)
-        .withMutations(function (item) {
-            item.map(function (value, key) {
-                if (opts.callbacks[key]) {
-                    item.set(key, opts.callbacks[key](value, argv));
-                }
-            });
-        });
-};
-
-/**
- * @param value
- * @returns {{globs: Array, objs: Array}}
- */
-opts.makeFilesArg = function (value) {
-
-    var globs = [];
-    var objs  = [];
-
-    if (_.isString(value)) {
-        globs = globs.concat(
-            opts.utils.explodeFilesArg(value)
-        );
-    }
-
-    if (isList(value) && value.size) {
-        value.forEach(function (value) {
-            if (_.isString(value)) {
-                globs.push(value);
-            } else {
-                if (isMap(value)) {
-                    objs.push(value);
-                }
-            }
-        });
-    }
-
-    return {
-        globs: globs,
-        objs: objs
-    };
-};
Index: node_modules/browser-sync/lib/cli/opts.init.json
===================================================================
--- node_modules/browser-sync/lib/cli/opts.init.json	(revision )
+++ node_modules/browser-sync/lib/cli/opts.init.json	(revision )
@@ -1,1 +0,0 @@
-{}
\ No newline at end of file
Index: node_modules/browser-sync/lib/cli/cli-template.js
===================================================================
--- node_modules/browser-sync/lib/cli/cli-template.js	(revision )
+++ node_modules/browser-sync/lib/cli/cli-template.js	(revision )
@@ -1,15 +0,0 @@
-
-/*
- |--------------------------------------------------------------------------
- | Browser-sync config file
- |--------------------------------------------------------------------------
- |
- | For up-to-date information about the options:
- |   http://www.browsersync.io/docs/options/
- |
- | There are more options than you see here, these are just the ones that are
- | set internally. See the website for more info.
- |
- |
- */
-module.exports = //OPTS;
\ No newline at end of file
Index: node_modules/browser-sync/lib/cli/command.init.js
===================================================================
--- node_modules/browser-sync/lib/cli/command.init.js	(revision )
+++ node_modules/browser-sync/lib/cli/command.init.js	(revision )
@@ -1,15 +0,0 @@
-"use strict";
-
-var info          = require("./cli-info");
-
-/**
- * $ browser-sync init
- *
- * This command will generate a configuration
- * file in the current directory
- *
- * @param opts
- */
-module.exports = function (opts) {
-    info.makeConfig(process.cwd(), opts.cb);
-};
Index: node_modules/browser-sync/lib/cli/opts.start.json
===================================================================
--- node_modules/browser-sync/lib/cli/opts.start.json	(revision )
+++ node_modules/browser-sync/lib/cli/opts.start.json	(revision )
@@ -1,120 +0,0 @@
-{
-  "server": {
-    "alias": "s",
-    "desc": "Run a Local server (uses your cwd as the web root)"
-  },
-  "serveStatic": {
-    "type": "array",
-    "alias": "ss",
-    "desc": "Directories to serve static files from"
-  },
-  "port": {
-    "type": "number",
-    "desc": "Specify a port to use"
-  },
-  "proxy": {
-    "alias": "p",
-    "desc": "Proxy an existing server",
-    "example": "$0 shane is cool"
-  },
-  "ws": {
-    "type": "boolean",
-    "desc": "Proxy mode only - enable websocket proxying"
-  },
-  "browser": {
-    "type": "array",
-    "alias": "b",
-    "desc": "Choose which browser should be auto-opened"
-  },
-  "files": {
-    "type": "array",
-    "alias": "f",
-    "desc": "File paths to watch"
-  },
-  "index": {
-    "type": "string",
-    "desc": "Specify which file should be used as the index page"
-  },
-  "plugins": {
-    "type": "array",
-    "desc": "Load Browsersync plugins"
-  },
-  "extensions": {
-    "type": "array",
-    "desc": "Specify file extension fallbacks"
-  },
-  "startPath": {
-    "type": "string",
-    "desc": "Specify the start path for the opened browser"
-  },
-  "https": {
-    "desc": "Enable SSL for local development"
-  },
-  "directory": {
-    "type": "boolean",
-    "desc": "Show a directory listing for the server"
-  },
-  "xip": {
-    "type": "boolean",
-    "desc": "Use xip.io domain routing"
-  },
-  "tunnel": {
-    "desc": "Use a public URL"
-  },
-  "open": {
-    "type": "string",
-    "desc": "Choose which URL is auto-opened (local, external or tunnel), or provide a url"
-  },
-  "cors": {
-    "type": "boolean",
-    "desc": "Add Access Control headers to every request"
-  },
-  "config": {
-    "type": "string",
-    "alias": "c",
-    "desc": "Specify a path to a configuration file"
-  },
-  "host": {
-    "desc": "Specify a hostname to use"
-  },
-  "logLevel": {
-    "desc": "Set the logger output level (silent, info or debug)"
-  },
-  "reload-delay": {
-    "type": "number",
-    "desc": "Time in milliseconds to delay the reload event following file changes"
-  },
-  "reload-debounce": {
-    "type": "number",
-    "desc": "Restrict the frequency in which browser:reload events can be emitted to connected clients"
-  },
-  "ui-port": {
-    "type": "number",
-    "desc": "Specify a port for the UI to use"
-  },
-  "watchEvents": {
-    "type": "array",
-    "desc": "Specify which file events to respond to"
-  },
-  "no-notify": {
-    "desc": "Disable the notify element in browsers"
-  },
-  "no-open": {
-    "desc": "Don't open a new browser window"
-  },
-  "no-online": {
-    "desc": "Force offline usage"
-  },
-  "no-ui": {
-    "desc": "Don't start the user interface"
-  },
-  "no-ghost-mode": {
-    "desc": "Disable Ghost Mode"
-  },
-  "no-inject-changes": {
-    "desc": "Reload on every file change"
-  },
-  "no-reload-on-restart": {
-    "desc": "Don't auto-reload all browsers following a restart"
-  }
-}
Index: node_modules/browser-sync/lib/cli/command.start.js
===================================================================
--- node_modules/browser-sync/lib/cli/command.start.js	(revision )
+++ node_modules/browser-sync/lib/cli/command.start.js	(revision )
@@ -1,88 +0,0 @@
-"use strict";
-
-var path  = require("path");
-var fs    = require("fs");
-var _     = require("../../lodash.custom");
-var utils = require("../utils");
-var opts  = require("./cli-options").utils;
-
-/**
- * $ browser-sync start <options>
- *
- * This commands starts the Browsersync servers
- * & Optionally UI.
- *
- * @param opts
- * @returns {Function}
- */
-module.exports = function (opts) {
-
-    var flags    = preprocessFlags(opts.cli.flags);
-    var maybepkg = path.resolve(process.cwd(), "package.json");
-    var input    = flags;
-
-    if (flags.config) {
-        var maybeconf = path.resolve(process.cwd(), flags.config);
-        if (fs.existsSync(maybeconf)) {
-            var conf = require(maybeconf);
-            input = _.merge({}, conf, flags);
-        } else {
-            utils.fail(true, new Error("Configuration file '" + flags.config + "' not found"), opts.cb);
-        }
-    } else {
-        if (fs.existsSync(maybepkg)) {
-            var pkg = require(maybepkg);
-            if (pkg["browser-sync"]) {
-                console.log("> Configuration obtained from package.json");
-                input = _.merge({}, pkg["browser-sync"], flags);
-            }
-        }
-    }
-
-    return require("../../")
-        .create("cli")
-        .init(input, opts.cb);
-};
-
-/**
- * @param flags
- * @returns {*}
- */
-function preprocessFlags (flags) {
-    return [
-        stripUndefined,
-        legacyFilesArgs
-    ].reduce(function (flags, fn) {
-        return fn.call(null, flags);
-    }, flags);
-}
-
-/**
- * Incoming undefined values are problematic as
- * they interfere with Immutable.Map.mergeDeep
- * @param subject
- * @returns {*}
- */
-function stripUndefined (subject) {
-    return Object.keys(subject).reduce(function (acc, key) {
-        var value = subject[key];
-        if (typeof value === "undefined") {
-            return acc;
-        }
-        acc[key] = value;
-        return acc;
-    }, {});
-}
-
-/**
- * @param flags
- * @returns {*}
- */
-function legacyFilesArgs(flags) {
-    if (flags.files && flags.files.length) {
-        flags.files = flags.files.reduce(function (acc, item) {
-            return acc.concat(opts.explodeFilesArg(item));
-        }, []);
-    }
-    return flags;
-}
Index: node_modules/browser-sync/lib/cli/opts.recipe.json
===================================================================
--- node_modules/browser-sync/lib/cli/opts.recipe.json	(revision )
+++ node_modules/browser-sync/lib/cli/opts.recipe.json	(revision )
@@ -1,6 +0,0 @@
-{
-  "output": {
-    "alias": "o",
-    "desc": "Specify an output directory"
-  }
-}
Index: node_modules/browser-sync/lib/cli/opts.reload.json
===================================================================
--- node_modules/browser-sync/lib/cli/opts.reload.json	(revision )
+++ node_modules/browser-sync/lib/cli/opts.reload.json	(revision )
@@ -1,16 +0,0 @@
-{
-  "files": {
-    "desc": "File paths to reload",
-    "type": "array",
-    "alias": "f"
-  },
-  "port": {
-    "alias": "p",
-    "type": "number",
-    "desc": "Target a running instance by port number"
-  },
-  "url": {
-    "alias": "u",
-    "desc": "Provide the full the url to the running Browsersync instance"
-  }
-}
Index: node_modules/browser-sync/lib/cli/command.recipe.js
===================================================================
--- node_modules/browser-sync/lib/cli/command.recipe.js	(revision )
+++ node_modules/browser-sync/lib/cli/command.recipe.js	(revision )
@@ -1,64 +0,0 @@
-"use strict";
-var logger = require("../logger").logger;
-
-/**
- * $ browser-sync recipe <name> <options>
- *
- * This command will copy a recipe into either the current directory
- * or one given with the --output flag
- *
- * @param opts
- * @returns {Function}
- */
-module.exports = function (opts) {
-
-    var path      = require("path");
-    var fs        = require("fs-extra");
-    var input     = opts.cli.input.slice(1);
-    var resolved  = require.resolve("bs-recipes");
-    var dir       = path.dirname(resolved);
-
-    var logRecipes = function () {
-        var dirs = fs.readdirSync(path.join(dir, "recipes"));
-        logger.info("Install one of the following with {cyan:browser-sync recipe <name>\n");
-        dirs.forEach(function (name) {
-            console.log("    " + name);
-        });
-    };
-
-    if (!input.length) {
-        logger.info("No recipe name provided!");
-        logRecipes();
-        return opts.cb();
-    }
-
-    if (opts.cli.input[1] === "ls") {
-        logRecipes();
-        return opts.cb();
-    }
-
-    input         = input[0];
-    var flags     = opts.cli.flags;
-    var output    = flags.output ? path.resolve(flags.output) : path.join(process.cwd(), input);
-    var targetDir = path.join(dir, "recipes", input);
-
-    if (fs.existsSync(output)) {
-        return opts.cb(new Error("Target folder exists remove it first and then try again"));
-    }
-
-    if (fs.existsSync(targetDir)) {
-        fs.copy(targetDir, output, function (err) {
-            if (err) {
-                opts.cb(err);
-            } else {
-                logger.info("Recipe copied into {cyan:%s}", output);
-                logger.info("Next, inside that folder, run {cyan:npm i && npm start}");
-                opts.cb(null);
-            }
-        });
-    } else {
-        logger.info("Recipe {cyan:%s} not found. The following are available though", input);
-        logRecipes();
-        opts.cb();
-    }
-};
Index: node_modules/browser-sync/lib/cli/command.reload.js
===================================================================
--- node_modules/browser-sync/lib/cli/command.reload.js	(revision )
+++ node_modules/browser-sync/lib/cli/command.reload.js	(revision )
@@ -1,44 +0,0 @@
-"use strict";
-
-/**
- * $ browser-sync reload <options>
- *
- * This commands starts the Browsersync servers
- * & Optionally UI.
- *
- * @param opts
- * @returns {Function}
- */
-module.exports = function (opts) {
-
-    var flags = opts.cli.flags;
-    if (!flags.url) {
-        flags.url = "http://localhost:" + (flags.port || 3000);
-    }
-    var proto  = require("../http-protocol");
-    var scheme = flags.url.match(/^https/) ? "https" : "http";
-    var args   = {method: "reload"};
-
-    if (flags.files) {
-        args.args = flags.files;
-    }
-
-    var url    = proto.getUrl(args, flags.url);
-
-    if (scheme === "https") {
-        process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
-    }
-
-    require(scheme).get(url, function (res) {
-        res.on("data", function () {
-            if (res.statusCode === 200) {
-                opts.cb(null, res);
-            }
-        });
-    }).on("error", function (err) {
-        if (err.code === "ECONNREFUSED") {
-            err.message = "Browsersync not running at " + flags.url;
-        }
-        return opts.cb(err);
-    });
-};
Index: node_modules/browser-sync/lib/public/exit.js
===================================================================
--- node_modules/browser-sync/lib/public/exit.js	(revision )
+++ node_modules/browser-sync/lib/public/exit.js	(revision )
@@ -1,17 +0,0 @@
-"use strict";
-
-/**
- * @param {BrowserSync} browserSync
- * @returns {Function}
- */
-module.exports = function (browserSync) {
-
-    function exit() {
-        if (browserSync.active) {
-            browserSync.events.emit("service:exit");
-            browserSync.cleanup();
-        }
-    }
-
-    return exit;
-};
Index: node_modules/browser-sync/lib/public/init.js
===================================================================
--- node_modules/browser-sync/lib/public/init.js	(revision )
+++ node_modules/browser-sync/lib/public/init.js	(revision )
@@ -1,32 +0,0 @@
-"use strict";
-
-var _         = require("../../lodash.custom");
-var merge     = require("../cli/cli-options").merge;
-
-/**
- * @param {BrowserSync} browserSync
- * @param {String} [name] - instance name
- * @param {Object} pjson
- * @returns {Function}
- */
-module.exports = function (browserSync, name, pjson) {
-
-    return function () {
-
-        /**
-         * Handle new + old signatures for init.
-         */
-        var args = require("../args")(_.toArray(arguments));
-
-        /**
-         * If the current instance is already running, just return an error
-         */
-        if (browserSync.active) {
-            return args.cb(new Error("Instance: " + name + " is already running!"));
-        }
-
-        args.config.version = pjson.version;
-
-        return browserSync.init(merge(args.config), args.cb);
-    };
-};
Index: node_modules/browser-sync/lib/public/pause.js
===================================================================
--- node_modules/browser-sync/lib/public/pause.js	(revision )
+++ node_modules/browser-sync/lib/public/pause.js	(revision )
@@ -1,12 +0,0 @@
-"use strict";
-
-/**
- * @param {BrowserSync} browserSync
- * @returns {Function}
- */
-module.exports = function (browserSync) {
-
-    return function () {
-        browserSync.paused = true;
-    };
-};
Index: node_modules/browser-sync/lib/public/notify.js
===================================================================
--- node_modules/browser-sync/lib/public/notify.js	(revision )
+++ node_modules/browser-sync/lib/public/notify.js	(revision )
@@ -1,19 +0,0 @@
-"use strict";
-
-/**
- * @param {BrowserSync} browserSync
- * @returns {Function}
- */
-module.exports = function (browserSync) {
-
-    return function (msg, timeout) {
-
-        if (msg) {
-            browserSync.events.emit("browser:notify", {
-                message: msg,
-                timeout: timeout || 2000,
-                override: true
-            });
-        }
-    };
-};
Index: node_modules/browser-sync/lib/public/reload.js
===================================================================
--- node_modules/browser-sync/lib/public/reload.js	(revision )
+++ node_modules/browser-sync/lib/public/reload.js	(revision )
@@ -1,67 +0,0 @@
-"use strict";
-
-var utils         = require("../utils");
-var publicUtils   = require("./public-utils");
-var _             = require("../../lodash.custom");
-var defaultConfig = require("../default-config");
-var stream        = require("./stream");
-
-/**
- * @param emitter
- * @returns {Function}
- */
-module.exports = function (emitter) {
-
-    /**
-     * Inform browsers about file changes.
-     *
-     * eg: reload("core.css")
-     */
-    function browserSyncReload (opts) {
-
-        /**
-         * BACKWARDS COMPATIBILITY:
-         * Passing an object as the only arg to the `reload`
-         * method with at *least* the key-value pair of {stream: true},
-         * was only ever used for streams support - so it's safe to check
-         * for that signature here and defer to the
-         * dedicated `.stream()` method instead.
-         */
-        if (_.isObject(opts)) {
-            if (!Array.isArray(opts) && Object.keys(opts).length) {
-                if (opts.stream === true) {
-                    return stream(emitter)(opts);
-                }
-            }
-        }
-
-        /**
-         * Handle single string paths such as
-         * reload("core.css")
-         */
-        if (typeof opts === "string" && opts !== "undefined") {
-            return publicUtils.emitChangeEvent(emitter, opts, true);
-        }
-
-        /**
-         * Handle an array of file paths such as
-         * reload(["core.css, "ie.css"])
-         */
-        if (Array.isArray(opts)) {
-            return opts.forEach(function (filepath) {
-                publicUtils.emitChangeEvent(emitter, filepath, true);
-            });
-        }
-
-        /**
-         * At this point the argument given was neither an object,
-         * array or string so we simply perform a reload. This is to
-         * allow the following syntax to work as expected
-         *
-         * reload();
-         */
-        return publicUtils.emitBrowserReload(emitter);
-    }
-
-    return browserSyncReload;
-};
Index: node_modules/browser-sync/lib/public/resume.js
===================================================================
--- node_modules/browser-sync/lib/public/resume.js	(revision )
+++ node_modules/browser-sync/lib/public/resume.js	(revision )
@@ -1,12 +0,0 @@
-"use strict";
-
-/**
- * @param {BrowserSync} browserSync
- * @returns {Function}
- */
-module.exports = function (browserSync) {
-
-    return function () {
-        browserSync.paused = false;
-    };
-};
Index: node_modules/browser-sync/lib/public/stream.js
===================================================================
--- node_modules/browser-sync/lib/public/stream.js	(revision )
+++ node_modules/browser-sync/lib/public/stream.js	(revision )
@@ -1,98 +0,0 @@
-"use strict";
-
-var path       = require("path");
-var micromatch = require("micromatch");
-var utils      = require("./public-utils");
-
-/**
- * @param emitter
- * @returns {Function}
- */
-module.exports = function (emitter) {
-
-    /**
-     * Return a transform/through stream that listens to file
-     * paths and fires internal Browsersync events.
-     * @param {{once: boolean, match: string|array}} [opts]
-     * @returns {Stream.Transform}
-     */
-    function browserSyncThroughStream (opts) {
-
-        opts = opts || {};
-        var emitted = false;
-        var Transform = require("stream").Transform;
-        var reload = new Transform({objectMode: true});
-        var changed = [];
-
-        reload._transform = function (file, encoding, next) {
-
-            var stream = this;
-
-            /**
-             * End is always called to send the current file down
-             * stream. Browsersync never acts upon a stream,
-             * we only `listen` to it.
-             */
-            function end () {
-                stream.push(file); // always send the file down-stream
-                next();
-            }
-
-            /**
-             * If {match: <pattern>} was provided, test the
-             * current filepath against it
-             */
-            if (opts.match) {
-                if (!micromatch(file.path, opts.match, {dot: true}).length) {
-                    return end();
-                }
-            }
-
-            /**
-             * if {once: true} provided, emit the reload event for the
-             * first file only
-             */
-            if (opts.once === true && !emitted) {
-
-                utils.emitBrowserReload(emitter);
-
-                emitted = true;
-
-            } else { // handle multiple
-
-                if (opts.once === true && emitted) {
-
-                } else {
-
-                    if (file.path) {
-
-                        emitted = true;
-                        utils.emitChangeEvent(emitter, file.path, false);
-                        changed.push(path.basename(file.path));
-                    }
-                }
-            }
-
-            end();
-        };
-
-        /**
-         * When this current operation has finished, emit the
-         * steam:changed event so that any loggers can pick up it
-         * @param next
-         * @private
-         */
-        reload._flush = function (next) {
-
-            if (changed.length) {
-                utils.emitStreamChangedEvent(emitter, changed);
-            }
-
-            next();
-        };
-
-        return reload;
-    }
-
-    return browserSyncThroughStream;
-};
Index: node_modules/browser-sync/lib/public/public-utils.js
===================================================================
--- node_modules/browser-sync/lib/public/public-utils.js	(revision )
+++ node_modules/browser-sync/lib/public/public-utils.js	(revision )
@@ -1,65 +0,0 @@
-"use strict";
-
-var _ = require("../../lodash.custom");
-
-module.exports = {
-    /**
-     * Emit the internal `file:change` event
-     * @param {EventEmitter} emitter
-     * @param {string} path
-     * @param {boolean} [log]
-     */
-    emitChangeEvent: function emitChangeEvent (emitter, path, log) {
-        emitter.emit("file:changed", {
-            path:      path,
-            log:       log,
-            namespace: "core",
-            event:     "change"
-        });
-    },
-    /**
-     * Emit the internal `browser:reload` event
-     * @param {EventEmitter} emitter
-     */
-    emitBrowserReload: function emitChangeEvent (emitter) {
-        emitter.emit("_browser:reload");
-    },
-    /**
-     * Emit the internal `stream:changed` event
-     * @param {EventEmitter} emitter
-     * @param {Array} changed
-     */
-    emitStreamChangedEvent: function (emitter, changed) {
-        emitter.emit("stream:changed", {changed: changed});
-    },
-    /**
-     * This code handles the switch between .reload & .stream
-     * since 2.6.0
-     * @param name
-     * @param args
-     * @returns {boolean}
-     */
-    isStreamArg: function (name, args) {
-
-        if (name === "stream") {
-            return true;
-        }
-
-        if (name !== "reload") {
-            return false;
-        }
-
-        var firstArg = args[0];
-
-        /**
-         * If here, it's reload with args
-         */
-        if (_.isObject(firstArg)) {
-            if (!Array.isArray(firstArg) && Object.keys(firstArg).length) {
-                return firstArg.stream === true;
-            }
-        }
-
-        return false;
-    }
-};
Index: node_modules/browser-sync/lib/public/socket.io.min.1.6.0.js
===================================================================
--- node_modules/browser-sync/lib/public/socket.io.min.1.6.0.js	(revision )
+++ node_modules/browser-sync/lib/public/socket.io.min.1.6.0.js	(revision )
@@ -1,3 +0,0 @@
-!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"object"==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(n){if(r[n])return r[n].exports;var o=r[n]={exports:{},id:n,loaded:!1};return t[n].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var r={};return e.m=t,e.c=r,e.p="",e(0)}([function(t,e,r){"use strict";function n(t,e){"object"===("undefined"==typeof t?"undefined":i(t))&&(e=t,t=void 0),e=e||{};var r,n=s(t),a=n.source,p=n.id,f=n.path,l=h[p]&&f in h[p].nsps,d=e.forceNew||e["force new connection"]||!1===e.multiplex||l;return d?(u("ignoring socket cache for %s",a),r=c(a,e)):(h[p]||(u("new io instance for %s",a),h[p]=c(a,e)),r=h[p]),n.query&&!e.query?e.query=n.query:e&&"object"===i(e.query)&&(e.query=o(e.query)),r.socket(n.path,e)}function o(t){var e=[];for(var r in t)t.hasOwnProperty(r)&&e.push(encodeURIComponent(r)+"="+encodeURIComponent(t[r]));return e.join("&")}var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},s=r(1),a=r(7),c=r(17),u=r(3)("socket.io-client");t.exports=e=n;var h=e.managers={};e.protocol=a.protocol,e.connect=n,e.Manager=r(17),e.Socket=r(45)},function(t,e,r){(function(e){"use strict";function n(t,r){var n=t;r=r||e.location,null==t&&(t=r.protocol+"//"+r.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?r.protocol+t:r.host+t),/^(https?|wss?):\/\//.test(t)||(i("protocol-less url %s",t),t="undefined"!=typeof r?r.protocol+"//"+t:"https://"+t),i("parse %s",t),n=o(t)),n.port||(/^(http|ws)$/.test(n.protocol)?n.port="80":/^(http|ws)s$/.test(n.protocol)&&(n.port="443")),n.path=n.path||"/";var s=n.host.indexOf(":")!==-1,a=s?"["+n.host+"]":n.host;return n.id=n.protocol+"://"+a+":"+n.port,n.href=n.protocol+"://"+a+(r&&r.port===n.port?"":":"+n.port),n}var o=r(2),i=r(3)("socket.io-client:url");t.exports=n}).call(e,function(){return this}())},function(t,e){var r=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,n=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];t.exports=function(t){var e=t,o=t.indexOf("["),i=t.indexOf("]");o!=-1&&i!=-1&&(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,";")+t.substring(i,t.length));for(var s=r.exec(t||""),a={},c=14;c--;)a[n[c]]=s[c]||"";return o!=-1&&i!=-1&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a}},function(t,e,r){(function(n){function o(){return"undefined"!=typeof document&&"WebkitAppearance"in document.documentElement.style||window.console&&(console.firebug||console.exception&&console.table)||navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31}function i(){var t=arguments,r=this.useColors;if(t[0]=(r?"%c":"")+this.namespace+(r?" %c":" ")+t[0]+(r?"%c ":" ")+"+"+e.humanize(this.diff),!r)return t;var n="color: "+this.color;t=[t[0],n,"color: inherit"].concat(Array.prototype.slice.call(t,1));var o=0,i=0;return t[0].replace(/%[a-z%]/g,function(t){"%%"!==t&&(o++,"%c"===t&&(i=o))}),t.splice(i,0,n),t}function s(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function a(t){try{null==t?e.storage.removeItem("debug"):e.storage.debug=t}catch(t){}}function c(){try{return e.storage.debug}catch(t){}if("undefined"!=typeof n&&"env"in n)return n.env.DEBUG}function u(){try{return window.localStorage}catch(t){}}e=t.exports=r(5),e.log=s,e.formatArgs=i,e.save=a,e.load=c,e.useColors=o,e.storage="undefined"!=typeof chrome&&"undefined"!=typeof chrome.storage?chrome.storage.local:u(),e.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],e.formatters.j=function(t){try{return JSON.stringify(t)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}},e.enable(c())}).call(e,r(4))},function(t,e){function r(){throw new Error("setTimeout has not been defined")}function n(){throw new Error("clearTimeout has not been defined")}function o(t){if(h===setTimeout)return setTimeout(t,0);if((h===r||!h)&&setTimeout)return h=setTimeout,setTimeout(t,0);try{return h(t,0)}catch(e){try{return h.call(null,t,0)}catch(e){return h.call(this,t,0)}}}function i(t){if(p===clearTimeout)return clearTimeout(t);if((p===n||!p)&&clearTimeout)return p=clearTimeout,clearTimeout(t);try{return p(t)}catch(e){try{return p.call(null,t)}catch(e){return p.call(this,t)}}}function s(){y&&l&&(y=!1,l.length?d=l.concat(d):g=-1,d.length&&a())}function a(){if(!y){var t=o(s);y=!0;for(var e=d.length;e;){for(l=d,d=[];++g<e;)l&&l[g].run();g=-1,e=d.length}l=null,y=!1,i(t)}}function c(t,e){this.fun=t,this.array=e}function u(){}var h,p,f=t.exports={};!function(){try{h="function"==typeof setTimeout?setTimeout:r}catch(t){h=r}try{p="function"==typeof clearTimeout?clearTimeout:n}catch(t){p=n}}();var l,d=[],y=!1,g=-1;f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];d.push(new c(t,e)),1!==d.length||y||o(a)},c.prototype.run=function(){this.fun.apply(null,this.array)},f.title="browser",f.browser=!0,f.env={},f.argv=[],f.version="",f.versions={},f.on=u,f.addListener=u,f.once=u,f.off=u,f.removeListener=u,f.removeAllListeners=u,f.emit=u,f.binding=function(t){throw new Error("process.binding is not supported")},f.cwd=function(){return"/"},f.chdir=function(t){throw new Error("process.chdir is not supported")},f.umask=function(){return 0}},function(t,e,r){function n(){return e.colors[h++%e.colors.length]}function o(t){function r(){}function o(){var t=o,r=+new Date,i=r-(u||r);t.diff=i,t.prev=u,t.curr=r,u=r,null==t.useColors&&(t.useColors=e.useColors()),null==t.color&&t.useColors&&(t.color=n());for(var s=new Array(arguments.length),a=0;a<s.length;a++)s[a]=arguments[a];s[0]=e.coerce(s[0]),"string"!=typeof s[0]&&(s=["%o"].concat(s));var c=0;s[0]=s[0].replace(/%([a-z%])/g,function(r,n){if("%%"===r)return r;c++;var o=e.formatters[n];if("function"==typeof o){var i=s[c];r=o.call(t,i),s.splice(c,1),c--}return r}),s=e.formatArgs.apply(t,s);var h=o.log||e.log||console.log.bind(console);h.apply(t,s)}r.enabled=!1,o.enabled=!0;var i=e.enabled(t)?o:r;return i.namespace=t,i}function i(t){e.save(t);for(var r=(t||"").split(/[\s,]+/),n=r.length,o=0;o<n;o++)r[o]&&(t=r[o].replace(/[\\^$+?.()|[\]{}]/g,"\\$&").replace(/\*/g,".*?"),"-"===t[0]?e.skips.push(new RegExp("^"+t.substr(1)+"$")):e.names.push(new RegExp("^"+t+"$")))}function s(){e.enable("")}function a(t){var r,n;for(r=0,n=e.skips.length;r<n;r++)if(e.skips[r].test(t))return!1;for(r=0,n=e.names.length;r<n;r++)if(e.names[r].test(t))return!0;return!1}function c(t){return t instanceof Error?t.stack||t.message:t}e=t.exports=o.debug=o,e.coerce=c,e.disable=s,e.enable=i,e.enabled=a,e.humanize=r(6),e.names=[],e.skips=[],e.formatters={};var u,h=0},function(t,e){function r(t){if(t=String(t),!(t.length>1e4)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(e){var r=parseFloat(e[1]),n=(e[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return r*h;case"days":case"day":case"d":return r*u;case"hours":case"hour":case"hrs":case"hr":case"h":return r*c;case"minutes":case"minute":case"mins":case"min":case"m":return r*a;case"seconds":case"second":case"secs":case"sec":case"s":return r*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return r;default:return}}}}function n(t){return t>=u?Math.round(t/u)+"d":t>=c?Math.round(t/c)+"h":t>=a?Math.round(t/a)+"m":t>=s?Math.round(t/s)+"s":t+"ms"}function o(t){return i(t,u,"day")||i(t,c,"hour")||i(t,a,"minute")||i(t,s,"second")||t+" ms"}function i(t,e,r){if(!(t<e))return t<1.5*e?Math.floor(t/e)+" "+r:Math.ceil(t/e)+" "+r+"s"}var s=1e3,a=60*s,c=60*a,u=24*c,h=365.25*u;t.exports=function(t,e){e=e||{};var i=typeof t;if("string"===i&&t.length>0)return r(t);if("number"===i&&isNaN(t)===!1)return e.long?o(t):n(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))}},function(t,e,r){function n(){}function o(t){var r="",n=!1;return r+=t.type,e.BINARY_EVENT!=t.type&&e.BINARY_ACK!=t.type||(r+=t.attachments,r+="-"),t.nsp&&"/"!=t.nsp&&(n=!0,r+=t.nsp),null!=t.id&&(n&&(r+=",",n=!1),r+=t.id),null!=t.data&&(n&&(r+=","),r+=f.stringify(t.data)),p("encoded %j as %s",t,r),r}function i(t,e){function r(t){var r=d.deconstructPacket(t),n=o(r.packet),i=r.buffers;i.unshift(n),e(i)}d.removeBlobs(t,r)}function s(){this.reconstructor=null}function a(t){var r={},n=0;if(r.type=Number(t.charAt(0)),null==e.types[r.type])return h();if(e.BINARY_EVENT==r.type||e.BINARY_ACK==r.type){for(var o="";"-"!=t.charAt(++n)&&(o+=t.charAt(n),n!=t.length););if(o!=Number(o)||"-"!=t.charAt(n))throw new Error("Illegal attachments");r.attachments=Number(o)}if("/"==t.charAt(n+1))for(r.nsp="";++n;){var i=t.charAt(n);if(","==i)break;if(r.nsp+=i,n==t.length)break}else r.nsp="/";var s=t.charAt(n+1);if(""!==s&&Number(s)==s){for(r.id="";++n;){var i=t.charAt(n);if(null==i||Number(i)!=i){--n;break}if(r.id+=t.charAt(n),n==t.length)break}r.id=Number(r.id)}return t.charAt(++n)&&(r=c(r,t.substr(n))),p("decoded %s as %j",t,r),r}function c(t,e){try{t.data=f.parse(e)}catch(t){return h()}return t}function u(t){this.reconPack=t,this.buffers=[]}function h(t){return{type:e.ERROR,data:"parser error"}}var p=r(8)("socket.io-parser"),f=r(11),l=r(13),d=r(14),y=r(16);e.protocol=4,e.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=n,e.Decoder=s,n.prototype.encode=function(t,r){if(p("encoding packet %j",t),e.BINARY_EVENT==t.type||e.BINARY_ACK==t.type)i(t,r);else{var n=o(t);r([n])}},l(s.prototype),s.prototype.add=function(t){var r;if("string"==typeof t)r=a(t),e.BINARY_EVENT==r.type||e.BINARY_ACK==r.type?(this.reconstructor=new u(r),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",r)):this.emit("decoded",r);else{if(!y(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");r=this.reconstructor.takeBinaryData(t),r&&(this.reconstructor=null,this.emit("decoded",r))}},s.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},u.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length==this.reconPack.attachments){var e=d.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},u.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,r){function n(){return"WebkitAppearance"in document.documentElement.style||window.console&&(console.firebug||console.exception&&console.table)||navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31}function o(){var t=arguments,r=this.useColors;if(t[0]=(r?"%c":"")+this.namespace+(r?" %c":" ")+t[0]+(r?"%c ":" ")+"+"+e.humanize(this.diff),!r)return t;var n="color: "+this.color;t=[t[0],n,"color: inherit"].concat(Array.prototype.slice.call(t,1));var o=0,i=0;return t[0].replace(/%[a-z%]/g,function(t){"%%"!==t&&(o++,"%c"===t&&(i=o))}),t.splice(i,0,n),t}function i(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function s(t){try{null==t?e.storage.removeItem("debug"):e.storage.debug=t}catch(t){}}function a(){var t;try{t=e.storage.debug}catch(t){}return t}function c(){try{return window.localStorage}catch(t){}}e=t.exports=r(9),e.log=i,e.formatArgs=o,e.save=s,e.load=a,e.useColors=n,e.storage="undefined"!=typeof chrome&&"undefined"!=typeof chrome.storage?chrome.storage.local:c(),e.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],e.formatters.j=function(t){return JSON.stringify(t)},e.enable(a())},function(t,e,r){function n(){return e.colors[h++%e.colors.length]}function o(t){function r(){}function o(){var t=o,r=+new Date,i=r-(u||r);t.diff=i,t.prev=u,t.curr=r,u=r,null==t.useColors&&(t.useColors=e.useColors()),null==t.color&&t.useColors&&(t.color=n());var s=Array.prototype.slice.call(arguments);s[0]=e.coerce(s[0]),"string"!=typeof s[0]&&(s=["%o"].concat(s));var a=0;s[0]=s[0].replace(/%([a-z%])/g,function(r,n){if("%%"===r)return r;a++;var o=e.formatters[n];if("function"==typeof o){var i=s[a];r=o.call(t,i),s.splice(a,1),a--}return r}),"function"==typeof e.formatArgs&&(s=e.formatArgs.apply(t,s));var c=o.log||e.log||console.log.bind(console);c.apply(t,s)}r.enabled=!1,o.enabled=!0;var i=e.enabled(t)?o:r;return i.namespace=t,i}function i(t){e.save(t);for(var r=(t||"").split(/[\s,]+/),n=r.length,o=0;o<n;o++)r[o]&&(t=r[o].replace(/\*/g,".*?"),"-"===t[0]?e.skips.push(new RegExp("^"+t.substr(1)+"$")):e.names.push(new RegExp("^"+t+"$")))}function s(){e.enable("")}function a(t){var r,n;for(r=0,n=e.skips.length;r<n;r++)if(e.skips[r].test(t))return!1;for(r=0,n=e.names.length;r<n;r++)if(e.names[r].test(t))return!0;return!1}function c(t){return t instanceof Error?t.stack||t.message:t}e=t.exports=o,e.coerce=c,e.disable=s,e.enable=i,e.enabled=a,e.humanize=r(10),e.names=[],e.skips=[],e.formatters={};var u,h=0},function(t,e){function r(t){if(t=""+t,!(t.length>1e4)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(e){var r=parseFloat(e[1]),n=(e[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return r*h;case"days":case"day":case"d":return r*u;case"hours":case"hour":case"hrs":case"hr":case"h":return r*c;case"minutes":case"minute":case"mins":case"min":case"m":return r*a;case"seconds":case"second":case"secs":case"sec":case"s":return r*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return r}}}}function n(t){return t>=u?Math.round(t/u)+"d":t>=c?Math.round(t/c)+"h":t>=a?Math.round(t/a)+"m":t>=s?Math.round(t/s)+"s":t+"ms"}function o(t){return i(t,u,"day")||i(t,c,"hour")||i(t,a,"minute")||i(t,s,"second")||t+" ms"}function i(t,e,r){if(!(t<e))return t<1.5*e?Math.floor(t/e)+" "+r:Math.ceil(t/e)+" "+r+"s"}var s=1e3,a=60*s,c=60*a,u=24*c,h=365.25*u;t.exports=function(t,e){return e=e||{},"string"==typeof t?r(t):e.long?o(t):n(t)}},function(t,e,r){(function(t,r){var n=!1;(function(){function o(t,e){function r(t){if(r[t]!==g)return r[t];var o;if("bug-string-char-index"==t)o="a"!="a"[0];else if("json"==t)o=r("json-stringify")&&r("json-parse");else{var s,a="{\"a\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}";if("json-stringify"==t){var c=e.stringify,h="function"==typeof c&&b;if(h){(s=function(){return 1}).toJSON=s;try{h="0"===c(0)&&"0"===c(new n)&&"\"\""==c(new i)&&c(v)===g&&c(g)===g&&c()===g&&"1"===c(s)&&"[1]"==c([s])&&"[null]"==c([g])&&"null"==c(null)&&"[null,null,null]"==c([g,v,null])&&c({a:[s,!0,!1,null,"\0\b\n\f\r\t"]})==a&&"1"===c(null,s)&&"[\n 1,\n 2\n]"==c([1,2],null,1)&&"\"-271821-04-20T00:00:00.000Z\""==c(new u(-864e13))&&"\"+275760-09-13T00:00:00.000Z\""==c(new u(864e13))&&"\"-000001-01-01T00:00:00.000Z\""==c(new u(-621987552e5))&&"\"1969-12-31T23:59:59.999Z\""==c(new u(-1))}catch(t){h=!1}}o=h}if("json-parse"==t){var p=e.parse;if("function"==typeof p)try{if(0===p("0")&&!p(!1)){s=p(a);var f=5==s.a.length&&1===s.a[0];if(f){try{f=!p("\"\t\"")}catch(t){}if(f)try{f=1!==p("01")}catch(t){}if(f)try{f=1!==p("1.")}catch(t){}}}}catch(t){f=!1}o=f}}return r[t]=!!o}t||(t=c.Object()),e||(e=c.Object());var n=t.Number||c.Number,i=t.String||c.String,a=t.Object||c.Object,u=t.Date||c.Date,h=t.SyntaxError||c.SyntaxError,p=t.TypeError||c.TypeError,f=t.Math||c.Math,l=t.JSON||c.JSON;"object"==typeof l&&l&&(e.stringify=l.stringify,e.parse=l.parse);var d,y,g,m=a.prototype,v=m.toString,b=new u(-0xc782b5b800cec);try{b=b.getUTCFullYear()==-109252&&0===b.getUTCMonth()&&1===b.getUTCDate()&&10==b.getUTCHours()&&37==b.getUTCMinutes()&&6==b.getUTCSeconds()&&708==b.getUTCMilliseconds()}catch(t){}if(!r("json")){var w="[object Function]",k="[object Date]",A="[object Number]",x="[object String]",B="[object Array]",C="[object Boolean]",S=r("bug-string-char-index");if(!b)var T=f.floor,E=[0,31,59,90,120,151,181,212,243,273,304,334],_=function(t,e){return E[e]+365*(t-1970)+T((t-1969+(e=+(e>1)))/4)-T((t-1901+e)/100)+T((t-1601+e)/400)};if((d=m.hasOwnProperty)||(d=function(t){var e,r={};return(r.__proto__=null,r.__proto__={toString:1},r).toString!=v?d=function(t){var e=this.__proto__,r=t in(this.__proto__=null,this);return this.__proto__=e,r}:(e=r.constructor,d=function(t){var r=(this.constructor||e).prototype;return t in this&&!(t in r&&this[t]===r[t])}),r=null,d.call(this,t)}),y=function(t,e){var r,n,o,i=0;(r=function(){this.valueOf=0}).prototype.valueOf=0,n=new r;for(o in n)d.call(n,o)&&i++;return r=n=null,i?y=2==i?function(t,e){var r,n={},o=v.call(t)==w;for(r in t)o&&"prototype"==r||d.call(n,r)||!(n[r]=1)||!d.call(t,r)||e(r)}:function(t,e){var r,n,o=v.call(t)==w;for(r in t)o&&"prototype"==r||!d.call(t,r)||(n="constructor"===r)||e(r);(n||d.call(t,r="constructor"))&&e(r)}:(n=["valueOf","toString","toLocaleString","propertyIsEnumerable","isPrototypeOf","hasOwnProperty","constructor"],y=function(t,e){var r,o,i=v.call(t)==w,a=!i&&"function"!=typeof t.constructor&&s[typeof t.hasOwnProperty]&&t.hasOwnProperty||d;for(r in t)i&&"prototype"==r||!a.call(t,r)||e(r);for(o=n.length;r=n[--o];a.call(t,r)&&e(r));}),y(t,e)},!r("json-stringify")){var N={92:"\\\\",34:"\\\"",8:"\\b",12:"\\f",10:"\\n",13:"\\r",9:"\\t"},j="000000",O=function(t,e){return(j+(e||0)).slice(-t)},P="\\u00",R=function(t){for(var e="\"",r=0,n=t.length,o=!S||n>10,i=o&&(S?t.split(""):t);r<n;r++){var s=t.charCodeAt(r);switch(s){case 8:case 9:case 10:case 12:case 13:case 34:case 92:e+=N[s];break;default:if(s<32){e+=P+O(2,s.toString(16));break}e+=o?i[r]:t.charAt(r)}}return e+"\""},D=function(t,e,r,n,o,i,s){var a,c,u,h,f,l,m,b,w,S,E,N,j,P,q,U;try{a=e[t]}catch(t){}if("object"==typeof a&&a)if(c=v.call(a),c!=k||d.call(a,"toJSON"))"function"==typeof a.toJSON&&(c!=A&&c!=x&&c!=B||d.call(a,"toJSON"))&&(a=a.toJSON(t));else if(a>-1/0&&a<1/0){if(_){for(f=T(a/864e5),u=T(f/365.2425)+1970-1;_(u+1,0)<=f;u++);for(h=T((f-_(u,0))/30.42);_(u,h+1)<=f;h++);f=1+f-_(u,h),l=(a%864e5+864e5)%864e5,m=T(l/36e5)%24,b=T(l/6e4)%60,w=T(l/1e3)%60,S=l%1e3}else u=a.getUTCFullYear(),h=a.getUTCMonth(),f=a.getUTCDate(),m=a.getUTCHours(),b=a.getUTCMinutes(),w=a.getUTCSeconds(),S=a.getUTCMilliseconds();a=(u<=0||u>=1e4?(u<0?"-":"+")+O(6,u<0?-u:u):O(4,u))+"-"+O(2,h+1)+"-"+O(2,f)+"T"+O(2,m)+":"+O(2,b)+":"+O(2,w)+"."+O(3,S)+"Z"}else a=null;if(r&&(a=r.call(e,t,a)),null===a)return"null";if(c=v.call(a),c==C)return""+a;if(c==A)return a>-1/0&&a<1/0?""+a:"null";if(c==x)return R(""+a);if("object"==typeof a){for(P=s.length;P--;)if(s[P]===a)throw p();if(s.push(a),E=[],q=i,i+=o,c==B){for(j=0,P=a.length;j<P;j++)N=D(j,a,r,n,o,i,s),E.push(N===g?"null":N);U=E.length?o?"[\n"+i+E.join(",\n"+i)+"\n"+q+"]":"["+E.join(",")+"]":"[]"}else y(n||a,function(t){var e=D(t,a,r,n,o,i,s);e!==g&&E.push(R(t)+":"+(o?" ":"")+e)}),U=E.length?o?"{\n"+i+E.join(",\n"+i)+"\n"+q+"}":"{"+E.join(",")+"}":"{}";return s.pop(),U}};e.stringify=function(t,e,r){var n,o,i,a;if(s[typeof e]&&e)if((a=v.call(e))==w)o=e;else if(a==B){i={};for(var c,u=0,h=e.length;u<h;c=e[u++],a=v.call(c),(a==x||a==A)&&(i[c]=1));}if(r)if((a=v.call(r))==A){if((r-=r%1)>0)for(n="",r>10&&(r=10);n.length<r;n+=" ");}else a==x&&(n=r.length<=10?r:r.slice(0,10));return D("",(c={},c[""]=t,c),o,i,n,"",[])}}if(!r("json-parse")){var q,U,M=i.fromCharCode,L={92:"\\",34:"\"",47:"/",98:"\b",116:"\t",110:"\n",102:"\f",114:"\r"},I=function(){throw q=U=null,h()},H=function(){for(var t,e,r,n,o,i=U,s=i.length;q<s;)switch(o=i.charCodeAt(q)){case 9:case 10:case 13:case 32:q++;break;case 123:case 125:case 91:case 93:case 58:case 44:return t=S?i.charAt(q):i[q],q++,t;case 34:for(t="@",q++;q<s;)if(o=i.charCodeAt(q),o<32)I();else if(92==o)switch(o=i.charCodeAt(++q)){case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:t+=L[o],q++;break;case 117:for(e=++q,r=q+4;q<r;q++)o=i.charCodeAt(q),o>=48&&o<=57||o>=97&&o<=102||o>=65&&o<=70||I();t+=M("0x"+i.slice(e,q));break;default:I()}else{if(34==o)break;for(o=i.charCodeAt(q),e=q;o>=32&&92!=o&&34!=o;)o=i.charCodeAt(++q);t+=i.slice(e,q)}if(34==i.charCodeAt(q))return q++,t;I();default:if(e=q,45==o&&(n=!0,o=i.charCodeAt(++q)),o>=48&&o<=57){for(48==o&&(o=i.charCodeAt(q+1),o>=48&&o<=57)&&I(),n=!1;q<s&&(o=i.charCodeAt(q),o>=48&&o<=57);q++);if(46==i.charCodeAt(q)){for(r=++q;r<s&&(o=i.charCodeAt(r),o>=48&&o<=57);r++);r==q&&I(),q=r}if(o=i.charCodeAt(q),101==o||69==o){for(o=i.charCodeAt(++q),43!=o&&45!=o||q++,r=q;r<s&&(o=i.charCodeAt(r),o>=48&&o<=57);r++);r==q&&I(),q=r}return+i.slice(e,q)}if(n&&I(),"true"==i.slice(q,q+4))return q+=4,!0;if("false"==i.slice(q,q+5))return q+=5,!1;if("null"==i.slice(q,q+4))return q+=4,null;I()}return"$"},z=function(t){var e,r;if("$"==t&&I(),"string"==typeof t){if("@"==(S?t.charAt(0):t[0]))return t.slice(1);if("["==t){for(e=[];t=H(),"]"!=t;r||(r=!0))r&&(","==t?(t=H(),"]"==t&&I()):I()),","==t&&I(),e.push(z(t));return e}if("{"==t){for(e={};t=H(),"}"!=t;r||(r=!0))r&&(","==t?(t=H(),"}"==t&&I()):I()),","!=t&&"string"==typeof t&&"@"==(S?t.charAt(0):t[0])&&":"==H()||I(),e[t.slice(1)]=z(H());return e}I()}return t},J=function(t,e,r){var n=X(t,e,r);n===g?delete t[e]:t[e]=n},X=function(t,e,r){var n,o=t[e];if("object"==typeof o&&o)if(v.call(o)==B)for(n=o.length;n--;)J(o,n,r);else y(o,function(t){J(o,t,r)});return r.call(t,e,o)};e.parse=function(t,e){var r,n;return q=0,U=""+t,r=z(H()),"$"!=H()&&I(),q=U=null,e&&v.call(e)==w?X((n={},n[""]=r,n),"",e):r}}}return e.runInContext=o,e}var i="function"==typeof n&&n.amd,s={function:!0,object:!0},a=s[typeof e]&&e&&!e.nodeType&&e,c=s[typeof window]&&window||this,u=a&&s[typeof t]&&t&&!t.nodeType&&"object"==typeof r&&r;if(!u||u.global!==u&&u.window!==u&&u.self!==u||(c=u),a&&!i)o(c,a);else{var h=c.JSON,p=c.JSON3,f=!1,l=o(c,c.JSON3={noConflict:function(){return f||(f=!0,c.JSON=h,c.JSON3=p,h=p=null),l}});c.JSON={parse:l.parse,stringify:l.stringify}}i&&n(function(){return l})}).call(this)}).call(e,r(12)(t),function(){return this}())},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children=[],t.webpackPolyfill=1),t}},function(t,e){function r(t){if(t)return n(t)}function n(t){for(var e in r.prototype)t[e]=r.prototype[e];return t}t.exports=r,r.prototype.on=r.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks[t]=this._callbacks[t]||[]).push(e),this},r.prototype.once=function(t,e){function r(){n.off(t,r),e.apply(this,arguments)}var n=this;return this._callbacks=this._callbacks||{},r.fn=e,this.on(t,r),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var r=this._callbacks[t];if(!r)return this;if(1==arguments.length)return delete this._callbacks[t],this;for(var n,o=0;o<r.length;o++)if(n=r[o],n===e||n.fn===e){r.splice(o,1);break}return this},r.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),r=this._callbacks[t];if(r){r=r.slice(0);for(var n=0,o=r.length;n<o;++n)r[n].apply(this,e)}return this},r.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks[t]||[]},r.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,r){(function(t){var n=r(15),o=r(16);e.deconstructPacket=function(t){function e(t){if(!t)return t;if(o(t)){var i={_placeholder:!0,num:r.length};return r.push(t),i}if(n(t)){for(var s=new Array(t.length),a=0;a<t.length;a++)s[a]=e(t[a]);return s}if("object"==typeof t&&!(t instanceof Date)){var s={};for(var c in t)s[c]=e(t[c]);return s}return t}var r=[],i=t.data,s=t;return s.data=e(i),s.attachments=r.length,{packet:s,buffers:r}},e.reconstructPacket=function(t,e){function r(t){if(t&&t._placeholder){var o=e[t.num];return o}if(n(t)){for(var i=0;i<t.length;i++)t[i]=r(t[i]);return t}if(t&&"object"==typeof t){for(var s in t)t[s]=r(t[s]);return t}return t}return t.data=r(t.data),t.attachments=void 0,t},e.removeBlobs=function(e,r){function i(e,c,u){if(!e)return e;if(t.Blob&&e instanceof Blob||t.File&&e instanceof File){s++;var h=new FileReader;h.onload=function(){u?u[c]=this.result:a=this.result,--s||r(a)},h.readAsArrayBuffer(e)}else if(n(e))for(var p=0;p<e.length;p++)i(e[p],p,e);else if(e&&"object"==typeof e&&!o(e))for(var f in e)i(e[f],f,e)}var s=0,a=e;i(a),s||r(a)}}).call(e,function(){return this}())},function(t,e){t.exports=Array.isArray||function(t){return"[object Array]"==Object.prototype.toString.call(t)}},function(t,e){(function(e){function r(t){return e.Buffer&&e.Buffer.isBuffer(t)||e.ArrayBuffer&&t instanceof ArrayBuffer}t.exports=r}).call(e,function(){return this}())},function(t,e,r){"use strict";function n(t,e){return this instanceof n?(t&&"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new l({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[],this.encoder=new c.Encoder,this.decoder=new c.Decoder,this.autoConnect=e.autoConnect!==!1,void(this.autoConnect&&this.open())):new n(t,e)}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(18),s=r(45),a=r(36),c=r(7),u=r(47),h=r(48),p=r(3)("socket.io-client:manager"),f=r(43),l=r(51),d=Object.prototype.hasOwnProperty;t.exports=n,n.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)d.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},n.prototype.updateSocketIds=function(){for(var t in this.nsps)d.call(this.nsps,t)&&(this.nsps[t].id=this.engine.id)},a(n.prototype),n.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},n.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},n.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},n.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},n.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},n.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},n.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},n.prototype.open=n.prototype.connect=function(t,e){if(p("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;p("opening %s",this.uri),this.engine=i(this.uri,this.opts);var r=this.engine,n=this;this.readyState="opening",this.skipReconnect=!1;var o=u(r,"open",function(){n.onopen(),t&&t()}),s=u(r,"error",function(e){if(p("connect_error"),n.cleanup(),n.readyState="closed",n.emitAll("connect_error",e),t){var r=new Error("Connection error");r.data=e,t(r)}else n.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout;p("connect attempt will timeout after %d",a);var c=setTimeout(function(){p("connect attempt timed out after %d",a),o.destroy(),r.close(),r.emit("error","timeout"),n.emitAll("connect_timeout",a)},a);this.subs.push({destroy:function(){clearTimeout(c)}})}return this.subs.push(o),this.subs.push(s),this},n.prototype.onopen=function(){p("open"),this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(u(t,"data",h(this,"ondata"))),this.subs.push(u(t,"ping",h(this,"onping"))),this.subs.push(u(t,"pong",h(this,"onpong"))),this.subs.push(u(t,"error",h(this,"onerror"))),this.subs.push(u(t,"close",h(this,"onclose"))),this.subs.push(u(this.decoder,"decoded",h(this,"ondecoded")))},n.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},n.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},n.prototype.ondata=function(t){this.decoder.add(t)},n.prototype.ondecoded=function(t){this.emit("packet",t)},n.prototype.onerror=function(t){p("error",t),this.emitAll("error",t)},n.prototype.socket=function(t,e){function r(){~f(o.connecting,n)||o.connecting.push(n)}var n=this.nsps[t];if(!n){n=new s(this,t,e),this.nsps[t]=n;var o=this;n.on("connecting",r),n.on("connect",function(){n.id=o.engine.id}),this.autoConnect&&r()}return n},n.prototype.destroy=function(t){var e=f(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},n.prototype.packet=function(t){p("writing packet %j",t);var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(r){for(var n=0;n<r.length;n++)e.engine.write(r[n],t.options);e.encoding=!1,e.processPacketQueue()}))},n.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},n.prototype.cleanup=function(){p("cleanup");for(var t=this.subs.length,e=0;e<t;e++){var r=this.subs.shift();r.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},n.prototype.close=n.prototype.disconnect=function(){p("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},n.prototype.onclose=function(t){p("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},n.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)p("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();p("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var r=setTimeout(function(){t.skipReconnect||(p("attempting reconnect"),t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(p("reconnect attempt error"),t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):(p("reconnect success"),t.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(r)}})}},n.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)}},function(t,e,r){t.exports=r(19)},function(t,e,r){t.exports=r(20),t.exports.parser=r(27)},function(t,e,r){(function(e){function n(t,r){if(!(this instanceof n))return new n(t,r);r=r||{},t&&"object"==typeof t&&(r=t,t=null),t?(t=h(t),r.hostname=t.host,r.secure="https"===t.protocol||"wss"===t.protocol,r.port=t.port,t.query&&(r.query=t.query)):r.host&&(r.hostname=h(r.host).host),
-    this.secure=null!=r.secure?r.secure:e.location&&"https:"===location.protocol,r.hostname&&!r.port&&(r.port=this.secure?"443":"80"),this.agent=r.agent||!1,this.hostname=r.hostname||(e.location?location.hostname:"localhost"),this.port=r.port||(e.location&&location.port?location.port:this.secure?443:80),this.query=r.query||{},"string"==typeof this.query&&(this.query=f.decode(this.query)),this.upgrade=!1!==r.upgrade,this.path=(r.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!r.forceJSONP,this.jsonp=!1!==r.jsonp,this.forceBase64=!!r.forceBase64,this.enablesXDR=!!r.enablesXDR,this.timestampParam=r.timestampParam||"t",this.timestampRequests=r.timestampRequests,this.transports=r.transports||["polling","websocket"],this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=r.policyPort||843,this.rememberUpgrade=r.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=r.onlyBinaryUpgrades,this.perMessageDeflate=!1!==r.perMessageDeflate&&(r.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=r.pfx||null,this.key=r.key||null,this.passphrase=r.passphrase||null,this.cert=r.cert||null,this.ca=r.ca||null,this.ciphers=r.ciphers||null,this.rejectUnauthorized=void 0===r.rejectUnauthorized?null:r.rejectUnauthorized,this.forceNode=!!r.forceNode;var o="object"==typeof e&&e;o.global===o&&(r.extraHeaders&&Object.keys(r.extraHeaders).length>0&&(this.extraHeaders=r.extraHeaders),r.localAddress&&(this.localAddress=r.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}function o(t){var e={};for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);return e}var i=r(21),s=r(36),a=r(3)("engine.io-client:socket"),c=r(43),u=r(27),h=r(2),p=r(44),f=r(37);t.exports=n,n.priorWebsocketSuccess=!1,s(n.prototype),n.protocol=u.protocol,n.Socket=n,n.Transport=r(26),n.transports=r(21),n.parser=r(27),n.prototype.createTransport=function(t){a("creating transport \"%s\"",t);var e=o(this.query);e.EIO=u.protocol,e.transport=t,this.id&&(e.sid=this.id);var r=new i[t]({agent:this.agent,hostname:this.hostname,port:this.port,secure:this.secure,path:this.path,query:e,forceJSONP:this.forceJSONP,jsonp:this.jsonp,forceBase64:this.forceBase64,enablesXDR:this.enablesXDR,timestampRequests:this.timestampRequests,timestampParam:this.timestampParam,policyPort:this.policyPort,socket:this,pfx:this.pfx,key:this.key,passphrase:this.passphrase,cert:this.cert,ca:this.ca,ciphers:this.ciphers,rejectUnauthorized:this.rejectUnauthorized,perMessageDeflate:this.perMessageDeflate,extraHeaders:this.extraHeaders,forceNode:this.forceNode,localAddress:this.localAddress});return r},n.prototype.open=function(){var t;if(this.rememberUpgrade&&n.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)t="websocket";else{if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit("error","No transports available")},0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(t){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},n.prototype.setTransport=function(t){a("setting transport %s",t.name);var e=this;this.transport&&(a("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=t,t.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})},n.prototype.probe=function(t){function e(){if(f.onlyBinaryUpgrades){var e=!this.supportsBinary&&f.transport.supportsBinary;p=p||e}p||(a("probe transport \"%s\" opened",t),h.send([{type:"ping",data:"probe"}]),h.once("packet",function(e){if(!p)if("pong"===e.type&&"probe"===e.data){if(a("probe transport \"%s\" pong",t),f.upgrading=!0,f.emit("upgrading",h),!h)return;n.priorWebsocketSuccess="websocket"===h.name,a("pausing current transport \"%s\"",f.transport.name),f.transport.pause(function(){p||"closed"!==f.readyState&&(a("changing transport and sending upgrade packet"),u(),f.setTransport(h),h.send([{type:"upgrade"}]),f.emit("upgrade",h),h=null,f.upgrading=!1,f.flush())})}else{a("probe transport \"%s\" failed",t);var r=new Error("probe error");r.transport=h.name,f.emit("upgradeError",r)}}))}function r(){p||(p=!0,u(),h.close(),h=null)}function o(e){var n=new Error("probe error: "+e);n.transport=h.name,r(),a("probe transport \"%s\" failed because of error: %s",t,e),f.emit("upgradeError",n)}function i(){o("transport closed")}function s(){o("socket closed")}function c(t){h&&t.name!==h.name&&(a("\"%s\" works - aborting \"%s\"",t.name,h.name),r())}function u(){h.removeListener("open",e),h.removeListener("error",o),h.removeListener("close",i),f.removeListener("close",s),f.removeListener("upgrading",c)}a("probing transport \"%s\"",t);var h=this.createTransport(t,{probe:1}),p=!1,f=this;n.priorWebsocketSuccess=!1,h.once("open",e),h.once("error",o),h.once("close",i),this.once("close",s),this.once("upgrading",c),h.open()},n.prototype.onOpen=function(){if(a("socket open"),this.readyState="open",n.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause){a("starting upgrade probes");for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])}},n.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(a("socket receive: type \"%s\", data \"%s\"",t.type,t.data),this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(p(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}else a("packet received with socket readyState \"%s\"",this.readyState)},n.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},n.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){"closed"!==e.readyState&&e.onClose("ping timeout")},t||e.pingInterval+e.pingTimeout)},n.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){a("writing ping packet - expecting pong within %sms",t.pingTimeout),t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},n.prototype.ping=function(){var t=this;this.sendPacket("ping",function(){t.emit("ping")})},n.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},n.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(a("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},n.prototype.write=n.prototype.send=function(t,e,r){return this.sendPacket("message",t,e,r),this},n.prototype.sendPacket=function(t,e,r,n){if("function"==typeof e&&(n=e,e=void 0),"function"==typeof r&&(n=r,r=null),"closing"!==this.readyState&&"closed"!==this.readyState){r=r||{},r.compress=!1!==r.compress;var o={type:t,data:e,options:r};this.emit("packetCreate",o),this.writeBuffer.push(o),n&&this.once("flush",n),this.flush()}},n.prototype.close=function(){function t(){n.onClose("forced close"),a("socket closing - telling transport to close"),n.transport.close()}function e(){n.removeListener("upgrade",e),n.removeListener("upgradeError",e),t()}function r(){n.once("upgrade",e),n.once("upgradeError",e)}if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var n=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?r():t()}):this.upgrading?r():t()}return this},n.prototype.onError=function(t){a("socket error %j",t),n.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},n.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){a("socket close with reason: \"%s\"",t);var r=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),r.writeBuffer=[],r.prevBufferLen=0}},n.prototype.filterUpgrades=function(t){for(var e=[],r=0,n=t.length;r<n;r++)~c(this.transports,t[r])&&e.push(t[r]);return e}}).call(e,function(){return this}())},function(t,e,r){(function(t){function n(e){var r,n=!1,a=!1,c=!1!==e.jsonp;if(t.location){var u="https:"===location.protocol,h=location.port;h||(h=u?443:80),n=e.hostname!==location.hostname||h!==e.port,a=e.secure!==u}if(e.xdomain=n,e.xscheme=a,r=new o(e),"open"in r&&!e.forceJSONP)return new i(e);if(!c)throw new Error("JSONP disabled");return new s(e)}var o=r(22),i=r(24),s=r(40),a=r(41);e.polling=n,e.websocket=a}).call(e,function(){return this}())},function(t,e,r){(function(e){var n=r(23);t.exports=function(t){var r=t.xdomain,o=t.xscheme,i=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!r||n))return new XMLHttpRequest}catch(t){}try{if("undefined"!=typeof XDomainRequest&&!o&&i)return new XDomainRequest}catch(t){}if(!r)try{return new(e[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(t){}}}).call(e,function(){return this}())},function(t,e){try{t.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(e){t.exports=!1}},function(t,e,r){(function(e){function n(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,e.location){var r="https:"===location.protocol,n=location.port;n||(n=r?443:80),this.xd=t.hostname!==e.location.hostname||n!==t.port,this.xs=t.secure!==r}else this.extraHeaders=t.extraHeaders}function i(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&&i.requests[t].abort()}var a=r(22),c=r(25),u=r(36),h=r(38),p=r(3)("engine.io-client:polling-xhr");t.exports=o,t.exports.Request=i,h(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var r="string"!=typeof t&&void 0!==t,n=this.request({method:"POST",data:t,isBinary:r}),o=this;n.on("success",e),n.on("error",function(t){o.onError("xhr post error",t)}),this.sendXhr=n},o.prototype.doPoll=function(){p("xhr poll");var t=this.request(),e=this;t.on("data",function(t){e.onData(t)}),t.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=t},u(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var r=this.xhr=new a(t),n=this;try{p("xhr open %s: %s",this.method,this.uri),r.open(this.method,this.uri,this.async);try{if(this.extraHeaders){r.setDisableHeaderCheck(!0);for(var o in this.extraHeaders)this.extraHeaders.hasOwnProperty(o)&&r.setRequestHeader(o,this.extraHeaders[o])}}catch(t){}if(this.supportsBinary&&(r.responseType="arraybuffer"),"POST"===this.method)try{this.isBinary?r.setRequestHeader("Content-type","application/octet-stream"):r.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(t){}try{r.setRequestHeader("Accept","*/*")}catch(t){}"withCredentials"in r&&(r.withCredentials=!0),this.requestTimeout&&(r.timeout=this.requestTimeout),this.hasXDR()?(r.onload=function(){n.onLoad()},r.onerror=function(){n.onError(r.responseText)}):r.onreadystatechange=function(){4===r.readyState&&(200===r.status||1223===r.status?n.onLoad():setTimeout(function(){n.onError(r.status)},0))},p("xhr data %s",this.data),r.send(this.data)}catch(t){return void setTimeout(function(){n.onError(t)},0)}e.document&&(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},i.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},i.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},i.prototype.cleanup=function(t){if("undefined"!=typeof this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=n:this.xhr.onreadystatechange=n,t)try{this.xhr.abort()}catch(t){}e.document&&delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type").split(";")[0]}catch(t){}if("application/octet-stream"===e)t=this.xhr.response||this.xhr.responseText;else if(this.supportsBinary)try{t=String.fromCharCode.apply(null,new Uint8Array(this.xhr.response))}catch(e){for(var r=new Uint8Array(this.xhr.response),n=[],o=0,i=r.length;o<i;o++)n.push(r[o]);t=String.fromCharCode.apply(null,n)}else t=this.xhr.responseText}catch(t){this.onError(t)}null!=t&&this.onData(t)},i.prototype.hasXDR=function(){return"undefined"!=typeof e.XDomainRequest&&!this.xs&&this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},e.document&&(e.attachEvent?e.attachEvent("onunload",s):e.addEventListener&&e.addEventListener("beforeunload",s,!1))}).call(e,function(){return this}())},function(t,e,r){function n(t){var e=t&&t.forceBase64;h&&!e||(this.supportsBinary=!1),o.call(this,t)}var o=r(26),i=r(37),s=r(27),a=r(38),c=r(39),u=r(3)("engine.io-client:polling");t.exports=n;var h=function(){var t=r(22),e=new t({xdomain:!1});return null!=e.responseType}();a(n,o),n.prototype.name="polling",n.prototype.doOpen=function(){this.poll()},n.prototype.pause=function(t){function e(){u("paused"),r.readyState="paused",t()}var r=this;if(this.readyState="pausing",this.polling||!this.writable){var n=0;this.polling&&(u("we are currently polling - waiting to pause"),n++,this.once("pollComplete",function(){u("pre-pause polling complete"),--n||e()})),this.writable||(u("we are currently writing - waiting to pause"),n++,this.once("drain",function(){u("pre-pause writing complete"),--n||e()}))}else e()},n.prototype.poll=function(){u("polling"),this.polling=!0,this.doPoll(),this.emit("poll")},n.prototype.onData=function(t){var e=this;u("polling got data %s",t);var r=function(t,r,n){return"opening"===e.readyState&&e.onOpen(),"close"===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,r),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState?this.poll():u("ignoring poll - transport state \"%s\"",this.readyState))},n.prototype.doClose=function(){function t(){u("writing close packet"),e.write([{type:"close"}])}var e=this;"open"===this.readyState?(u("transport open - closing"),t()):(u("transport not open - deferring close"),this.once("open",t))},n.prototype.write=function(t){var e=this;this.writable=!1;var r=function(){e.writable=!0,e.emit("drain")};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,r)})},n.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",r="";!1!==this.timestampRequests&&(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(r=":"+this.port),t.length&&(t="?"+t);var n=this.hostname.indexOf(":")!==-1;return e+"://"+(n?"["+this.hostname+"]":this.hostname)+r+this.path+t}},function(t,e,r){function n(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=r(27),i=r(36);t.exports=n,i(n.prototype),n.prototype.onError=function(t,e){var r=new Error(t);return r.type="TransportError",r.description=e,this.emit("error",r),this},n.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},n.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},n.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");this.write(t)},n.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},n.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},n.prototype.onPacket=function(t){this.emit("packet",t)},n.prototype.onClose=function(){this.readyState="closed",this.emit("close")}},function(t,e,r){(function(t){function n(t,r){var n="b"+e.packets[t.type]+t.data.data;return r(n)}function o(t,r,n){if(!r)return e.encodeBase64Packet(t,n);var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a<i.length;a++)s[a+1]=i[a];return n(s.buffer)}function i(t,r,n){if(!r)return e.encodeBase64Packet(t,n);var o=new FileReader;return o.onload=function(){t.data=o.result,e.encodePacket(t,r,!0,n)},o.readAsArrayBuffer(t.data)}function s(t,r,n){if(!r)return e.encodeBase64Packet(t,n);if(m)return i(t,r,n);var o=new Uint8Array(1);o[0]=v[t.type];var s=new k([o.buffer,t.data]);return n(s)}function a(t){try{t=d.decode(t)}catch(t){return!1}return t}function c(t,e,r){for(var n=new Array(t.length),o=l(t.length,r),i=function(t,r,o){e(r,function(e,r){n[t]=r,o(e,n)})},s=0;s<t.length;s++)i(s,t[s],o)}var u,h=r(28),p=r(29),f=r(31),l=r(32),d=r(33);t&&t.ArrayBuffer&&(u=r(34));var y="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),g="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),m=y||g;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=h(v),w={type:"error",data:"parser error"},k=r(35);e.encodePacket=function(e,r,i,a){"function"==typeof r&&(a=r,r=!1),"function"==typeof i&&(a=i,i=null);var c=void 0===e.data?void 0:e.data.buffer||e.data;if(t.ArrayBuffer&&c instanceof ArrayBuffer)return o(e,r,a);if(k&&c instanceof t.Blob)return s(e,r,a);if(c&&c.base64)return n(e,a);var u=v[e.type];return void 0!==e.data&&(u+=i?d.encode(String(e.data)):String(e.data)),a(""+u)},e.encodeBase64Packet=function(r,n){var o="b"+e.packets[r.type];if(k&&r.data instanceof t.Blob){var i=new FileReader;return i.onload=function(){var t=i.result.split(",")[1];n(o+t)},i.readAsDataURL(r.data)}var s;try{s=String.fromCharCode.apply(null,new Uint8Array(r.data))}catch(t){for(var a=new Uint8Array(r.data),c=new Array(a.length),u=0;u<a.length;u++)c[u]=a[u];s=String.fromCharCode.apply(null,c)}return o+=t.btoa(s),n(o)},e.decodePacket=function(t,r,n){if(void 0===t)return w;if("string"==typeof t){if("b"==t.charAt(0))return e.decodeBase64Packet(t.substr(1),r);if(n&&(t=a(t),t===!1))return w;var o=t.charAt(0);return Number(o)==o&&b[o]?t.length>1?{type:b[o],data:t.substring(1)}:{type:b[o]}:w}var i=new Uint8Array(t),o=i[0],s=f(t,1);return k&&"blob"===r&&(s=new k([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var r=b[t.charAt(0)];if(!u)return{type:r,data:{base64:!0,data:t.substr(1)}};var n=u.decode(t.substr(1));return"blob"===e&&k&&(n=new k([n])),{type:r,data:n}},e.encodePayload=function(t,r,n){function o(t){return t.length+":"+t}function i(t,n){e.encodePacket(t,!!s&&r,!0,function(t){n(null,o(t))})}"function"==typeof r&&(n=r,r=null);var s=p(t);return r&&s?k&&!m?e.encodePayloadAsBlob(t,n):e.encodePayloadAsArrayBuffer(t,n):t.length?void c(t,i,function(t,e){return n(e.join(""))}):n("0:")},e.decodePayload=function(t,r,n){if("string"!=typeof t)return e.decodePayloadAsBinary(t,r,n);"function"==typeof r&&(n=r,r=null);var o;if(""==t)return n(w,0,1);for(var i,s,a="",c=0,u=t.length;c<u;c++){var h=t.charAt(c);if(":"!=h)a+=h;else{if(""==a||a!=(i=Number(a)))return n(w,0,1);if(s=t.substr(c+1,i),a!=s.length)return n(w,0,1);if(s.length){if(o=e.decodePacket(s,r,!0),w.type==o.type&&w.data==o.data)return n(w,0,1);var p=n(o,c+i,u);if(!1===p)return}c+=i,a=""}}return""!=a?n(w,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,r){function n(t,r){e.encodePacket(t,!0,!0,function(t){return r(null,t)})}return t.length?void c(t,n,function(t,e){var n=e.reduce(function(t,e){var r;return r="string"==typeof e?e.length:e.byteLength,t+r.toString().length+r+2},0),o=new Uint8Array(n),i=0;return e.forEach(function(t){var e="string"==typeof t,r=t;if(e){for(var n=new Uint8Array(t.length),s=0;s<t.length;s++)n[s]=t.charCodeAt(s);r=n.buffer}e?o[i++]=0:o[i++]=1;for(var a=r.byteLength.toString(),s=0;s<a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var n=new Uint8Array(r),s=0;s<n.length;s++)o[i++]=n[s]}),r(o.buffer)}):r(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,r){function n(t,r){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var n=new Uint8Array(t.length),o=0;o<t.length;o++)n[o]=t.charCodeAt(o);t=n.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o<s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,k){var c=new k([e.buffer,a.buffer,t]);r(null,c)}})}c(t,n,function(t,e){return r(new k(e))})},e.decodePayloadAsBinary=function(t,r,n){"function"==typeof r&&(n=r,r=null);for(var o=t,i=[],s=!1;o.byteLength>0;){for(var a=new Uint8Array(o),c=0===a[0],u="",h=1;255!=a[h];h++){if(u.length>310){s=!0;break}u+=a[h]}if(s)return n(w,0,1);o=f(o,2+u.length),u=parseInt(u);var p=f(o,0,u);if(c)try{p=String.fromCharCode.apply(null,new Uint8Array(p))}catch(t){var l=new Uint8Array(p);p="";for(var h=0;h<l.length;h++)p+=String.fromCharCode(l[h])}i.push(p),o=f(o,u)}var d=i.length;i.forEach(function(t,o){n(e.decodePacket(t,r,!0),o,d)})}}).call(e,function(){return this}())},function(t,e){t.exports=Object.keys||function(t){var e=[],r=Object.prototype.hasOwnProperty;for(var n in t)r.call(t,n)&&e.push(n);return e}},function(t,e,r){(function(e){function n(t){function r(t){if(!t)return!1;if(e.Buffer&&e.Buffer.isBuffer(t)||e.ArrayBuffer&&t instanceof ArrayBuffer||e.Blob&&t instanceof Blob||e.File&&t instanceof File)return!0;if(o(t)){for(var n=0;n<t.length;n++)if(r(t[n]))return!0}else if(t&&"object"==typeof t){t.toJSON&&(t=t.toJSON());for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&r(t[i]))return!0}return!1}return r(t)}var o=r(30);t.exports=n}).call(e,function(){return this}())},function(t,e){t.exports=Array.isArray||function(t){return"[object Array]"==Object.prototype.toString.call(t)}},function(t,e){t.exports=function(t,e,r){var n=t.byteLength;if(e=e||0,r=r||n,t.slice)return t.slice(e,r);if(e<0&&(e+=n),r<0&&(r+=n),r>n&&(r=n),e>=n||e>=r||0===n)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(r-e),s=e,a=0;s<r;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function r(t,e,r){function o(t,n){if(o.count<=0)throw new Error("after called too many times");--o.count,t?(i=!0,e(t),e=r):0!==o.count||i||e(null,n)}var i=!1;return r=r||n,o.count=t,0===t?e():o}function n(){}t.exports=r},function(t,e,r){var n;(function(t,o){!function(i){function s(t){for(var e,r,n=[],o=0,i=t.length;o<i;)e=t.charCodeAt(o++),e>=55296&&e<=56319&&o<i?(r=t.charCodeAt(o++),56320==(64512&r)?n.push(((1023&e)<<10)+(1023&r)+65536):(n.push(e),o--)):n.push(e);return n}function a(t){for(var e,r=t.length,n=-1,o="";++n<r;)e=t[n],e>65535&&(e-=65536,o+=b(e>>>10&1023|55296),e=56320|1023&e),o+=b(e);return o}function c(t,e){return b(t>>e&63|128)}function u(t){if(0==(4294967168&t))return b(t);var e="";return 0==(4294965248&t)?e=b(t>>6&31|192):0==(4294901760&t)?(e=b(t>>12&15|224),e+=c(t,6)):0==(4292870144&t)&&(e=b(t>>18&7|240),e+=c(t,12),e+=c(t,6)),e+=b(63&t|128)}function h(t){for(var e,r=s(t),n=r.length,o=-1,i="";++o<n;)e=r[o],i+=u(e);return i}function p(){if(v>=m)throw Error("Invalid byte index");var t=255&g[v];if(v++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function f(){var t,e,r,n,o;if(v>m)throw Error("Invalid byte index");if(v==m)return!1;if(t=255&g[v],v++,0==(128&t))return t;if(192==(224&t)){var e=p();if(o=(31&t)<<6|e,o>=128)return o;throw Error("Invalid continuation byte")}if(224==(240&t)){if(e=p(),r=p(),o=(15&t)<<12|e<<6|r,o>=2048)return o;throw Error("Invalid continuation byte")}if(240==(248&t)&&(e=p(),r=p(),n=p(),o=(15&t)<<18|e<<12|r<<6|n,o>=65536&&o<=1114111))return o;throw Error("Invalid WTF-8 detected")}function l(t){g=s(t),m=g.length,v=0;for(var e,r=[];(e=f())!==!1;)r.push(e);return a(r)}var d="object"==typeof e&&e,y=("object"==typeof t&&t&&t.exports==d&&t,"object"==typeof o&&o);y.global!==y&&y.window!==y||(i=y);var g,m,v,b=String.fromCharCode,w={version:"1.0.0",encode:h,decode:l};n=function(){return w}.call(e,r,e,t),!(void 0!==n&&(t.exports=n))}(this)}).call(e,r(12)(t),function(){return this}())},function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r=new Uint8Array(256),n=0;n<t.length;n++)r[t.charCodeAt(n)]=n;e.encode=function(e){var r,n=new Uint8Array(e),o=n.length,i="";for(r=0;r<o;r+=3)i+=t[n[r]>>2],i+=t[(3&n[r])<<4|n[r+1]>>4],i+=t[(15&n[r+1])<<2|n[r+2]>>6],i+=t[63&n[r+2]];return o%3===2?i=i.substring(0,i.length-1)+"=":o%3===1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,n,o,i,s,a=.75*t.length,c=t.length,u=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var h=new ArrayBuffer(a),p=new Uint8Array(h);for(e=0;e<c;e+=4)n=r[t.charCodeAt(e)],o=r[t.charCodeAt(e+1)],i=r[t.charCodeAt(e+2)],s=r[t.charCodeAt(e+3)],p[u++]=n<<2|o>>4,p[u++]=(15&o)<<4|i>>2,p[u++]=(3&i)<<6|63&s;return h}}()},function(t,e){(function(e){function r(t){for(var e=0;e<t.length;e++){var r=t[e];if(r.buffer instanceof ArrayBuffer){var n=r.buffer;if(r.byteLength!==n.byteLength){var o=new Uint8Array(r.byteLength);o.set(new Uint8Array(n,r.byteOffset,r.byteLength)),n=o.buffer}t[e]=n}}}function n(t,e){e=e||{};var n=new i;r(t);for(var o=0;o<t.length;o++)n.append(t[o]);return e.type?n.getBlob(e.type):n.getBlob()}function o(t,e){return r(t),new Blob(t,e||{})}var i=e.BlobBuilder||e.WebKitBlobBuilder||e.MSBlobBuilder||e.MozBlobBuilder,s=function(){try{var t=new Blob(["hi"]);return 2===t.size}catch(t){return!1}}(),a=s&&function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(t){return!1}}(),c=i&&i.prototype.append&&i.prototype.getBlob;t.exports=function(){return s?a?e.Blob:o:c?n:void 0}()}).call(e,function(){return this}())},function(t,e,r){function n(t){if(t)return o(t)}function o(t){for(var e in n.prototype)t[e]=n.prototype[e];return t}t.exports=n,n.prototype.on=n.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},n.prototype.once=function(t,e){function r(){this.off(t,r),e.apply(this,arguments)}return r.fn=e,this.on(t,r),this},n.prototype.off=n.prototype.removeListener=n.prototype.removeAllListeners=n.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var r=this._callbacks["$"+t];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var n,o=0;o<r.length;o++)if(n=r[o],n===e||n.fn===e){r.splice(o,1);break}return this},n.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),r=this._callbacks["$"+t];if(r){r=r.slice(0);for(var n=0,o=r.length;n<o;++n)r[n].apply(this,e)}return this},n.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},n.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e){e.encode=function(t){var e="";for(var r in t)t.hasOwnProperty(r)&&(e.length&&(e+="&"),e+=encodeURIComponent(r)+"="+encodeURIComponent(t[r]));return e},e.decode=function(t){for(var e={},r=t.split("&"),n=0,o=r.length;n<o;n++){var i=r[n].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}},function(t,e){"use strict";function r(t){var e="";do e=s[t%a]+e,t=Math.floor(t/a);while(t>0);return e}function n(t){var e=0;for(h=0;h<t.length;h++)e=e*a+c[t.charAt(h)];return e}function o(){var t=r(+new Date);return t!==i?(u=0,i=t):t+"."+r(u++)}for(var i,s="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),a=64,c={},u=0,h=0;h<a;h++)c[s[h]]=h;o.encode=r,o.decode=n,t.exports=o},function(t,e,r){(function(e){function n(){}function o(t){i.call(this,t),this.query=this.query||{},a||(e.___eio||(e.___eio=[]),a=e.___eio),this.index=a.length;var r=this;a.push(function(t){r.onData(t)}),this.query.j=this.index,e.document&&e.addEventListener&&e.addEventListener("beforeunload",function(){r.script&&(r.script.onerror=n)},!1)}var i=r(25),s=r(38);t.exports=o;var a,c=/\n/g,u=/\\n/g;s(o,i),o.prototype.supportsBinary=!1,o.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),i.prototype.doClose.call(this)},o.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var r=document.getElementsByTagName("script")[0];r?r.parentNode.insertBefore(e,r):(document.head||document.body).appendChild(e),this.script=e;var n="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);n&&setTimeout(function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)},100)},o.prototype.doWrite=function(t,e){function r(){n(),e()}function n(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError("jsonp polling iframe removal error",t)}try{var t="<iframe src=\"javascript:0\" name=\""+o.iframeId+"\">";i=document.createElement(t)}catch(t){i=document.createElement("iframe"),i.name=o.iframeId,i.src="javascript:0"}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement("form"),a=document.createElement("textarea"),h=this.iframeId="eio_iframe_"+this.index;s.className="socketio",s.style.position="absolute",s.style.top="-1000px",s.style.left="-1000px",s.target=h,s.method="POST",s.setAttribute("accept-charset","utf-8"),a.name="d",s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),n(),t=t.replace(u,"\\\n"),this.area.value=t.replace(c,"\\n");try{this.form.submit()}catch(t){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){
-        "complete"===o.iframe.readyState&&r()}:this.iframe.onload=r}}).call(e,function(){return this}())},function(t,e,r){(function(e){function n(t){var e=t&&t.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=p&&!t.forceNode,this.usingBrowserWebSocket||(f=o),i.call(this,t)}var o,i=r(26),s=r(27),a=r(37),c=r(38),u=r(39),h=r(3)("engine.io-client:websocket"),p=e.WebSocket||e.MozWebSocket;if("undefined"==typeof window)try{o=r(42)}catch(t){}var f=p;f||"undefined"!=typeof window||(f=o),t.exports=n,c(n,i),n.prototype.name="websocket",n.prototype.supportsBinary=!0,n.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=void 0,r={agent:this.agent,perMessageDeflate:this.perMessageDeflate};r.pfx=this.pfx,r.key=this.key,r.passphrase=this.passphrase,r.cert=this.cert,r.ca=this.ca,r.ciphers=this.ciphers,r.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&&(r.headers=this.extraHeaders),this.localAddress&&(r.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket?new f(t):new f(t,e,r)}catch(t){return this.emit("error",t)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},n.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},n.prototype.write=function(t){function r(){n.emit("flush"),setTimeout(function(){n.writable=!0,n.emit("drain")},0)}var n=this;this.writable=!1;for(var o=t.length,i=0,a=o;i<a;i++)!function(t){s.encodePacket(t,n.supportsBinary,function(i){if(!n.usingBrowserWebSocket){var s={};if(t.options&&(s.compress=t.options.compress),n.perMessageDeflate){var a="string"==typeof i?e.Buffer.byteLength(i):i.length;a<n.perMessageDeflate.threshold&&(s.compress=!1)}}try{n.usingBrowserWebSocket?n.ws.send(i):n.ws.send(i,s)}catch(t){h("websocket closed before onclose event")}--o||r()})}(t[i])},n.prototype.onClose=function(){i.prototype.onClose.call(this)},n.prototype.doClose=function(){"undefined"!=typeof this.ws&&this.ws.close()},n.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",r="";this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(r=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=u()),this.supportsBinary||(t.b64=1),t=a.encode(t),t.length&&(t="?"+t);var n=this.hostname.indexOf(":")!==-1;return e+"://"+(n?"["+this.hostname+"]":this.hostname)+r+this.path+t},n.prototype.check=function(){return!(!f||"__initialize"in f&&this.name===n.prototype.name)}}).call(e,function(){return this}())},function(t,e){},function(t,e){var r=[].indexOf;t.exports=function(t,e){if(r)return t.indexOf(e);for(var n=0;n<t.length;++n)if(t[n]===e)return n;return-1}},function(t,e){(function(e){var r=/^[\],:{}\s]*$/,n=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,o=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,i=/(?:^|:|,)(?:\s*\[)+/g,s=/^\s+/,a=/\s+$/;t.exports=function(t){return"string"==typeof t&&t?(t=t.replace(s,"").replace(a,""),e.JSON&&JSON.parse?JSON.parse(t):r.test(t.replace(n,"@").replace(o,"]").replace(i,""))?new Function("return "+t)():void 0):null}}).call(e,function(){return this}())},function(t,e,r){"use strict";function n(t,e,r){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,r&&r.query&&(this.query=r.query),this.io.autoConnect&&this.open()}var o=r(7),i=r(36),s=r(46),a=r(47),c=r(48),u=r(3)("socket.io-client:socket"),h=r(49);t.exports=e=n;var p={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},f=i.prototype.emit;i(n.prototype),n.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[a(t,"open",c(this,"onopen")),a(t,"packet",c(this,"onpacket")),a(t,"close",c(this,"onclose"))]}},n.prototype.open=n.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting"),this)},n.prototype.send=function(){var t=s(arguments);return t.unshift("message"),this.emit.apply(this,t),this},n.prototype.emit=function(t){if(p.hasOwnProperty(t))return f.apply(this,arguments),this;var e=s(arguments),r=o.EVENT;h(e)&&(r=o.BINARY_EVENT);var n={type:r,data:e};return n.options={},n.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(u("emitting packet with ack id %d",this.ids),this.acks[this.ids]=e.pop(),n.id=this.ids++),this.connected?this.packet(n):this.sendBuffer.push(n),delete this.flags,this},n.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},n.prototype.onopen=function(){u("transport is open - connecting"),"/"!==this.nsp&&(this.query?this.packet({type:o.CONNECT,query:this.query}):this.packet({type:o.CONNECT}))},n.prototype.onclose=function(t){u("close (%s)",t),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},n.prototype.onpacket=function(t){if(t.nsp===this.nsp)switch(t.type){case o.CONNECT:this.onconnect();break;case o.EVENT:this.onevent(t);break;case o.BINARY_EVENT:this.onevent(t);break;case o.ACK:this.onack(t);break;case o.BINARY_ACK:this.onack(t);break;case o.DISCONNECT:this.ondisconnect();break;case o.ERROR:this.emit("error",t.data)}},n.prototype.onevent=function(t){var e=t.data||[];u("emitting event %j",e),null!=t.id&&(u("attaching ack callback to event"),e.push(this.ack(t.id))),this.connected?f.apply(this,e):this.receiveBuffer.push(e)},n.prototype.ack=function(t){var e=this,r=!1;return function(){if(!r){r=!0;var n=s(arguments);u("sending ack %j",n);var i=h(n)?o.BINARY_ACK:o.ACK;e.packet({type:i,id:t,data:n})}}},n.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e?(u("calling ack %s with %j",t.id,t.data),e.apply(this,t.data),delete this.acks[t.id]):u("bad ack %s",t.id)},n.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit("connect"),this.emitBuffered()},n.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)f.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},n.prototype.ondisconnect=function(){u("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},n.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},n.prototype.close=n.prototype.disconnect=function(){return this.connected&&(u("performing disconnect (%s)",this.nsp),this.packet({type:o.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},n.prototype.compress=function(t){return this.flags=this.flags||{},this.flags.compress=t,this}},function(t,e){function r(t,e){var r=[];e=e||0;for(var n=e||0;n<t.length;n++)r[n-e]=t[n];return r}t.exports=r},function(t,e){"use strict";function r(t,e,r){return t.on(e,r),{destroy:function(){t.removeListener(e,r)}}}t.exports=r},function(t,e){var r=[].slice;t.exports=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var n=r.call(arguments,2);return function(){return e.apply(t,n.concat(r.call(arguments)))}}},function(t,e,r){(function(e){function n(t){function r(t){if(!t)return!1;if(e.Buffer&&e.Buffer.isBuffer&&e.Buffer.isBuffer(t)||e.ArrayBuffer&&t instanceof ArrayBuffer||e.Blob&&t instanceof Blob||e.File&&t instanceof File)return!0;if(o(t)){for(var n=0;n<t.length;n++)if(r(t[n]))return!0}else if(t&&"object"==typeof t){t.toJSON&&"function"==typeof t.toJSON&&(t=t.toJSON());for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&r(t[i]))return!0}return!1}return r(t)}var o=r(50);t.exports=n}).call(e,function(){return this}())},function(t,e){t.exports=Array.isArray||function(t){return"[object Array]"==Object.prototype.toString.call(t)}},function(t,e){function r(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}t.exports=r,r.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),r=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-r:t+r}return 0|Math.min(t,this.max)},r.prototype.reset=function(){this.attempts=0},r.prototype.setMin=function(t){this.ms=t},r.prototype.setMax=function(t){this.max=t},r.prototype.setJitter=function(t){this.jitter=t}}])});
\ No newline at end of file
Index: node_modules/browser-sync/lib/server/certs/gen.sh
===================================================================
--- node_modules/browser-sync/lib/server/certs/gen.sh	(revision )
+++ node_modules/browser-sync/lib/server/certs/gen.sh	(revision )
@@ -1,6 +0,0 @@
-openssl genrsa -des3 -out server.key 2048
-openssl req -new -key server.key -out server.csr
-openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt
-cp server.key server.key.copy
-openssl rsa -in server.key.copy -out server.key
-rm server.key.copy
Index: node_modules/browser-sync/lib/server/certs/server.crt
===================================================================
--- node_modules/browser-sync/lib/server/certs/server.crt	(revision )
+++ node_modules/browser-sync/lib/server/certs/server.crt	(revision )
@@ -1,19 +0,0 @@
------BEGIN CERTIFICATE-----
-MIIDBjCCAe4CCQCir/8eGDIE/jANBgkqhkiG9w0BAQsFADBFMQswCQYDVQQGEwJH
-QjETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0
-cyBQdHkgTHRkMB4XDTE3MDQxMDExNDcyNloXDTI3MDQwODExNDcyNlowRTELMAkG
-A1UEBhMCR0IxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoMGEludGVybmV0
-IFdpZGdpdHMgUHR5IEx0ZDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
-AMRLR2crKB4X/9pM3gR641iDscZWW3aqo70nUDxzo5Bhk8uupqz0EfdRoCLCUeQi
-xVp3HJ1HqnilMW7dETGGkDHKdxJRjrkBrYHhE3Kw/LCC4tEb400F6Ikm6OudVPIB
-P+CuwfNAw70KHSx/CtIrbTz0HhDC6XN0azp39pDLRBnWWluz3iU+rFLMx7YT2Q8k
-1nQAwcXkzLjeU7txAt2pYGQUgvBQETO5RI7QQ0CmwaV4gfHWGABBTX34WQun7g1Q
-YukrG3/4fVeNLzGW787FKCvL07BTymJTwXXbTTPXg4chw9p+YkLLPrr+AOVe/PF1
-MJppDT3gKdKMHFo3vMycUf0CAwEAATANBgkqhkiG9w0BAQsFAAOCAQEAEVmUYRrT
-fCQmBDox3evqj4n8dJVStjgdw/7BPkm49SmGtaxsST/eUSGwT7dTvZBLov6BK/OW
-+arhHZIvUY/DXlsV4NfCM4TK8KVefrwgd8ZsfQJW73L+FB0IOAY/6s+YKHm/wQGF
-ptSOycJvEltsqfIegtYcvvD6c6SkSOvqApaF+Ai10+yiLe20KyOvM3PefZLV7mFE
-0zCNyglZ75HftvHHV0wh82T2Et/R+txH+6dTwh065Dd6rrDzljtcAd2HC7B26ERK
-dA2zJd9Y4eMz8osacmG/afVuR9rqtFGwdyZ1Kb5xQRzGWlrjvSmAFUx9W9iA4Ilv
-3+56a5njSTFYKw==
------END CERTIFICATE-----
Index: node_modules/browser-sync/lib/server/certs/server.csr
===================================================================
--- node_modules/browser-sync/lib/server/certs/server.csr	(revision )
+++ node_modules/browser-sync/lib/server/certs/server.csr	(revision )
@@ -1,17 +0,0 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICoTCCAYkCAQAwRTELMAkGA1UEBhMCR0IxEzARBgNVBAgMClNvbWUtU3RhdGUx
-ITAfBgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDCCASIwDQYJKoZIhvcN
-AQEBBQADggEPADCCAQoCggEBAMRLR2crKB4X/9pM3gR641iDscZWW3aqo70nUDxz
-o5Bhk8uupqz0EfdRoCLCUeQixVp3HJ1HqnilMW7dETGGkDHKdxJRjrkBrYHhE3Kw
-/LCC4tEb400F6Ikm6OudVPIBP+CuwfNAw70KHSx/CtIrbTz0HhDC6XN0azp39pDL
-RBnWWluz3iU+rFLMx7YT2Q8k1nQAwcXkzLjeU7txAt2pYGQUgvBQETO5RI7QQ0Cm
-waV4gfHWGABBTX34WQun7g1QYukrG3/4fVeNLzGW787FKCvL07BTymJTwXXbTTPX
-g4chw9p+YkLLPrr+AOVe/PF1MJppDT3gKdKMHFo3vMycUf0CAwEAAaAXMBUGCSqG
-SIb3DQEJBzEIDAYxMjM0NTYwDQYJKoZIhvcNAQELBQADggEBABlVUaWK/UUovgPZ
-+rqNG8/j6aggSCCye9CkauLB/WqhQFfLl9lWTYdUVmWweNU0SJwDU9lWF/TngipF
-RZs6501DkXKxaDT9/3JYg4lRz6zHLy+a77pavJOeN0+cFAPZZuGyxZvYHFYPVSVH
-EeJL6bO/nZ/ARgIp0YNkQblDarxq1ARj7YT1Z24D5KgO1kQ55+fCY/wtct8TLGk9
-ujvWBbFEBSrJCDjRQeSctlP5qG8yfeJqZwZzo4PQMUwABhNLGUz0z0ceK8W1QnOm
-T+nCN5Fni04wO4dAZvYPp6wmU0Gpi2XBihbFl9CT3B5AmJmM8hQVpuQlmXeXT0FO
-pOZFpko=
------END CERTIFICATE REQUEST-----
Index: node_modules/browser-sync/lib/server/certs/server.key
===================================================================
--- node_modules/browser-sync/lib/server/certs/server.key	(revision )
+++ node_modules/browser-sync/lib/server/certs/server.key	(revision )
@@ -1,27 +0,0 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEogIBAAKCAQEAxEtHZysoHhf/2kzeBHrjWIOxxlZbdqqjvSdQPHOjkGGTy66m
-rPQR91GgIsJR5CLFWnccnUeqeKUxbt0RMYaQMcp3ElGOuQGtgeETcrD8sILi0Rvj
-TQXoiSbo651U8gE/4K7B80DDvQodLH8K0ittPPQeEMLpc3RrOnf2kMtEGdZaW7Pe
-JT6sUszHthPZDyTWdADBxeTMuN5Tu3EC3algZBSC8FARM7lEjtBDQKbBpXiB8dYY
-AEFNffhZC6fuDVBi6Ssbf/h9V40vMZbvzsUoK8vTsFPKYlPBddtNM9eDhyHD2n5i
-Qss+uv4A5V788XUwmmkNPeAp0owcWje8zJxR/QIDAQABAoIBADbeT/wvnQwkazkL
-CXg5HXltfnDRTMmz0wcZiR0MueiuzdA+ZoqrwqXeJCPzK07YxU+PQelY0fbdPh8e
-HiM42O+CB5yQPZPLO0O1tWj2vftc6qfG4tdx0lkcDjlmBguLe96DGuWy8cPSousA
-K/cpemRyXEEVKopCPYLfa4V3u/Z4be2U/39KNjVkHFhSdSYQl6ferhEfUPwTPi7O
-7l1/QUBabqN5FzNc2TeMVhhcJkXtYqF3RxGsaRfT0lK/j2hpbX7Bn2T0CfA/40jY
-2OCERqFPfZWx/ShTT52b3fyX/FEua7Nukq/MZdYZou63dDIjCQQyTJSflX6lVojO
-SuUoumECgYEA6CSkLiKcRLlTfec3LkjqkWtXR5ibL33g/H1fsZEQKFOyMbIXpUkX
-Hybpku8NGeetjKynO3yRirp+NiBHGPn3cHc9WJ5GGG1ew9hRQ9QzyC3Tit15TDbu
-J8i50/MaQHZSiUCnPQ/ceIZCNz8STcsEz87o/7utRLJKOvIIAPj+/8kCgYEA2Hd/
-v5oUroMRbtzPtMJDMHiGEQyNxEGDNqcuxgXSmiEEqPLfk2qR3yLffzA9UQOg4wkX
-/dSXsyomPriKWTvADXu1lNdkPGmW/1tk+onnHu6qgOalva30ZKhtteVjUqxEJEke
-mHhNHyIVuj6lExLw9LZhVvzoOi+aj4AD+DRS4pUCgYBEtuveOCJ3eUAMiY9c5PqB
-9vsL11FAOouJUXcs8VqOBVA+w4+aPktYzkTfWGFRZLGLbWPHCPVv0gof7Wf+Laef
-o7wF6junaWBeqj5LzJlTTLVMaohIFg5iuli/Mzt3D08ZD4kxWuuQxXT+M24wlsKi
-3IU9hYkhR4EPd6sE1q9seQKBgEpQRBAgModywbJgpgH1SyHBzqzdtXGx1/0USg97
-gkCdoz7pGm4+gNOs4jOE+Rft+fbXcWAX8vh0OOsBaaWWyKkYVk9B3syKp2cFFlaY
-rzrETs6v4CiNJsDDvd5bYMzKDR6z54gKjNdqWTE2Pm+c6hHo5uP5MTSAkTxAg5xb
-QjU9AoGAaYPXlm3IKVO12FgNg/ffduooi0PKa1yRNJGnhpQKNvBQXs8eV+CQ83aK
-kQHUExuJDrOfsC2iwF/2ZywXhEfbhL7ar0aw5zrhV+r7qvYFWxu/YoLoNVMDByw5
-wAN0oIbsGWYmtIIti8+b9IcacTbAZ79ctlTLb1HCyPMosHxDkv8=
------END RSA PRIVATE KEY-----
Index: node_modules/browser-sync/lib/server/certs/browsersync.pfx
===================================================================
--- node_modules/browser-sync/lib/server/certs/browsersync.pfx	(revision )
+++ node_modules/browser-sync/lib/server/certs/browsersync.pfx	(revision )
@@ -1,0 +0,0 @@
Index: node_modules/browser-sync/lib/server/index.js
===================================================================
--- node_modules/browser-sync/lib/server/index.js	(revision )
+++ node_modules/browser-sync/lib/server/index.js	(revision )
@@ -1,95 +0,0 @@
-"use strict";
-
-var enableDestroy = require("server-destroy");
-var _ = require("../../lodash.custom");
-
-/**
- * Browsersync server
- * Three available modes: Snippet, Server or Proxy
- */
-module.exports.plugin = function (bs) {
-
-    var debug   = bs.debug;
-    var proxy   = bs.options.get("proxy");
-    var type    = bs.options.get("mode");
-
-    var bsServer = createServer(bs);
-
-    if (type === "server" || type === "snippet") {
-        debug("Static Server running ({magenta:%s}) ...", bs.options.get("scheme"));
-    }
-
-    if (proxy) {
-        debug("Proxy running, proxing: {magenta:%s}", proxy.get("target"));
-    }
-
-    if (bsServer) {
-
-        /**
-         * Allow server to be destroyed gracefully
-         */
-        enableDestroy(bsServer.server);
-
-        /**
-         * Listen on the available port
-         */
-        bsServer.server.listen(bs.options.get("port"));
-
-        /**
-         * Hack to deal with https://github.com/socketio/socket.io/issues/1602#issuecomment-224270022
-         */
-        bs.registerCleanupTask(function () {
-            if (bs.io && bs.io.sockets) {
-                setCloseReceived(bs.io.sockets);
-            }
-            if (bs.ui && bs.ui.socket) {
-                setCloseReceived(bs.ui.socket);
-            }
-        });
-
-        /**
-         * Destroy the server on cleanup
-         */
-        bs.registerCleanupTask(function () {
-            bsServer.server.destroy();
-        });
-    }
-
-    function setCloseReceived(io) {
-        Object.keys(io.sockets).forEach(function (key) {
-            _.set(io.sockets[key], "conn.transport.socket._closeReceived", true);
-        });
-    }
-
-    debug("Running mode: %s", type.toUpperCase());
-
-    return {
-        server: bsServer.server,
-        app:    bsServer.app
-    };
-};
-
-/**
- * Launch the server for serving the client JS plus static files
- * @param {BrowserSync} bs
- * @returns {{staticServer: (http.Server), proxyServer: (http.Server)}}
- */
-function createServer (bs) {
-
-    var proxy   = bs.options.get("proxy");
-    var server  = bs.options.get("server");
-
-    if (!proxy && !server) {
-        return require("./snippet-server")(bs);
-    }
-
-    if (proxy) {
-        return require("./proxy-server")(bs);
-    }
-
-    if (server) {
-        return require("./static-server")(bs);
-    }
-}
-
-module.exports.createServer = createServer;
Index: node_modules/browser-sync/lib/server/utils.js
===================================================================
--- node_modules/browser-sync/lib/server/utils.js	(revision )
+++ node_modules/browser-sync/lib/server/utils.js	(revision )
@@ -1,453 +0,0 @@
-"use strict";
-
-var fs           = require("fs");
-var path         = require("path");
-var join         = require("path").join;
-var connect      = require("connect");
-var Immutable    = require("immutable");
-var http         = require("http");
-var https        = require("https");
-var Map          = require("immutable").Map;
-var fromJS       = require("immutable").fromJS;
-var List         = require("immutable").List;
-var snippet      = require("./../snippet").utils;
-var _            = require("./../../lodash.custom");
-var serveStatic  = require("serve-static");
-var logger       = require("../logger");
-var snippetUtils = require("../snippet").utils;
-var lrSnippet    = require("resp-modifier");
-var utils        = require("../utils");
-
-function getCa (options) {
-    var caOption = options.getIn(["https", "ca"]);
-    // if not provided, use Browsersync self-signed
-    if (typeof caOption === "undefined") {
-        return fs.readFileSync(join(__dirname, "certs", "server.csr"));
-    }
-    // if a string was given, read that file from disk
-    if (typeof caOption === "string") {
-        return fs.readFileSync(caOption);
-    }
-    // if an array was given, read all
-    if (List.isList(caOption)) {
-        return caOption.toArray().map(function (x) {
-            return fs.readFileSync(x);
-        });
-    }
-}
-
-function getKey(options) {
-    return fs.readFileSync(options.getIn(["https", "key"])  || join(__dirname, "certs", "server.key"));
-}
-
-function getCert(options) {
-    return fs.readFileSync(options.getIn(["https", "cert"]) || join(__dirname, "certs", "server.crt"));
-}
-
-function getHttpsServerDefaults (options) {
-    return fromJS({
-        key: getKey(options),
-        cert: getCert(options),
-        ca: getCa(options),
-        passphrase: ""
-    });
-}
-
-function getPFXDefaults (options) {
-    return fromJS({
-        pfx: fs.readFileSync(options.getIn(["https", "pfx"]))
-    });
-}
-
-var serverUtils = {
-    /**
-     * @param options
-     * @returns {{key, cert}}
-     */
-    getHttpsOptions: function (options) {
-        var userOption = options.get("https");
-        if (Map.isMap(userOption)) {
-            if (userOption.has("pfx")) {
-                return userOption.mergeDeep(getPFXDefaults(options));
-            }
-            return userOption.mergeDeep(getHttpsServerDefaults(options));
-        }
-        return getHttpsServerDefaults(options);
-    },
-    /**
-     * Get either http or https server
-     * or use the httpModule provided in options if present
-     */
-    getServer: function (app, options) {
-        return {
-            server: (function () {
-
-                var httpModule = serverUtils.getHttpModule(options);
-
-                if (options.get("scheme") === "https") {
-                    var opts = serverUtils.getHttpsOptions(options);
-                    return httpModule.createServer(opts.toJS(), app);
-                }
-
-                return httpModule.createServer(app);
-            })(),
-            app: app
-        };
-    },
-    getHttpModule: function (options) {
-        /**
-         * Users may provide a string to be used by nodes
-         * require lookup.
-         */
-        var httpModule = options.get("httpModule");
-
-        if (typeof httpModule === "string") {
-            /**
-             * Note, this could throw, but let that happen as
-             * the error message good enough.
-             */
-            var maybe = path.resolve(process.cwd(), "node_modules", httpModule);
-            return require(maybe);
-        }
-
-        if (options.get("scheme") === "https") {
-            return https;
-        }
-
-        return http;
-    },
-    getMiddlewares: function (bs) {
-
-        var clientJs = bs.pluginManager.hook("client:js", {
-            port: bs.options.get("port"),
-            options: bs.options
-        });
-
-        var scripts = bs.pluginManager.get("client:script")(
-            bs.options.toJS(),
-            clientJs,
-            "middleware"
-        );
-
-        var defaultMiddlewares = [
-            {
-                id: "Browsersync HTTP Protocol",
-                route: require("../config").httpProtocol.path,
-                handle: require("../http-protocol").middleware(bs)
-            },
-            {
-                id: "Browsersync IE8 Support",
-                route: "",
-                handle: snippet.isOldIe(bs.options.get("excludedFileTypes").toJS())
-            },
-            {
-                id: "Browsersync Response Modifier",
-                route: "",
-                handle: serverUtils.getSnippetMiddleware(bs)
-            },
-            {
-                id: "Browsersync Client - versioned",
-                route: bs.options.getIn(["scriptPaths", "versioned"]),
-                handle: scripts
-            },
-            {
-                id: "Browsersync Client",
-                route: bs.options.getIn(["scriptPaths", "path"]),
-                handle: scripts
-            }
-        ];
-
-        /**
-         * Add cors middleware to the front of the stack
-         * if a user provided a 'cors' flag
-         */
-        if (bs.options.get("cors")) {
-            defaultMiddlewares.unshift({
-                id: "Browsersync CORS support",
-                route: "",
-                handle: serverUtils.getCorsMiddlewware()
-            })
-        }
-
-        /**
-         * Add serve static middleware
-         */
-        if (bs.options.get("serveStatic")) {
-
-            var ssMiddlewares = serverUtils.getServeStaticMiddlewares(bs.options.get("serveStatic"), bs.options.get("serveStaticOptions", Immutable.Map({})).toJS());
-            var withErrors    = ssMiddlewares.filter(function(x) { return x.get("errors").size > 0 });
-            var withoutErrors = ssMiddlewares.filter(function(x) { return x.get("errors").size === 0 });
-
-            if (withErrors.size) {
-                withErrors.forEach(function (item) {
-                    logger.logger.error("{red:Warning!} %s", item.getIn(["errors", 0, "data", "message"]));
-                });
-            }
-
-            if (withoutErrors.size) {
-                withoutErrors.forEach(function (item) {
-                    defaultMiddlewares.push.apply(defaultMiddlewares, item.get("items").toJS());
-                });
-            }
-        }
-
-        /**
-         * Add user-provided middlewares
-         */
-        var userMiddlewares   = bs.options.get("middleware").map(normaliseMiddleware).toArray();
-        var beforeMiddlewares = userMiddlewares.filter(function (x) { return x.override; });
-        var afterMiddlewares  = userMiddlewares.filter(function (x) { return !x.override; });
-
-        return [].concat(beforeMiddlewares, defaultMiddlewares, afterMiddlewares);
-
-        function normaliseMiddleware(item) {
-            /**
-             * Object given in options, which
-             * ended up being a Map
-             */
-            if (Map.isMap(item)) {
-                return item.toJS();
-            }
-            /**
-             * Single function
-             */
-            if (typeof item === "function") {
-                return {
-                    route: "",
-                    handle: item
-                }
-            }
-            /**
-             * Plain obj
-             */
-            if ((item.route !== undefined) && item.handle) {
-                return item;
-            }
-        }
-    },
-    getBaseApp: function (bs) {
-
-        var app         = connect();
-        var middlewares = serverUtils.getMiddlewares(bs);
-
-        /**
-         * Add all internal middlewares
-         */
-        middlewares.forEach(function (item) {
-            app.stack.push(item);
-        });
-
-        return app;
-    },
-    getSnippetMiddleware: function (bs) {
-
-        var rules = [];
-        var blacklist = List([])
-            .concat(bs.options.getIn(["snippetOptions", "ignorePaths"]))
-            .concat(bs.options.getIn(["snippetOptions", "blacklist"]))
-            .filter(Boolean);
-
-        var whitelist = List([])
-            .concat(bs.options.getIn(["snippetOptions", "whitelist"]));
-
-        // Snippet
-        rules.push(snippetUtils.getRegex(bs.options.get("snippet"), bs.options.get("snippetOptions")));
-
-        // User
-        bs.options.get("rewriteRules").forEach(function (rule) {
-            if (Map.isMap(rule)) {
-                rules.push(rule.toJS());
-            }
-            if (_.isPlainObject(rule)) {
-                rules.push(rule);
-            }
-        });
-
-        // Proxy
-        if (bs.options.get("proxy")) {
-            var proxyRule = require("./proxy-utils").rewriteLinks(bs.options.getIn(["proxy", "url"]).toJS());
-            rules.push(proxyRule);
-        }
-
-        var lr = lrSnippet.create({
-            rules:     rules,
-            blacklist: blacklist.toArray(),
-            whitelist: whitelist.toArray()
-        });
-
-        return lr.middleware;
-    },
-    getCorsMiddlewware: function () {
-
-        return function (req, res, next) {
-            // Website you wish to allow to connect
-            res.setHeader("Access-Control-Allow-Origin", "*");
-
-            // Request methods you wish to allow
-            res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS, PUT, PATCH, DELETE");
-
-            // Request headers you wish to allow
-            res.setHeader("Access-Control-Allow-Headers", "X-Requested-With,content-type");
-
-            // Set to true if you need the website to include cookies in the requests sent
-            // to the API (e.g. in case you use sessions)
-            res.setHeader("Access-Control-Allow-Credentials", true);
-            next();
-        }
-    },
-    /**
-     * @param ssOption
-     * @param serveStaticOptions
-     * @returns {*}
-     */
-    getServeStaticMiddlewares: function (ssOption, serveStaticOptions) {
-
-        return ssOption.map(function (dir, i) {
-
-            /**
-             * When a user gives a plain string only, eg:
-             *   serveStatic: ['./temp']
-             *     ->
-             *       This means a middleware will be created with
-             *         route: ''
-             *         handle: serveStatic('./temp', options)
-             */
-            if (_.isString(dir)) {
-                return getFromString(dir)
-            }
-
-            /**
-             * If a user gave an object eg:
-             *   serveStatic: [{route: "", dir: ["test", "./tmp"]}]
-             *     ->
-             *       This means we need to create a middle for each route + dir combo
-             */
-            if (Immutable.Map.isMap(dir)) {
-                return getFromMap(dir, i);
-            }
-
-            /**
-             * At this point, an item in the serveStatic array was not a string
-             * or an object so we return an error that can be logged
-             */
-            return fromJS({
-                items: [],
-                errors: [{
-                    type: "Invalid Type",
-                    data: {
-                        message: "Only strings and Objects (with route+dir) are supported for the ServeStatic option"
-                    }
-                }]
-            })
-        });
-
-        /**
-         * @param {string} x
-         * @returns {string}
-         */
-        function getRoute (x) {
-            if (x === "") return "";
-            return x[0] === "/" ? x : "/" + x;
-        }
-
-        /**
-         * @param dir
-         * @returns {Map}
-         */
-        function getFromString(dir) {
-            return fromJS({
-                items: [
-                    {
-                        route: "",
-                        handle: serveStatic(dir, serveStaticOptions)
-                    }
-                ],
-                errors: []
-            })
-        }
-
-        /**
-         * @param dir
-         * @returns {Map}
-         */
-        function getFromMap(dir) {
-
-            var ssOptions = (function () {
-                if (dir.get("options")) {
-                    return dir.get("options").toJS();
-                }
-                return {}
-            })();
-
-            var route = Immutable.List([]).concat(dir.get("route")).filter(_.isString);
-            var _dir  = Immutable.List([]).concat(dir.get("dir")).filter(_.isString);
-
-            if (_dir.size === 0) {
-
-                return fromJS({
-                    items: [],
-                    errors: [{
-                        type: "Invalid Object",
-                        data: {
-                            message: "Serve Static requires a 'dir' property when using an Object"
-                        }
-                    }]
-                })
-            }
-
-            var ssItems = (function () {
-
-                /**
-                 * iterate over every 'route' item
-                 * @type {Immutable.List<any>|Immutable.List<*>|Immutable.List<any>|*}
-                 */
-                var routeItems = (function () {
-
-                    /**
-                     * If no 'route' was given, assume we want to match all
-                     * paths
-                     */
-                    if (route.size === 0) {
-                        return _dir.map(function (dirString) {
-                            return Map({
-                                route: "",
-                                dir: dirString
-                            });
-                        });
-                    }
-
-                    return route.reduce(function (acc, routeString) {
-                        /**
-                         * For each 'route' item, also iterate through 'dirs'
-                         * @type {Immutable.Iterable<K, M>}
-                         */
-                        var perDir = _dir.map(function (dirString) {
-                            return Map({
-                                route: getRoute(routeString),
-                                dir: dirString
-                            })
-                        });
-                        return acc.concat(perDir);
-
-                    }, List([]));
-                })();
-
-                /**
-                 * Now create a serverStatic Middleware for each item
-                 */
-                return routeItems.map(function (routeItem) {
-                    return routeItem.merge({
-                        handle: serveStatic(routeItem.get("dir"), ssOptions)
-                    });
-                });
-            })();
-
-            return fromJS({
-                items: ssItems,
-                errors: []
-            });
-        }
-    }
-};
-
-module.exports = serverUtils;
Index: node_modules/browser-sync/lib/server/proxy-utils.js
===================================================================
--- node_modules/browser-sync/lib/server/proxy-utils.js	(revision )
+++ node_modules/browser-sync/lib/server/proxy-utils.js	(revision )
@@ -1,138 +0,0 @@
-var url = require("url");
-
-module.exports.rewriteLinks = function (userServer) {
-
-    var host   = userServer.hostname;
-    var string = host;
-    var port   = userServer.port;
-
-    if (host && port) {
-        if (parseInt(port, 10) !== 80) {
-            string = host + ":" + port;
-        }
-    }
-
-    return {
-        match: new RegExp("https?:\\\\/\\\\/" + string + "|('|\")\\\/\\\/" + string + "|https?://" + string + "(\/)?|('|\")(https?://|/|\\.)?" + string + "(\/)?(.*?)(?=[ ,'\"\\s])", "g"),
-        //match: new RegExp("https?:\\\\/\\\\/" + string + "|https?://" + string + "(\/)?|('|\")(https?://|/|\\.)?" + string + "(\/)?(.*?)(?=[ ,'\"\\s])", "g"),
-        //match: new RegExp("https?:\\\\?/\\\\?/" + string + "(\/)?|('|\")(https?://|\\\\?/|\\.)?" + string + "(\/)?(.*?)(?=[ ,'\"\\s])", "g"),
-        //match: new RegExp('https?://' + string + '(\/)?|(\'|")(https?://|/|\\.)?' + string + '(\/)?(.*?)(?=[ ,\'"\\s])', 'g'),
-        //match: new RegExp("https?:\\\\/\\\\/" + string, "g"),
-        fn:    function (req, res, match) {
-
-            var proxyUrl = req.headers["host"];
-
-            /**
-             * Reject subdomains
-             */
-            if (match[0] === ".") {
-                return match;
-            }
-
-            var captured = match[0] === "'" || match[0] === "\"" ? match[0] : "";
-
-            /**
-             * allow http https
-             * @type {string}
-             */
-            var pre = "//";
-
-            if (match[0] === "'" || match[0] === "\"") {
-                match = match.slice(1);
-            }
-
-            /**
-             * parse the url
-             * @type {number|*}
-             */
-            var out = url.parse(match);
-
-            /**
-             * If host not set, just do a simple replace
-             */
-            if (!out.host) {
-                string = string.replace(/^(\/)/, "");
-                return captured + match.replace(string, proxyUrl);
-            }
-
-            /**
-             * Only add trailing slash if one was
-             * present in the original match
-             */
-            if (out.path === "/") {
-                if (match.slice(-1) === "/") {
-                    out.path = "/";
-                } else {
-                    out.path = "";
-                }
-            }
-
-            /**
-             * Finally append all of parsed url
-             */
-            return [
-                captured,
-                pre,
-                proxyUrl,
-                out.path || "",
-                out.hash || ""
-            ].join("");
-        }
-    };
-};
-
-/**
- * Remove 'domain' from any cookies
- * @param {Object} res
- */
-module.exports.checkCookies = function checkCookies (res) {
-    if (typeof(res.headers["set-cookie"]) !== "undefined") {
-        res.headers["set-cookie"] = res.headers["set-cookie"].map(function (item) {
-            return rewriteCookies(item);
-        });
-    }
-};
-
-/**
- * Remove the domain from any cookies.
- * @param rawCookie
- * @returns {string}
- */
-function rewriteCookies (rawCookie) {
-
-    var objCookie = (function () {
-        // simple parse function (does not remove quotes)
-        var obj = {};
-        var pairs = rawCookie.split(/; */);
-
-        pairs.forEach( function( pair ) {
-            var eqIndex = pair.indexOf("=");
-
-            // skip things that don't look like key=value
-            if (eqIndex < 0) {
-                return;
-            }
-
-            var key = pair.substr(0, eqIndex).trim();
-            obj[key] = pair.substr(eqIndex + 1, pair.length).trim();
-        });
-
-        return obj;
-    })();
-
-    var pairs = Object.keys(objCookie)
-        .filter(function (item) {
-            return item !== "domain";
-        })
-        .map(function (key) {
-            return key + "=" + objCookie[key];
-        });
-
-    if (rawCookie.match(/httponly/i)) {
-        pairs.push("HttpOnly");
-    }
-
-    return pairs.join("; ");
-}
-
-module.exports.rewriteCookies = rewriteCookies;
Index: node_modules/browser-sync/lib/server/proxy-server.js
===================================================================
--- node_modules/browser-sync/lib/server/proxy-server.js	(revision )
+++ node_modules/browser-sync/lib/server/proxy-server.js	(revision )
@@ -1,195 +0,0 @@
-"use strict";
-
-var httpProxy  = require("http-proxy");
-var utils      = require("./utils");
-var proxyUtils = require("./proxy-utils");
-var Immutable  = require("immutable");
-var Map        = require("immutable").Map;
-var List       = require("immutable").List;
-
-/**
- * Default options that are passed along to http-proxy
- */
-var defaultHttpProxyOptions = Map({
-    /**
-     * This ensures targets are more likely to
-     * accept each request
-     */
-    changeOrigin: true,
-    /**
-     * This handles redirects
-     */
-    autoRewrite: true,
-    /**
-     * This allows our self-signed certs to be used for development
-     */
-    secure: false,
-    ws: true
-});
-
-var defaultCookieOptions = Map({
-    stripDomain: true
-});
-
-var ProxyOption = Immutable.Record({
-    route: "",
-    target: "",
-    rewriteRules: true,
-    /**
-     * Functions to be called on proxy request
-     * with args [proxyReq, req, res, options]
-     */
-    proxyReq:     List([]),
-    /**
-     * Functions to be called on proxy response
-     * with args [proxyRes, req, res]
-     */
-    proxyRes:     List([]),
-    /**
-     * Functions to be called on proxy response
-     * with args [proxyReq, req, socket, options, head]
-     */
-    proxyReqWs:   List([]),
-    errHandler:   undefined,
-    url:          Map({}),
-    proxyOptions: Map(defaultHttpProxyOptions),
-    cookies:      Map(defaultCookieOptions),
-    ws:           false,
-    middleware:   List([]),
-    reqHeaders:   undefined
-});
-
-/**
- * @param {BrowserSync} bs
- * @param {String} scripts
- * @returns {*}
- */
-module.exports = function createProxyServer (bs) {
-
-    var opt         = new ProxyOption().mergeDeep(bs.options.get("proxy"));
-    var proxy       = httpProxy.createProxyServer(opt.get("proxyOptions").set("target", opt.get("target")).toJS());
-    var target      = opt.get("target");
-    var proxyReq    = getProxyReqFunctions(opt.get("proxyReq"), opt, bs);
-    var proxyRes    = getProxyResFunctions(opt.get("proxyRes"), opt);
-    var proxyResWs  = opt.get("proxyReqWs");
-    bs.options      = bs.options.update("middleware", function (mw) {
-        return mw.concat({
-            id: "Browsersync Proxy",
-            route: opt.get("route"),
-            handle: function (req, res) {
-                proxy.web(req, res, {
-                    target: target
-                });
-            }
-        });
-    });
-
-    var app  = utils.getBaseApp(bs);
-
-    /**
-     * @type {*|{server, app}}
-     */
-    var browserSyncServer = utils.getServer(app, bs.options);
-    browserSyncServer.proxy = proxy;
-
-    if (opt.get("ws")) {
-        // debug(`+ ws upgrade for: ${x.get("target")}`);
-        browserSyncServer.server.on("upgrade", function (req, socket, head) {
-            proxy.ws(req, socket, head);
-        });
-    }
-
-    /**
-     * Add any user provided functions for proxyReq, proxyReqWs and proxyRes
-     */
-    applyFns("proxyReq",   proxyReq);
-    applyFns("proxyRes",   proxyRes);
-    applyFns("proxyReqWs", proxyResWs);
-
-    /**
-     * Handle Proxy errors
-     */
-    proxy.on("error", function (err) {
-        if (typeof opt.get("errHandler") === "function") {
-            opt.get("errHandler").call(null, err);
-        }
-    });
-
-    /**
-     * Apply functions to proxy events
-     * @param {string} name - the name of the http-proxy event
-     * @param {Array} fns - functions to call on each event
-     */
-    function applyFns (name, fns) {
-        if (!List.isList(fns)) fns = [fns];
-        proxy.on(name, function () {
-            var args = arguments;
-            fns.forEach(function(fn) {
-                if (typeof fn === "function") {
-                    fn.apply(null, args);
-                }
-            });
-        });
-    }
-
-    return browserSyncServer;
-};
-
-/**
- * @param resFns
- * @returns {*}
- */
-function getProxyResFunctions (resFns, opt) {
-    if (opt.getIn(["cookies", "stripDomain"])) {
-        return resFns.push(proxyUtils.checkCookies);
-    }
-    return resFns;
-}
-
-/**
- * @param reqFns
- * @returns {*}
- */
-function getProxyReqFunctions (reqFns, opt, bs) {
-
-    var reqHeaders = opt.getIn(["reqHeaders"]);
-
-    if (!reqHeaders) {
-        return reqFns;
-    }
-
-    /**
-     * Back-compat for old `reqHeaders` option here a
-     * function was given that returned an object
-     * where key:value was header-name:header-value
-     * This didn't really work as it clobbered all other headers,
-     * but it remains for the unlucky few who used it.
-     */
-    if (typeof reqHeaders === "function") {
-        var output = reqHeaders.call(bs, opt.toJS());
-        if (Object.keys(output).length) {
-            return reqFns.concat(function (proxyReq) {
-                Object.keys(output).forEach(function (key) {
-                    proxyReq.setHeader(key, output[key]);
-                });
-            });
-        }
-    }
-
-    /**
-     * Now, if {key:value} given, set the each header
-     *
-     * eg: reqHeaders: {
-     *     'is-dev': 'true'
-     * }
-     */
-    if (Map.isMap(reqHeaders)) {
-        return reqFns.concat(function (proxyReq) {
-            reqHeaders.forEach(function (value, key) {
-                proxyReq.setHeader(key, value);
-            });
-        });
-    }
-
-    return reqFns;
-}
Index: node_modules/browser-sync/lib/server/static-server.js
===================================================================
--- node_modules/browser-sync/lib/server/static-server.js	(revision )
+++ node_modules/browser-sync/lib/server/static-server.js	(revision )
@@ -1,79 +0,0 @@
-"use strict";
-
-var connect      = require("connect");
-var serverUtils  = require("./utils.js");
-var resolve      = require("path").resolve;
-var utils        = require("../utils.js");
-var serveStatic  = require("serve-static");
-var serveIndex   = require("serve-index");
-
-/**
- * @param {BrowserSync} bs
- * @param scripts
- * @returns {*}
- */
-module.exports = function createServer (bs) {
-
-    var options            = bs.options;
-    var server             = options.get("server");
-    var basedirs           = utils.arrayify(server.get("baseDir"));
-    var serveStaticOptions = server.get("serveStaticOptions").toJS(); // passed to 3rd party
-
-    var _serveStatic = 0;
-    var _routes = 0;
-    bs.options = bs.options
-        /**
-         * Add directory Middleware if given in server.directory
-         */
-        .update("middleware", function (mw) {
-            if (!server.get("directory")) {
-                return mw;
-            }
-
-            return mw.concat({
-                route: "",
-                handle: serveIndex(resolve(basedirs[0]), {icons:true}),
-                id: "Browsersync Server Directory Middleware"
-            });
-        })
-        /**
-         * Add middleware for server.baseDir Option
-         */
-        .update("middleware", function (mw) {
-            return mw.concat(basedirs.map(function (root) {
-                return {
-                    route: "",
-                    id: "Browsersync Server ServeStatic Middleware - " + _serveStatic++,
-                    handle: serveStatic(resolve(root), serveStaticOptions)
-                }
-            }));
-        })
-        /**
-         * Add middleware for server.routes
-         */
-        .update("middleware", function (mw) {
-
-            if (!server.get("routes")) {
-                return mw;
-            }
-
-            return mw.concat(server.get("routes").map(function (root, urlPath) {
-                // strip trailing slash
-                if (urlPath[urlPath.length - 1] === "/") {
-                    urlPath = urlPath.slice(0, -1);
-                }
-                return {
-                    route: urlPath,
-                    id: "Browsersync Server Routes Middleware - " + _routes++,
-                    handle: serveStatic(resolve(root))
-                }
-            }));
-        });
-
-    var app = serverUtils.getBaseApp(bs);
-
-    /**
-     * Finally, return the server + App
-     */
-    return serverUtils.getServer(app, bs.options);
-};
Index: node_modules/browser-sync/lib/server/snippet-server.js
===================================================================
--- node_modules/browser-sync/lib/server/snippet-server.js	(revision )
+++ node_modules/browser-sync/lib/server/snippet-server.js	(revision )
@@ -1,16 +0,0 @@
-"use strict";
-
-var connect = require("connect");
-var serverUtils = require("./utils.js");
-
-/**
- * Create a server for the snippet
- * @param {BrowserSync} bs
- * @param scripts
- * @returns {*}
- */
-module.exports = function createSnippetServer (bs, scripts) {
-
-    var app = serverUtils.getBaseApp(bs, bs.options, scripts);
-    return serverUtils.getServer(app, bs.options);
-};
Index: node_modules/browser-sync/lib/args.js
===================================================================
--- node_modules/browser-sync/lib/args.js	(revision )
+++ node_modules/browser-sync/lib/args.js	(revision )
@@ -1,86 +0,0 @@
-"use strict";
-
-/**
- * The purpose of this function is
- * to handle back-backwards compatibility
- * @param {Object} args
- * @returns {{config: {}, cb: *}}
- */
-module.exports = function (args) {
-
-    var config = {};
-    var cb;
-
-    switch (args.length) {
-
-        case 1 :
-
-            if (isFilesArg(args[0])) {
-
-                config.files = args[0];
-
-            } else if (typeof args[0] === "function") {
-
-                cb = args[0];
-
-            } else {
-
-                config = args[0];
-
-            }
-
-            break;
-
-        case 2 :
-
-            // if second is a function, first MUST be config
-            if (typeof args[1] === "function") {
-
-                config = args[0] || {};
-                cb = args[1];
-
-            } else {
-
-                if (args[1] === null || args[1] === undefined) {
-
-                    config = args[0];
-
-                } else {
-
-                    // finally, second arg could be a plain object for config
-                    config = args[1] || {};
-
-                    if (!config.files) {
-                        config.files = args[0];
-                    }
-                }
-
-            }
-
-            break;
-
-        case 3 :
-
-            config = args[1] || {};
-
-            if (!config.files) {
-                config.files = args[0];
-            }
-
-            cb = args[2];
-    }
-
-    return {
-        config: config,
-        cb: cb
-    };
-};
-
-/**
- * Files args were only ever strings or arrays
- * @param arg
- * @returns {*|boolean}
- */
-function isFilesArg (arg) {
-    return Array.isArray(arg) || typeof arg === "string";
-}
Index: node_modules/browser-sync/lib/async.js
===================================================================
--- node_modules/browser-sync/lib/async.js	(revision )
+++ node_modules/browser-sync/lib/async.js	(revision )
@@ -1,323 +0,0 @@
-"use strict";
-
-var _            = require("../lodash.custom");
-var Immutable    = require("immutable");
-
-var utils        = require("./utils");
-var pluginUtils  = require("./plugins");
-var connectUtils = require("./connect-utils");
-
-module.exports = {
-    /**
-     * BrowserSync needs at least 1 free port.
-     * It will check the one provided in config
-     * and keep incrementing until an available one is found.
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    getEmptyPort: function (bs, done) {
-        utils.getPorts(bs.options, function (err, port) {
-            if (err) {
-                return utils.fail(true, err, bs.cb);
-            }
-            bs.debug("Found a free port: {magenta:%s", port);
-            done(null, {
-                options: {
-                    port: port
-                }
-            });
-        });
-    },
-    /**
-     * If the running mode is proxy, we'll use a separate port
-     * for the Browsersync web-socket server. This is to eliminate any issues
-     * with trying to proxy web sockets through to the users server.
-     * @param bs
-     * @param done
-     */
-    getExtraPortForProxy: function (bs, done) {
-        /**
-         * An extra port is not needed in snippet/server mode
-         */
-        if (bs.options.get("mode") !== "proxy") {
-            return done();
-        }
-
-        /**
-         * Web socket support is disabled by default
-         */
-        if (!bs.options.getIn(["proxy", "ws"])) {
-            return done();
-        }
-
-        /**
-         * Use 1 higher than server port by default...
-         */
-        var socketPort = bs.options.get("port") + 1;
-
-        /**
-         * Or use the user-defined socket.port option instead
-         */
-        if (bs.options.hasIn(["socket", "port"])) {
-            socketPort = bs.options.getIn(["socket", "port"]);
-        }
-
-        utils.getPort(socketPort, null, function (err, port) {
-            if (err) {
-                return utils.fail(true, err, bs.cb);
-            }
-            done(null, {
-                optionsIn: [
-                    {
-                        path: ["socket", "port"],
-                        value: port
-                    }
-                ]
-            });
-        });
-    },
-    /**
-     * Some features require an internet connection.
-     * If the user did not provide either `true` or `false`
-     * for the online option, we will attempt to resolve www.google.com
-     * as a way of determining network connectivity
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    getOnlineStatus: function (bs, done) {
-        if (_.isUndefined(bs.options.get("online")) && _.isUndefined(process.env.TESTING)) {
-            require("dns").resolve("www.google.com", function (err) {
-                var online = false;
-                if (err) {
-                    bs.debug("Could not resolve www.google.com, setting {magenta:online: false}");
-                } else {
-                    bs.debug("Resolved www.google.com, setting {magenta:online: true}");
-                    online = true;
-                }
-                done(null, {
-                    options: {
-                        online: online
-                    }
-                });
-            });
-        } else {
-            done();
-        }
-    },
-    /**
-     * Try to load plugins that were given in options
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    resolveInlineUserPlugins: function (bs, done) {
-
-        var plugins = bs.options
-            .get("plugins")
-            .map(pluginUtils.resolvePlugin)
-            .map(pluginUtils.requirePlugin);
-
-        plugins
-            .forEach(function (plugin) {
-                if (plugin.get("errors").size) {
-                    return logPluginError(plugin);
-                }
-                var jsPlugin = plugin.toJS();
-                jsPlugin.options = jsPlugin.options || {};
-                jsPlugin.options.moduleName = jsPlugin.moduleName;
-                bs.registerPlugin(jsPlugin.module, jsPlugin.options);
-            });
-
-        function logPluginError (plugin) {
-            utils.fail(true, plugin.getIn(["errors", 0]), bs.cb);
-        }
-
-        done();
-    },
-    /**
-     *
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    setOptions: function (bs, done) {
-        done(null, {
-            options: {
-                urls:        utils.getUrlOptions(bs.options),
-                snippet:     connectUtils.scriptTags(bs.options),
-                scriptPaths: Immutable.fromJS(connectUtils.clientScript(bs.options, true)),
-                files:       bs.pluginManager.hook(
-                    "files:watch",
-                    bs.options.get("files"),
-                    bs.pluginManager.pluginOptions
-                )
-            }
-        });
-    },
-    /**
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    setInternalEvents: function (bs, done) {
-        require("./internal-events")(bs);
-        done();
-    },
-    /**
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    setFileWatchers: function (bs, done) {
-        done(null, {
-            instance: {
-                watchers: bs.pluginManager.get("file:watcher")(bs)
-            }
-        });
-    },
-    /**
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    mergeMiddlewares: function (bs, done) {
-
-        done(null, {
-            options: {
-                middleware: bs.pluginManager.hook(
-                    "server:middleware",
-                    bs.options.get("middleware")
-                )
-            }
-        });
-    },
-    /**
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    startServer: function (bs, done) {
-
-        var server = bs.pluginManager.get("server")(bs);
-
-        done(null, {
-            instance: {
-                server: server.server,
-                app: server.app
-            }
-        });
-    },
-    /**
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    startTunnel: function (bs, done) {
-        if (bs.options.get("tunnel") && bs.options.get("online")) {
-            var localTunnel = require("./tunnel");
-            localTunnel(bs, function (err, tunnel) {
-                if (err) {
-                    return done(err);
-                } else {
-                    return done(null, {
-                        optionsIn: [
-                            {
-                                path:  ["urls", "tunnel"],
-                                value: tunnel.url
-                            }
-                        ],
-                        instance: {
-                            tunnel: tunnel
-                        }
-                    });
-                }
-            });
-        } else {
-            done();
-        }
-    },
-    /**
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    startSockets: function (bs, done) {
-
-        var clientEvents = bs.pluginManager.hook(
-            "client:events",
-            bs.options.get("clientEvents").toJS()
-        );
-
-        // Start the socket, needs an existing server.
-        var io = bs.pluginManager.get("socket")(
-            bs.server,
-            clientEvents,
-            bs
-        );
-
-        done(null, {
-            instance: {
-                io: io
-            },
-            options: {
-                clientEvents: Immutable.fromJS(clientEvents)
-            }
-        });
-    },
-    /**
-     *
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    startUi: function (bs, done) {
-
-        var PLUGIN_NAME = "UI";
-        var userPlugins   = bs.getUserPlugins();
-        var ui            = bs.pluginManager.get(PLUGIN_NAME);
-        var uiOpts        = bs.options.get("ui");
-
-        if (!uiOpts || uiOpts.get("enabled") === false) {
-            return done();
-        }
-
-        // if user provided a UI, use it instead
-        if (userPlugins.some(function (item) {
-            return item.name === PLUGIN_NAME;
-        })) {
-            uiOpts = bs.options.get("ui").mergeDeep(Immutable.fromJS(bs.pluginManager.pluginOptions[PLUGIN_NAME]));
-        }
-
-        return ui(uiOpts.toJS(), bs, function (err, ui) {
-            if (err) {
-                return done(err);
-            }
-            done(null, {
-                instance: {
-                    ui: ui
-                }
-            });
-        });
-    },
-    /**
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    mergeUiSettings: function (bs, done) {
-
-        if (!bs.ui) {
-            return done();
-        }
-
-        done(null, {
-            options: {
-                urls: bs.options.get("urls").merge(bs.ui.options.get("urls"))
-            }
-        });
-    },
-    /**
-     * @param {BrowserSync} bs
-     * @param {Function} done
-     */
-    initUserPlugins: function (bs, done) {
-
-        bs.pluginManager.initUserPlugins(bs);
-
-        done(null, {
-            options: {
-                userPlugins: bs.getUserPlugins()
-            }
-        });
-    }
-};
Index: node_modules/browser-sync/lib/hooks.js
===================================================================
--- node_modules/browser-sync/lib/hooks.js	(revision )
+++ node_modules/browser-sync/lib/hooks.js	(revision )
@@ -1,96 +0,0 @@
-"use strict";
-
-var _            = require("../lodash.custom");
-var Immutable    = require("immutable");
-var snippetUtils = require("./snippet").utils;
-
-module.exports = {
-
-    /**
-     *
-     * @this {BrowserSync}
-     * @returns {String}
-     */
-    "client:js": function (hooks, data) {
-
-        var js  = snippetUtils.getClientJs(data.port, data.options);
-
-        return hooks.reduce(function (joined, hook) {
-            return joined + hook;
-        }, js);
-    },
-    /**
-     * @this {BrowserSync}
-     * @returns {Array}
-     */
-    "client:events": function (hooks, clientEvents) {
-
-        hooks.forEach(function (hook) {
-
-            var result = hook(this);
-
-            if (Array.isArray(result)) {
-                clientEvents = _.union(clientEvents, result);
-            } else {
-                clientEvents.push(result);
-            }
-        }, this);
-
-        return clientEvents;
-    },
-    /**
-     * @returns {Array}
-     */
-    "server:middleware": function (hooks, initial) {
-
-        initial = initial || [];
-
-        _.each(hooks, function (hook) {
-
-            var result = hook(this);
-
-            if (Array.isArray(result)) {
-                result.forEach(function (res) {
-                    if (_.isFunction(res)) {
-                        initial = initial.push(res);
-                    }
-                });
-
-            } else {
-                if (_.isFunction(result)) {
-                    initial = initial.push(result);
-                }
-            }
-        }, this);
-
-        return initial;
-    },
-    /**
-     * @param {Array} hooks
-     * @param {Map|List} initial
-     * @param pluginOptions
-     * @returns {any}
-     */
-    "files:watch": function (hooks, initial, pluginOptions) {
-
-        var opts;
-
-        if (pluginOptions) {
-            opts = Immutable.fromJS(pluginOptions);
-            opts.forEach(function (value, key) {
-                if (!value) {
-                    return;
-                }
-                var files = value.get("files");
-                if (files) {
-                    var fileArg = require("./cli/cli-options").makeFilesArg(files);
-                    if (fileArg) {
-                        initial = initial.set(key, Immutable.fromJS(fileArg));
-                    }
-                }
-            });
-        }
-
-        return initial;
-    }
-};
Index: node_modules/browser-sync/lib/utils.js
===================================================================
--- node_modules/browser-sync/lib/utils.js	(revision )
+++ node_modules/browser-sync/lib/utils.js	(revision )
@@ -1,310 +0,0 @@
-"use strict";
-
-var _             = require("../lodash.custom");
-var devIp         = require("dev-ip")();
-var Immutable     = require("immutable");
-var portScanner   = require("portscanner");
-var path          = require("path");
-var List          = require("immutable").List;
-var UAParser      = require("ua-parser-js");
-var parser        = new UAParser();
-
-var utils = {
-    /**
-     * @param {Object} options
-     * @returns {String|boolean} - the IP address
-     * @param devIp
-     */
-    getHostIp: function (options, devIp) {
-
-        if (options) {
-            var host = options.get("host");
-            if (host && host !== "localhost") {
-                return host;
-            }
-            if (options.get("detect") === false || !devIp.length) {
-                return false;
-            }
-        }
-
-        return devIp.length ? devIp[0] : false;
-    },
-    /**
-     * Set URL Options
-     */
-    getUrlOptions: function (options) {
-
-        var scheme = options.get("scheme");
-
-        var port   = options.get("port");
-        var urls   = {};
-
-        if (options.get("online") === false) {
-            urls.local = utils.getUrl(scheme + "://localhost:" + port, options);
-            return Immutable.fromJS(urls);
-        }
-
-        var external  = utils.xip(utils.getHostIp(options, devIp), options);
-        var localhost = "localhost";
-
-        if (options.get("xip")) {
-            localhost = "127.0.0.1";
-        }
-
-        localhost = utils.xip(localhost, options);
-
-        return Immutable.fromJS(utils.getUrls(external, localhost, scheme, options));
-    },
-    /**
-     * Append a start path if given in options
-     * @param {String} url
-     * @param {Object} options
-     * @returns {String}
-     */
-    getUrl: function (url, options) {
-
-        var prefix = "/";
-        var startPath = options.get("startPath");
-
-        if (startPath) {
-            if (startPath.charAt(0) === "/") {
-                prefix = "";
-            }
-            url = url + prefix + startPath;
-        }
-
-        return url;
-    },
-    /**
-     * @param {String} external
-     * @param {String} local
-     * @param {String} scheme
-     * @param {Object} options
-     * @returns {{local: string, external: string}}
-     */
-    getUrls: function (external, local, scheme, options) {
-
-        var urls = {
-            local: utils.getUrl(utils._makeUrl(scheme, local, options.get("port")), options)
-        };
-
-        if (external !== local) {
-            urls.external = utils.getUrl(utils._makeUrl(scheme, external, options.get("port")), options);
-        }
-
-        return urls;
-    },
-    /**
-     * @param {String} scheme
-     * @param {String} host
-     * @param {Number} port
-     * @returns {String}
-     * @private
-     */
-    _makeUrl: function (scheme, host, port) {
-        return scheme + "://" + host + ":" + port;
-    },
-    /**
-     * Get ports
-     * @param {Object} options
-     * @param {Function} cb
-     */
-    getPorts: function (options, cb) {
-
-        var port  = options.get("port");
-        var ports = options.get("ports"); // backwards compatibility
-        var max;
-
-        if (ports) {
-            port = ports.get("min");
-            max  = ports.get("max") || null;
-        }
-
-        utils.getPort(port, max, cb);
-    },
-    getPort: function (port, max, cb) {
-        portScanner.findAPortNotInUse(port, max, {
-            host: "localhost",
-            timeout: 1000
-        }, cb);
-    },
-    /**
-     * @param {String} ua
-     * @returns {Object}
-     */
-    getUaString: function (ua) {
-        return parser.setUA(ua).getBrowser();
-    },
-    /**
-     * Open the page in browser
-     * @param {String} url
-     * @param {Object} options
-     * @param {BrowserSync} bs
-     */
-    openBrowser: function (url, options, bs) {
-
-        var open    = options.get("open");
-        var browser = options.get("browser");
-
-        if (_.isString(open)) {
-            if (options.getIn(["urls", open])) {
-                url = options.getIn(["urls", open]);
-            }
-        }
-
-        if (open) {
-            if (browser !== "default") {
-                if (utils.isList(browser)) {
-                    browser.forEach(function (browser) {
-                        utils.open(url, browser, bs);
-                    });
-                } else {
-                    utils.open(url, browser, bs); // single
-                }
-            } else {
-                utils.open(url, null, bs);
-            }
-        }
-    },
-    /**
-     * Wrapper for opn module
-     * @param url
-     * @param name
-     * @param bs
-     */
-    open: function (url, name, bs) {
-        var options = (function () {
-            if (_.isString(name)) {
-                return {app: name};
-            }
-            if (Immutable.Map.isMap(name)) {
-                return name.toJS();
-            }
-            return {};
-        })();
-        var opn = require("opn");
-        opn(url, options).catch(function() {
-            bs.events.emit("browser:error");
-        });
-    },
-    /**
-     * @param {Boolean} kill
-     * @param {String|Error} [errMessage]
-     * @param {Function} [cb]
-     */
-    fail: function (kill, errMessage, cb) {
-        if (kill) {
-            if (_.isFunction(cb)) {
-                if (errMessage.message) { // Is this an error object?
-                    cb(errMessage);
-                } else {
-                    cb(new Error(errMessage));
-                }
-            }
-            process.exit(1);
-        }
-    },
-    /**
-     * Add support for xip.io urls
-     * @param {String} host
-     * @param {Object} options
-     * @returns {String}
-     */
-    xip: function (host, options) {
-        var suffix = options.get("hostnameSuffix");
-        if (options.get("xip")) {
-            return host + ".xip.io";
-        }
-        if (suffix) {
-            return host + suffix;
-        }
-        return host;
-    },
-    /**
-     * Determine if an array of file paths will cause a full page reload.
-     * @param {Array} needles - filepath such as ["core.css", "index.html"]
-     * @param {Array} haystack
-     * @returns {Boolean}
-     */
-    willCauseReload: function (needles, haystack) {
-        return needles.some(function (needle) {
-            return !_.includes(haystack, path.extname(needle).replace(".", ""));
-        });
-    },
-    isList: Immutable.List.isList,
-    isMap: Immutable.List.isMap,
-    /**
-     * @param {Map} options
-     * @returns {Array}
-     */
-    getConfigErrors: function (options) {
-
-        var messages = require("./config").errors;
-
-        var errors = [];
-
-        if (options.get("server") && options.get("proxy")) {
-            errors.push(messages["server+proxy"]);
-        }
-
-        return errors;
-    },
-    /**
-     * @param {Map} options
-     * @param {Function} [cb]
-     */
-    verifyConfig: function (options, cb) {
-        var errors = utils.getConfigErrors(options);
-        if (errors.length) {
-            utils.fail(true, errors.join("\n"), cb);
-            return false;
-        }
-        return true;
-    },
-    /**
-     * @param err
-     */
-    defaultCallback: function (err) {
-        if (err && err.message) {
-            console.error(err.message);
-        }
-    },
-    eachSeries: function (arr, iterator, callback) {
-        callback = callback || function () {};
-        var completed = 0;
-        var iterate = function () {
-            iterator(arr[completed], function (err) {
-                if (err) {
-                    callback(err);
-                    callback = function () {};
-                } else {
-                    ++completed;
-                    if (completed >= arr.length) {
-                        callback();
-                    } else {
-                        iterate();
-                    }
-                }
-            });
-        };
-        iterate();
-    },
-    /**
-     * @param {Immutable.List|Array|String} incoming
-     * @returns {Array}
-     */
-    arrayify: function (incoming) {
-        if (List.isList(incoming)) {
-            return incoming.toArray();
-        }
-        return [].concat(incoming).filter(Boolean);
-    }
-};
-
-module.exports              = utils;
-module.exports.portscanner  = portScanner;
-module.exports.UAParser     = UAParser;
-module.exports.connect      = require("connect");
-module.exports.devIp        = devIp;
-module.exports.serveStatic  = require("serve-static");
-module.exports.easyExtender = require("easy-extender");
Index: node_modules/browser-sync/lib/config.js
===================================================================
--- node_modules/browser-sync/lib/config.js	(revision )
+++ node_modules/browser-sync/lib/config.js	(revision )
@@ -1,31 +0,0 @@
-"use strict";
-
-var path = require("path");
-/**
- * @type {{controlPanel: {jsFile: string, baseDir: *}, socketIoScript: string, configFile: string, client: {shims: string}}}
- */
-module.exports = {
-    controlPanel: {
-        jsFile: "/js/app.js",
-        baseDir: path.join(__dirname, "control-panel")
-    },
-    templates: {
-        scriptTag: path.join(__dirname, "templates/script-tags.tmpl"),
-        scriptTagSimple: path.join(__dirname, "templates/script-tags-simple.tmpl"),
-        connector: path.join(__dirname, "templates/connector.tmpl")
-    },
-    socketIoScript: "/public/socket.io.min.1.6.0.js",
-    configFile: "default-config.js",
-    userFile: "bs-config.js",
-    template: "cli-template.js",
-    httpProtocol: {
-        path: "/__browser_sync__"
-    },
-    client: {
-        shims: "/client/client-shims.js"
-    },
-    errors: {
-        "server+proxy": "Invalid config. You cannot specify both server & proxy options.",
-        "proxy+https":  "Invalid config. You set https: true, but your proxy target doesn't reflect this."
-    }
-};
Index: node_modules/browser-sync/lib/logger.js
===================================================================
--- node_modules/browser-sync/lib/logger.js	(revision )
+++ node_modules/browser-sync/lib/logger.js	(revision )
@@ -1,288 +0,0 @@
-"use strict";
-
-var messages = require("./connect-utils");
-var utils    = require("./utils");
-var _        = require("../lodash.custom");
-
-var template = "[{blue:%s}] ";
-
-var logger   = require("eazy-logger").Logger({
-    prefix: template.replace("%s", "BS"),
-    useLevelPrefixes: false
-});
-
-module.exports.logger = logger;
-
-/**
- * @param name
- * @returns {*}
- */
-module.exports.getLogger = function (name) {
-    return logger.clone(function (config) {
-        config.prefix = config.prefix + template.replace("%s", name);
-        return config;
-    });
-};
-
-/**
- * Logging Callbacks
- */
-module.exports.callbacks = {
-    /**
-     * Log when file-watching has started
-     * @param {BrowserSync} bs
-     * @param data
-     */
-    "file:watching": function (bs, data) {
-        if (Object.keys(data).length) {
-            logger.info("Watching files...");
-        }
-    },
-    /**
-     * Log when a file changes
-     * @param {BrowserSync} bs
-     * @param data
-     */
-    "file:reload": function (bs, data) {
-        if (canLogFileChange(bs, data)) {
-
-            if (data.path[0] === "*") {
-                return logger.info("{cyan:Reloading files that match: {magenta:%s", data.path);
-            }
-
-            logger.info("{cyan:File event [" + data.event + "] : {magenta:%s", data.path);
-        }
-    },
-    /**
-     *
-     */
-    "service:exit": function () {
-        logger.debug("Exiting...");
-    },
-    /**
-     *
-     */
-    "browser:reload": function (bs) {
-        if (canLogFileChange(bs)) {
-            logger.info("{cyan:Reloading Browsers...");
-        }
-    },
-    /**
-     *
-     */
-    "browser:error": function () {
-        logger.error("Couldn't open browser (if you are using BrowserSync in a headless environment, you might want to set the {cyan:open} option to {cyan:false})");
-    },
-    /**
-     * @param {BrowserSync} bs
-     * @param data
-     */
-    "stream:changed": function (bs, data) {
-        if (canLogFileChange(bs)) {
-            var changed = data.changed;
-
-            logger.info("{cyan:%s %s changed} ({magenta:%s})",
-                changed.length,
-                changed.length > 1 ? "files" : "file",
-                changed.join(", ")
-            );
-        }
-    },
-    /**
-     * Client connected logging
-     * @param {BrowserSync} bs
-     * @param data
-     */
-    "client:connected": function (bs, data) {
-
-        var uaString = utils.getUaString(data.ua);
-        var msg = "{cyan:Browser Connected: {magenta:%s, version: %s}";
-        var method = "info";
-
-        if (!bs.options.get("logConnections")) {
-            method = "debug";
-        }
-
-        logger.log(method, msg,
-            uaString.name,
-            uaString.version
-        );
-    },
-    /**
-     * Main logging when the service is running
-     * @param {BrowserSync} bs
-     * @param data
-     */
-    "service:running": function (bs, data) {
-
-        var type    = data.type;
-
-        if (type === "server") {
-
-            var baseDir = bs.options.getIn(["server", "baseDir"]);
-
-            logUrls(bs.options.get("urls").toJS());
-
-            if (baseDir) {
-                if (utils.isList(baseDir)) {
-                    baseDir.forEach(serveFiles);
-                } else {
-                    serveFiles(baseDir);
-                }
-            }
-        }
-
-        if (type === "proxy") {
-
-            logger.info("Proxying: {cyan:%s}", bs.options.getIn(["proxy", "target"]));
-            logUrls(bs.options.get("urls").toJS());
-        }
-
-        if (type === "snippet") {
-
-            if (bs.options.get("logSnippet")) {
-
-                logger.info(
-                    "{bold:Copy the following snippet into your website, " +
-                    "just before the closing {cyan:</body>} tag"
-                );
-
-                logger.unprefixed("info",
-                    messages.scriptTags(bs.options)
-                );
-            }
-
-            logUrls(bs.options.get("urls").filter(function (value, key) {
-                return key.slice(0, 2) === "ui";
-            }).toJS());
-        }
-
-        function serveFiles (base) {
-            logger.info("Serving files from: {magenta:%s}", base);
-        }
-    }
-};
-
-/**
- * Plugin interface for BrowserSync
- * @param {EventEmitter} emitter
- * @param {BrowserSync} bs
- * @returns {Object}
- */
-module.exports.plugin = function (emitter, bs) {
-
-    var logPrefix = bs.options.get("logPrefix");
-    var logLevel  = bs.options.get("logLevel");
-
-    // Should set logger level here!
-    logger.setLevel(logLevel);
-
-    if (logPrefix) {
-        if (_.isFunction(logPrefix)) {
-            logger.setPrefix(logPrefix);
-        } else {
-            logger.setPrefix(template.replace("%s", logPrefix));
-        }
-    }
-
-    _.each(exports.callbacks, function (func, event) {
-        emitter.on(event, func.bind(this, bs));
-    });
-
-    return logger;
-};
-
-/**
- *
- * @param urls
- */
-function logUrls (urls) {
-
-    var keys = Object.keys(urls);
-    var longestName = 0;
-    var longesturl  = 0;
-    var offset      = 2;
-
-    if (!keys.length) {
-        return;
-    }
-
-    var names = keys.map(function (key) {
-        if (key.length > longestName) {
-            longestName = key.length;
-        }
-        if (urls[key].length > longesturl) {
-            longesturl = urls[key].length;
-        }
-        return key;
-    });
-
-    var underline  = getChars(longestName + offset + longesturl + 1, "-");
-    var underlined = false;
-
-    logger.info("{bold:Access URLs:");
-    logger.unprefixed("info", "{grey: %s", underline);
-
-    keys.forEach(function (key, i) {
-        var keyname = getKeyName(key);
-        logger.unprefixed("info", " %s: {magenta:%s}",
-            getPadding(key.length, longestName + offset) + keyname,
-            urls[key]
-        );
-        if (!underlined && names[i + 1] && names[i + 1].indexOf("ui") > -1) {
-            underlined = true;
-            logger.unprefixed("info", "{grey: %s}", underline);
-        }
-    });
-
-    logger.unprefixed("info", "{grey: %s}", underline);
-}
-
-/**
- * @param {Number} len
- * @param {Number} max
- * @returns {string}
- */
-function getPadding (len, max) {
-    return new Array(max - (len + 1)).join(" ");
-}
-
-/**
- * @param {Number} len
- * @param {String} char
- * @returns {string}
- */
-function getChars (len, char) {
-    return new Array(len).join(char);
-}
-
-/**
- * Transform url-key names into something more presentable
- * @param key
- * @returns {string}
- */
-function getKeyName(key) {
-    if (key.indexOf("ui") > -1) {
-        if (key === "ui") {
-            return "UI";
-        }
-        if (key === "ui-external") {
-            return "UI External";
-        }
-    }
-    return key.substr(0, 1).toUpperCase() + key.substring(1);
-}
-
-/**
- * Determine if file changes should be logged
- * @param bs
- * @param data
- * @returns {boolean}
- */
-function canLogFileChange(bs, data) {
-    if (data && data.log === false) {
-        return false;
-    }
-
-    return bs.options.get("logFileChanges");
-}
Index: node_modules/browser-sync/lib/templates/connector.tmpl
===================================================================
--- node_modules/browser-sync/lib/templates/connector.tmpl	(revision )
+++ node_modules/browser-sync/lib/templates/connector.tmpl	(revision )
@@ -1,10 +0,0 @@
-window.___browserSync___ = {};
-___browserSync___.io = window.io;
-window.io = window.___browserSync___oldSocketIo;
-window.___browserSync___oldSocketIo=undefined;
-___browserSync___.socketConfig = %config%;
-___browserSync___.url = %url%;
-if (location.protocol == "https:" && /^http:/.test(___browserSync___.url)) {
-    ___browserSync___.url = ___browserSync___.url.replace(/^http:/, "https:");
-}
-___browserSync___.socket = ___browserSync___.io(___browserSync___.url, ___browserSync___.socketConfig);
Index: node_modules/browser-sync/lib/templates/script-tags.tmpl
===================================================================
--- node_modules/browser-sync/lib/templates/script-tags.tmpl	(revision )
+++ node_modules/browser-sync/lib/templates/script-tags.tmpl	(revision )
@@ -1,3 +0,0 @@
-<script id="__bs_script__">//<![CDATA[
-    document.write("<script %async% src='%script%'><\/script>".replace("HOST", location.hostname));
-//]]></script>
Index: node_modules/browser-sync/lib/templates/script-tags-simple.tmpl
===================================================================
--- node_modules/browser-sync/lib/templates/script-tags-simple.tmpl	(revision )
+++ node_modules/browser-sync/lib/templates/script-tags-simple.tmpl	(revision )
@@ -1,1 +0,0 @@
-<script %async% id="__bs_script__" src="%script%"></script>
Index: node_modules/browser-sync/lib/tunnel.js
===================================================================
--- node_modules/browser-sync/lib/tunnel.js	(revision )
+++ node_modules/browser-sync/lib/tunnel.js	(revision )
@@ -1,35 +0,0 @@
-"use strict";
-
-var _ = require("../lodash.custom");
-var utils = require("util");
-
-/**
- * @param {BrowserSync} bs
- * @param {Function} cb
- */
-module.exports = function (bs, cb) {
-
-    var opts         = {};
-    var options      = bs.options;
-    var port         = options.get("port");
-
-    if (_.isString(options.get("tunnel"))) {
-        opts.subdomain = options.get("tunnel");
-    }
-
-    bs.debug("Requesting a tunnel connection on port: {magenta:%s}", port);
-    bs.debug("Requesting a tunnel connection with options: {magenta:%s}", utils.inspect(opts));
-
-    require("localtunnel")(port, opts, function (err, tunnel) {
-        if (err) {
-            return cb(err);
-        }
-
-        tunnel.on("error", function (err) {
-            bs.logger.info("Localtunnel issue: " + err.message);
-            bs.logger.info("Oops! The localtunnel appears to have disconnected. Reconnecting...");
-        });
-
-        return cb(null, tunnel);
-    });
-};
Index: node_modules/browser-sync/lib/options.js
===================================================================
--- node_modules/browser-sync/lib/options.js	(revision )
+++ node_modules/browser-sync/lib/options.js	(revision )
@@ -1,250 +0,0 @@
-"use strict";
-
-var _             = require("../lodash.custom");
-var Immutable     = require("immutable");
-var defaultConfig = require("./default-config");
-
-/**
- * @param {Map} options
- * @returns {Map}
- */
-module.exports.update = function (options) {
-
-    return options.withMutations(function (item) {
-
-        setMode(item);
-        setScheme(item);
-        setStartPath(item);
-        setProxyWs(item);
-        setServerOpts(item);
-        setNamespace(item);
-        fixSnippetOptions(item);
-        fixRewriteRules(item);
-        setMiddleware(item);
-        setOpen(item);
-
-        if (item.get("uiPort")) {
-            item.setIn(["ui", "port"], item.get("uiPort"));
-        }
-    });
-};
-
-/**
- * Move top-level ws options to proxy.ws
- * This is to allow it to be set from the CLI
- * @param item
- */
-function setProxyWs(item) {
-    if (item.get("ws") && item.get("mode") === "proxy") {
-        item.setIn(["proxy", "ws"], true);
-    }
-}
-
-/**
- * @param item
- */
-function setOpen (item) {
-    var open = item.get("open");
-    if (item.get("mode") === "snippet") {
-        if (open !== "ui" && open !== "ui-external") {
-            item.set("open", false);
-        }
-    }
-}
-
-/**
- * Set the running mode
- * @param item
- */
-function setMode (item) {
-    item.set("mode", (function () {
-        if (item.get("server")) {
-            return "server";
-        }
-        if (item.get("proxy")) {
-            return "proxy";
-        }
-        return "snippet";
-    })());
-}
-
-/**
- * @param item
- */
-function setScheme (item) {
-
-    var scheme = "http";
-
-    if (item.getIn(["server", "https"])) {
-        scheme = "https";
-    }
-
-    if (item.get("https")) {
-        scheme = "https";
-    }
-
-    if (item.getIn(["proxy", "url", "protocol"])) {
-        if (item.getIn(["proxy", "url", "protocol"]) === "https:") {
-            scheme = "https";
-        }
-    }
-
-    item.set("scheme", scheme);
-}
-
-/**
- * @param item
- */
-function setStartPath (item) {
-
-    if (item.get("proxy")) {
-        var path = item.getIn(["proxy", "url", "path"]);
-        if (path !== "/") {
-            item.set("startPath", path);
-        }
-    }
-
-}
-
-/**
- * @param item
- */
-function setNamespace(item) {
-    var namespace = item.getIn(["socket", "namespace"]);
-
-    if (_.isFunction(namespace)) {
-        item.setIn(["socket", "namespace"], namespace(defaultConfig.socket.namespace));
-    }
-}
-
-/**
- * @param item
- */
-function setServerOpts(item) {
-
-    if (item.get("server")) {
-
-        var indexarg = item.get("index") || item.getIn(["server", "index"]) || "index.html";
-        var optPath  = ["server", "serveStaticOptions"];
-
-        if (item.get("directory")) {
-            item.setIn(["server", "directory"], true);
-        }
-
-        if (!item.getIn(optPath)) {
-            item.setIn(optPath, Immutable.Map({
-                index: indexarg
-            }));
-        } else {
-            if (!item.hasIn(optPath.concat(["index"]))) {
-                item.setIn(optPath.concat(["index"]), indexarg);
-            }
-        }
-
-        // cli extensions
-        if (item.get("extensions")) {
-            item.setIn(optPath.concat(["extensions"]), item.get("extensions"));
-        }
-    }
-}
-
-/**
- * Back-compat fixes for rewriteRules being set to a boolean
- */
-function fixRewriteRules (item) {
-    return item.update("rewriteRules", function (rr) {
-        return Immutable.List([]).concat(rr).filter(Boolean)
-    });
-}
-
-function fixSnippetOptions (item) {
-
-    var ignorePaths  = item.getIn(["snippetOptions", "ignorePaths"]);
-    var includePaths = item.getIn(["snippetOptions", "whitelist"]);
-
-    if (ignorePaths) {
-        if (_.isString(ignorePaths)) {
-            ignorePaths = [ignorePaths];
-        }
-        ignorePaths = ignorePaths.map(ensureSlash);
-        item.setIn(["snippetOptions", "blacklist"], Immutable.List(ignorePaths));
-    }
-    if (includePaths) {
-        includePaths = includePaths.map(ensureSlash);
-        item.setIn(["snippetOptions", "whitelist"], Immutable.List(includePaths));
-    }
-}
-
-/**
- * Enforce paths to begin with a forward slash
- */
-function ensureSlash (item) {
-    if (item[0] !== "/") {
-        return "/" + item;
-    }
-    return item;
-}
-
-/**
- *
- */
-function setMiddleware (item) {
-
-    var mw = getMiddlwares(item);
-
-    item.set("middleware", mw);
-}
-
-/**
- * top-level option, or given as part of the proxy/server option
- * @param item
- * @returns {*}
- */
-function getMiddlwares (item) {
-
-    var mw       = item.get("middleware");
-    var serverMw = item.getIn(["server", "middleware"]);
-    var proxyMw  = item.getIn(["proxy",  "middleware"]);
-
-    var list     = Immutable.List([]);
-
-    if (mw) {
-        return listMerge(list, mw);
-    }
-
-    if (serverMw) {
-        return listMerge(list, serverMw);
-    }
-
-    if (proxyMw) {
-        return listMerge(list, proxyMw);
-    }
-
-    return list;
-}
-
-/**
- * @param item
- * @returns {*}
- */
-function isList (item) {
-    return Immutable.List.isList(item);
-}
-
-/**
- * @param list
- * @param item
- * @returns {*}
- */
-function listMerge(list, item) {
-
-    if (_.isFunction(item)) {
-        list = list.push(item);
-    }
-
-    if (isList(item) && item.size) {
-        list = list.merge(item);
-    }
-
-    return list;
-}
Index: node_modules/browser-sync/lib/plugins.js
===================================================================
--- node_modules/browser-sync/lib/plugins.js	(revision )
+++ node_modules/browser-sync/lib/plugins.js	(revision )
@@ -1,185 +0,0 @@
-var Immutable  = require("immutable");
-var Map        = Immutable.Map;
-var isMap      = Immutable.Map.isMap;
-var List       = Immutable.List;
-var qs         = require("qs");
-var path       = require("path");
-var fs         = require("fs");
-
-var Plugin = Immutable.Record({
-    moduleName: "",
-    name:       "",
-    active:     true,
-    module:     undefined,
-    options:    Map({}),
-    via:        "inline",
-    dir:        process.cwd(),
-    init:       undefined,
-    errors:     List([])
-});
-
-/**
- * Accept a string/object
- * and resolve it into the plugin format above
- * @param item
- * @returns {*}
- */
-function resolvePlugin(item) {
-
-    /**
-     * Handle when string was given, such as plugins: ['bs-html-injector']
-     */
-    if (typeof item === "string") {
-        return getFromString(item);
-    }
-
-    if (!isMap(item)) {
-        return new Plugin().mergeDeep({errors: [new Error("Plugin not supported in this format")]});
-    }
-
-    if (item.has("module")) {
-
-        var nameOrObj = item.get("module");
-        var options = item.get("options");
-
-        /**
-         * The 'module' key can be a string, this allows
-         * inline plugin references, but with options
-         * eg:
-         *
-         * bs.init({
-         *     plugins: [
-         *         {
-         *             module: './myjs-file.js'
-         *             options: {
-         *                 files: "*.html"
-         *             }
-         *         }
-         *     ]
-         * });
-         */
-        if (typeof nameOrObj === "string") {
-            return getFromString(nameOrObj)
-                .mergeDeep({
-                    options: options
-                });
-        }
-
-        /**
-         * If the plugin was given completely inline (because it needs options)
-         * eg:
-         *
-         * bs.init({
-         *     plugins: [
-         *         {
-         *             module: {
-         *                 plugin: function() {
-         *                     console.log('My plugin code')
-         *                 }
-         *             },
-         *             options: {
-         *                 files: "*.html"
-         *             }
-         *         }
-         *     ]
-         * })
-         */
-        if (Immutable.Map.isMap(nameOrObj)) {
-            return new Plugin({
-                module: nameOrObj,
-                options: options
-            });
-        }
-    }
-
-    /**
-     * If a module was given directly. For example, ater calling require.
-     *
-     * eg:
-     *    var myplugin = require('./some-js');
-     *    bs.init({plugins: [myplugin]});
-     */
-    if (item.has("plugin")) {
-        return new Plugin({
-            module: item
-        })
-    }
-
-    /**
-     * If we reach here, the plugin option was used incorrectly
-     */
-    return new Plugin().mergeDeep({errors: [new Error("Plugin was not configured correctly")]})
-}
-
-module.exports.resolvePlugin = resolvePlugin;
-
-/**
- * Load a plugin from disk
- * @param item
- * @returns {*}
- */
-function requirePlugin (item) {
-
-    /**
-     * if the "module" property already exists and
-     * is not a string, then we bail and don't bother looking
-     * for the file
-     */
-    if (item.get("module") && typeof item.get("module") !== "string") {
-        return item;
-    }
-
-    try {
-        /**
-         * Try a raw node require() call - this will be how
-         * regular "npm installed" plugins wil work
-         */
-        var maybe = path.resolve(process.cwd(), "node_modules", item.get("name"));
-        return item.set("module", require(maybe));
-    } catch (e) {
-        /**
-         * If require threw an MODULE_NOT_FOUND error, try again
-         * by resolving from cwd. This is needed since cli
-         * users will not add ./ to the front of a path (which
-         * node requires to resolve from cwd)
-         */
-        if (e.code === "MODULE_NOT_FOUND") {
-            var maybe = path.resolve(process.cwd(), item.get("name"));
-            if (fs.existsSync(maybe)) {
-                return item.set("module", require(maybe));
-            } else {
-                /**
-                 * Finally return a plugin that contains the error
-                 * this will be picked up later and discarded
-                 */
-                return item.update("errors", function (errors) {
-                    return errors.concat(e);
-                });
-            }
-        }
-        throw e;
-    }
-}
-module.exports.requirePlugin = requirePlugin;
-
-function getFromString(string) {
-
-    /**
-     * We allow query strings for plugins, so always split on ?
-     */
-    var split = string.split("?");
-
-    var outGoing = new Plugin({
-        moduleName: split[0],
-        name: split[0]
-    });
-
-    if (split.length > 1) {
-        return outGoing.update("options", function (opts) {
-            return opts.mergeDeep(qs.parse(split[1]));
-        });
-    }
-
-    return outGoing;
-}
-
Index: node_modules/browser-sync/lib/snippet.js
===================================================================
--- node_modules/browser-sync/lib/snippet.js	(revision )
+++ node_modules/browser-sync/lib/snippet.js	(revision )
@@ -1,106 +0,0 @@
-"use strict";
-
-var connectUtils = require("./connect-utils");
-var config       = require("./config");
-
-var lrSnippet    = require("resp-modifier");
-var path         = require("path");
-var _            = require("../lodash.custom");
-var utils        = require("./utils");
-var fs           = require("fs");
-
-/**
- * Utils for snippet injection
- */
-var snippetUtils = {
-    /**
-     * @param {String} url
-     * @param {Array} excludeList
-     * @returns {boolean}
-     */
-    isExcluded: function (url, excludeList) {
-
-        var extension = path.extname(url);
-
-        if (extension) {
-
-            if (~url.indexOf("?")) {
-                return true;
-            }
-            extension = extension.slice(1);
-            return _.includes(excludeList, extension);
-        }
-        return false;
-    },
-    /**
-     * @param {String} snippet
-     * @param {Object} options
-     * @returns {{match: RegExp, fn: Function}}
-     */
-    getRegex: function (snippet, options) {
-
-        var fn = options.getIn(["rule", "fn"]);
-
-        return {
-            match: options.getIn(["rule", "match"]),
-            fn: function (req, res, match) {
-                return fn.apply(null, [snippet, match]);
-            },
-            once: true,
-            id: "bs-snippet"
-        };
-    },
-    getSnippetMiddleware: function (snippet, options, rewriteRules) {
-        return lrSnippet.create(snippetUtils.getRules(snippet, options, rewriteRules));
-    },
-    getRules: function (snippet, options, rewriteRules) {
-
-        var rules = [snippetUtils.getRegex(snippet, options)];
-
-        if (rewriteRules) {
-            rules = rules.concat(rewriteRules);
-        }
-
-        return {
-            rules: rules,
-            blacklist: utils.arrayify(options.get("blacklist")),
-            whitelist: utils.arrayify(options.get("whitelist"))
-        };
-    },
-    /**
-     * @param {Object} req
-     * @param {Array} [excludeList]
-     * @returns {Object}
-     */
-    isOldIe: function (excludeList) {
-        return function (req, res, next) {
-            var ua = req.headers["user-agent"];
-            var match = /MSIE (\d)\.\d/.exec(ua);
-            if (match) {
-                if (parseInt(match[1], 10) < 9) {
-                    if (!snippetUtils.isExcluded(req.url, excludeList)) {
-                        req.headers["accept"] = "text/html";
-                    }
-                }
-            }
-            next();
-        }
-    },
-    /**
-     * @param {Number} port
-     * @param {BrowserSync.options} options
-     * @returns {String}
-     */
-    getClientJs: function (port, options) {
-        var socket = snippetUtils.getSocketScript();
-        var noConflictJs = "window.___browserSync___oldSocketIo = window.io;";
-        return noConflictJs + socket + ";" + connectUtils.socketConnector(options);
-    },
-    /**
-     * @returns {String}
-     */
-    getSocketScript: function () {
-        return fs.readFileSync(path.join(__dirname, config.socketIoScript), "utf-8");
-    }
-};
-module.exports.utils = snippetUtils;
Index: node_modules/browser-sync/lib/sockets.js
===================================================================
--- node_modules/browser-sync/lib/sockets.js	(revision )
+++ node_modules/browser-sync/lib/sockets.js	(revision )
@@ -1,100 +0,0 @@
-"use strict";
-
-var socket  = require("socket.io");
-var utils   = require("./server/utils");
-var Steward = require("emitter-steward");
-
-/**
- * Plugin interface
- * @returns {*|function(this:exports)}
- */
-module.exports.plugin = function (server, clientEvents, bs) {
-    return exports.init(server, clientEvents, bs);
-};
-
-/**
- * @param {http.Server} server
- * @param clientEvents
- * @param {BrowserSync} bs
- */
-module.exports.init = function (server, clientEvents, bs) {
-
-    var emitter      = bs.events;
-
-    var socketConfig = bs.options
-        .get("socket")
-        .toJS();
-
-    if (bs.options.get("mode") === "proxy" && bs.options.getIn(["proxy", "ws"])) {
-        server = utils.getServer(null, bs.options).server;
-        server.listen(bs.options.getIn(["socket", "port"]));
-        bs.registerCleanupTask(function () {
-            server.close();
-        });
-    }
-
-    var socketIoConfig  = socketConfig.socketIoOptions;
-    socketIoConfig.path = socketConfig.path;
-
-    var io = socket(server, socketIoConfig);
-
-    // Override default namespace.
-    io.sockets = io.of(socketConfig.namespace);
-
-    io.set("heartbeat interval", socketConfig.clients.heartbeatTimeout);
-
-    var steward  = new Steward(emitter);
-    bs.registerCleanupTask(steward.destroy.bind(steward));
-
-    /**
-     * Listen for new connections
-     */
-    io.sockets.on("connection", handleConnection);
-
-    /**
-     * Handle each new connection
-     * @param {Object} client
-     */
-    function handleConnection (client) {
-
-        // set ghostmode callbacks
-        if (bs.options.get("ghostMode")) {
-
-            addGhostMode(client);
-        }
-
-        client.emit("connection", bs.options.toJS()); //todo - trim the amount of options sent to clients
-
-        emitter.emit("client:connected", {
-            ua: client.handshake.headers["user-agent"]
-        });
-    }
-
-    /**
-     * @param {string} event
-     * @param {Socket.client} client
-     * @param {Object} data
-     */
-    function handleClientEvent(event, client, data) {
-
-        if (steward.valid(client.id)) {
-
-            client.broadcast.emit(event, data);
-        }
-    }
-
-    /**
-     * @param client
-     */
-    function addGhostMode (client) {
-
-        clientEvents.forEach(addEvent);
-
-        function addEvent(event) {
-
-            client.on(event, handleClientEvent.bind(null, event, client));
-        }
-    }
-
-    return io;
-};
Index: node_modules/browser-sync/lib/file-utils.js
===================================================================
--- node_modules/browser-sync/lib/file-utils.js	(revision )
+++ node_modules/browser-sync/lib/file-utils.js	(revision )
@@ -1,61 +0,0 @@
-"use strict";
-
-var _         = require("../lodash.custom");
-
-var fileUtils = {
-    /**
-     * React to file-change events that occur on "core" namespace only
-     * @param bs
-     * @param data
-     */
-    changedFile: function (bs, data) {
-        /**
-         * If the event property is undefined, infer that it's a 'change'
-         * event due the fact this handler is for emitter.emit("file:changed")
-         */
-        if (_.isUndefined(data.event)) {
-            data.event = "change";
-        }
-        /**
-         * Chokidar always sends an 'event' property - which could be
-         * `add` `unlink` etc etc so we need to check for that and only
-         * respond to 'change', for now.
-         */
-        if (bs.options.get("watchEvents").indexOf(data.event) > -1) {
-            if (!bs.paused && data.namespace === "core") {
-                bs.events.emit("file:reload", fileUtils.getFileInfo(data, bs.options));
-            }
-        }
-    },
-    /**
-     * @param data
-     * @param options
-     * @returns {{assetFileName: *, fileExtension: String}}
-     */
-    getFileInfo: function (data, options) {
-
-        data.ext      = require("path").extname(data.path).slice(1);
-        data.basename = require("path").basename(data.path);
-
-        var obj = {
-            ext:           data.ext,
-            path:          data.path,
-            basename:      data.basename,
-            event:         data.event,
-            type:          "inject"
-        };
-
-        // RELOAD page
-        if (!_.includes(options.get("injectFileTypes").toJS(), obj.ext)) {
-            obj.url  = obj.path;
-            obj.type = "reload";
-        }
-
-        obj.path = data.path;
-        obj.log  = data.log;
-
-        return obj;
-    }
-};
-
-module.exports = fileUtils;
Index: node_modules/browser-sync/lib/async-tasks.js
===================================================================
--- node_modules/browser-sync/lib/async-tasks.js	(revision )
+++ node_modules/browser-sync/lib/async-tasks.js	(revision )
@@ -1,60 +0,0 @@
-var async           = require("./async");
-
-module.exports = [
-    {
-        step: "Finding an empty port",
-        fn: async.getEmptyPort
-    },
-    {
-        step: "Getting an extra port for Proxy",
-        fn: async.getExtraPortForProxy
-    },
-    {
-        step: "Checking online status",
-        fn: async.getOnlineStatus
-    },
-    {
-        step: "Resolve user plugins from options",
-        fn: async.resolveInlineUserPlugins
-    },
-    {
-        step: "Set Urls and other options that rely on port/online status",
-        fn: async.setOptions
-    },
-    {
-        step: "Setting Internal Events",
-        fn: async.setInternalEvents
-    },
-    {
-        step: "Setting file watchers",
-        fn: async.setFileWatchers
-    },
-    {
-        step: "Merging middlewares from core + plugins",
-        fn: async.mergeMiddlewares
-    },
-    {
-        step: "Starting the Server",
-        fn: async.startServer
-    },
-    {
-        step: "Starting the HTTPS Tunnel",
-        fn: async.startTunnel
-    },
-    {
-        step: "Starting the web-socket server",
-        fn: async.startSockets
-    },
-    {
-        step: "Starting the UI",
-        fn: async.startUi
-    },
-    {
-        step: "Merge UI settings",
-        fn: async.mergeUiSettings
-    },
-    {
-        step: "Init user plugins",
-        fn: async.initUserPlugins
-    }
-];
Index: node_modules/browser-sync/lib/browser-sync.js
===================================================================
--- node_modules/browser-sync/lib/browser-sync.js	(revision )
+++ node_modules/browser-sync/lib/browser-sync.js	(revision )
@@ -1,696 +0,0 @@
-"use strict";
-
-var hooks           = require("./hooks");
-var asyncTasks      = require("./async-tasks");
-var config          = require("./config");
-var connectUtils    = require("./connect-utils");
-var utils           = require("./utils");
-var logger          = require("./logger");
-
-var eachSeries      = utils.eachSeries;
-var _               = require("../lodash.custom");
-var EE              = require("easy-extender");
-
-/**
- * Required internal plugins.
- * Any of these can be overridden by deliberately
- * causing a name-clash.
- */
-var defaultPlugins = {
-    "logger":        logger,
-    "socket":        require("./sockets"),
-    "file:watcher":  require("./file-watcher"),
-    "server":        require("./server"),
-    "tunnel":        require("./tunnel"),
-    "client:script": require("browser-sync-client"),
-    "UI":            require("browser-sync-ui")
-};
-
-/**
- * @constructor
- */
-var BrowserSync = function (emitter) {
-
-    var bs      = this;
-
-    bs.cwd      = process.cwd();
-    bs.active   = false;
-    bs.paused   = false;
-    bs.config   = config;
-    bs.utils    = utils;
-    bs.events   = bs.emitter = emitter;
-
-    bs._userPlugins   = [];
-    bs._reloadQueue   = [];
-    bs._cleanupTasks  = [];
-    bs._browserReload = false;
-
-    // Plugin management
-    bs.pluginManager = new EE(defaultPlugins, hooks);
-};
-
-/**
- * Call a user-options provided callback
- * @param name
- */
-BrowserSync.prototype.callback = function (name) {
-
-    var bs  = this;
-    var cb  = bs.options.getIn(["callbacks", name]);
-
-    if (_.isFunction(cb)) {
-        cb.apply(bs.publicInstance, _.toArray(arguments).slice(1));
-    }
-};
-
-/**
- * @param {Map} options
- * @param {Function} cb
- * @returns {BrowserSync}
- */
-BrowserSync.prototype.init = function (options, cb) {
-
-    /**
-     * Safer access to `this`
-     * @type {BrowserSync}
-     */
-    var bs = this;
-
-    /**
-     * Set user-provided callback, or assign a noop
-     * @type {Function}
-     */
-    bs.cb  = cb || utils.defaultCallback;
-
-    /**
-     * Verify provided config.
-     * Some options are not compatible and will cause us to
-     * end the process.
-     */
-    if (!utils.verifyConfig(options, bs.cb)) {
-        return;
-    }
-
-    /**
-     * Save a reference to the original options
-     * @type {Map}
-     * @private
-     */
-    bs._options = options;
-
-    /**
-     * Set additional options that depend on what the
-     * user may of provided
-     * @type {Map}
-     */
-    bs.options  = require("./options").update(options);
-
-    /**
-     * Kick off default plugins.
-     */
-    bs.pluginManager.init();
-
-    /**
-     * Create a base logger & debugger.
-     */
-    bs.logger   = bs.pluginManager.get("logger")(bs.events, bs);
-    bs.debugger = bs.logger.clone({useLevelPrefixes: true});
-    bs.debug    = bs.debugger.debug;
-
-    /**
-     * Run each setup task in sequence
-     */
-    eachSeries(
-        asyncTasks,
-        taskRunner(bs),
-        tasksComplete(bs)
-    );
-
-    return this;
-};
-
-/**
- * Run 1 setup task.
- * Each task is a pure function.
- * They can return options or instance properties to set,
- * but they cannot set them directly.
- * @param {BrowserSync} bs
- * @returns {Function}
- */
-function taskRunner (bs) {
-
-    return function (item, cb) {
-
-        bs.debug("-> {yellow:Starting Step: " + item.step);
-
-        /**
-         * Execute the current task.
-         */
-        item.fn(bs, executeTask);
-
-        function executeTask(err, out) {
-
-            /**
-             * Exit early if any task returned an error.
-             */
-            if (err) {
-                return cb(err);
-            }
-
-            /**
-             * Act on return values (such as options to be set,
-             * or instance properties to be set
-             */
-            if (out) {
-                handleOut(bs, out);
-            }
-
-            bs.debug("+  {green:Step Complete: " + item.step);
-
-            cb();
-        }
-    };
-}
-
-/**
- * @param bs
- * @param out
- */
-function handleOut (bs, out) {
-    /**
-     * Set a single/many option.
-     */
-    if (out.options) {
-        setOptions(bs, out.options);
-    }
-
-    /**
-     * Any options returned that require path access?
-     */
-    if (out.optionsIn) {
-        out.optionsIn.forEach(function (item) {
-            bs.setOptionIn(item.path, item.value);
-        });
-    }
-
-    /**
-     * Any instance properties returned?
-     */
-    if (out.instance) {
-        Object.keys(out.instance).forEach(function (key) {
-            bs[key] = out.instance[key];
-        });
-    }
-}
-
-/**
- * Update the options Map
- * @param bs
- * @param options
- */
-function setOptions (bs, options) {
-
-    /**
-     * If multiple options were set, act on the immutable map
-     * in an efficient way
-     */
-    if (Object.keys(options).length > 1) {
-        bs.setMany(function (item) {
-            Object.keys(options).forEach(function (key) {
-                item.set(key, options[key]);
-                return item;
-            });
-        });
-    } else {
-        Object.keys(options).forEach(function (key) {
-            bs.setOption(key, options[key]);
-        });
-    }
-}
-
-/**
- * At this point, ALL async tasks have completed
- * @param {BrowserSync} bs
- * @returns {Function}
- */
-function tasksComplete (bs) {
-
-    return function (err) {
-
-        if (err) {
-            bs.logger.setOnce("useLevelPrefixes", true).error(err.message);
-        }
-
-        /**
-         * Set active flag
-         */
-        bs.active = true;
-
-        /**
-         * @deprecated
-         */
-        bs.events.emit("init", bs);
-
-        /**
-         * This is no-longer needed as the Callback now only resolves
-         * when everything (including slow things, like the tunnel) is ready.
-         * It's here purely for backwards compatibility.
-         * @deprecated
-         */
-        bs.events.emit("service:running", {
-            options: bs.options,
-            baseDir: bs.options.getIn(["server", "baseDir"]),
-            type:    bs.options.get("mode"),
-            port:    bs.options.get("port"),
-            url:     bs.options.getIn(["urls", "local"]),
-            urls:    bs.options.get("urls").toJS(),
-            tunnel:  bs.options.getIn(["urls", "tunnel"])
-        });
-
-        /**
-         * Call any option-provided callbacks
-         */
-        bs.callback("ready", null, bs);
-
-        /**
-         * Finally, call the user-provided callback given as last arg
-         */
-        bs.cb(null, bs);
-    };
-}
-
-/**
- * @param module
- * @param opts
- * @param cb
- */
-BrowserSync.prototype.registerPlugin = function (module, opts, cb) {
-
-    var bs = this;
-
-    bs.pluginManager.registerPlugin(module, opts, cb);
-
-    if (module["plugin:name"]) {
-        bs._userPlugins.push(module);
-    }
-};
-
-/**
- * Get a plugin by name
- * @param name
- */
-BrowserSync.prototype.getUserPlugin = function (name) {
-
-    var bs = this;
-
-    var items = bs.getUserPlugins(function (item) {
-        return item["plugin:name"] === name;
-    });
-
-    if (items && items.length) {
-        return items[0];
-    }
-
-    return false;
-};
-
-/**
- * @param {Function} [filter]
- */
-BrowserSync.prototype.getUserPlugins = function (filter) {
-
-    var bs = this;
-
-    filter = filter || function () {
-        return true;
-    };
-
-    /**
-     * Transform Plugins option
-     */
-    bs.userPlugins = bs._userPlugins.filter(filter).map(function (plugin) {
-        return {
-            name: plugin["plugin:name"],
-            active: plugin._enabled,
-            opts: bs.pluginManager.pluginOptions[plugin["plugin:name"]]
-        };
-    });
-
-    return bs.userPlugins;
-};
-
-/**
- * Get middleware
- * @returns {*}
- */
-BrowserSync.prototype.getMiddleware = function (type) {
-
-    var types = {
-        "connector": connectUtils.socketConnector(this.options),
-        "socket-js": require("./snippet").utils.getSocketScript()
-    };
-
-    if (type in types) {
-        return function (req, res) {
-            res.setHeader("Content-Type", "text/javascript");
-            res.end(types[type]);
-        };
-    }
-};
-
-/**
- * Shortcut for pushing a file-serving middleware
- * onto the stack
- * @param {String} path
- * @param {{type: string, content: string}} props
- */
-var _serveFileCount = 0;
-BrowserSync.prototype.serveFile = function (path, props) {
-
-    var bs = this;
-    var mode = bs.options.get("mode");
-    var entry = {
-        handle: function (req, res) {
-            res.setHeader("Content-Type", props.type);
-            res.end(props.content);
-        },
-        id: "Browsersync - " + _serveFileCount++,
-        route: path
-    };
-
-    bs._addMiddlewareToStack(entry);
-};
-
-/**
- * Add middlewares on the fly
- * @param {{route: string, handle: function, id?: string}}
- */
-BrowserSync.prototype._addMiddlewareToStack = function (entry) {
-    var bs = this;
-    if (bs.options.get("mode") === "proxy") {
-        bs.app.stack.splice(bs.app.stack.length-1, 0, entry);
-    } else {
-        bs.app.stack.push(entry);
-    }
-};
-
-var _addMiddlewareCount = 0;
-BrowserSync.prototype.addMiddleware = function (route, handle, opts) {
-
-    var bs   = this;
-
-    if (!bs.app) {
-        return;
-    }
-
-    opts = opts || {};
-
-    if (!opts.id) {
-        opts.id = "bs-mw-" + _addMiddlewareCount++;
-    }
-
-    if (route === "*") {
-        route = "";
-    }
-
-    var entry = {
-        id: opts.id,
-        route: route,
-        handle: handle
-    };
-
-    if (opts.override) {
-        entry.override = true;
-    }
-
-    bs.options = bs.options.update("middleware", function (mw) {
-        if (bs.options.get("mode") === "proxy") {
-            return mw.insert(mw.size-1, entry);
-        }
-        return mw.concat(entry);
-    });
-
-    bs.resetMiddlewareStack();
-};
-
-/**
- * Remove middlewares on the fly
- * @param {String} id
- * @returns {Server}
- */
-BrowserSync.prototype.removeMiddleware = function (id) {
-
-    var bs = this;
-
-    if (!bs.app) {
-        return;
-    }
-
-    bs.options = bs.options.update("middleware", function (mw) {
-        return mw.filter(function (mw) {
-            return mw.id !== id;
-        });
-    });
-
-    bs.resetMiddlewareStack();
-};
-
-/**
- * Middleware for socket connection (external usage)
- * @param opts
- * @returns {*}
- */
-BrowserSync.prototype.getSocketConnector = function (opts) {
-
-    var bs = this;
-
-    return function (req, res) {
-        res.setHeader("Content-Type", "text/javascript");
-        res.end(bs.getExternalSocketConnector(opts));
-    };
-};
-
-/**
- * Socket connector as a string
- * @param {Object} opts
- * @returns {*}
- */
-BrowserSync.prototype.getExternalSocketConnector = function (opts) {
-
-    var bs = this;
-
-    return connectUtils.socketConnector(
-        bs.options.withMutations(function (item) {
-            item.set("socket", item.get("socket").merge(opts));
-            if (!bs.options.getIn(["proxy", "ws"])) {
-                item.set("mode", "snippet");
-            }
-        })
-    );
-};
-
-/**
- * Socket io as string (for embedding)
- * @returns {*}
- */
-BrowserSync.prototype.getSocketIoScript = function () {
-
-    return require("./snippet").utils.getSocketScript();
-};
-
-/**
- * Callback helper
- * @param name
- */
-BrowserSync.prototype.getOption = function (name) {
-
-    this.debug("Getting option: {magenta:%s", name);
-    return this.options.get(name);
-};
-
-/**
- * Callback helper
- * @param path
- */
-BrowserSync.prototype.getOptionIn = function (path) {
-
-    this.debug("Getting option via path: {magenta:%s", path);
-    return this.options.getIn(path);
-};
-
-/**
- * @returns {BrowserSync.options}
- */
-BrowserSync.prototype.getOptions = function () {
-    return this.options;
-};
-
-/**
- * @returns {BrowserSync.options}
- */
-BrowserSync.prototype.getLogger = logger.getLogger;
-
-/**
- * @param {String} name
- * @param {*} value
- * @returns {BrowserSync.options|*}
- */
-BrowserSync.prototype.setOption = function (name, value, opts) {
-
-    var bs = this;
-
-    opts = opts || {};
-
-    bs.debug("Setting Option: {cyan:%s} - {magenta:%s", name, value.toString());
-
-    bs.options = bs.options.set(name, value);
-
-    if (!opts.silent) {
-        bs.events.emit("options:set", {path: name, value: value, options: bs.options});
-    }
-    return this.options;
-};
-
-/**
- * @param path
- * @param value
- * @param opts
- * @returns {Map|*|BrowserSync.options}
- */
-BrowserSync.prototype.setOptionIn = function (path, value, opts) {
-
-    var bs = this;
-
-    opts = opts || {};
-
-    bs.debug("Setting Option: {cyan:%s} - {magenta:%s", path.join("."), value.toString());
-    bs.options = bs.options.setIn(path, value);
-    if (!opts.silent) {
-        bs.events.emit("options:set", {path: path, value: value, options: bs.options});
-    }
-    return bs.options;
-};
-
-/**
- * Set multiple options with mutations
- * @param fn
- * @param opts
- * @returns {Map|*}
- */
-BrowserSync.prototype.setMany = function (fn, opts) {
-
-    var bs = this;
-
-    opts = opts || {};
-
-    bs.debug("Setting multiple Options");
-    bs.options = bs.options.withMutations(fn);
-    if (!opts.silent) {
-        bs.events.emit("options:set", {options: bs.options.toJS()});
-    }
-    return this.options;
-};
-
-BrowserSync.prototype.addRewriteRule = function (rule) {
-    var bs = this;
-
-    bs.options = bs.options.update("rewriteRules", function (rules) {
-        return rules.concat(rule);
-    });
-
-    bs.resetMiddlewareStack();
-};
-
-BrowserSync.prototype.removeRewriteRule = function (id) {
-    var bs = this;
-    bs.options = bs.options.update("rewriteRules", function (rules) {
-        return rules.filter(function (rule) {
-            return rule.id !== id;
-        });
-    });
-
-    bs.resetMiddlewareStack();
-};
-
-BrowserSync.prototype.setRewriteRules = function (rules) {
-    var bs = this;
-    bs.options = bs.options.update("rewriteRules", function (_) {
-        return rules;
-    });
-
-    bs.resetMiddlewareStack();
-};
-
-/**
- * Add a new rewrite rule to the stack
- * @param {Object} rule
- */
-BrowserSync.prototype.resetMiddlewareStack = function () {
-
-    var bs = this;
-    var middlewares = require("./server/utils").getMiddlewares(bs, bs.options);
-
-    bs.app.stack = middlewares;
-};
-
-/**
- * @param fn
- */
-BrowserSync.prototype.registerCleanupTask = function (fn) {
-
-    this._cleanupTasks.push(fn);
-};
-
-/**
- * Instance Cleanup
- */
-BrowserSync.prototype.cleanup = function (cb) {
-
-    var bs = this;
-    if (!bs.active) {
-        return;
-    }
-
-    // Remove all event listeners
-    if (bs.events) {
-        bs.debug("Removing event listeners...");
-        bs.events.removeAllListeners();
-    }
-
-    // Close any core file watchers
-    if (bs.watchers) {
-        Object.keys(bs.watchers).forEach(function (key) {
-            bs.watchers[key].watchers.forEach(function (watcher) {
-                watcher.close();
-            });
-        });
-    }
-
-    // Run any additional clean up tasks
-    bs._cleanupTasks.forEach(function (fn) {
-        if (_.isFunction(fn)) {
-            fn(bs);
-        }
-    });
-
-    // Reset the flag
-    bs.debug("Setting {magenta:active: false");
-    bs.active = false;
-    bs.paused = false;
-
-    bs.pluginManager.plugins        = {};
-    bs.pluginManager.pluginOptions  = {};
-    bs.pluginManager.defaultPlugins = defaultPlugins;
-
-    bs._userPlugins                = [];
-    bs.userPlugins                 = [];
-    bs._reloadTimer                = undefined;
-    bs._reloadQueue                = [];
-    bs._cleanupTasks               = [];
-
-    if (_.isFunction(cb)) {
-        cb(null, bs);
-    }
-};
-
-module.exports = BrowserSync;
Index: node_modules/browser-sync/lib/file-watcher.js
===================================================================
--- node_modules/browser-sync/lib/file-watcher.js	(revision )
+++ node_modules/browser-sync/lib/file-watcher.js	(revision )
@@ -1,86 +0,0 @@
-"use strict";
-
-var _ = require("../lodash.custom");
-var utils = require("./utils");
-var Rx = require("rx");
-
-/**
- * Plugin interface
- * @returns {*|function(this:exports)}
- */
-module.exports.plugin = function (bs) {
-
-    var options = bs.options;
-    var emitter = bs.emitter;
-
-    var defaultWatchOptions = options.get("watchOptions").toJS();
-
-    return options.get("files").reduce(function (map, glob, namespace) {
-
-        /**
-         * Default CB when not given
-         * @param event
-         * @param path
-         */
-        var fn = function (event, path) {
-            emitter.emit("file:changed", {
-                event: event,
-                path: path,
-                namespace: namespace
-            });
-        };
-
-        var jsItem = glob.toJS();
-
-        if (jsItem.globs.length) {
-            var watcher = watch(jsItem.globs, defaultWatchOptions, fn);
-            map[namespace] = {
-                watchers: [watcher]
-            };
-        }
-
-        if (jsItem.objs.length) {
-            jsItem.objs.forEach(function (item) {
-                if (!_.isFunction(item.fn)) {
-                    item.fn = fn;
-                }
-                var watcher = watch(item.match, item.options || defaultWatchOptions, item.fn.bind(bs.publicInstance));
-                if (!map[namespace]) {
-                    map[namespace] = {
-                        watchers: [watcher]
-                    };
-                } else {
-                    map[namespace].watchers.push(watcher);
-                }
-            });
-        }
-
-        return map;
-
-    }, {});
-};
-
-/**
- * @param patterns
- * @param opts
- * @param cb
- * @returns {*}
- */
-function watch (patterns, opts, cb) {
-
-    if (typeof opts === "function") {
-        cb = opts;
-        opts = {};
-    }
-
-    var watcher = require("chokidar")
-        .watch(patterns, opts);
-
-    if (_.isFunction(cb)) {
-        watcher.on("all", cb);
-    }
-
-    return watcher;
-}
-
-module.exports.watch = watch;
Index: node_modules/browser-sync/lib/connect-utils.js
===================================================================
--- node_modules/browser-sync/lib/connect-utils.js	(revision )
+++ node_modules/browser-sync/lib/connect-utils.js	(revision )
@@ -1,245 +0,0 @@
-"use strict";
-
-var _             = require("../lodash.custom");
-var fs            = require("fs");
-var config        = require("./config");
-
-function getPath(options, relative, port) {
-    if (options.get("mode") === "snippet") {
-        return options.get("scheme") + "://HOST:" + port + relative;
-    } else {
-        return "//HOST:" + port + relative;
-    }
-}
-
-var connectUtils = {
-    /**
-     * @param {Immutable.Map} options
-     * @returns {String}
-     */
-    scriptTags: function (options) {
-
-        var scriptPath     = this.clientScript(options);
-        var async          = options.getIn(["snippetOptions", "async"]);
-        var scriptDomain   = options.getIn(["script", "domain"]);
-
-        /**
-         * Generate the [src] attribute based on user options
-         */
-        var scriptSrc = (function () {
-
-            if (options.get("localOnly")) {
-                return [
-                    options.get("scheme"),
-                    "://localhost:",
-                    options.get("port"),
-                    scriptPath
-                ].join("");
-            }
-
-            /**
-             * First, was "scriptPath" set? if so the user wanted full control over the
-             * script tag output
-             *
-             */
-            if (_.isFunction(options.get("scriptPath"))) {
-                return options.get("scriptPath").apply(null, getScriptArgs(options, scriptPath));
-            }
-
-            /**
-             * Next, if "script.domain" was given, allow that + the path to the JS file
-             * eg:
-             *  script.domain=localhost:3000
-             * -> localhost:3000/browser-sync/browser-sync-client.js
-             */
-            if (scriptDomain) {
-                if (_.isFunction(scriptDomain)) {
-                    return scriptDomain.call(null, options) + scriptPath;
-                }
-                if (scriptDomain.match(/\{port\}/)) {
-                    return scriptDomain.replace("{port}", options.get("port")) + scriptPath;
-                }
-                return scriptDomain + scriptPath;
-            }
-
-            /**
-             * Now if server or proxy, use dynamic script
-             * eg:
-             *  browser-sync start --server
-             * ->
-             *  "HOST:3000/browser-sync/browser-sync-client.js".replace("HOST", location.hostname)
-             */
-            if (options.get("server") || options.get("proxy")) {
-                return scriptPath;
-            }
-
-            /**
-             * Final use case is snippet mode
-             * -> "http://HOST:3000/browser-sync/browser-sync-client.js".replace("HOST", location.hostname)
-             * -> "//HOST:3000/browser-sync/browser-sync-client.js".replace("HOST", location.hostname)"
-             */
-            return getPath(options, scriptPath, options.get("port"));
-        })();
-
-        /**
-         * Decide which template shall be used to generate the script tags
-         */
-        var template = (function () {
-            if (scriptDomain || options.get("localOnly")) {
-                return config.templates.scriptTagSimple;
-            }
-            return config.templates.scriptTag;
-        })();
-
-        /**
-         * Finally read the template file from disk and replace
-         * the dynamic values.
-         */
-        return fs.readFileSync(template, "utf8")
-            .replace("%script%", scriptSrc)
-            .replace("%async%", async ? "async" : "");
-    },
-    /**
-     * @param {Map} options
-     * @returns {String}
-     */
-    socketConnector: function (options) {
-
-        var socket        = options.get("socket");
-        var template      = fs.readFileSync(config.templates.connector, "utf-8");
-        var url           = connectUtils.getConnectionUrl(options);
-
-        /**
-         * ***Backwards compatibility***. While `socket.path` is technically a
-         * socketIoClientConfig property, it's been documented previously
-         * as a top-level option, so must stay.
-         */
-        var clientConfig  = socket
-            .get("socketIoClientConfig")
-            .merge({
-                path: socket.get("path")
-            });
-
-        template = template
-            .replace("%config%", JSON.stringify(clientConfig.toJS()))
-            .replace("%url%",  url);
-
-        return template;
-    },
-    /**
-     * @param {Object} socketOpts
-     * @param {Map} options
-     * @returns {String|Function}
-     */
-    getNamespace: function (socketOpts, options) {
-
-        var namespace = socketOpts.namespace;
-
-        if (typeof namespace === "function") {
-            return namespace(options);
-        }
-
-        if (!namespace.match(/^\//)) {
-            namespace = "/" + namespace;
-        }
-
-        return namespace;
-    },
-    /**
-     * @param {Map} options
-     * @returns {string}
-     */
-    getConnectionUrl: function (options) {
-
-        var socketOpts       = options.get("socket").toJS();
-        var namespace        = connectUtils.getNamespace(socketOpts, options);
-
-        var protocol         = "";
-        var withHostnamePort = "'{protocol}' + location.hostname + ':{port}{ns}'";
-        var withHost         = "'{protocol}' + location.host + '{ns}'";
-        var withDomain       = "'{domain}{ns}'";
-        var port             = options.get("port");
-
-        // default use-case is server/proxy
-        var string           = withHost;
-
-        if (options.get("mode") !== "server") {
-            protocol = options.get("scheme") + "://";
-            string   = withHostnamePort;
-        }
-
-        if (options.get("mode") === "proxy" && options.getIn(["proxy", "ws"])) {
-            port = options.getIn(["socket", "port"]);
-        }
-
-        /**
-         * Ensure socket.domain is always a string (for noop replacements later)
-         */
-        socketOpts.domain = (function () {
-            if (options.get("localOnly")) {
-                string = withDomain;
-                return [
-                    options.get("scheme"),
-                    "://localhost:",
-                    options.get("port")
-                ].join("");
-            }
-            if (socketOpts.domain) {
-                string = withDomain;
-                /**
-                 * User provided a function
-                 */
-                if (_.isFunction(socketOpts.domain)) {
-                    return socketOpts.domain.call(null, options);
-                }
-                /**
-                 * User provided a string
-                 */
-                if (_.isString(socketOpts.domain)) {
-                    return socketOpts.domain;
-                }
-            }
-            return "";
-        })();
-
-        return string
-            .replace("{protocol}", protocol)
-            .replace("{port}",     port)
-            .replace("{domain}",   socketOpts.domain.replace("{port}", port))
-            .replace("{ns}",       namespace);
-    },
-    /**
-     * @param {Object} [options]
-     * @param {Boolean} [both]
-     */
-    clientScript: function (options, both) {
-
-        var prefix    = options.getIn(["socket", "clientPath"]);
-        var script    = prefix + "/browser-sync-client.js";
-        var versioned = prefix + "/browser-sync-client.js?v=" + options.get("version");
-
-        if (both) {
-            return {
-                path: script,
-                versioned: versioned
-            };
-        }
-
-        return versioned;
-    }
-};
-
-/**
- * @param options
- * @returns {*[]}
- */
-function getScriptArgs (options, scriptPath) {
-    var abspath = options.get("scheme") + "://HOST:" + options.get("port") + scriptPath;
-    return [
-        scriptPath,
-        options.get("port"),
-        options.set("absolute", abspath)
-    ];
-}
-
-module.exports = connectUtils;
Index: node_modules/browser-sync/lib/http-protocol.js
===================================================================
--- node_modules/browser-sync/lib/http-protocol.js	(revision )
+++ node_modules/browser-sync/lib/http-protocol.js	(revision )
@@ -1,69 +0,0 @@
-"use strict";
-
-var queryString = require("qs");
-var proto = exports;
-
-/**
- * Use BrowserSync options + querystring to create a
- * full HTTP/HTTTPS url.
- *
- * Eg. http://localhost:3000/__browser_sync__?method=reload
- * Eg. http://localhost:3000/__browser_sync__?method=reload&args=core.css
- * Eg. http://localhost:3000/__browser_sync__?method=reload&args=core.css&args=core.min
- *
- * @param args
- * @param url
- * @returns {string}
- */
-proto.getUrl = function (args, url) {
-    return [
-        url,
-        require("./config").httpProtocol.path,
-        "?",
-        queryString.stringify(args)
-    ].join("");
-};
-
-/**
- * Return a middleware for handling the requests
- * @param {BrowserSync} bs
- * @returns {Function}
- */
-proto.middleware = function (bs) {
-
-    return function (req, res) {
-
-        var params = queryString.parse(req.url.replace(/^.*\?/, ""));
-        var output;
-
-        if (!Object.keys(params).length) {
-            output = [
-                "Error: No Parameters were provided.",
-                "Example: http://localhost:3000/__browser_sync__?method=reload&args=core.css"
-            ];
-            res.writeHead(500, {"Content-Type": "text/plain"});
-            res.end(output.join("\n"));
-            return;
-        }
-
-        try {
-
-            require("./public/" + params.method)(bs.events).apply(null, [params.args]);
-
-            output = [
-                "Called public API method `.%s()`".replace("%s", params.method),
-                "With args: " + JSON.stringify(params.args)
-            ];
-
-            res.end(output.join("\n"));
-
-        } catch (e) {
-
-            res.writeHead(404, {"Content-Type": "text/plain"});
-            res.write("Public API method `" + params.method + "` not found.");
-            res.end();
-
-            return;
-        }
-    };
-};
Index: node_modules/browser-sync/lib/default-config.js
===================================================================
--- node_modules/browser-sync/lib/default-config.js	(revision )
+++ node_modules/browser-sync/lib/default-config.js	(revision )
@@ -1,546 +0,0 @@
-"use strict";
-/**
- * @module BrowserSync.options
- */
-module.exports = {
-
-    /**
-     * Browsersync includes a user-interface that is accessed via a separate port.
-     * The UI allows to controls all devices, push sync updates and much more.
-     * @property ui
-     * @type Object
-     * @param {Number} [port=3001]
-     * @param {Number} [weinre.port=8080]
-     * @since 2.0.0
-     * @default false
-     */
-    ui: {
-        port: 3001,
-        weinre: {
-            port: 8080
-        }
-    },
-
-    /**
-     * Browsersync can watch your files as you work. Changes you make will either
-     * be injected into the page (CSS & images) or will cause all browsers to do
-     * a full-page refresh.
-     * @property files
-     * @type Array|String
-     * @default false
-     */
-    files: false,
-
-    /**
-     * Specify which file events to respond to.
-     * Available events: `add`, `change`, `unlink`, `addDir`, `unlinkDir`
-     * @property watchEvents
-     * @type Array
-     * @default ["change"]
-     * @since 2.18.8
-     */
-    watchEvents: ["change"],
-
-    /**
-     * File watching options that get passed along to [Chokidar](https://github.com/paulmillr/chokidar).
-     * Check their docs for available options
-     * @property watchOptions
-     * @type Object
-     * @default undefined
-     * @since 2.6.0
-     */
-    watchOptions: {
-        ignoreInitial: true
-        /*
-         persistent: true,
-
-         ignored: '*.txt',
-         followSymlinks: true,
-         cwd: '.',
-
-         usePolling: true,
-         alwaysStat: false,
-         depth: undefined,
-         interval: 100,
-
-         ignorePermissionErrors: false,
-         atomic: true
-         */
-    },
-
-    /**
-     * Use the built-in static server for basic HTML/JS/CSS websites.
-     * @property server
-     * @type Object|Boolean
-     * @default false
-     */
-    server: false,
-
-    /**
-     * Proxy an EXISTING vhost. Browsersync will wrap your vhost with a proxy URL to view your site.
-     * @property proxy
-     * @type String|Object|Boolean
-     * @param {String} [target]
-     * @param {Boolean} [ws] - Enable websocket proxying
-     * @param {Function|Array} [middleware]
-     * @param {Function} [reqHeaders]
-     * @param {Array} [proxyReq]
-     * @param {Array} [proxyRes]
-     * @default false
-     */
-    proxy: false,
-
-    /**
-     * @property port
-     * @type Number
-     * @default 3000
-     */
-    port: 3000,
-
-    /**
-     * @property middleware
-     * @type Function|Array
-     * @default false
-     */
-    middleware: false,
-
-    /**
-     * Add additional directories from which static
-     * files should be served. Should only be used in `proxy` or `snippet`
-     * mode.
-     * @property serveStatic
-     * @type Array
-     * @default []
-     * @since 2.8.0
-     */
-    serveStatic: [],
-
-    /**
-     * Options that are passed to the serve-static middleware
-     * when you use the string[] syntax: eg: `serveStatic: ['./app']`. Please see
-     * [serve-static](https://github.com/expressjs/serve-static) for details
-     *
-     * @property serveStaticOptions
-     * @type Object
-     * @since 2.17.0
-     */
-
-    /**
-     * Enable https for localhost development. **Note** - this is not needed for proxy
-     * option as it will be inferred from your target url.
-     * @property https
-     * @type Boolean
-     * @default undefined
-     * @since 1.3.0
-     */
-
-    /**
-     * Override http module to allow using 3rd party server modules (such as http2)
-     * @property httpModule
-     * @type string
-     * @default undefined
-     * @since 2.18.0
-     */
-
-    /**
-     * Clicks, Scrolls & Form inputs on any device will be mirrored to all others.
-     * @property ghostMode
-     * @param {Boolean} [clicks=true]
-     * @param {Boolean} [scroll=true]
-     * @param {Boolean} [location=true]
-     * @param {Boolean} [forms=true]
-     * @param {Boolean} [forms.submit=true]
-     * @param {Boolean} [forms.inputs=true]
-     * @param {Boolean} [forms.toggles=true]
-     * @type Object
-     */
-    ghostMode: {
-        clicks: true,
-        scroll: true,
-        location: true,
-        forms: {
-            submit: true,
-            inputs: true,
-            toggles: true
-        }
-    },
-
-    /**
-     * Can be either "info", "debug", "warn", or "silent"
-     * @property logLevel
-     * @type String
-     * @default info
-     */
-    logLevel: "info",
-
-    /**
-     * Change the console logging prefix. Useful if you're creating your
-     * own project based on Browsersync
-     * @property logPrefix
-     * @type String
-     * @default Browsersync
-     * @since 1.5.1
-     */
-    logPrefix: "Browsersync",
-
-    /**
-     * @property logConnections
-     * @type Boolean
-     * @default false
-     */
-    logConnections: false,
-
-    /**
-     * @property logFileChanges
-     * @type Boolean
-     * @default true
-     */
-    logFileChanges: true,
-
-    /**
-     * Log the snippet to the console when you're in snippet mode (no proxy/server)
-     * @property logSnippet
-     * @type: Boolean
-     * @default true
-     * @since 1.5.2
-     */
-    logSnippet: true,
-
-    /**
-     * You can control how the snippet is injected
-     * onto each page via a custom regex + function.
-     * You can also provide patterns for certain urls
-     * that should be ignored from the snippet injection.
-     * @property snippetOptions
-     * @since 2.0.0
-     * @param {Boolean} [async] - should the script tags have the async attribute?
-     * @param {Array} [blacklist]
-     * @param {Array} [whitelist]
-     * @param {RegExp} [rule.match=/$/]
-     * @param {Function} [rule.fn=Function]
-     * @type Object
-     */
-    snippetOptions: {
-        async: true,
-        whitelist: [],
-        blacklist: [],
-        rule: {
-            match: /<body[^>]*>/i,
-            fn: function (snippet, match) {
-                return match + snippet;
-            }
-        }
-    },
-
-    /**
-     * Add additional HTML rewriting rules.
-     * @property rewriteRules
-     * @since 2.4.0
-     * @type Array
-     * @default false
-     */
-    rewriteRules: [],
-
-    /**
-     * @property tunnel
-     * @type String|Boolean
-     * @default null
-     */
-
-    /**
-     * Some features of Browsersync (such as `xip` & `tunnel`) require an internet connection, but if you're
-     * working offline, you can reduce start-up time by setting this option to `false`
-     * @property online
-     * @type Boolean
-     * @default undefined
-     */
-
-    /**
-     * Decide which URL to open automatically when Browsersync starts. Defaults to "local" if none set.
-     * Can be `true`, `local`, `external`, `ui`, `ui-external`, `tunnel` or `false`
-     * @property open
-     * @type Boolean|String
-     * @default true
-     */
-    open: "local",
-
-    /**
-     * @property browser
-     * @type String|Array
-     * @default default
-     */
-    browser: "default",
-
-    /**
-     * Add HTTP access control (CORS) headers to assets served by Browsersync.
-     * @property cors
-     * @type boolean
-     * @default false
-     * @since 2.16.0
-     */
-    cors: false,
-
-    /**
-     * Requires an internet connection - useful for services such as [Typekit](https://typekit.com/)
-     * as it allows you to configure domains such as `*.xip.io` in your kit settings
-     * @property xip
-     * @type Boolean
-     * @default false
-     */
-    xip: false,
-
-    hostnameSuffix: false,
-
-    /**
-     * Reload each browser when Browsersync is restarted.
-     * @property reloadOnRestart
-     * @type Boolean
-     * @default false
-     */
-    reloadOnRestart: false,
-
-    /**
-     * The small pop-over notifications in the browser are not always needed/wanted.
-     * @property notify
-     * @type Boolean
-     * @default true
-     */
-    notify: true,
-
-    /**
-     * @property scrollProportionally
-     * @type Boolean
-     * @default true
-     */
-    scrollProportionally: true,
-
-    /**
-     * @property scrollThrottle
-     * @type Number
-     * @default 0
-     */
-    scrollThrottle: 0,
-
-    /**
-     * Decide which technique should be used to restore
-     * scroll position following a reload.
-     * Can be `window.name` or `cookie`
-     * @property scrollRestoreTechnique
-     * @type String
-     * @default 'window.name'
-     */
-    scrollRestoreTechnique: "window.name",
-
-    /**
-     * Sync the scroll position of any element
-     * on the page. Add any amount of CSS selectors
-     * @property scrollElements
-     * @type Array
-     * @default []
-     * @since 2.9.0
-     */
-    scrollElements: [],
-
-    /**
-     * Sync the scroll position of any element
-     * on the page - where any scrolled element
-     * will cause all others to match scroll position.
-     * This is helpful when a breakpoint alters which element
-     * is actually scrolling
-     * @property scrollElementMapping
-     * @type Array
-     * @default []
-     * @since 2.9.0
-     */
-    scrollElementMapping: [],
-
-    /**
-     * Time, in milliseconds, to wait before
-     * instructing the browser to reload/inject following a
-     * file change event
-     * @property reloadDelay
-     * @type Number
-     * @default 0
-     */
-    reloadDelay: 0,
-
-    /**
-     * Wait for a specified window of event-silence before
-     * sending any reload events.
-     * @property reloadDebounce
-     * @type Number
-     * @default 0
-     * @since 2.6.0
-     */
-    reloadDebounce: 0,
-
-    /**
-     * Emit only the first event during sequential time windows
-     * of a specified duration.
-     * @property reloadThrottle
-     * @type Number
-     * @default 0
-     * @since 2.13.0
-     */
-    reloadThrottle: 0,
-
-    /**
-     * User provided plugins
-     * @property plugins
-     * @type Array
-     * @default []
-     * @since 2.6.0
-     */
-    plugins: [],
-
-    /**
-     * @property injectChanges
-     * @type Boolean
-     * @default true
-     */
-    injectChanges: true,
-
-    /**
-     * @property startPath
-     * @type String|Null
-     * @default null
-     */
-    startPath: null,
-
-    /**
-     * Whether to minify client script, or not.
-     * @property minify
-     * @type Boolean
-     * @default true
-     */
-    minify: true,
-
-    /**
-     * @property host
-     * @type String
-     * @default null
-     */
-    host: null,
-
-    /**
-     * Support environments where dynamic hostnames are not required
-     * (ie: electron)
-     * @property localOnly
-     * @type Boolean
-     * @default false
-     * @since 2.14.0
-     */
-    localOnly: false,
-
-    /**
-     * @property codeSync
-     * @type Boolean
-     * @default true
-     */
-    codeSync: true,
-
-    /**
-     * @property timestamps
-     * @type Boolean
-     * @default true
-     */
-    timestamps: true,
-
-    clientEvents: [
-        "scroll",
-        "scroll:element",
-        "input:text",
-        "input:toggles",
-        "form:submit",
-        "form:reset",
-        "click"
-    ],
-
-    /**
-     * Alter the script path for complete control over where the Browsersync
-     * Javascript is served from. Whatever you return from this function
-     * will be used as the script path.
-     * @property scriptPath
-     * @default undefined
-     * @since 1.5.0
-     * @type Function
-     */
-
-    /**
-     * Configure the Socket.IO path and namespace & domain to avoid collisions.
-     * @property socket
-     * @param {String} [path="/browser-sync/socket.io"]
-     * @param {String} [clientPath="/browser-sync"]
-     * @param {String|Function} [namespace="/browser-sync"]
-     * @param {String|Function} [domain=undefined]
-     * @param {String|Function} [port=undefined]
-     * @param {Object} [clients.heartbeatTimeout=5000]
-     * @since 1.6.2
-     * @type Object
-     */
-    socket: {
-        socketIoOptions: {
-            log: false
-        },
-        socketIoClientConfig: {
-            reconnectionAttempts: 50
-        },
-        path: "/browser-sync/socket.io",
-        clientPath: "/browser-sync",
-        namespace: "/browser-sync",
-        clients: {
-            heartbeatTimeout: 5000
-        }
-    },
-
-    /**
-     * Configure the script domain
-     * @property script
-     * @param {String|Function} [domain=undefined]
-     * @since 2.14.0
-     * @type Object
-     */
-
-    tagNames: {
-        "less": "link",
-        "scss": "link",
-        "css":  "link",
-        "jpg":  "img",
-        "jpeg": "img",
-        "png":  "img",
-        "svg":  "img",
-        "gif":  "img",
-        "js":   "script"
-    },
-
-    injectFileTypes: ["css", "png", "jpg", "jpeg", "svg", "gif", "webp", "map"],
-    excludedFileTypes: [
-        "js",
-        "css",
-        "pdf",
-        "map",
-        "svg",
-        "ico",
-        "woff",
-        "json",
-        "eot",
-        "ttf",
-        "png",
-        "jpg",
-        "jpeg",
-        "webp",
-        "gif",
-        "mp4",
-        "mp3",
-        "3gp",
-        "ogg",
-        "ogv",
-        "webm",
-        "m4a",
-        "flv",
-        "wmv",
-        "avi",
-        "swf",
-        "scss"
-    ]
-};
Index: node_modules/browser-sync/lib/internal-events.js
===================================================================
--- node_modules/browser-sync/lib/internal-events.js	(revision )
+++ node_modules/browser-sync/lib/internal-events.js	(revision )
@@ -1,110 +0,0 @@
-"use strict";
-
-var utils     = require("./utils");
-var fileUtils = require("./file-utils");
-var Rx        = require("rx");
-var fromEvent = Rx.Observable.fromEvent;
-var fileHandler = require("./file-event-handler");
-
-module.exports = function (bs) {
-
-    var events = {
-        /**
-         * File reloads
-         * @param data
-         */
-        "file:reload": function (data) {
-            bs.io.sockets.emit("file:reload", data);
-        },
-        /**
-         * Browser Reloads
-         */
-        "browser:reload": function () {
-            bs.io.sockets.emit("browser:reload");
-        },
-        /**
-         * Browser Notify
-         * @param data
-         */
-        "browser:notify": function (data) {
-            bs.io.sockets.emit("browser:notify", data);
-        },
-        /**
-         * Things that happened after the service is running
-         * @param data
-         */
-        "service:running": function (data) {
-
-            var mode = bs.options.get("mode");
-            var open = bs.options.get("open");
-
-            if (mode === "proxy" || mode === "server" || open === "ui" || open === "ui-external") {
-                utils.openBrowser(data.url, bs.options, bs);
-            }
-
-            // log about any file watching
-            if (bs.watchers) {
-                bs.events.emit("file:watching", bs.watchers);
-            }
-        },
-        /**
-         * Option setting
-         * @param data
-         */
-        "options:set": function (data) {
-            if (bs.io) {
-                bs.io.sockets.emit("options:set", data);
-            }
-        },
-        /**
-         * Plugin configuration setting
-         * @param data
-         */
-        "plugins:configure": function (data) {
-            if (data.active) {
-                bs.pluginManager.enablePlugin(data.name);
-            } else {
-                bs.pluginManager.disablePlugin(data.name);
-            }
-            bs.setOption("userPlugins", bs.getUserPlugins());
-        },
-        "plugins:opts": function (data) {
-            if (bs.pluginManager.pluginOptions[data.name]) {
-                bs.pluginManager.pluginOptions[data.name] = data.opts;
-                bs.setOption("userPlugins", bs.getUserPlugins());
-            }
-        }
-    };
-
-    Object.keys(events).forEach(function (event) {
-        bs.events.on(event, events[event]);
-    });
-
-    var reloader = fileHandler.applyReloadOperators(fromEvent(bs.events, "_browser:reload"), bs.options)
-        .subscribe(function() {
-            bs.events.emit("browser:reload");
-        });
-
-    var coreNamespacedWatchers = fromEvent(bs.events, "file:changed")
-        .filter(function() { return bs.options.get("codeSync") })
-        .filter(function(x) { return  x.namespace === "core" });
-
-    var handler = fileHandler.fileChanges(coreNamespacedWatchers, bs.options)
-        .subscribe(function (x) {
-            if (x.type === "reload") {
-                bs.events.emit("browser:reload");
-            }
-            if (x.type === "inject") {
-                x.files.forEach(function(data) {
-                    if (!bs.paused && data.namespace === "core") {
-                        bs.events.emit("file:reload", fileUtils.getFileInfo(data, bs.options));
-                    }
-                });
-            }
-        });
-
-    bs.registerCleanupTask(function() {
-        handler.dispose();
-        reloader.dispose();
-    });
-};
Index: node_modules/browser-sync/lib/file-event-handler.js
===================================================================
--- node_modules/browser-sync/lib/file-event-handler.js	(revision )
+++ node_modules/browser-sync/lib/file-event-handler.js	(revision )
@@ -1,120 +0,0 @@
-var utils = require("./utils");
-
-/**
- * Apply the operators that apply to the 'file:changed' event
- * @param {Rx.Observable} subject
- * @param options
- * @return {Rx.Observable<{type: string, files: Array<any>}>}
- */
-function fileChanges(subject, options) {
-    var operators = [
-        {
-            option: "reloadThrottle",
-            fnName: "throttle"
-        },
-        {
-            option: "reloadDelay",
-            fnName: "delay"
-        }
-    ];
-
-    var scheduler = options.getIn(["debug", "scheduler"]);
-
-    /**
-     * if the 'reloadDebounce' option was provided, create
-     * a stream buffered/debounced stream of events
-     */
-    var initial = (function() {
-        if (options.get("reloadDebounce") > 0) {
-            return getAggregatedDebouncedStream(subject, options, scheduler);
-        }
-        return subject;
-    })();
-
-    return applyOperators(operators, initial, options, scheduler)
-        .map(function(xs) {
-
-            var items = [].concat(xs);
-            var paths = items.map(function (x) { return x.path });
-
-            if (utils.willCauseReload(paths, options.get("injectFileTypes").toJS())) {
-                return {
-                    type: "reload",
-                    files: items
-                }
-            }
-            return {
-                type: "inject",
-                files: items
-            }
-        });
-}
-module.exports.fileChanges = fileChanges;
-
-/**
- * Apply the operators that apply to the 'browser:reload' event
- * @param {Rx.Observable} subject
- * @param options
- * @returns {Rx.Observable}
- */
-function applyReloadOperators (subject, options) {
-    var operators = [
-        {
-            option: "reloadDebounce",
-            fnName: "debounce"
-        },
-        {
-            option: "reloadThrottle",
-            fnName: "throttle"
-        },
-        {
-            option: "reloadDelay",
-            fnName: "delay"
-        }
-    ];
-
-    return applyOperators(operators, subject, options, options.getIn(["debug", "scheduler"]));
-}
-module.exports.applyReloadOperators = applyReloadOperators;
-
-/**
- * @param items
- * @param subject
- * @param options
- * @param scheduler
- */
-function applyOperators (items, subject, options, scheduler) {
-    return items.reduce(function(subject, item) {
-        var value = options.get(item.option);
-        if (value > 0) {
-            return subject[item.fnName].call(subject, value, scheduler);
-        }
-        return subject;
-    }, subject);
-}
-
-/**
- * @param subject
- * @param options
- * @param scheduler
- */
-function getAggregatedDebouncedStream (subject, options, scheduler) {
-    return subject
-        .filter(function(x) { return options.get("watchEvents").indexOf(x.event) > -1 })
-        .buffer(subject.debounce(options.get("reloadDebounce"), scheduler))
-        .map(function(buffered) {
-            return buffered.reduce(function (acc, item) {
-                if (!acc[item.path]) acc[item.path] = item;
-                if (acc[item.path]) acc[item.path] = item;
-                return acc;
-            }, {});
-        })
-        .map(function(group) {
-            return Object
-                .keys(group)
-                .map(function(key) {
-                    return group[key];
-                });
-        })
-        .filter(function (x) { return x.length })
-}
Index: node_modules/browser-sync/LICENSE
===================================================================
--- node_modules/browser-sync/LICENSE	(revision )
+++ node_modules/browser-sync/LICENSE	(revision )
@@ -1,202 +0,0 @@
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [2015] [Shane Osbourne]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
Index: node_modules/browser-sync/index.js
===================================================================
--- node_modules/browser-sync/index.js	(revision )
+++ node_modules/browser-sync/index.js	(revision )
@@ -1,376 +0,0 @@
-#! /usr/bin/env node
-"use strict";
-
-/**
- * @module BrowserSync
- */
-var pjson         = require("./package.json");
-var BrowserSync   = require("./lib/browser-sync");
-var publicUtils   = require("./lib/public/public-utils");
-var events        = require("events");
-var PassThrough   = require("stream").PassThrough;
-var logger        = require("eazy-logger").Logger({
-    useLevelPrefixes: true
-});
-
-var singleton        = false;
-var singletonPlugins = [];
-var instances        = [];
-
-/**
- * @type {boolean|EventEmitter}
- */
-var singletonEmitter = false;
-
-module.exports         = initSingleton;
-
-/**
- * Create a Browsersync instance
- * @method create
- * @param {String} name an identifier that can used for retrieval later
- */
-module.exports.create    = create;
-
-/**
- * Get a single instance by name. This is useful if you have your
- * build scripts in separate files
- * @method get
- * @param {String} name
- * @returns {Object|Boolean}
- */
-module.exports.get = function (name) {
-    var instance = getSingle(name);
-    if (instance) {
-        return instance;
-    }
-    throw new Error("An instance with the name `%s` was not found.".replace("%s", name));
-};
-
-/**
- * Check if an instance has been created.
- * @method has
- * @param {String} name
- * @returns {Boolean}
- */
-module.exports.has = function (name) {
-    var instance = getSingle(name);
-    if (instance) {
-        return true;
-    }
-    return false;
-};
-
-/**
- * Start the Browsersync service. This will launch a server, proxy or start the snippet
- * mode depending on your use-case.
- * @method init
- * @param {Object} [config] This is the main configuration for your Browsersync instance and can contain any of the [available options]({{site.links.options}})
- *  If you do not pass a config an argument for configuration, Browsersync will still run; but it will be in the `snippet` mode
- * @param {Function} [cb] If you pass a callback function, it will be called when Browsersync has completed all setup tasks and is ready to use. This
- * is useful when you need to wait for information (for example: urls, port etc) or perform other tasks synchronously.
- * @returns {BrowserSync}
- */
-module.exports.init    = initSingleton;
-
-/**
- * Register a plugin. Must implement at least a 'plugin' method that returns a
- * callable function.
- *
- * @method use
- * @param {String} name The name of the plugin
- * @param {Object} module The object to be `required`.
- * @param {Function} [cb] A callback function that will return any errors.
- */
-module.exports.use     = function () {
-    var args = Array.prototype.slice.call(arguments);
-    singletonPlugins.push({
-        args: args
-    });
-};
-
-/**
- * The `reload` method will inform all browsers about changed files and will either cause the browser to refresh, or inject the files where possible.
- *
- * @method reload
- * @param {String|Array|Object} [arg] The file or files to be reloaded.
- * @returns {*}
- */
-module.exports.reload  = noop("reload");
-
-/**
- * The `stream` method returns a transform stream and can act once or on many files.
- *
- * @method stream
- * @param {Object} [opts] Configuration for the stream method
- * @param {Object} [opts.match] Resulting files to reload. The path is from the
- * root of the site (not the root of your project).  You can use '**' to recurse
- * directories.
- * @param {Object} [opts.once] Only reload on the first changed file in teh stream.
- * @since 2.6.0
- * @returns {*}
- */
-module.exports.stream  = noop("stream");
-
-/**
- * Helper method for browser notifications
- *
- * @method notify
- * @param {String|HTML} msg Can be a simple message such as 'Connected' or HTML
- * @param {Number} [timeout] How long the message will remain in the browser. @since 1.3.0
- */
-module.exports.notify  = noop("notify");
-
-/**
- * This method will close any running server, stop file watching & exit the current process.
- *
- * @method exit
- */
-module.exports.exit    = noop("exit");
-
-/**
- * Stand alone file-watcher. Use this along with Browsersync to create your own, minimal build system
- * @method watch
- * @param {string} patterns Glob patterns for files to watch
- * @param {object} [opts] Options to be passed to Chokidar - check what's available in [their docs](https://github.com/paulmillr/chokidar#getting-started)
- * @param {function} [fn] Callback function for each event.
- * @since 2.6.0
- */
-module.exports.watch   = noop("watch");
-
-/**
- * Method to pause file change events
- *
- * @method pause
- */
-module.exports.pause   = noop("pause");
-
-/**
- * Method to resume paused watchers
- *
- * @method resume
- */
-module.exports.resume  = noop("resume");
-
-/**
- * Add properties fo
- */
-Object.defineProperties(module.exports, {
-    /**
-     * The internal Event Emitter used by the running Browsersync instance (if there is one).
-     * You can use this to emit your own events, such as changed files, logging etc.
-     *
-     * @property emitter
-     */
-    "emitter": {
-        get: function () {
-            if (!singletonEmitter) {
-                singletonEmitter = newEmitter();
-                return singletonEmitter;
-            }
-            return singletonEmitter;
-        }
-    },
-    /**
-     * A simple true/false flag that you can use to determine if there's a currently-running Browsersync instance.
-     *
-     * @property active
-     */
-    "active": {
-        get: getSingletonValue.bind(null, "active")
-    },
-    /**
-     * A simple true/false flag to determine if the current instance is paused
-     *
-     * @property paused
-     */
-    "paused": {
-        get: getSingletonValue.bind(null, "paused")
-    }
-});
-
-/**
- * Event emitter factory
- * @returns {EventEmitter}
- */
-function newEmitter() {
-    var emitter = new events.EventEmitter();
-    emitter.setMaxListeners(20);
-    return emitter;
-}
-
-/**
- * Get the singleton's emitter, or a new one.
- * @returns {EventEmitter}
- */
-function getSingletonEmitter() {
-    if (singletonEmitter) {
-        return singletonEmitter;
-    }
-    singletonEmitter = newEmitter();
-    return singletonEmitter;
-}
-
-/**
- * Helper to allow methods to be called on the module export
- * before there's a running instance
- * @param {String} name
- * @returns {Function}
- */
-function noop(name) {
-    return function () {
-        var args = Array.prototype.slice.call(arguments);
-        if (singleton) {
-            return singleton[name].apply(singleton, args);
-        } else {
-            if (publicUtils.isStreamArg(name, args)) {
-                return new PassThrough({objectMode: true});
-            }
-        }
-    };
-}
-
-/**
- * Create a single instance when module export is used directly via browserSync({});
- * This is mostly for back-compatibility, for also for the nicer api.
- * This will never be removed to ensure we never break user-land, but
- * we should discourage it's use.
- * @returns {*}
- */
-function initSingleton() {
-    var instance;
-    if (instances.length) {
-        instance = instances.filter(function (item) {
-            return item.name === "singleton";
-        });
-        if (instance.length) {
-            logger.error("{yellow:You tried to start Browsersync twice!} To create multiple instances, use {cyan:browserSync.create().init()");
-            return instance;
-        }
-    }
-    var args = Array.prototype.slice.call(arguments);
-    singleton = create("singleton", getSingletonEmitter());
-
-    if (singletonPlugins.length) {
-        singletonPlugins.forEach(function (obj) {
-            singleton.instance.registerPlugin.apply(singleton.instance, obj.args);
-        });
-    }
-
-    singleton.init.apply(null, args);
-    return singleton;
-}
-
-/**
- * @param {String} prop
- * @returns {Object|Boolean}
- */
-function getSingletonValue(prop) {
-    var single = getSingle("singleton");
-    if (single) {
-        return single[prop];
-    }
-    return false;
-}
-
-/**
- * Get a single instance by name
- * @param {String} name
- * @returns {Object|Boolean}
- */
-function getSingle(name) {
-    if (instances.length) {
-        var match = instances.filter(function (item) {
-            return item.name === name;
-        });
-        if (match.length) {
-            return match[0];
-        }
-    }
-    return false;
-}
-
-/**
- * Create an instance of Browsersync
- * @param {String} [name]
- * @param {EventEmitter} [emitter]
- * @returns {{init: *, exit: (exit|exports), notify: *, reload: *, cleanup: *, emitter: (Browsersync.events|*), use: *}}
- */
-function create(name, emitter) {
-
-    name    = name    || new Date().getTime();
-    emitter = emitter || newEmitter();
-
-    var browserSync = new BrowserSync(emitter);
-
-    var instance = {
-        name:      name,
-        instance:  browserSync,
-        exit:      require("./lib/public/exit")(browserSync),
-        notify:    require("./lib/public/notify")(browserSync),
-        pause:     require("./lib/public/pause")(browserSync),
-        resume:    require("./lib/public/resume")(browserSync),
-        reload:    require("./lib/public/reload")(emitter),
-        stream:    require("./lib/public/stream")(emitter),
-        cleanup:   browserSync.cleanup.bind(browserSync),
-        use:       browserSync.registerPlugin.bind(browserSync),
-        getOption: browserSync.getOption.bind(browserSync),
-        emitter:   browserSync.events,
-        watch:     require("./lib/file-watcher").watch
-    };
-
-    browserSync.publicInstance = instance;
-    instance.init = require("./lib/public/init")(browserSync, name, pjson);
-
-    Object.defineProperty(instance, "active", {
-        get: function () {
-            return browserSync.active;
-        }
-    });
-
-    Object.defineProperty(instance, "paused", {
-        get: function () {
-            return browserSync.paused;
-        }
-    });
-
-    /**
-     * Access to client-side socket for emitting events
-     *
-     * @property sockets
-     */
-    Object.defineProperty(instance, "sockets", {
-        get: function () {
-            if (!browserSync.active) {
-                return {
-                    emit: function () {},
-                    on: function () {}
-                };
-            } else {
-                return browserSync.io.sockets;
-            }
-        }
-    });
-
-    instances.push(instance);
-
-    return instance;
-}
-
-/**
- * Reset the state of the module.
- * (should only be needed for test environments)
- */
-module.exports.reset = function () {
-    instances.forEach(function (item) {
-        item.cleanup();
-    });
-    instances        = [];
-    singletonPlugins = [];
-    singletonEmitter = false;
-    singleton        = false;
-};
-
-/**
- * @type {Array}
- */
-module.exports.instances = instances;
Index: node_modules/browser-sync/package.json
===================================================================
--- node_modules/browser-sync/package.json	(revision )
+++ node_modules/browser-sync/package.json	(revision )
@@ -1,96 +0,0 @@
-{
-  "name": "browser-sync",
-  "description": "Live CSS Reload & Browser Syncing",
-  "version": "2.18.13",
-  "homepage": "http://www.browsersync.io/",
-  "author": {
-    "name": "Shane Osbourne"
-  },
-  "repository": "Browsersync/browser-sync",
-  "license": "Apache-2.0",
-  "bin": "bin/browser-sync.js",
-  "files": [
-    "bin",
-    "index.js",
-    "lib",
-    "lodash.custom.js"
-  ],
-  "engines": {
-    "node": ">= 0.8.0"
-  },
-  "scripts": {
-    "env": "node ./test/env.js",
-    "test": "npm run lint && npm run env && npm run unit",
-    "lint": "eslint index.js lib bin examples test/specs gulpfile.js --fix",
-    "pro": "protractor test/protractor/config.single.js",
-    "pro-local": "node test/protractor/setup.js",
-    "unit": "mocha --recursive test/specs --timeout 10000 --bail",
-    "cover": "npm run env && npm run cover-local && npm run coveralls",
-    "cover-local": "istanbul cover -x lodash.custom.js _mocha -- --timeout 10000 --recursive ./test/specs",
-    "coveralls": "istanbul-coveralls",
-    "pre-release": "npm test && npm run pro-local && npm run pro",
-    "lodash": "lodash include=isUndefined,isFunction,toArray,includes,union,each,isString,merge,isObject,set exports=node"
-  },
-  "dependencies": {
-    "browser-sync-client": "2.5.1",
-    "browser-sync-ui": "0.6.3",
-    "bs-recipes": "1.3.4",
-    "chokidar": "1.7.0",
-    "connect": "3.5.0",
-    "dev-ip": "^1.0.1",
-    "easy-extender": "2.3.2",
-    "eazy-logger": "3.0.2",
-    "emitter-steward": "^1.0.0",
-    "fs-extra": "3.0.1",
-    "http-proxy": "1.15.2",
-    "immutable": "3.8.1",
-    "localtunnel": "1.8.3",
-    "micromatch": "2.3.11",
-    "opn": "4.0.2",
-    "portscanner": "2.1.1",
-    "qs": "6.2.1",
-    "resp-modifier": "6.0.2",
-    "rx": "4.1.0",
-    "serve-index": "1.8.0",
-    "serve-static": "1.12.2",
-    "server-destroy": "1.0.1",
-    "socket.io": "1.6.0",
-    "socket.io-client": "1.6.0",
-    "ua-parser-js": "0.7.12",
-    "yargs": "6.4.0"
-  },
-  "devDependencies": {
-    "browser-sync-spa": "1.0.3",
-    "bs-html-injector": "3.0.3",
-    "bs-latency": "1.0.0",
-    "bs-rewrite-rules": "2.0.0",
-    "bs-snippet-injector": "2.0.1",
-    "chai": "3.5.0",
-    "chalk": "1.1.3",
-    "compression": "1.6.2",
-    "eslint": "3.7.1",
-    "graceful-fs": "4.1.9",
-    "gulp": "3.9.1",
-    "gulp-contribs": "0.0.3",
-    "gulp-conventional-changelog": "1.1.0",
-    "gulp-filter": "4.0.0",
-    "http2": "^3.3.6",
-    "istanbul": "0.4.5",
-    "istanbul-coveralls": "1.0.3",
-    "lodash-cli": "4.15.0",
-    "mocha": "3.4.1",
-    "q": "1.4.1",
-    "request": "2.79.0",
-    "rimraf": "2.5.4",
-    "sinon": "1.17.5",
-    "socket.io-client": "1.5.0",
-    "supertest": "2.0.0",
-    "vinyl": "1.2.0"
-  },
-  "keywords": [
-    "browser sync",
-    "css",
-    "live reload",
-    "sync"
-  ]
-}
Index: node_modules/browser-sync/lodash.custom.js
===================================================================
--- node_modules/browser-sync/lodash.custom.js	(revision )
+++ node_modules/browser-sync/lodash.custom.js	(revision )
@@ -1,4314 +0,0 @@
-/**
- * @license
- * lodash (Custom Build) <https://lodash.com/>
- * Build: `lodash include="isUndefined,isFunction,toArray,includes,union,each,isString,merge,isObject,set" exports="node"`
- * Copyright jQuery Foundation and other contributors <https://jquery.org/>
- * Released under MIT license <https://lodash.com/license>
- * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
- * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
- */
-;(function() {
-
-  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
-  var undefined;
-
-  /** Used as the semantic version number. */
-  var VERSION = '4.13.1';
-
-  /** Used as the size to enable large array optimizations. */
-  var LARGE_ARRAY_SIZE = 200;
-
-  /** Used as the `TypeError` message for "Functions" methods. */
-  var FUNC_ERROR_TEXT = 'Expected a function';
-
-  /** Used to stand-in for `undefined` hash values. */
-  var HASH_UNDEFINED = '__lodash_hash_undefined__';
-
-  /** Used to compose bitmasks for comparison styles. */
-  var UNORDERED_COMPARE_FLAG = 1,
-      PARTIAL_COMPARE_FLAG = 2;
-
-  /** Used as references for various `Number` constants. */
-  var INFINITY = 1 / 0,
-      MAX_SAFE_INTEGER = 9007199254740991,
-      MAX_INTEGER = 1.7976931348623157e+308,
-      NAN = 0 / 0;
-
-  /** `Object#toString` result references. */
-  var argsTag = '[object Arguments]',
-      arrayTag = '[object Array]',
-      boolTag = '[object Boolean]',
-      dateTag = '[object Date]',
-      errorTag = '[object Error]',
-      funcTag = '[object Function]',
-      genTag = '[object GeneratorFunction]',
-      mapTag = '[object Map]',
-      numberTag = '[object Number]',
-      objectTag = '[object Object]',
-      promiseTag = '[object Promise]',
-      regexpTag = '[object RegExp]',
-      setTag = '[object Set]',
-      stringTag = '[object String]',
-      symbolTag = '[object Symbol]',
-      weakMapTag = '[object WeakMap]';
-
-  var arrayBufferTag = '[object ArrayBuffer]',
-      dataViewTag = '[object DataView]',
-      float32Tag = '[object Float32Array]',
-      float64Tag = '[object Float64Array]',
-      int8Tag = '[object Int8Array]',
-      int16Tag = '[object Int16Array]',
-      int32Tag = '[object Int32Array]',
-      uint8Tag = '[object Uint8Array]',
-      uint8ClampedTag = '[object Uint8ClampedArray]',
-      uint16Tag = '[object Uint16Array]',
-      uint32Tag = '[object Uint32Array]';
-
-  /** Used to match property names within property paths. */
-  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
-      reIsPlainProp = /^\w*$/,
-      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(\.|\[\])(?:\4|$))/g;
-
-  /**
-   * Used to match `RegExp`
-   * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
-   */
-  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
-
-  /** Used to match leading and trailing whitespace. */
-  var reTrim = /^\s+|\s+$/g;
-
-  /** Used to match backslashes in property paths. */
-  var reEscapeChar = /\\(\\)?/g;
-
-  /** Used to match `RegExp` flags from their coerced string values. */
-  var reFlags = /\w*$/;
-
-  /** Used to detect bad signed hexadecimal string values. */
-  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
-
-  /** Used to detect binary string values. */
-  var reIsBinary = /^0b[01]+$/i;
-
-  /** Used to detect host constructors (Safari). */
-  var reIsHostCtor = /^\[object .+?Constructor\]$/;
-
-  /** Used to detect octal string values. */
-  var reIsOctal = /^0o[0-7]+$/i;
-
-  /** Used to detect unsigned integer values. */
-  var reIsUint = /^(?:0|[1-9]\d*)$/;
-
-  /** Used to compose unicode character classes. */
-  var rsAstralRange = '\\ud800-\\udfff',
-      rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
-      rsComboSymbolsRange = '\\u20d0-\\u20f0',
-      rsVarRange = '\\ufe0e\\ufe0f';
-
-  /** Used to compose unicode capture groups. */
-  var rsAstral = '[' + rsAstralRange + ']',
-      rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
-      rsFitz = '\\ud83c[\\udffb-\\udfff]',
-      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
-      rsNonAstral = '[^' + rsAstralRange + ']',
-      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
-      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
-      rsZWJ = '\\u200d';
-
-  /** Used to compose unicode regexes. */
-  var reOptMod = rsModifier + '?',
-      rsOptVar = '[' + rsVarRange + ']?',
-      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
-      rsSeq = rsOptVar + reOptMod + rsOptJoin,
-      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
-
-  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
-  var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
-
-  /** Used to identify `toStringTag` values of typed arrays. */
-  var typedArrayTags = {};
-  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
-  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
-  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
-  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
-  typedArrayTags[uint32Tag] = true;
-  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
-  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
-  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
-  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
-  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
-  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
-  typedArrayTags[setTag] = typedArrayTags[stringTag] =
-  typedArrayTags[weakMapTag] = false;
-
-  /** Used to identify `toStringTag` values supported by `_.clone`. */
-  var cloneableTags = {};
-  cloneableTags[argsTag] = cloneableTags[arrayTag] =
-  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
-  cloneableTags[boolTag] = cloneableTags[dateTag] =
-  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
-  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
-  cloneableTags[int32Tag] = cloneableTags[mapTag] =
-  cloneableTags[numberTag] = cloneableTags[objectTag] =
-  cloneableTags[regexpTag] = cloneableTags[setTag] =
-  cloneableTags[stringTag] = cloneableTags[symbolTag] =
-  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
-  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
-  cloneableTags[errorTag] = cloneableTags[funcTag] =
-  cloneableTags[weakMapTag] = false;
-
-  /** Built-in method references without a dependency on `root`. */
-  var freeParseInt = parseInt;
-
-  /** Detect free variable `exports`. */
-  var freeExports = typeof exports == 'object' && exports;
-
-  /** Detect free variable `module`. */
-  var freeModule = freeExports && typeof module == 'object' && module;
-
-  /** Detect the popular CommonJS extension `module.exports`. */
-  var moduleExports = freeModule && freeModule.exports === freeExports;
-
-  /** Detect free variable `global` from Node.js. */
-  var freeGlobal = checkGlobal(typeof global == 'object' && global);
-
-  /** Detect free variable `self`. */
-  var freeSelf = checkGlobal(typeof self == 'object' && self);
-
-  /** Detect `this` as the global object. */
-  var thisGlobal = checkGlobal(typeof this == 'object' && this);
-
-  /** Used as a reference to the global object. */
-  var root = freeGlobal || freeSelf || thisGlobal || Function('return this')();
-
-  /*--------------------------------------------------------------------------*/
-
-  /**
-   * Adds the key-value `pair` to `map`.
-   *
-   * @private
-   * @param {Object} map The map to modify.
-   * @param {Array} pair The key-value pair to add.
-   * @returns {Object} Returns `map`.
-   */
-  function addMapEntry(map, pair) {
-    // Don't return `Map#set` because it doesn't return the map instance in IE 11.
-    map.set(pair[0], pair[1]);
-    return map;
-  }
-
-  /**
-   * Adds `value` to `set`.
-   *
-   * @private
-   * @param {Object} set The set to modify.
-   * @param {*} value The value to add.
-   * @returns {Object} Returns `set`.
-   */
-  function addSetEntry(set, value) {
-    set.add(value);
-    return set;
-  }
-
-  /**
-   * A faster alternative to `Function#apply`, this function invokes `func`
-   * with the `this` binding of `thisArg` and the arguments of `args`.
-   *
-   * @private
-   * @param {Function} func The function to invoke.
-   * @param {*} thisArg The `this` binding of `func`.
-   * @param {Array} args The arguments to invoke `func` with.
-   * @returns {*} Returns the result of `func`.
-   */
-  function apply(func, thisArg, args) {
-    var length = args.length;
-    switch (length) {
-      case 0: return func.call(thisArg);
-      case 1: return func.call(thisArg, args[0]);
-      case 2: return func.call(thisArg, args[0], args[1]);
-      case 3: return func.call(thisArg, args[0], args[1], args[2]);
-    }
-    return func.apply(thisArg, args);
-  }
-
-  /**
-   * A specialized version of `_.forEach` for arrays without support for
-   * iteratee shorthands.
-   *
-   * @private
-   * @param {Array} [array] The array to iterate over.
-   * @param {Function} iteratee The function invoked per iteration.
-   * @returns {Array} Returns `array`.
-   */
-  function arrayEach(array, iteratee) {
-    var index = -1,
-        length = array ? array.length : 0;
-
-    while (++index < length) {
-      if (iteratee(array[index], index, array) === false) {
-        break;
-      }
-    }
-    return array;
-  }
-
-  /**
-   * A specialized version of `_.includes` for arrays without support for
-   * specifying an index to search from.
-   *
-   * @private
-   * @param {Array} [array] The array to search.
-   * @param {*} target The value to search for.
-   * @returns {boolean} Returns `true` if `target` is found, else `false`.
-   */
-  function arrayIncludes(array, value) {
-    var length = array ? array.length : 0;
-    return !!length && baseIndexOf(array, value, 0) > -1;
-  }
-
-  /**
-   * This function is like `arrayIncludes` except that it accepts a comparator.
-   *
-   * @private
-   * @param {Array} [array] The array to search.
-   * @param {*} target The value to search for.
-   * @param {Function} comparator The comparator invoked per element.
-   * @returns {boolean} Returns `true` if `target` is found, else `false`.
-   */
-  function arrayIncludesWith(array, value, comparator) {
-    var index = -1,
-        length = array ? array.length : 0;
-
-    while (++index < length) {
-      if (comparator(value, array[index])) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * A specialized version of `_.map` for arrays without support for iteratee
-   * shorthands.
-   *
-   * @private
-   * @param {Array} [array] The array to iterate over.
-   * @param {Function} iteratee The function invoked per iteration.
-   * @returns {Array} Returns the new mapped array.
-   */
-  function arrayMap(array, iteratee) {
-    var index = -1,
-        length = array ? array.length : 0,
-        result = Array(length);
-
-    while (++index < length) {
-      result[index] = iteratee(array[index], index, array);
-    }
-    return result;
-  }
-
-  /**
-   * Appends the elements of `values` to `array`.
-   *
-   * @private
-   * @param {Array} array The array to modify.
-   * @param {Array} values The values to append.
-   * @returns {Array} Returns `array`.
-   */
-  function arrayPush(array, values) {
-    var index = -1,
-        length = values.length,
-        offset = array.length;
-
-    while (++index < length) {
-      array[offset + index] = values[index];
-    }
-    return array;
-  }
-
-  /**
-   * A specialized version of `_.reduce` for arrays without support for
-   * iteratee shorthands.
-   *
-   * @private
-   * @param {Array} [array] The array to iterate over.
-   * @param {Function} iteratee The function invoked per iteration.
-   * @param {*} [accumulator] The initial value.
-   * @param {boolean} [initAccum] Specify using the first element of `array` as
-   *  the initial value.
-   * @returns {*} Returns the accumulated value.
-   */
-  function arrayReduce(array, iteratee, accumulator, initAccum) {
-    var index = -1,
-        length = array ? array.length : 0;
-
-    if (initAccum && length) {
-      accumulator = array[++index];
-    }
-    while (++index < length) {
-      accumulator = iteratee(accumulator, array[index], index, array);
-    }
-    return accumulator;
-  }
-
-  /**
-   * A specialized version of `_.some` for arrays without support for iteratee
-   * shorthands.
-   *
-   * @private
-   * @param {Array} [array] The array to iterate over.
-   * @param {Function} predicate The function invoked per iteration.
-   * @returns {boolean} Returns `true` if any element passes the predicate check,
-   *  else `false`.
-   */
-  function arraySome(array, predicate) {
-    var index = -1,
-        length = array ? array.length : 0;
-
-    while (++index < length) {
-      if (predicate(array[index], index, array)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
-   *
-   * @private
-   * @param {Array} array The array to search.
-   * @param {*} value The value to search for.
-   * @param {number} fromIndex The index to search from.
-   * @returns {number} Returns the index of the matched value, else `-1`.
-   */
-  function baseIndexOf(array, value, fromIndex) {
-    if (value !== value) {
-      return indexOfNaN(array, fromIndex);
-    }
-    var index = fromIndex - 1,
-        length = array.length;
-
-    while (++index < length) {
-      if (array[index] === value) {
-        return index;
-      }
-    }
-    return -1;
-  }
-
-  /**
-   * The base implementation of `_.times` without support for iteratee shorthands
-   * or max array length checks.
-   *
-   * @private
-   * @param {number} n The number of times to invoke `iteratee`.
-   * @param {Function} iteratee The function invoked per iteration.
-   * @returns {Array} Returns the array of results.
-   */
-  function baseTimes(n, iteratee) {
-    var index = -1,
-        result = Array(n);
-
-    while (++index < n) {
-      result[index] = iteratee(index);
-    }
-    return result;
-  }
-
-  /**
-   * The base implementation of `_.values` and `_.valuesIn` which creates an
-   * array of `object` property values corresponding to the property names
-   * of `props`.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @param {Array} props The property names to get values for.
-   * @returns {Object} Returns the array of property values.
-   */
-  function baseValues(object, props) {
-    return arrayMap(props, function(key) {
-      return object[key];
-    });
-  }
-
-  /**
-   * Checks if a cache value for `key` exists.
-   *
-   * @private
-   * @param {Object} cache The cache to query.
-   * @param {string} key The key of the entry to check.
-   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
-   */
-  function cacheHas(cache, key) {
-    return cache.has(key);
-  }
-
-  /**
-   * Checks if `value` is a global object.
-   *
-   * @private
-   * @param {*} value The value to check.
-   * @returns {null|Object} Returns `value` if it's a global object, else `null`.
-   */
-  function checkGlobal(value) {
-    return (value && value.Object === Object) ? value : null;
-  }
-
-  /**
-   * Gets the value at `key` of `object`.
-   *
-   * @private
-   * @param {Object} [object] The object to query.
-   * @param {string} key The key of the property to get.
-   * @returns {*} Returns the property value.
-   */
-  function getValue(object, key) {
-    return object == null ? undefined : object[key];
-  }
-
-  /**
-   * Gets the index at which the first occurrence of `NaN` is found in `array`.
-   *
-   * @private
-   * @param {Array} array The array to search.
-   * @param {number} fromIndex The index to search from.
-   * @param {boolean} [fromRight] Specify iterating from right to left.
-   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
-   */
-  function indexOfNaN(array, fromIndex, fromRight) {
-    var length = array.length,
-        index = fromIndex + (fromRight ? 1 : -1);
-
-    while ((fromRight ? index-- : ++index < length)) {
-      var other = array[index];
-      if (other !== other) {
-        return index;
-      }
-    }
-    return -1;
-  }
-
-  /**
-   * Checks if `value` is a host object in IE < 9.
-   *
-   * @private
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
-   */
-  function isHostObject(value) {
-    // Many host objects are `Object` objects that can coerce to strings
-    // despite having improperly defined `toString` methods.
-    var result = false;
-    if (value != null && typeof value.toString != 'function') {
-      try {
-        result = !!(value + '');
-      } catch (e) {}
-    }
-    return result;
-  }
-
-  /**
-   * Converts `iterator` to an array.
-   *
-   * @private
-   * @param {Object} iterator The iterator to convert.
-   * @returns {Array} Returns the converted array.
-   */
-  function iteratorToArray(iterator) {
-    var data,
-        result = [];
-
-    while (!(data = iterator.next()).done) {
-      result.push(data.value);
-    }
-    return result;
-  }
-
-  /**
-   * Converts `map` to its key-value pairs.
-   *
-   * @private
-   * @param {Object} map The map to convert.
-   * @returns {Array} Returns the key-value pairs.
-   */
-  function mapToArray(map) {
-    var index = -1,
-        result = Array(map.size);
-
-    map.forEach(function(value, key) {
-      result[++index] = [key, value];
-    });
-    return result;
-  }
-
-  /**
-   * Converts `set` to an array of its values.
-   *
-   * @private
-   * @param {Object} set The set to convert.
-   * @returns {Array} Returns the values.
-   */
-  function setToArray(set) {
-    var index = -1,
-        result = Array(set.size);
-
-    set.forEach(function(value) {
-      result[++index] = value;
-    });
-    return result;
-  }
-
-  /**
-   * Converts `string` to an array.
-   *
-   * @private
-   * @param {string} string The string to convert.
-   * @returns {Array} Returns the converted array.
-   */
-  function stringToArray(string) {
-    return string.match(reComplexSymbol);
-  }
-
-  /*--------------------------------------------------------------------------*/
-
-  /** Used for built-in method references. */
-  var arrayProto = Array.prototype,
-      objectProto = Object.prototype;
-
-  /** Used to detect overreaching core-js shims. */
-  var coreJsData = root['__core-js_shared__'];
-
-  /** Used to detect methods masquerading as native. */
-  var maskSrcKey = (function() {
-    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
-    return uid ? ('Symbol(src)_1.' + uid) : '';
-  }());
-
-  /** Used to resolve the decompiled source of functions. */
-  var funcToString = Function.prototype.toString;
-
-  /** Used to check objects for own properties. */
-  var hasOwnProperty = objectProto.hasOwnProperty;
-
-  /** Used to infer the `Object` constructor. */
-  var objectCtorString = funcToString.call(Object);
-
-  /**
-   * Used to resolve the
-   * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
-   * of values.
-   */
-  var objectToString = objectProto.toString;
-
-  /** Used to detect if a method is native. */
-  var reIsNative = RegExp('^' +
-    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
-    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
-  );
-
-  /** Built-in value references. */
-  var Buffer = moduleExports ? root.Buffer : undefined,
-      Reflect = root.Reflect,
-      Symbol = root.Symbol,
-      Uint8Array = root.Uint8Array,
-      enumerate = Reflect ? Reflect.enumerate : undefined,
-      getOwnPropertySymbols = Object.getOwnPropertySymbols,
-      iteratorSymbol = typeof (iteratorSymbol = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined,
-      objectCreate = Object.create,
-      propertyIsEnumerable = objectProto.propertyIsEnumerable,
-      splice = arrayProto.splice;
-
-  /* Built-in method references for those with the same name as other `lodash` methods. */
-  var nativeGetPrototype = Object.getPrototypeOf,
-      nativeKeys = Object.keys,
-      nativeMax = Math.max;
-
-  /* Built-in method references that are verified to be native. */
-  var DataView = getNative(root, 'DataView'),
-      Map = getNative(root, 'Map'),
-      Promise = getNative(root, 'Promise'),
-      Set = getNative(root, 'Set'),
-      WeakMap = getNative(root, 'WeakMap'),
-      nativeCreate = getNative(Object, 'create');
-
-  /** Used to lookup unminified function names. */
-  var realNames = {};
-
-  /** Used to detect maps, sets, and weakmaps. */
-  var dataViewCtorString = toSource(DataView),
-      mapCtorString = toSource(Map),
-      promiseCtorString = toSource(Promise),
-      setCtorString = toSource(Set),
-      weakMapCtorString = toSource(WeakMap);
-
-  /** Used to convert symbols to primitives and strings. */
-  var symbolProto = Symbol ? Symbol.prototype : undefined,
-      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
-      symbolToString = symbolProto ? symbolProto.toString : undefined;
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * Creates a `lodash` object which wraps `value` to enable implicit method
-   * chain sequences. Methods that operate on and return arrays, collections,
-   * and functions can be chained together. Methods that retrieve a single value
-   * or may return a primitive value will automatically end the chain sequence
-   * and return the unwrapped value. Otherwise, the value must be unwrapped
-   * with `_#value`.
-   *
-   * Explicit chain sequences, which must be unwrapped with `_#value`, may be
-   * enabled using `_.chain`.
-   *
-   * The execution of chained methods is lazy, that is, it's deferred until
-   * `_#value` is implicitly or explicitly called.
-   *
-   * Lazy evaluation allows several methods to support shortcut fusion.
-   * Shortcut fusion is an optimization to merge iteratee calls; this avoids
-   * the creation of intermediate arrays and can greatly reduce the number of
-   * iteratee executions. Sections of a chain sequence qualify for shortcut
-   * fusion if the section is applied to an array of at least `200` elements
-   * and any iteratees accept only one argument. The heuristic for whether a
-   * section qualifies for shortcut fusion is subject to change.
-   *
-   * Chaining is supported in custom builds as long as the `_#value` method is
-   * directly or indirectly included in the build.
-   *
-   * In addition to lodash methods, wrappers have `Array` and `String` methods.
-   *
-   * The wrapper `Array` methods are:
-   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
-   *
-   * The wrapper `String` methods are:
-   * `replace` and `split`
-   *
-   * The wrapper methods that support shortcut fusion are:
-   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
-   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
-   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
-   *
-   * The chainable wrapper methods are:
-   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
-   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
-   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
-   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
-   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
-   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
-   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
-   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
-   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
-   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
-   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
-   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
-   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
-   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
-   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
-   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
-   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
-   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
-   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
-   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
-   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
-   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
-   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
-   * `zipObject`, `zipObjectDeep`, and `zipWith`
-   *
-   * The wrapper methods that are **not** chainable by default are:
-   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
-   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `divide`, `each`,
-   * `eachRight`, `endsWith`, `eq`, `escape`, `escapeRegExp`, `every`, `find`,
-   * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `first`,
-   * `floor`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,
-   * `forOwnRight`, `get`, `gt`, `gte`, `has`, `hasIn`, `head`, `identity`,
-   * `includes`, `indexOf`, `inRange`, `invoke`, `isArguments`, `isArray`,
-   * `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, `isBoolean`,
-   * `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`,
-   * `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMap`,
-   * `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
-   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
-   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
-   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
-   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
-   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
-   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
-   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
-   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
-   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
-   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
-   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
-   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
-   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
-   * `upperFirst`, `value`, and `words`
-   *
-   * @name _
-   * @constructor
-   * @category Seq
-   * @param {*} value The value to wrap in a `lodash` instance.
-   * @returns {Object} Returns the new `lodash` wrapper instance.
-   * @example
-   *
-   * function square(n) {
-   *   return n * n;
-   * }
-   *
-   * var wrapped = _([1, 2, 3]);
-   *
-   * // Returns an unwrapped value.
-   * wrapped.reduce(_.add);
-   * // => 6
-   *
-   * // Returns a wrapped value.
-   * var squares = wrapped.map(square);
-   *
-   * _.isArray(squares);
-   * // => false
-   *
-   * _.isArray(squares.value());
-   * // => true
-   */
-  function lodash() {
-    // No operation performed.
-  }
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * Creates a hash object.
-   *
-   * @private
-   * @constructor
-   * @param {Array} [entries] The key-value pairs to cache.
-   */
-  function Hash(entries) {
-    var index = -1,
-        length = entries ? entries.length : 0;
-
-    this.clear();
-    while (++index < length) {
-      var entry = entries[index];
-      this.set(entry[0], entry[1]);
-    }
-  }
-
-  /**
-   * Removes all key-value entries from the hash.
-   *
-   * @private
-   * @name clear
-   * @memberOf Hash
-   */
-  function hashClear() {
-    this.__data__ = nativeCreate ? nativeCreate(null) : {};
-  }
-
-  /**
-   * Removes `key` and its value from the hash.
-   *
-   * @private
-   * @name delete
-   * @memberOf Hash
-   * @param {Object} hash The hash to modify.
-   * @param {string} key The key of the value to remove.
-   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
-   */
-  function hashDelete(key) {
-    return this.has(key) && delete this.__data__[key];
-  }
-
-  /**
-   * Gets the hash value for `key`.
-   *
-   * @private
-   * @name get
-   * @memberOf Hash
-   * @param {string} key The key of the value to get.
-   * @returns {*} Returns the entry value.
-   */
-  function hashGet(key) {
-    var data = this.__data__;
-    if (nativeCreate) {
-      var result = data[key];
-      return result === HASH_UNDEFINED ? undefined : result;
-    }
-    return hasOwnProperty.call(data, key) ? data[key] : undefined;
-  }
-
-  /**
-   * Checks if a hash value for `key` exists.
-   *
-   * @private
-   * @name has
-   * @memberOf Hash
-   * @param {string} key The key of the entry to check.
-   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
-   */
-  function hashHas(key) {
-    var data = this.__data__;
-    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
-  }
-
-  /**
-   * Sets the hash `key` to `value`.
-   *
-   * @private
-   * @name set
-   * @memberOf Hash
-   * @param {string} key The key of the value to set.
-   * @param {*} value The value to set.
-   * @returns {Object} Returns the hash instance.
-   */
-  function hashSet(key, value) {
-    var data = this.__data__;
-    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
-    return this;
-  }
-
-  // Add methods to `Hash`.
-  Hash.prototype.clear = hashClear;
-  Hash.prototype['delete'] = hashDelete;
-  Hash.prototype.get = hashGet;
-  Hash.prototype.has = hashHas;
-  Hash.prototype.set = hashSet;
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * Creates an list cache object.
-   *
-   * @private
-   * @constructor
-   * @param {Array} [entries] The key-value pairs to cache.
-   */
-  function ListCache(entries) {
-    var index = -1,
-        length = entries ? entries.length : 0;
-
-    this.clear();
-    while (++index < length) {
-      var entry = entries[index];
-      this.set(entry[0], entry[1]);
-    }
-  }
-
-  /**
-   * Removes all key-value entries from the list cache.
-   *
-   * @private
-   * @name clear
-   * @memberOf ListCache
-   */
-  function listCacheClear() {
-    this.__data__ = [];
-  }
-
-  /**
-   * Removes `key` and its value from the list cache.
-   *
-   * @private
-   * @name delete
-   * @memberOf ListCache
-   * @param {string} key The key of the value to remove.
-   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
-   */
-  function listCacheDelete(key) {
-    var data = this.__data__,
-        index = assocIndexOf(data, key);
-
-    if (index < 0) {
-      return false;
-    }
-    var lastIndex = data.length - 1;
-    if (index == lastIndex) {
-      data.pop();
-    } else {
-      splice.call(data, index, 1);
-    }
-    return true;
-  }
-
-  /**
-   * Gets the list cache value for `key`.
-   *
-   * @private
-   * @name get
-   * @memberOf ListCache
-   * @param {string} key The key of the value to get.
-   * @returns {*} Returns the entry value.
-   */
-  function listCacheGet(key) {
-    var data = this.__data__,
-        index = assocIndexOf(data, key);
-
-    return index < 0 ? undefined : data[index][1];
-  }
-
-  /**
-   * Checks if a list cache value for `key` exists.
-   *
-   * @private
-   * @name has
-   * @memberOf ListCache
-   * @param {string} key The key of the entry to check.
-   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
-   */
-  function listCacheHas(key) {
-    return assocIndexOf(this.__data__, key) > -1;
-  }
-
-  /**
-   * Sets the list cache `key` to `value`.
-   *
-   * @private
-   * @name set
-   * @memberOf ListCache
-   * @param {string} key The key of the value to set.
-   * @param {*} value The value to set.
-   * @returns {Object} Returns the list cache instance.
-   */
-  function listCacheSet(key, value) {
-    var data = this.__data__,
-        index = assocIndexOf(data, key);
-
-    if (index < 0) {
-      data.push([key, value]);
-    } else {
-      data[index][1] = value;
-    }
-    return this;
-  }
-
-  // Add methods to `ListCache`.
-  ListCache.prototype.clear = listCacheClear;
-  ListCache.prototype['delete'] = listCacheDelete;
-  ListCache.prototype.get = listCacheGet;
-  ListCache.prototype.has = listCacheHas;
-  ListCache.prototype.set = listCacheSet;
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * Creates a map cache object to store key-value pairs.
-   *
-   * @private
-   * @constructor
-   * @param {Array} [entries] The key-value pairs to cache.
-   */
-  function MapCache(entries) {
-    var index = -1,
-        length = entries ? entries.length : 0;
-
-    this.clear();
-    while (++index < length) {
-      var entry = entries[index];
-      this.set(entry[0], entry[1]);
-    }
-  }
-
-  /**
-   * Removes all key-value entries from the map.
-   *
-   * @private
-   * @name clear
-   * @memberOf MapCache
-   */
-  function mapCacheClear() {
-    this.__data__ = {
-      'hash': new Hash,
-      'map': new (Map || ListCache),
-      'string': new Hash
-    };
-  }
-
-  /**
-   * Removes `key` and its value from the map.
-   *
-   * @private
-   * @name delete
-   * @memberOf MapCache
-   * @param {string} key The key of the value to remove.
-   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
-   */
-  function mapCacheDelete(key) {
-    return getMapData(this, key)['delete'](key);
-  }
-
-  /**
-   * Gets the map value for `key`.
-   *
-   * @private
-   * @name get
-   * @memberOf MapCache
-   * @param {string} key The key of the value to get.
-   * @returns {*} Returns the entry value.
-   */
-  function mapCacheGet(key) {
-    return getMapData(this, key).get(key);
-  }
-
-  /**
-   * Checks if a map value for `key` exists.
-   *
-   * @private
-   * @name has
-   * @memberOf MapCache
-   * @param {string} key The key of the entry to check.
-   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
-   */
-  function mapCacheHas(key) {
-    return getMapData(this, key).has(key);
-  }
-
-  /**
-   * Sets the map `key` to `value`.
-   *
-   * @private
-   * @name set
-   * @memberOf MapCache
-   * @param {string} key The key of the value to set.
-   * @param {*} value The value to set.
-   * @returns {Object} Returns the map cache instance.
-   */
-  function mapCacheSet(key, value) {
-    getMapData(this, key).set(key, value);
-    return this;
-  }
-
-  // Add methods to `MapCache`.
-  MapCache.prototype.clear = mapCacheClear;
-  MapCache.prototype['delete'] = mapCacheDelete;
-  MapCache.prototype.get = mapCacheGet;
-  MapCache.prototype.has = mapCacheHas;
-  MapCache.prototype.set = mapCacheSet;
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   *
-   * Creates an array cache object to store unique values.
-   *
-   * @private
-   * @constructor
-   * @param {Array} [values] The values to cache.
-   */
-  function SetCache(values) {
-    var index = -1,
-        length = values ? values.length : 0;
-
-    this.__data__ = new MapCache;
-    while (++index < length) {
-      this.add(values[index]);
-    }
-  }
-
-  /**
-   * Adds `value` to the array cache.
-   *
-   * @private
-   * @name add
-   * @memberOf SetCache
-   * @alias push
-   * @param {*} value The value to cache.
-   * @returns {Object} Returns the cache instance.
-   */
-  function setCacheAdd(value) {
-    this.__data__.set(value, HASH_UNDEFINED);
-    return this;
-  }
-
-  /**
-   * Checks if `value` is in the array cache.
-   *
-   * @private
-   * @name has
-   * @memberOf SetCache
-   * @param {*} value The value to search for.
-   * @returns {number} Returns `true` if `value` is found, else `false`.
-   */
-  function setCacheHas(value) {
-    return this.__data__.has(value);
-  }
-
-  // Add methods to `SetCache`.
-  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
-  SetCache.prototype.has = setCacheHas;
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * Creates a stack cache object to store key-value pairs.
-   *
-   * @private
-   * @constructor
-   * @param {Array} [entries] The key-value pairs to cache.
-   */
-  function Stack(entries) {
-    this.__data__ = new ListCache(entries);
-  }
-
-  /**
-   * Removes all key-value entries from the stack.
-   *
-   * @private
-   * @name clear
-   * @memberOf Stack
-   */
-  function stackClear() {
-    this.__data__ = new ListCache;
-  }
-
-  /**
-   * Removes `key` and its value from the stack.
-   *
-   * @private
-   * @name delete
-   * @memberOf Stack
-   * @param {string} key The key of the value to remove.
-   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
-   */
-  function stackDelete(key) {
-    return this.__data__['delete'](key);
-  }
-
-  /**
-   * Gets the stack value for `key`.
-   *
-   * @private
-   * @name get
-   * @memberOf Stack
-   * @param {string} key The key of the value to get.
-   * @returns {*} Returns the entry value.
-   */
-  function stackGet(key) {
-    return this.__data__.get(key);
-  }
-
-  /**
-   * Checks if a stack value for `key` exists.
-   *
-   * @private
-   * @name has
-   * @memberOf Stack
-   * @param {string} key The key of the entry to check.
-   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
-   */
-  function stackHas(key) {
-    return this.__data__.has(key);
-  }
-
-  /**
-   * Sets the stack `key` to `value`.
-   *
-   * @private
-   * @name set
-   * @memberOf Stack
-   * @param {string} key The key of the value to set.
-   * @param {*} value The value to set.
-   * @returns {Object} Returns the stack cache instance.
-   */
-  function stackSet(key, value) {
-    var cache = this.__data__;
-    if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {
-      cache = this.__data__ = new MapCache(cache.__data__);
-    }
-    cache.set(key, value);
-    return this;
-  }
-
-  // Add methods to `Stack`.
-  Stack.prototype.clear = stackClear;
-  Stack.prototype['delete'] = stackDelete;
-  Stack.prototype.get = stackGet;
-  Stack.prototype.has = stackHas;
-  Stack.prototype.set = stackSet;
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * This function is like `assignValue` except that it doesn't assign
-   * `undefined` values.
-   *
-   * @private
-   * @param {Object} object The object to modify.
-   * @param {string} key The key of the property to assign.
-   * @param {*} value The value to assign.
-   */
-  function assignMergeValue(object, key, value) {
-    if ((value !== undefined && !eq(object[key], value)) ||
-        (typeof key == 'number' && value === undefined && !(key in object))) {
-      object[key] = value;
-    }
-  }
-
-  /**
-   * Assigns `value` to `key` of `object` if the existing value is not equivalent
-   * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
-   * for equality comparisons.
-   *
-   * @private
-   * @param {Object} object The object to modify.
-   * @param {string} key The key of the property to assign.
-   * @param {*} value The value to assign.
-   */
-  function assignValue(object, key, value) {
-    var objValue = object[key];
-    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
-        (value === undefined && !(key in object))) {
-      object[key] = value;
-    }
-  }
-
-  /**
-   * Gets the index at which the `key` is found in `array` of key-value pairs.
-   *
-   * @private
-   * @param {Array} array The array to search.
-   * @param {*} key The key to search for.
-   * @returns {number} Returns the index of the matched value, else `-1`.
-   */
-  function assocIndexOf(array, key) {
-    var length = array.length;
-    while (length--) {
-      if (eq(array[length][0], key)) {
-        return length;
-      }
-    }
-    return -1;
-  }
-
-  /**
-   * The base implementation of `_.assign` without support for multiple sources
-   * or `customizer` functions.
-   *
-   * @private
-   * @param {Object} object The destination object.
-   * @param {Object} source The source object.
-   * @returns {Object} Returns `object`.
-   */
-  function baseAssign(object, source) {
-    return object && copyObject(source, keys(source), object);
-  }
-
-  /**
-   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
-   * traversed objects.
-   *
-   * @private
-   * @param {*} value The value to clone.
-   * @param {boolean} [isDeep] Specify a deep clone.
-   * @param {boolean} [isFull] Specify a clone including symbols.
-   * @param {Function} [customizer] The function to customize cloning.
-   * @param {string} [key] The key of `value`.
-   * @param {Object} [object] The parent object of `value`.
-   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
-   * @returns {*} Returns the cloned value.
-   */
-  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
-    var result;
-    if (customizer) {
-      result = object ? customizer(value, key, object, stack) : customizer(value);
-    }
-    if (result !== undefined) {
-      return result;
-    }
-    if (!isObject(value)) {
-      return value;
-    }
-    var isArr = isArray(value);
-    if (isArr) {
-      result = initCloneArray(value);
-      if (!isDeep) {
-        return copyArray(value, result);
-      }
-    } else {
-      var tag = getTag(value),
-          isFunc = tag == funcTag || tag == genTag;
-
-      if (isBuffer(value)) {
-        return cloneBuffer(value, isDeep);
-      }
-      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
-        if (isHostObject(value)) {
-          return object ? value : {};
-        }
-        result = initCloneObject(isFunc ? {} : value);
-        if (!isDeep) {
-          return copySymbols(value, baseAssign(result, value));
-        }
-      } else {
-        if (!cloneableTags[tag]) {
-          return object ? value : {};
-        }
-        result = initCloneByTag(value, tag, baseClone, isDeep);
-      }
-    }
-    // Check for circular references and return its corresponding clone.
-    stack || (stack = new Stack);
-    var stacked = stack.get(value);
-    if (stacked) {
-      return stacked;
-    }
-    stack.set(value, result);
-
-    if (!isArr) {
-      var props = isFull ? getAllKeys(value) : keys(value);
-    }
-    // Recursively populate clone (susceptible to call stack limits).
-    arrayEach(props || value, function(subValue, key) {
-      if (props) {
-        key = subValue;
-        subValue = value[key];
-      }
-      assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
-    });
-    return result;
-  }
-
-  /**
-   * The base implementation of `_.create` without support for assigning
-   * properties to the created object.
-   *
-   * @private
-   * @param {Object} prototype The object to inherit from.
-   * @returns {Object} Returns the new object.
-   */
-  function baseCreate(proto) {
-    return isObject(proto) ? objectCreate(proto) : {};
-  }
-
-  /**
-   * The base implementation of `_.forEach` without support for iteratee shorthands.
-   *
-   * @private
-   * @param {Array|Object} collection The collection to iterate over.
-   * @param {Function} iteratee The function invoked per iteration.
-   * @returns {Array|Object} Returns `collection`.
-   */
-  var baseEach = createBaseEach(baseForOwn);
-
-  /**
-   * The base implementation of `_.flatten` with support for restricting flattening.
-   *
-   * @private
-   * @param {Array} array The array to flatten.
-   * @param {number} depth The maximum recursion depth.
-   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
-   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
-   * @param {Array} [result=[]] The initial result value.
-   * @returns {Array} Returns the new flattened array.
-   */
-  function baseFlatten(array, depth, predicate, isStrict, result) {
-    var index = -1,
-        length = array.length;
-
-    predicate || (predicate = isFlattenable);
-    result || (result = []);
-
-    while (++index < length) {
-      var value = array[index];
-      if (depth > 0 && predicate(value)) {
-        if (depth > 1) {
-          // Recursively flatten arrays (susceptible to call stack limits).
-          baseFlatten(value, depth - 1, predicate, isStrict, result);
-        } else {
-          arrayPush(result, value);
-        }
-      } else if (!isStrict) {
-        result[result.length] = value;
-      }
-    }
-    return result;
-  }
-
-  /**
-   * The base implementation of `baseForOwn` which iterates over `object`
-   * properties returned by `keysFunc` and invokes `iteratee` for each property.
-   * Iteratee functions may exit iteration early by explicitly returning `false`.
-   *
-   * @private
-   * @param {Object} object The object to iterate over.
-   * @param {Function} iteratee The function invoked per iteration.
-   * @param {Function} keysFunc The function to get the keys of `object`.
-   * @returns {Object} Returns `object`.
-   */
-  var baseFor = createBaseFor();
-
-  /**
-   * The base implementation of `_.forOwn` without support for iteratee shorthands.
-   *
-   * @private
-   * @param {Object} object The object to iterate over.
-   * @param {Function} iteratee The function invoked per iteration.
-   * @returns {Object} Returns `object`.
-   */
-  function baseForOwn(object, iteratee) {
-    return object && baseFor(object, iteratee, keys);
-  }
-
-  /**
-   * The base implementation of `_.get` without support for default values.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @param {Array|string} path The path of the property to get.
-   * @returns {*} Returns the resolved value.
-   */
-  function baseGet(object, path) {
-    path = isKey(path, object) ? [path] : castPath(path);
-
-    var index = 0,
-        length = path.length;
-
-    while (object != null && index < length) {
-      object = object[toKey(path[index++])];
-    }
-    return (index && index == length) ? object : undefined;
-  }
-
-  /**
-   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
-   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
-   * symbols of `object`.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @param {Function} keysFunc The function to get the keys of `object`.
-   * @param {Function} symbolsFunc The function to get the symbols of `object`.
-   * @returns {Array} Returns the array of property names and symbols.
-   */
-  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
-    var result = keysFunc(object);
-    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
-  }
-
-  /**
-   * The base implementation of `_.has` without support for deep paths.
-   *
-   * @private
-   * @param {Object} [object] The object to query.
-   * @param {Array|string} key The key to check.
-   * @returns {boolean} Returns `true` if `key` exists, else `false`.
-   */
-  function baseHas(object, key) {
-    // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
-    // that are composed entirely of index properties, return `false` for
-    // `hasOwnProperty` checks of them.
-    return object != null &&
-      (hasOwnProperty.call(object, key) ||
-        (typeof object == 'object' && key in object && getPrototype(object) === null));
-  }
-
-  /**
-   * The base implementation of `_.hasIn` without support for deep paths.
-   *
-   * @private
-   * @param {Object} [object] The object to query.
-   * @param {Array|string} key The key to check.
-   * @returns {boolean} Returns `true` if `key` exists, else `false`.
-   */
-  function baseHasIn(object, key) {
-    return object != null && key in Object(object);
-  }
-
-  /**
-   * The base implementation of `_.isEqual` which supports partial comparisons
-   * and tracks traversed objects.
-   *
-   * @private
-   * @param {*} value The value to compare.
-   * @param {*} other The other value to compare.
-   * @param {Function} [customizer] The function to customize comparisons.
-   * @param {boolean} [bitmask] The bitmask of comparison flags.
-   *  The bitmask may be composed of the following flags:
-   *     1 - Unordered comparison
-   *     2 - Partial comparison
-   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
-   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
-   */
-  function baseIsEqual(value, other, customizer, bitmask, stack) {
-    if (value === other) {
-      return true;
-    }
-    if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
-      return value !== value && other !== other;
-    }
-    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
-  }
-
-  /**
-   * A specialized version of `baseIsEqual` for arrays and objects which performs
-   * deep comparisons and tracks traversed objects enabling objects with circular
-   * references to be compared.
-   *
-   * @private
-   * @param {Object} object The object to compare.
-   * @param {Object} other The other object to compare.
-   * @param {Function} equalFunc The function to determine equivalents of values.
-   * @param {Function} [customizer] The function to customize comparisons.
-   * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
-   *  for more details.
-   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
-   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
-   */
-  function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
-    var objIsArr = isArray(object),
-        othIsArr = isArray(other),
-        objTag = arrayTag,
-        othTag = arrayTag;
-
-    if (!objIsArr) {
-      objTag = getTag(object);
-      objTag = objTag == argsTag ? objectTag : objTag;
-    }
-    if (!othIsArr) {
-      othTag = getTag(other);
-      othTag = othTag == argsTag ? objectTag : othTag;
-    }
-    var objIsObj = objTag == objectTag && !isHostObject(object),
-        othIsObj = othTag == objectTag && !isHostObject(other),
-        isSameTag = objTag == othTag;
-
-    if (isSameTag && !objIsObj) {
-      stack || (stack = new Stack);
-      return (objIsArr || isTypedArray(object))
-        ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
-        : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
-    }
-    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
-      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
-          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
-
-      if (objIsWrapped || othIsWrapped) {
-        var objUnwrapped = objIsWrapped ? object.value() : object,
-            othUnwrapped = othIsWrapped ? other.value() : other;
-
-        stack || (stack = new Stack);
-        return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
-      }
-    }
-    if (!isSameTag) {
-      return false;
-    }
-    stack || (stack = new Stack);
-    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
-  }
-
-  /**
-   * The base implementation of `_.isMatch` without support for iteratee shorthands.
-   *
-   * @private
-   * @param {Object} object The object to inspect.
-   * @param {Object} source The object of property values to match.
-   * @param {Array} matchData The property names, values, and compare flags to match.
-   * @param {Function} [customizer] The function to customize comparisons.
-   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
-   */
-  function baseIsMatch(object, source, matchData, customizer) {
-    var index = matchData.length,
-        length = index,
-        noCustomizer = !customizer;
-
-    if (object == null) {
-      return !length;
-    }
-    object = Object(object);
-    while (index--) {
-      var data = matchData[index];
-      if ((noCustomizer && data[2])
-            ? data[1] !== object[data[0]]
-            : !(data[0] in object)
-          ) {
-        return false;
-      }
-    }
-    while (++index < length) {
-      data = matchData[index];
-      var key = data[0],
-          objValue = object[key],
-          srcValue = data[1];
-
-      if (noCustomizer && data[2]) {
-        if (objValue === undefined && !(key in object)) {
-          return false;
-        }
-      } else {
-        var stack = new Stack;
-        if (customizer) {
-          var result = customizer(objValue, srcValue, key, object, source, stack);
-        }
-        if (!(result === undefined
-              ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
-              : result
-            )) {
-          return false;
-        }
-      }
-    }
-    return true;
-  }
-
-  /**
-   * The base implementation of `_.isNative` without bad shim checks.
-   *
-   * @private
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is a native function,
-   *  else `false`.
-   */
-  function baseIsNative(value) {
-    if (!isObject(value) || isMasked(value)) {
-      return false;
-    }
-    var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
-    return pattern.test(toSource(value));
-  }
-
-  /**
-   * The base implementation of `_.iteratee`.
-   *
-   * @private
-   * @param {*} [value=_.identity] The value to convert to an iteratee.
-   * @returns {Function} Returns the iteratee.
-   */
-  function baseIteratee(value) {
-    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
-    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
-    if (typeof value == 'function') {
-      return value;
-    }
-    if (value == null) {
-      return identity;
-    }
-    if (typeof value == 'object') {
-      return isArray(value)
-        ? baseMatchesProperty(value[0], value[1])
-        : baseMatches(value);
-    }
-    return property(value);
-  }
-
-  /**
-   * The base implementation of `_.keys` which doesn't skip the constructor
-   * property of prototypes or treat sparse arrays as dense.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @returns {Array} Returns the array of property names.
-   */
-  function baseKeys(object) {
-    return nativeKeys(Object(object));
-  }
-
-  /**
-   * The base implementation of `_.keysIn` which doesn't skip the constructor
-   * property of prototypes or treat sparse arrays as dense.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @returns {Array} Returns the array of property names.
-   */
-  function baseKeysIn(object) {
-    object = object == null ? object : Object(object);
-
-    var result = [];
-    for (var key in object) {
-      result.push(key);
-    }
-    return result;
-  }
-
-  // Fallback for IE < 9 with es6-shim.
-  if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
-    baseKeysIn = function(object) {
-      return iteratorToArray(enumerate(object));
-    };
-  }
-
-  /**
-   * The base implementation of `_.matches` which doesn't clone `source`.
-   *
-   * @private
-   * @param {Object} source The object of property values to match.
-   * @returns {Function} Returns the new spec function.
-   */
-  function baseMatches(source) {
-    var matchData = getMatchData(source);
-    if (matchData.length == 1 && matchData[0][2]) {
-      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
-    }
-    return function(object) {
-      return object === source || baseIsMatch(object, source, matchData);
-    };
-  }
-
-  /**
-   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
-   *
-   * @private
-   * @param {string} path The path of the property to get.
-   * @param {*} srcValue The value to match.
-   * @returns {Function} Returns the new spec function.
-   */
-  function baseMatchesProperty(path, srcValue) {
-    if (isKey(path) && isStrictComparable(srcValue)) {
-      return matchesStrictComparable(toKey(path), srcValue);
-    }
-    return function(object) {
-      var objValue = get(object, path);
-      return (objValue === undefined && objValue === srcValue)
-        ? hasIn(object, path)
-        : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
-    };
-  }
-
-  /**
-   * The base implementation of `_.merge` without support for multiple sources.
-   *
-   * @private
-   * @param {Object} object The destination object.
-   * @param {Object} source The source object.
-   * @param {number} srcIndex The index of `source`.
-   * @param {Function} [customizer] The function to customize merged values.
-   * @param {Object} [stack] Tracks traversed source values and their merged
-   *  counterparts.
-   */
-  function baseMerge(object, source, srcIndex, customizer, stack) {
-    if (object === source) {
-      return;
-    }
-    if (!(isArray(source) || isTypedArray(source))) {
-      var props = keysIn(source);
-    }
-    arrayEach(props || source, function(srcValue, key) {
-      if (props) {
-        key = srcValue;
-        srcValue = source[key];
-      }
-      if (isObject(srcValue)) {
-        stack || (stack = new Stack);
-        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
-      }
-      else {
-        var newValue = customizer
-          ? customizer(object[key], srcValue, (key + ''), object, source, stack)
-          : undefined;
-
-        if (newValue === undefined) {
-          newValue = srcValue;
-        }
-        assignMergeValue(object, key, newValue);
-      }
-    });
-  }
-
-  /**
-   * A specialized version of `baseMerge` for arrays and objects which performs
-   * deep merges and tracks traversed objects enabling objects with circular
-   * references to be merged.
-   *
-   * @private
-   * @param {Object} object The destination object.
-   * @param {Object} source The source object.
-   * @param {string} key The key of the value to merge.
-   * @param {number} srcIndex The index of `source`.
-   * @param {Function} mergeFunc The function to merge values.
-   * @param {Function} [customizer] The function to customize assigned values.
-   * @param {Object} [stack] Tracks traversed source values and their merged
-   *  counterparts.
-   */
-  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
-    var objValue = object[key],
-        srcValue = source[key],
-        stacked = stack.get(srcValue);
-
-    if (stacked) {
-      assignMergeValue(object, key, stacked);
-      return;
-    }
-    var newValue = customizer
-      ? customizer(objValue, srcValue, (key + ''), object, source, stack)
-      : undefined;
-
-    var isCommon = newValue === undefined;
-
-    if (isCommon) {
-      newValue = srcValue;
-      if (isArray(srcValue) || isTypedArray(srcValue)) {
-        if (isArray(objValue)) {
-          newValue = objValue;
-        }
-        else if (isArrayLikeObject(objValue)) {
-          newValue = copyArray(objValue);
-        }
-        else {
-          isCommon = false;
-          newValue = baseClone(srcValue, true);
-        }
-      }
-      else if (isPlainObject(srcValue) || isArguments(srcValue)) {
-        if (isArguments(objValue)) {
-          newValue = toPlainObject(objValue);
-        }
-        else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
-          isCommon = false;
-          newValue = baseClone(srcValue, true);
-        }
-        else {
-          newValue = objValue;
-        }
-      }
-      else {
-        isCommon = false;
-      }
-    }
-    stack.set(srcValue, newValue);
-
-    if (isCommon) {
-      // Recursively merge objects and arrays (susceptible to call stack limits).
-      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
-    }
-    stack['delete'](srcValue);
-    assignMergeValue(object, key, newValue);
-  }
-
-  /**
-   * The base implementation of `_.property` without support for deep paths.
-   *
-   * @private
-   * @param {string} key The key of the property to get.
-   * @returns {Function} Returns the new accessor function.
-   */
-  function baseProperty(key) {
-    return function(object) {
-      return object == null ? undefined : object[key];
-    };
-  }
-
-  /**
-   * A specialized version of `baseProperty` which supports deep paths.
-   *
-   * @private
-   * @param {Array|string} path The path of the property to get.
-   * @returns {Function} Returns the new accessor function.
-   */
-  function basePropertyDeep(path) {
-    return function(object) {
-      return baseGet(object, path);
-    };
-  }
-
-  /**
-   * The base implementation of `_.set`.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @param {Array|string} path The path of the property to set.
-   * @param {*} value The value to set.
-   * @param {Function} [customizer] The function to customize path creation.
-   * @returns {Object} Returns `object`.
-   */
-  function baseSet(object, path, value, customizer) {
-    path = isKey(path, object) ? [path] : castPath(path);
-
-    var index = -1,
-        length = path.length,
-        lastIndex = length - 1,
-        nested = object;
-
-    while (nested != null && ++index < length) {
-      var key = toKey(path[index]);
-      if (isObject(nested)) {
-        var newValue = value;
-        if (index != lastIndex) {
-          var objValue = nested[key];
-          newValue = customizer ? customizer(objValue, key, nested) : undefined;
-          if (newValue === undefined) {
-            newValue = objValue == null
-              ? (isIndex(path[index + 1]) ? [] : {})
-              : objValue;
-          }
-        }
-        assignValue(nested, key, newValue);
-      }
-      nested = nested[key];
-    }
-    return object;
-  }
-
-  /**
-   * The base implementation of `_.toString` which doesn't convert nullish
-   * values to empty strings.
-   *
-   * @private
-   * @param {*} value The value to process.
-   * @returns {string} Returns the string.
-   */
-  function baseToString(value) {
-    // Exit early for strings to avoid a performance hit in some environments.
-    if (typeof value == 'string') {
-      return value;
-    }
-    if (isSymbol(value)) {
-      return symbolToString ? symbolToString.call(value) : '';
-    }
-    var result = (value + '');
-    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
-  }
-
-  /**
-   * The base implementation of `_.uniqBy` without support for iteratee shorthands.
-   *
-   * @private
-   * @param {Array} array The array to inspect.
-   * @param {Function} [iteratee] The iteratee invoked per element.
-   * @param {Function} [comparator] The comparator invoked per element.
-   * @returns {Array} Returns the new duplicate free array.
-   */
-  function baseUniq(array, iteratee, comparator) {
-    var index = -1,
-        includes = arrayIncludes,
-        length = array.length,
-        isCommon = true,
-        result = [],
-        seen = result;
-
-    if (comparator) {
-      isCommon = false;
-      includes = arrayIncludesWith;
-    }
-    else if (length >= LARGE_ARRAY_SIZE) {
-      var set = iteratee ? null : createSet(array);
-      if (set) {
-        return setToArray(set);
-      }
-      isCommon = false;
-      includes = cacheHas;
-      seen = new SetCache;
-    }
-    else {
-      seen = iteratee ? [] : result;
-    }
-    outer:
-    while (++index < length) {
-      var value = array[index],
-          computed = iteratee ? iteratee(value) : value;
-
-      value = (comparator || value !== 0) ? value : 0;
-      if (isCommon && computed === computed) {
-        var seenIndex = seen.length;
-        while (seenIndex--) {
-          if (seen[seenIndex] === computed) {
-            continue outer;
-          }
-        }
-        if (iteratee) {
-          seen.push(computed);
-        }
-        result.push(value);
-      }
-      else if (!includes(seen, computed, comparator)) {
-        if (seen !== result) {
-          seen.push(computed);
-        }
-        result.push(value);
-      }
-    }
-    return result;
-  }
-
-  /**
-   * Casts `value` to a path array if it's not one.
-   *
-   * @private
-   * @param {*} value The value to inspect.
-   * @returns {Array} Returns the cast property path array.
-   */
-  function castPath(value) {
-    return isArray(value) ? value : stringToPath(value);
-  }
-
-  /**
-   * Creates a clone of  `buffer`.
-   *
-   * @private
-   * @param {Buffer} buffer The buffer to clone.
-   * @param {boolean} [isDeep] Specify a deep clone.
-   * @returns {Buffer} Returns the cloned buffer.
-   */
-  function cloneBuffer(buffer, isDeep) {
-    if (isDeep) {
-      return buffer.slice();
-    }
-    var result = new buffer.constructor(buffer.length);
-    buffer.copy(result);
-    return result;
-  }
-
-  /**
-   * Creates a clone of `arrayBuffer`.
-   *
-   * @private
-   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
-   * @returns {ArrayBuffer} Returns the cloned array buffer.
-   */
-  function cloneArrayBuffer(arrayBuffer) {
-    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
-    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
-    return result;
-  }
-
-  /**
-   * Creates a clone of `dataView`.
-   *
-   * @private
-   * @param {Object} dataView The data view to clone.
-   * @param {boolean} [isDeep] Specify a deep clone.
-   * @returns {Object} Returns the cloned data view.
-   */
-  function cloneDataView(dataView, isDeep) {
-    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
-    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
-  }
-
-  /**
-   * Creates a clone of `map`.
-   *
-   * @private
-   * @param {Object} map The map to clone.
-   * @param {Function} cloneFunc The function to clone values.
-   * @param {boolean} [isDeep] Specify a deep clone.
-   * @returns {Object} Returns the cloned map.
-   */
-  function cloneMap(map, isDeep, cloneFunc) {
-    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
-    return arrayReduce(array, addMapEntry, new map.constructor);
-  }
-
-  /**
-   * Creates a clone of `regexp`.
-   *
-   * @private
-   * @param {Object} regexp The regexp to clone.
-   * @returns {Object} Returns the cloned regexp.
-   */
-  function cloneRegExp(regexp) {
-    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
-    result.lastIndex = regexp.lastIndex;
-    return result;
-  }
-
-  /**
-   * Creates a clone of `set`.
-   *
-   * @private
-   * @param {Object} set The set to clone.
-   * @param {Function} cloneFunc The function to clone values.
-   * @param {boolean} [isDeep] Specify a deep clone.
-   * @returns {Object} Returns the cloned set.
-   */
-  function cloneSet(set, isDeep, cloneFunc) {
-    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
-    return arrayReduce(array, addSetEntry, new set.constructor);
-  }
-
-  /**
-   * Creates a clone of the `symbol` object.
-   *
-   * @private
-   * @param {Object} symbol The symbol object to clone.
-   * @returns {Object} Returns the cloned symbol object.
-   */
-  function cloneSymbol(symbol) {
-    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
-  }
-
-  /**
-   * Creates a clone of `typedArray`.
-   *
-   * @private
-   * @param {Object} typedArray The typed array to clone.
-   * @param {boolean} [isDeep] Specify a deep clone.
-   * @returns {Object} Returns the cloned typed array.
-   */
-  function cloneTypedArray(typedArray, isDeep) {
-    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
-    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
-  }
-
-  /**
-   * Copies the values of `source` to `array`.
-   *
-   * @private
-   * @param {Array} source The array to copy values from.
-   * @param {Array} [array=[]] The array to copy values to.
-   * @returns {Array} Returns `array`.
-   */
-  function copyArray(source, array) {
-    var index = -1,
-        length = source.length;
-
-    array || (array = Array(length));
-    while (++index < length) {
-      array[index] = source[index];
-    }
-    return array;
-  }
-
-  /**
-   * Copies properties of `source` to `object`.
-   *
-   * @private
-   * @param {Object} source The object to copy properties from.
-   * @param {Array} props The property identifiers to copy.
-   * @param {Object} [object={}] The object to copy properties to.
-   * @param {Function} [customizer] The function to customize copied values.
-   * @returns {Object} Returns `object`.
-   */
-  function copyObject(source, props, object, customizer) {
-    object || (object = {});
-
-    var index = -1,
-        length = props.length;
-
-    while (++index < length) {
-      var key = props[index];
-
-      var newValue = customizer
-        ? customizer(object[key], source[key], key, object, source)
-        : source[key];
-
-      assignValue(object, key, newValue);
-    }
-    return object;
-  }
-
-  /**
-   * Copies own symbol properties of `source` to `object`.
-   *
-   * @private
-   * @param {Object} source The object to copy symbols from.
-   * @param {Object} [object={}] The object to copy symbols to.
-   * @returns {Object} Returns `object`.
-   */
-  function copySymbols(source, object) {
-    return copyObject(source, getSymbols(source), object);
-  }
-
-  /**
-   * Creates a function like `_.assign`.
-   *
-   * @private
-   * @param {Function} assigner The function to assign values.
-   * @returns {Function} Returns the new assigner function.
-   */
-  function createAssigner(assigner) {
-    return rest(function(object, sources) {
-      var index = -1,
-          length = sources.length,
-          customizer = length > 1 ? sources[length - 1] : undefined,
-          guard = length > 2 ? sources[2] : undefined;
-
-      customizer = (assigner.length > 3 && typeof customizer == 'function')
-        ? (length--, customizer)
-        : undefined;
-
-      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
-        customizer = length < 3 ? undefined : customizer;
-        length = 1;
-      }
-      object = Object(object);
-      while (++index < length) {
-        var source = sources[index];
-        if (source) {
-          assigner(object, source, index, customizer);
-        }
-      }
-      return object;
-    });
-  }
-
-  /**
-   * Creates a `baseEach` or `baseEachRight` function.
-   *
-   * @private
-   * @param {Function} eachFunc The function to iterate over a collection.
-   * @param {boolean} [fromRight] Specify iterating from right to left.
-   * @returns {Function} Returns the new base function.
-   */
-  function createBaseEach(eachFunc, fromRight) {
-    return function(collection, iteratee) {
-      if (collection == null) {
-        return collection;
-      }
-      if (!isArrayLike(collection)) {
-        return eachFunc(collection, iteratee);
-      }
-      var length = collection.length,
-          index = fromRight ? length : -1,
-          iterable = Object(collection);
-
-      while ((fromRight ? index-- : ++index < length)) {
-        if (iteratee(iterable[index], index, iterable) === false) {
-          break;
-        }
-      }
-      return collection;
-    };
-  }
-
-  /**
-   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
-   *
-   * @private
-   * @param {boolean} [fromRight] Specify iterating from right to left.
-   * @returns {Function} Returns the new base function.
-   */
-  function createBaseFor(fromRight) {
-    return function(object, iteratee, keysFunc) {
-      var index = -1,
-          iterable = Object(object),
-          props = keysFunc(object),
-          length = props.length;
-
-      while (length--) {
-        var key = props[fromRight ? length : ++index];
-        if (iteratee(iterable[key], key, iterable) === false) {
-          break;
-        }
-      }
-      return object;
-    };
-  }
-
-  /**
-   * Creates a set of `values`.
-   *
-   * @private
-   * @param {Array} values The values to add to the set.
-   * @returns {Object} Returns the new set.
-   */
-  var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
-    return new Set(values);
-  };
-
-  /**
-   * A specialized version of `baseIsEqualDeep` for arrays with support for
-   * partial deep comparisons.
-   *
-   * @private
-   * @param {Array} array The array to compare.
-   * @param {Array} other The other array to compare.
-   * @param {Function} equalFunc The function to determine equivalents of values.
-   * @param {Function} customizer The function to customize comparisons.
-   * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
-   *  for more details.
-   * @param {Object} stack Tracks traversed `array` and `other` objects.
-   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
-   */
-  function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
-    var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
-        arrLength = array.length,
-        othLength = other.length;
-
-    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
-      return false;
-    }
-    // Assume cyclic values are equal.
-    var stacked = stack.get(array);
-    if (stacked) {
-      return stacked == other;
-    }
-    var index = -1,
-        result = true,
-        seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;
-
-    stack.set(array, other);
-
-    // Ignore non-index properties.
-    while (++index < arrLength) {
-      var arrValue = array[index],
-          othValue = other[index];
-
-      if (customizer) {
-        var compared = isPartial
-          ? customizer(othValue, arrValue, index, other, array, stack)
-          : customizer(arrValue, othValue, index, array, other, stack);
-      }
-      if (compared !== undefined) {
-        if (compared) {
-          continue;
-        }
-        result = false;
-        break;
-      }
-      // Recursively compare arrays (susceptible to call stack limits).
-      if (seen) {
-        if (!arraySome(other, function(othValue, othIndex) {
-              if (!seen.has(othIndex) &&
-                  (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
-                return seen.add(othIndex);
-              }
-            })) {
-          result = false;
-          break;
-        }
-      } else if (!(
-            arrValue === othValue ||
-              equalFunc(arrValue, othValue, customizer, bitmask, stack)
-          )) {
-        result = false;
-        break;
-      }
-    }
-    stack['delete'](array);
-    return result;
-  }
-
-  /**
-   * A specialized version of `baseIsEqualDeep` for comparing objects of
-   * the same `toStringTag`.
-   *
-   * **Note:** This function only supports comparing values with tags of
-   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
-   *
-   * @private
-   * @param {Object} object The object to compare.
-   * @param {Object} other The other object to compare.
-   * @param {string} tag The `toStringTag` of the objects to compare.
-   * @param {Function} equalFunc The function to determine equivalents of values.
-   * @param {Function} customizer The function to customize comparisons.
-   * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
-   *  for more details.
-   * @param {Object} stack Tracks traversed `object` and `other` objects.
-   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
-   */
-  function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
-    switch (tag) {
-      case dataViewTag:
-        if ((object.byteLength != other.byteLength) ||
-            (object.byteOffset != other.byteOffset)) {
-          return false;
-        }
-        object = object.buffer;
-        other = other.buffer;
-
-      case arrayBufferTag:
-        if ((object.byteLength != other.byteLength) ||
-            !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
-          return false;
-        }
-        return true;
-
-      case boolTag:
-      case dateTag:
-        // Coerce dates and booleans to numbers, dates to milliseconds and
-        // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
-        // not equal.
-        return +object == +other;
-
-      case errorTag:
-        return object.name == other.name && object.message == other.message;
-
-      case numberTag:
-        // Treat `NaN` vs. `NaN` as equal.
-        return (object != +object) ? other != +other : object == +other;
-
-      case regexpTag:
-      case stringTag:
-        // Coerce regexes to strings and treat strings, primitives and objects,
-        // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
-        // for more details.
-        return object == (other + '');
-
-      case mapTag:
-        var convert = mapToArray;
-
-      case setTag:
-        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
-        convert || (convert = setToArray);
-
-        if (object.size != other.size && !isPartial) {
-          return false;
-        }
-        // Assume cyclic values are equal.
-        var stacked = stack.get(object);
-        if (stacked) {
-          return stacked == other;
-        }
-        bitmask |= UNORDERED_COMPARE_FLAG;
-        stack.set(object, other);
-
-        // Recursively compare objects (susceptible to call stack limits).
-        return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
-
-      case symbolTag:
-        if (symbolValueOf) {
-          return symbolValueOf.call(object) == symbolValueOf.call(other);
-        }
-    }
-    return false;
-  }
-
-  /**
-   * A specialized version of `baseIsEqualDeep` for objects with support for
-   * partial deep comparisons.
-   *
-   * @private
-   * @param {Object} object The object to compare.
-   * @param {Object} other The other object to compare.
-   * @param {Function} equalFunc The function to determine equivalents of values.
-   * @param {Function} customizer The function to customize comparisons.
-   * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
-   *  for more details.
-   * @param {Object} stack Tracks traversed `object` and `other` objects.
-   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
-   */
-  function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
-    var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
-        objProps = keys(object),
-        objLength = objProps.length,
-        othProps = keys(other),
-        othLength = othProps.length;
-
-    if (objLength != othLength && !isPartial) {
-      return false;
-    }
-    var index = objLength;
-    while (index--) {
-      var key = objProps[index];
-      if (!(isPartial ? key in other : baseHas(other, key))) {
-        return false;
-      }
-    }
-    // Assume cyclic values are equal.
-    var stacked = stack.get(object);
-    if (stacked) {
-      return stacked == other;
-    }
-    var result = true;
-    stack.set(object, other);
-
-    var skipCtor = isPartial;
-    while (++index < objLength) {
-      key = objProps[index];
-      var objValue = object[key],
-          othValue = other[key];
-
-      if (customizer) {
-        var compared = isPartial
-          ? customizer(othValue, objValue, key, other, object, stack)
-          : customizer(objValue, othValue, key, object, other, stack);
-      }
-      // Recursively compare objects (susceptible to call stack limits).
-      if (!(compared === undefined
-            ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
-            : compared
-          )) {
-        result = false;
-        break;
-      }
-      skipCtor || (skipCtor = key == 'constructor');
-    }
-    if (result && !skipCtor) {
-      var objCtor = object.constructor,
-          othCtor = other.constructor;
-
-      // Non `Object` object instances with different constructors are not equal.
-      if (objCtor != othCtor &&
-          ('constructor' in object && 'constructor' in other) &&
-          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
-            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
-        result = false;
-      }
-    }
-    stack['delete'](object);
-    return result;
-  }
-
-  /**
-   * Creates an array of own enumerable property names and symbols of `object`.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @returns {Array} Returns the array of property names and symbols.
-   */
-  function getAllKeys(object) {
-    return baseGetAllKeys(object, keys, getSymbols);
-  }
-
-  /**
-   * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
-   * this function returns the custom method, otherwise it returns `baseIteratee`.
-   * If arguments are provided, the chosen function is invoked with them and
-   * its result is returned.
-   *
-   * @private
-   * @param {*} [value] The value to convert to an iteratee.
-   * @param {number} [arity] The arity of the created iteratee.
-   * @returns {Function} Returns the chosen function or its result.
-   */
-  function getIteratee() {
-    var result = lodash.iteratee || iteratee;
-    result = result === iteratee ? baseIteratee : result;
-    return arguments.length ? result(arguments[0], arguments[1]) : result;
-  }
-
-  /**
-   * Gets the "length" property value of `object`.
-   *
-   * **Note:** This function is used to avoid a
-   * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
-   * Safari on at least iOS 8.1-8.3 ARM64.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @returns {*} Returns the "length" value.
-   */
-  var getLength = baseProperty('length');
-
-  /**
-   * Gets the data for `map`.
-   *
-   * @private
-   * @param {Object} map The map to query.
-   * @param {string} key The reference key.
-   * @returns {*} Returns the map data.
-   */
-  function getMapData(map, key) {
-    var data = map.__data__;
-    return isKeyable(key)
-      ? data[typeof key == 'string' ? 'string' : 'hash']
-      : data.map;
-  }
-
-  /**
-   * Gets the property names, values, and compare flags of `object`.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @returns {Array} Returns the match data of `object`.
-   */
-  function getMatchData(object) {
-    var result = keys(object),
-        length = result.length;
-
-    while (length--) {
-      var key = result[length],
-          value = object[key];
-
-      result[length] = [key, value, isStrictComparable(value)];
-    }
-    return result;
-  }
-
-  /**
-   * Gets the native function at `key` of `object`.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @param {string} key The key of the method to get.
-   * @returns {*} Returns the function if it's native, else `undefined`.
-   */
-  function getNative(object, key) {
-    var value = getValue(object, key);
-    return baseIsNative(value) ? value : undefined;
-  }
-
-  /**
-   * Gets the `[[Prototype]]` of `value`.
-   *
-   * @private
-   * @param {*} value The value to query.
-   * @returns {null|Object} Returns the `[[Prototype]]`.
-   */
-  function getPrototype(value) {
-    return nativeGetPrototype(Object(value));
-  }
-
-  /**
-   * Creates an array of the own enumerable symbol properties of `object`.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @returns {Array} Returns the array of symbols.
-   */
-  function getSymbols(object) {
-    // Coerce `object` to an object to avoid non-object errors in V8.
-    // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.
-    return getOwnPropertySymbols(Object(object));
-  }
-
-  // Fallback for IE < 11.
-  if (!getOwnPropertySymbols) {
-    getSymbols = stubArray;
-  }
-
-  /**
-   * Gets the `toStringTag` of `value`.
-   *
-   * @private
-   * @param {*} value The value to query.
-   * @returns {string} Returns the `toStringTag`.
-   */
-  function getTag(value) {
-    return objectToString.call(value);
-  }
-
-  // Fallback for data views, maps, sets, and weak maps in IE 11,
-  // for data views in Edge, and promises in Node.js.
-  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
-      (Map && getTag(new Map) != mapTag) ||
-      (Promise && getTag(Promise.resolve()) != promiseTag) ||
-      (Set && getTag(new Set) != setTag) ||
-      (WeakMap && getTag(new WeakMap) != weakMapTag)) {
-    getTag = function(value) {
-      var result = objectToString.call(value),
-          Ctor = result == objectTag ? value.constructor : undefined,
-          ctorString = Ctor ? toSource(Ctor) : undefined;
-
-      if (ctorString) {
-        switch (ctorString) {
-          case dataViewCtorString: return dataViewTag;
-          case mapCtorString: return mapTag;
-          case promiseCtorString: return promiseTag;
-          case setCtorString: return setTag;
-          case weakMapCtorString: return weakMapTag;
-        }
-      }
-      return result;
-    };
-  }
-
-  /**
-   * Checks if `path` exists on `object`.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @param {Array|string} path The path to check.
-   * @param {Function} hasFunc The function to check properties.
-   * @returns {boolean} Returns `true` if `path` exists, else `false`.
-   */
-  function hasPath(object, path, hasFunc) {
-    path = isKey(path, object) ? [path] : castPath(path);
-
-    var result,
-        index = -1,
-        length = path.length;
-
-    while (++index < length) {
-      var key = toKey(path[index]);
-      if (!(result = object != null && hasFunc(object, key))) {
-        break;
-      }
-      object = object[key];
-    }
-    if (result) {
-      return result;
-    }
-    var length = object ? object.length : 0;
-    return !!length && isLength(length) && isIndex(key, length) &&
-      (isArray(object) || isString(object) || isArguments(object));
-  }
-
-  /**
-   * Initializes an array clone.
-   *
-   * @private
-   * @param {Array} array The array to clone.
-   * @returns {Array} Returns the initialized clone.
-   */
-  function initCloneArray(array) {
-    var length = array.length,
-        result = array.constructor(length);
-
-    // Add properties assigned by `RegExp#exec`.
-    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
-      result.index = array.index;
-      result.input = array.input;
-    }
-    return result;
-  }
-
-  /**
-   * Initializes an object clone.
-   *
-   * @private
-   * @param {Object} object The object to clone.
-   * @returns {Object} Returns the initialized clone.
-   */
-  function initCloneObject(object) {
-    return (typeof object.constructor == 'function' && !isPrototype(object))
-      ? baseCreate(getPrototype(object))
-      : {};
-  }
-
-  /**
-   * Initializes an object clone based on its `toStringTag`.
-   *
-   * **Note:** This function only supports cloning values with tags of
-   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
-   *
-   * @private
-   * @param {Object} object The object to clone.
-   * @param {string} tag The `toStringTag` of the object to clone.
-   * @param {Function} cloneFunc The function to clone values.
-   * @param {boolean} [isDeep] Specify a deep clone.
-   * @returns {Object} Returns the initialized clone.
-   */
-  function initCloneByTag(object, tag, cloneFunc, isDeep) {
-    var Ctor = object.constructor;
-    switch (tag) {
-      case arrayBufferTag:
-        return cloneArrayBuffer(object);
-
-      case boolTag:
-      case dateTag:
-        return new Ctor(+object);
-
-      case dataViewTag:
-        return cloneDataView(object, isDeep);
-
-      case float32Tag: case float64Tag:
-      case int8Tag: case int16Tag: case int32Tag:
-      case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
-        return cloneTypedArray(object, isDeep);
-
-      case mapTag:
-        return cloneMap(object, isDeep, cloneFunc);
-
-      case numberTag:
-      case stringTag:
-        return new Ctor(object);
-
-      case regexpTag:
-        return cloneRegExp(object);
-
-      case setTag:
-        return cloneSet(object, isDeep, cloneFunc);
-
-      case symbolTag:
-        return cloneSymbol(object);
-    }
-  }
-
-  /**
-   * Creates an array of index keys for `object` values of arrays,
-   * `arguments` objects, and strings, otherwise `null` is returned.
-   *
-   * @private
-   * @param {Object} object The object to query.
-   * @returns {Array|null} Returns index keys, else `null`.
-   */
-  function indexKeys(object) {
-    var length = object ? object.length : undefined;
-    if (isLength(length) &&
-        (isArray(object) || isString(object) || isArguments(object))) {
-      return baseTimes(length, String);
-    }
-    return null;
-  }
-
-  /**
-   * Checks if `value` is a flattenable `arguments` object or array.
-   *
-   * @private
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
-   */
-  function isFlattenable(value) {
-    return isArray(value) || isArguments(value);
-  }
-
-  /**
-   * Checks if `value` is a valid array-like index.
-   *
-   * @private
-   * @param {*} value The value to check.
-   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
-   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
-   */
-  function isIndex(value, length) {
-    length = length == null ? MAX_SAFE_INTEGER : length;
-    return !!length &&
-      (typeof value == 'number' || reIsUint.test(value)) &&
-      (value > -1 && value % 1 == 0 && value < length);
-  }
-
-  /**
-   * Checks if the given arguments are from an iteratee call.
-   *
-   * @private
-   * @param {*} value The potential iteratee value argument.
-   * @param {*} index The potential iteratee index or key argument.
-   * @param {*} object The potential iteratee object argument.
-   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
-   *  else `false`.
-   */
-  function isIterateeCall(value, index, object) {
-    if (!isObject(object)) {
-      return false;
-    }
-    var type = typeof index;
-    if (type == 'number'
-          ? (isArrayLike(object) && isIndex(index, object.length))
-          : (type == 'string' && index in object)
-        ) {
-      return eq(object[index], value);
-    }
-    return false;
-  }
-
-  /**
-   * Checks if `value` is a property name and not a property path.
-   *
-   * @private
-   * @param {*} value The value to check.
-   * @param {Object} [object] The object to query keys on.
-   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
-   */
-  function isKey(value, object) {
-    if (isArray(value)) {
-      return false;
-    }
-    var type = typeof value;
-    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
-        value == null || isSymbol(value)) {
-      return true;
-    }
-    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
-      (object != null && value in Object(object));
-  }
-
-  /**
-   * Checks if `value` is suitable for use as unique object key.
-   *
-   * @private
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
-   */
-  function isKeyable(value) {
-    var type = typeof value;
-    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
-      ? (value !== '__proto__')
-      : (value === null);
-  }
-
-  /**
-   * Checks if `func` has its source masked.
-   *
-   * @private
-   * @param {Function} func The function to check.
-   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
-   */
-  function isMasked(func) {
-    return !!maskSrcKey && (maskSrcKey in func);
-  }
-
-  /**
-   * Checks if `value` is likely a prototype object.
-   *
-   * @private
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
-   */
-  function isPrototype(value) {
-    var Ctor = value && value.constructor,
-        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
-
-    return value === proto;
-  }
-
-  /**
-   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
-   *
-   * @private
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` if suitable for strict
-   *  equality comparisons, else `false`.
-   */
-  function isStrictComparable(value) {
-    return value === value && !isObject(value);
-  }
-
-  /**
-   * A specialized version of `matchesProperty` for source values suitable
-   * for strict equality comparisons, i.e. `===`.
-   *
-   * @private
-   * @param {string} key The key of the property to get.
-   * @param {*} srcValue The value to match.
-   * @returns {Function} Returns the new spec function.
-   */
-  function matchesStrictComparable(key, srcValue) {
-    return function(object) {
-      if (object == null) {
-        return false;
-      }
-      return object[key] === srcValue &&
-        (srcValue !== undefined || (key in Object(object)));
-    };
-  }
-
-  /**
-   * Converts `string` to a property path array.
-   *
-   * @private
-   * @param {string} string The string to convert.
-   * @returns {Array} Returns the property path array.
-   */
-  var stringToPath = memoize(function(string) {
-    var result = [];
-    toString(string).replace(rePropName, function(match, number, quote, string) {
-      result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
-    });
-    return result;
-  });
-
-  /**
-   * Converts `value` to a string key if it's not a string or symbol.
-   *
-   * @private
-   * @param {*} value The value to inspect.
-   * @returns {string|symbol} Returns the key.
-   */
-  function toKey(value) {
-    if (typeof value == 'string' || isSymbol(value)) {
-      return value;
-    }
-    var result = (value + '');
-    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
-  }
-
-  /**
-   * Converts `func` to its source code.
-   *
-   * @private
-   * @param {Function} func The function to process.
-   * @returns {string} Returns the source code.
-   */
-  function toSource(func) {
-    if (func != null) {
-      try {
-        return funcToString.call(func);
-      } catch (e) {}
-      try {
-        return (func + '');
-      } catch (e) {}
-    }
-    return '';
-  }
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * Creates an array of unique values, in order, from all given arrays using
-   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
-   * for equality comparisons.
-   *
-   * @static
-   * @memberOf _
-   * @since 0.1.0
-   * @category Array
-   * @param {...Array} [arrays] The arrays to inspect.
-   * @returns {Array} Returns the new array of combined values.
-   * @example
-   *
-   * _.union([2], [1, 2]);
-   * // => [2, 1]
-   */
-  var union = rest(function(arrays) {
-    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
-  });
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * Iterates over elements of `collection` and invokes `iteratee` for each element.
-   * The iteratee is invoked with three arguments: (value, index|key, collection).
-   * Iteratee functions may exit iteration early by explicitly returning `false`.
-   *
-   * **Note:** As with other "Collections" methods, objects with a "length"
-   * property are iterated like arrays. To avoid this behavior use `_.forIn`
-   * or `_.forOwn` for object iteration.
-   *
-   * @static
-   * @memberOf _
-   * @since 0.1.0
-   * @alias each
-   * @category Collection
-   * @param {Array|Object} collection The collection to iterate over.
-   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
-   * @returns {Array|Object} Returns `collection`.
-   * @see _.forEachRight
-   * @example
-   *
-   * _([1, 2]).forEach(function(value) {
-   *   console.log(value);
-   * });
-   * // => Logs `1` then `2`.
-   *
-   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
-   *   console.log(key);
-   * });
-   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
-   */
-  function forEach(collection, iteratee) {
-    var func = isArray(collection) ? arrayEach : baseEach;
-    return func(collection, getIteratee(iteratee, 3));
-  }
-
-  /**
-   * Checks if `value` is in `collection`. If `collection` is a string, it's
-   * checked for a substring of `value`, otherwise
-   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
-   * is used for equality comparisons. If `fromIndex` is negative, it's used as
-   * the offset from the end of `collection`.
-   *
-   * @static
-   * @memberOf _
-   * @since 0.1.0
-   * @category Collection
-   * @param {Array|Object|string} collection The collection to search.
-   * @param {*} value The value to search for.
-   * @param {number} [fromIndex=0] The index to search from.
-   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
-   * @returns {boolean} Returns `true` if `value` is found, else `false`.
-   * @example
-   *
-   * _.includes([1, 2, 3], 1);
-   * // => true
-   *
-   * _.includes([1, 2, 3], 1, 2);
-   * // => false
-   *
-   * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
-   * // => true
-   *
-   * _.includes('pebbles', 'eb');
-   * // => true
-   */
-  function includes(collection, value, fromIndex, guard) {
-    collection = isArrayLike(collection) ? collection : values(collection);
-    fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
-
-    var length = collection.length;
-    if (fromIndex < 0) {
-      fromIndex = nativeMax(length + fromIndex, 0);
-    }
-    return isString(collection)
-      ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
-      : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
-  }
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * Creates a function that memoizes the result of `func`. If `resolver` is
-   * provided, it determines the cache key for storing the result based on the
-   * arguments provided to the memoized function. By default, the first argument
-   * provided to the memoized function is used as the map cache key. The `func`
-   * is invoked with the `this` binding of the memoized function.
-   *
-   * **Note:** The cache is exposed as the `cache` property on the memoized
-   * function. Its creation may be customized by replacing the `_.memoize.Cache`
-   * constructor with one whose instances implement the
-   * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
-   * method interface of `delete`, `get`, `has`, and `set`.
-   *
-   * @static
-   * @memberOf _
-   * @since 0.1.0
-   * @category Function
-   * @param {Function} func The function to have its output memoized.
-   * @param {Function} [resolver] The function to resolve the cache key.
-   * @returns {Function} Returns the new memoized function.
-   * @example
-   *
-   * var object = { 'a': 1, 'b': 2 };
-   * var other = { 'c': 3, 'd': 4 };
-   *
-   * var values = _.memoize(_.values);
-   * values(object);
-   * // => [1, 2]
-   *
-   * values(other);
-   * // => [3, 4]
-   *
-   * object.a = 2;
-   * values(object);
-   * // => [1, 2]
-   *
-   * // Modify the result cache.
-   * values.cache.set(object, ['a', 'b']);
-   * values(object);
-   * // => ['a', 'b']
-   *
-   * // Replace `_.memoize.Cache`.
-   * _.memoize.Cache = WeakMap;
-   */
-  function memoize(func, resolver) {
-    if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
-      throw new TypeError(FUNC_ERROR_TEXT);
-    }
-    var memoized = function() {
-      var args = arguments,
-          key = resolver ? resolver.apply(this, args) : args[0],
-          cache = memoized.cache;
-
-      if (cache.has(key)) {
-        return cache.get(key);
-      }
-      var result = func.apply(this, args);
-      memoized.cache = cache.set(key, result);
-      return result;
-    };
-    memoized.cache = new (memoize.Cache || MapCache);
-    return memoized;
-  }
-
-  // Assign cache to `_.memoize`.
-  memoize.Cache = MapCache;
-
-  /**
-   * Creates a function that invokes `func` with the `this` binding of the
-   * created function and arguments from `start` and beyond provided as
-   * an array.
-   *
-   * **Note:** This method is based on the
-   * [rest parameter](https://mdn.io/rest_parameters).
-   *
-   * @static
-   * @memberOf _
-   * @since 4.0.0
-   * @category Function
-   * @param {Function} func The function to apply a rest parameter to.
-   * @param {number} [start=func.length-1] The start position of the rest parameter.
-   * @returns {Function} Returns the new function.
-   * @example
-   *
-   * var say = _.rest(function(what, names) {
-   *   return what + ' ' + _.initial(names).join(', ') +
-   *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
-   * });
-   *
-   * say('hello', 'fred', 'barney', 'pebbles');
-   * // => 'hello fred, barney, & pebbles'
-   */
-  function rest(func, start) {
-    if (typeof func != 'function') {
-      throw new TypeError(FUNC_ERROR_TEXT);
-    }
-    start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
-    return function() {
-      var args = arguments,
-          index = -1,
-          length = nativeMax(args.length - start, 0),
-          array = Array(length);
-
-      while (++index < length) {
-        array[index] = args[start + index];
-      }
-      switch (start) {
-        case 0: return func.call(this, array);
-        case 1: return func.call(this, args[0], array);
-        case 2: return func.call(this, args[0], args[1], array);
-      }
-      var otherArgs = Array(start + 1);
-      index = -1;
-      while (++index < start) {
-        otherArgs[index] = args[index];
-      }
-      otherArgs[start] = array;
-      return apply(func, this, otherArgs);
-    };
-  }
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * Performs a
-   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
-   * comparison between two values to determine if they are equivalent.
-   *
-   * @static
-   * @memberOf _
-   * @since 4.0.0
-   * @category Lang
-   * @param {*} value The value to compare.
-   * @param {*} other The other value to compare.
-   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
-   * @example
-   *
-   * var object = { 'user': 'fred' };
-   * var other = { 'user': 'fred' };
-   *
-   * _.eq(object, object);
-   * // => true
-   *
-   * _.eq(object, other);
-   * // => false
-   *
-   * _.eq('a', 'a');
-   * // => true
-   *
-   * _.eq('a', Object('a'));
-   * // => false
-   *
-   * _.eq(NaN, NaN);
-   * // => true
-   */
-  function eq(value, other) {
-    return value === other || (value !== value && other !== other);
-  }
-
-  /**
-   * Checks if `value` is likely an `arguments` object.
-   *
-   * @static
-   * @memberOf _
-   * @since 0.1.0
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is correctly classified,
-   *  else `false`.
-   * @example
-   *
-   * _.isArguments(function() { return arguments; }());
-   * // => true
-   *
-   * _.isArguments([1, 2, 3]);
-   * // => false
-   */
-  function isArguments(value) {
-    // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
-    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
-      (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
-  }
-
-  /**
-   * Checks if `value` is classified as an `Array` object.
-   *
-   * @static
-   * @memberOf _
-   * @since 0.1.0
-   * @type {Function}
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is correctly classified,
-   *  else `false`.
-   * @example
-   *
-   * _.isArray([1, 2, 3]);
-   * // => true
-   *
-   * _.isArray(document.body.children);
-   * // => false
-   *
-   * _.isArray('abc');
-   * // => false
-   *
-   * _.isArray(_.noop);
-   * // => false
-   */
-  var isArray = Array.isArray;
-
-  /**
-   * Checks if `value` is array-like. A value is considered array-like if it's
-   * not a function and has a `value.length` that's an integer greater than or
-   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
-   *
-   * @static
-   * @memberOf _
-   * @since 4.0.0
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
-   * @example
-   *
-   * _.isArrayLike([1, 2, 3]);
-   * // => true
-   *
-   * _.isArrayLike(document.body.children);
-   * // => true
-   *
-   * _.isArrayLike('abc');
-   * // => true
-   *
-   * _.isArrayLike(_.noop);
-   * // => false
-   */
-  function isArrayLike(value) {
-    return value != null && isLength(getLength(value)) && !isFunction(value);
-  }
-
-  /**
-   * This method is like `_.isArrayLike` except that it also checks if `value`
-   * is an object.
-   *
-   * @static
-   * @memberOf _
-   * @since 4.0.0
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is an array-like object,
-   *  else `false`.
-   * @example
-   *
-   * _.isArrayLikeObject([1, 2, 3]);
-   * // => true
-   *
-   * _.isArrayLikeObject(document.body.children);
-   * // => true
-   *
-   * _.isArrayLikeObject('abc');
-   * // => false
-   *
-   * _.isArrayLikeObject(_.noop);
-   * // => false
-   */
-  function isArrayLikeObject(value) {
-    return isObjectLike(value) && isArrayLike(value);
-  }
-
-  /**
-   * Checks if `value` is a buffer.
-   *
-   * @static
-   * @memberOf _
-   * @since 4.3.0
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
-   * @example
-   *
-   * _.isBuffer(new Buffer(2));
-   * // => true
-   *
-   * _.isBuffer(new Uint8Array(2));
-   * // => false
-   */
-  var isBuffer = !Buffer ? stubFalse : function(value) {
-    return value instanceof Buffer;
-  };
-
-  /**
-   * Checks if `value` is classified as a `Function` object.
-   *
-   * @static
-   * @memberOf _
-   * @since 0.1.0
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is correctly classified,
-   *  else `false`.
-   * @example
-   *
-   * _.isFunction(_);
-   * // => true
-   *
-   * _.isFunction(/abc/);
-   * // => false
-   */
-  function isFunction(value) {
-    // The use of `Object#toString` avoids issues with the `typeof` operator
-    // in Safari 8 which returns 'object' for typed array and weak map constructors,
-    // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
-    var tag = isObject(value) ? objectToString.call(value) : '';
-    return tag == funcTag || tag == genTag;
-  }
-
-  /**
-   * Checks if `value` is a valid array-like length.
-   *
-   * **Note:** This function is loosely based on
-   * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
-   *
-   * @static
-   * @memberOf _
-   * @since 4.0.0
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is a valid length,
-   *  else `false`.
-   * @example
-   *
-   * _.isLength(3);
-   * // => true
-   *
-   * _.isLength(Number.MIN_VALUE);
-   * // => false
-   *
-   * _.isLength(Infinity);
-   * // => false
-   *
-   * _.isLength('3');
-   * // => false
-   */
-  function isLength(value) {
-    return typeof value == 'number' &&
-      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
-  }
-
-  /**
-   * Checks if `value` is the
-   * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
-   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
-   *
-   * @static
-   * @memberOf _
-   * @since 0.1.0
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
-   * @example
-   *
-   * _.isObject({});
-   * // => true
-   *
-   * _.isObject([1, 2, 3]);
-   * // => true
-   *
-   * _.isObject(_.noop);
-   * // => true
-   *
-   * _.isObject(null);
-   * // => false
-   */
-  function isObject(value) {
-    var type = typeof value;
-    return !!value && (type == 'object' || type == 'function');
-  }
-
-  /**
-   * Checks if `value` is object-like. A value is object-like if it's not `null`
-   * and has a `typeof` result of "object".
-   *
-   * @static
-   * @memberOf _
-   * @since 4.0.0
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
-   * @example
-   *
-   * _.isObjectLike({});
-   * // => true
-   *
-   * _.isObjectLike([1, 2, 3]);
-   * // => true
-   *
-   * _.isObjectLike(_.noop);
-   * // => false
-   *
-   * _.isObjectLike(null);
-   * // => false
-   */
-  function isObjectLike(value) {
-    return !!value && typeof value == 'object';
-  }
-
-  /**
-   * Checks if `value` is a plain object, that is, an object created by the
-   * `Object` constructor or one with a `[[Prototype]]` of `null`.
-   *
-   * @static
-   * @memberOf _
-   * @since 0.8.0
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is a plain object,
-   *  else `false`.
-   * @example
-   *
-   * function Foo() {
-   *   this.a = 1;
-   * }
-   *
-   * _.isPlainObject(new Foo);
-   * // => false
-   *
-   * _.isPlainObject([1, 2, 3]);
-   * // => false
-   *
-   * _.isPlainObject({ 'x': 0, 'y': 0 });
-   * // => true
-   *
-   * _.isPlainObject(Object.create(null));
-   * // => true
-   */
-  function isPlainObject(value) {
-    if (!isObjectLike(value) ||
-        objectToString.call(value) != objectTag || isHostObject(value)) {
-      return false;
-    }
-    var proto = getPrototype(value);
-    if (proto === null) {
-      return true;
-    }
-    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
-    return (typeof Ctor == 'function' &&
-      Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
-  }
-
-  /**
-   * Checks if `value` is classified as a `String` primitive or object.
-   *
-   * @static
-   * @since 0.1.0
-   * @memberOf _
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is correctly classified,
-   *  else `false`.
-   * @example
-   *
-   * _.isString('abc');
-   * // => true
-   *
-   * _.isString(1);
-   * // => false
-   */
-  function isString(value) {
-    return typeof value == 'string' ||
-      (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
-  }
-
-  /**
-   * Checks if `value` is classified as a `Symbol` primitive or object.
-   *
-   * @static
-   * @memberOf _
-   * @since 4.0.0
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is correctly classified,
-   *  else `false`.
-   * @example
-   *
-   * _.isSymbol(Symbol.iterator);
-   * // => true
-   *
-   * _.isSymbol('abc');
-   * // => false
-   */
-  function isSymbol(value) {
-    return typeof value == 'symbol' ||
-      (isObjectLike(value) && objectToString.call(value) == symbolTag);
-  }
-
-  /**
-   * Checks if `value` is classified as a typed array.
-   *
-   * @static
-   * @memberOf _
-   * @since 3.0.0
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is correctly classified,
-   *  else `false`.
-   * @example
-   *
-   * _.isTypedArray(new Uint8Array);
-   * // => true
-   *
-   * _.isTypedArray([]);
-   * // => false
-   */
-  function isTypedArray(value) {
-    return isObjectLike(value) &&
-      isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
-  }
-
-  /**
-   * Checks if `value` is `undefined`.
-   *
-   * @static
-   * @since 0.1.0
-   * @memberOf _
-   * @category Lang
-   * @param {*} value The value to check.
-   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
-   * @example
-   *
-   * _.isUndefined(void 0);
-   * // => true
-   *
-   * _.isUndefined(null);
-   * // => false
-   */
-  function isUndefined(value) {
-    return value === undefined;
-  }
-
-  /**
-   * Converts `value` to an array.
-   *
-   * @static
-   * @since 0.1.0
-   * @memberOf _
-   * @category Lang
-   * @param {*} value The value to convert.
-   * @returns {Array} Returns the converted array.
-   * @example
-   *
-   * _.toArray({ 'a': 1, 'b': 2 });
-   * // => [1, 2]
-   *
-   * _.toArray('abc');
-   * // => ['a', 'b', 'c']
-   *
-   * _.toArray(1);
-   * // => []
-   *
-   * _.toArray(null);
-   * // => []
-   */
-  function toArray(value) {
-    if (!value) {
-      return [];
-    }
-    if (isArrayLike(value)) {
-      return isString(value) ? stringToArray(value) : copyArray(value);
-    }
-    if (iteratorSymbol && value[iteratorSymbol]) {
-      return iteratorToArray(value[iteratorSymbol]());
-    }
-    var tag = getTag(value),
-        func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
-
-    return func(value);
-  }
-
-  /**
-   * Converts `value` to a finite number.
-   *
-   * @static
-   * @memberOf _
-   * @since 4.12.0
-   * @category Lang
-   * @param {*} value The value to convert.
-   * @returns {number} Returns the converted number.
-   * @example
-   *
-   * _.toFinite(3.2);
-   * // => 3.2
-   *
-   * _.toFinite(Number.MIN_VALUE);
-   * // => 5e-324
-   *
-   * _.toFinite(Infinity);
-   * // => 1.7976931348623157e+308
-   *
-   * _.toFinite('3.2');
-   * // => 3.2
-   */
-  function toFinite(value) {
-    if (!value) {
-      return value === 0 ? value : 0;
-    }
-    value = toNumber(value);
-    if (value === INFINITY || value === -INFINITY) {
-      var sign = (value < 0 ? -1 : 1);
-      return sign * MAX_INTEGER;
-    }
-    return value === value ? value : 0;
-  }
-
-  /**
-   * Converts `value` to an integer.
-   *
-   * **Note:** This method is loosely based on
-   * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
-   *
-   * @static
-   * @memberOf _
-   * @since 4.0.0
-   * @category Lang
-   * @param {*} value The value to convert.
-   * @returns {number} Returns the converted integer.
-   * @example
-   *
-   * _.toInteger(3.2);
-   * // => 3
-   *
-   * _.toInteger(Number.MIN_VALUE);
-   * // => 0
-   *
-   * _.toInteger(Infinity);
-   * // => 1.7976931348623157e+308
-   *
-   * _.toInteger('3.2');
-   * // => 3
-   */
-  function toInteger(value) {
-    var result = toFinite(value),
-        remainder = result % 1;
-
-    return result === result ? (remainder ? result - remainder : result) : 0;
-  }
-
-  /**
-   * Converts `value` to a number.
-   *
-   * @static
-   * @memberOf _
-   * @since 4.0.0
-   * @category Lang
-   * @param {*} value The value to process.
-   * @returns {number} Returns the number.
-   * @example
-   *
-   * _.toNumber(3.2);
-   * // => 3.2
-   *
-   * _.toNumber(Number.MIN_VALUE);
-   * // => 5e-324
-   *
-   * _.toNumber(Infinity);
-   * // => Infinity
-   *
-   * _.toNumber('3.2');
-   * // => 3.2
-   */
-  function toNumber(value) {
-    if (typeof value == 'number') {
-      return value;
-    }
-    if (isSymbol(value)) {
-      return NAN;
-    }
-    if (isObject(value)) {
-      var other = isFunction(value.valueOf) ? value.valueOf() : value;
-      value = isObject(other) ? (other + '') : other;
-    }
-    if (typeof value != 'string') {
-      return value === 0 ? value : +value;
-    }
-    value = value.replace(reTrim, '');
-    var isBinary = reIsBinary.test(value);
-    return (isBinary || reIsOctal.test(value))
-      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
-      : (reIsBadHex.test(value) ? NAN : +value);
-  }
-
-  /**
-   * Converts `value` to a plain object flattening inherited enumerable string
-   * keyed properties of `value` to own properties of the plain object.
-   *
-   * @static
-   * @memberOf _
-   * @since 3.0.0
-   * @category Lang
-   * @param {*} value The value to convert.
-   * @returns {Object} Returns the converted plain object.
-   * @example
-   *
-   * function Foo() {
-   *   this.b = 2;
-   * }
-   *
-   * Foo.prototype.c = 3;
-   *
-   * _.assign({ 'a': 1 }, new Foo);
-   * // => { 'a': 1, 'b': 2 }
-   *
-   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
-   * // => { 'a': 1, 'b': 2, 'c': 3 }
-   */
-  function toPlainObject(value) {
-    return copyObject(value, keysIn(value));
-  }
-
-  /**
-   * Converts `value` to a string. An empty string is returned for `null`
-   * and `undefined` values. The sign of `-0` is preserved.
-   *
-   * @static
-   * @memberOf _
-   * @since 4.0.0
-   * @category Lang
-   * @param {*} value The value to process.
-   * @returns {string} Returns the string.
-   * @example
-   *
-   * _.toString(null);
-   * // => ''
-   *
-   * _.toString(-0);
-   * // => '-0'
-   *
-   * _.toString([1, 2, 3]);
-   * // => '1,2,3'
-   */
-  function toString(value) {
-    return value == null ? '' : baseToString(value);
-  }
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * Gets the value at `path` of `object`. If the resolved value is
-   * `undefined`, the `defaultValue` is used in its place.
-   *
-   * @static
-   * @memberOf _
-   * @since 3.7.0
-   * @category Object
-   * @param {Object} object The object to query.
-   * @param {Array|string} path The path of the property to get.
-   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
-   * @returns {*} Returns the resolved value.
-   * @example
-   *
-   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
-   *
-   * _.get(object, 'a[0].b.c');
-   * // => 3
-   *
-   * _.get(object, ['a', '0', 'b', 'c']);
-   * // => 3
-   *
-   * _.get(object, 'a.b.c', 'default');
-   * // => 'default'
-   */
-  function get(object, path, defaultValue) {
-    var result = object == null ? undefined : baseGet(object, path);
-    return result === undefined ? defaultValue : result;
-  }
-
-  /**
-   * Checks if `path` is a direct or inherited property of `object`.
-   *
-   * @static
-   * @memberOf _
-   * @since 4.0.0
-   * @category Object
-   * @param {Object} object The object to query.
-   * @param {Array|string} path The path to check.
-   * @returns {boolean} Returns `true` if `path` exists, else `false`.
-   * @example
-   *
-   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
-   *
-   * _.hasIn(object, 'a');
-   * // => true
-   *
-   * _.hasIn(object, 'a.b');
-   * // => true
-   *
-   * _.hasIn(object, ['a', 'b']);
-   * // => true
-   *
-   * _.hasIn(object, 'b');
-   * // => false
-   */
-  function hasIn(object, path) {
-    return object != null && hasPath(object, path, baseHasIn);
-  }
-
-  /**
-   * Creates an array of the own enumerable property names of `object`.
-   *
-   * **Note:** Non-object values are coerced to objects. See the
-   * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
-   * for more details.
-   *
-   * @static
-   * @since 0.1.0
-   * @memberOf _
-   * @category Object
-   * @param {Object} object The object to query.
-   * @returns {Array} Returns the array of property names.
-   * @example
-   *
-   * function Foo() {
-   *   this.a = 1;
-   *   this.b = 2;
-   * }
-   *
-   * Foo.prototype.c = 3;
-   *
-   * _.keys(new Foo);
-   * // => ['a', 'b'] (iteration order is not guaranteed)
-   *
-   * _.keys('hi');
-   * // => ['0', '1']
-   */
-  function keys(object) {
-    var isProto = isPrototype(object);
-    if (!(isProto || isArrayLike(object))) {
-      return baseKeys(object);
-    }
-    var indexes = indexKeys(object),
-        skipIndexes = !!indexes,
-        result = indexes || [],
-        length = result.length;
-
-    for (var key in object) {
-      if (baseHas(object, key) &&
-          !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
-          !(isProto && key == 'constructor')) {
-        result.push(key);
-      }
-    }
-    return result;
-  }
-
-  /**
-   * Creates an array of the own and inherited enumerable property names of `object`.
-   *
-   * **Note:** Non-object values are coerced to objects.
-   *
-   * @static
-   * @memberOf _
-   * @since 3.0.0
-   * @category Object
-   * @param {Object} object The object to query.
-   * @returns {Array} Returns the array of property names.
-   * @example
-   *
-   * function Foo() {
-   *   this.a = 1;
-   *   this.b = 2;
-   * }
-   *
-   * Foo.prototype.c = 3;
-   *
-   * _.keysIn(new Foo);
-   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
-   */
-  function keysIn(object) {
-    var index = -1,
-        isProto = isPrototype(object),
-        props = baseKeysIn(object),
-        propsLength = props.length,
-        indexes = indexKeys(object),
-        skipIndexes = !!indexes,
-        result = indexes || [],
-        length = result.length;
-
-    while (++index < propsLength) {
-      var key = props[index];
-      if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
-          !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
-        result.push(key);
-      }
-    }
-    return result;
-  }
-
-  /**
-   * This method is like `_.assign` except that it recursively merges own and
-   * inherited enumerable string keyed properties of source objects into the
-   * destination object. Source properties that resolve to `undefined` are
-   * skipped if a destination value exists. Array and plain object properties
-   * are merged recursively. Other objects and value types are overridden by
-   * assignment. Source objects are applied from left to right. Subsequent
-   * sources overwrite property assignments of previous sources.
-   *
-   * **Note:** This method mutates `object`.
-   *
-   * @static
-   * @memberOf _
-   * @since 0.5.0
-   * @category Object
-   * @param {Object} object The destination object.
-   * @param {...Object} [sources] The source objects.
-   * @returns {Object} Returns `object`.
-   * @example
-   *
-   * var users = {
-   *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
-   * };
-   *
-   * var ages = {
-   *   'data': [{ 'age': 36 }, { 'age': 40 }]
-   * };
-   *
-   * _.merge(users, ages);
-   * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
-   */
-  var merge = createAssigner(function(object, source, srcIndex) {
-    baseMerge(object, source, srcIndex);
-  });
-
-  /**
-   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
-   * it's created. Arrays are created for missing index properties while objects
-   * are created for all other missing properties. Use `_.setWith` to customize
-   * `path` creation.
-   *
-   * **Note:** This method mutates `object`.
-   *
-   * @static
-   * @memberOf _
-   * @since 3.7.0
-   * @category Object
-   * @param {Object} object The object to modify.
-   * @param {Array|string} path The path of the property to set.
-   * @param {*} value The value to set.
-   * @returns {Object} Returns `object`.
-   * @example
-   *
-   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
-   *
-   * _.set(object, 'a[0].b.c', 4);
-   * console.log(object.a[0].b.c);
-   * // => 4
-   *
-   * _.set(object, ['x', '0', 'y', 'z'], 5);
-   * console.log(object.x[0].y.z);
-   * // => 5
-   */
-  function set(object, path, value) {
-    return object == null ? object : baseSet(object, path, value);
-  }
-
-  /**
-   * Creates an array of the own enumerable string keyed property values of `object`.
-   *
-   * **Note:** Non-object values are coerced to objects.
-   *
-   * @static
-   * @since 0.1.0
-   * @memberOf _
-   * @category Object
-   * @param {Object} object The object to query.
-   * @returns {Array} Returns the array of property values.
-   * @example
-   *
-   * function Foo() {
-   *   this.a = 1;
-   *   this.b = 2;
-   * }
-   *
-   * Foo.prototype.c = 3;
-   *
-   * _.values(new Foo);
-   * // => [1, 2] (iteration order is not guaranteed)
-   *
-   * _.values('hi');
-   * // => ['h', 'i']
-   */
-  function values(object) {
-    return object ? baseValues(object, keys(object)) : [];
-  }
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * This method returns the first argument given to it.
-   *
-   * @static
-   * @since 0.1.0
-   * @memberOf _
-   * @category Util
-   * @param {*} value Any value.
-   * @returns {*} Returns `value`.
-   * @example
-   *
-   * var object = { 'user': 'fred' };
-   *
-   * console.log(_.identity(object) === object);
-   * // => true
-   */
-  function identity(value) {
-    return value;
-  }
-
-  /**
-   * Creates a function that invokes `func` with the arguments of the created
-   * function. If `func` is a property name, the created function returns the
-   * property value for a given element. If `func` is an array or object, the
-   * created function returns `true` for elements that contain the equivalent
-   * source properties, otherwise it returns `false`.
-   *
-   * @static
-   * @since 4.0.0
-   * @memberOf _
-   * @category Util
-   * @param {*} [func=_.identity] The value to convert to a callback.
-   * @returns {Function} Returns the callback.
-   * @example
-   *
-   * var users = [
-   *   { 'user': 'barney', 'age': 36, 'active': true },
-   *   { 'user': 'fred',   'age': 40, 'active': false }
-   * ];
-   *
-   * // The `_.matches` iteratee shorthand.
-   * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
-   * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
-   *
-   * // The `_.matchesProperty` iteratee shorthand.
-   * _.filter(users, _.iteratee(['user', 'fred']));
-   * // => [{ 'user': 'fred', 'age': 40 }]
-   *
-   * // The `_.property` iteratee shorthand.
-   * _.map(users, _.iteratee('user'));
-   * // => ['barney', 'fred']
-   *
-   * // Create custom iteratee shorthands.
-   * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
-   *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
-   *     return func.test(string);
-   *   };
-   * });
-   *
-   * _.filter(['abc', 'def'], /ef/);
-   * // => ['def']
-   */
-  function iteratee(func) {
-    return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
-  }
-
-  /**
-   * A method that returns `undefined`.
-   *
-   * @static
-   * @memberOf _
-   * @since 2.3.0
-   * @category Util
-   * @example
-   *
-   * _.times(2, _.noop);
-   * // => [undefined, undefined]
-   */
-  function noop() {
-    // No operation performed.
-  }
-
-  /**
-   * Creates a function that returns the value at `path` of a given object.
-   *
-   * @static
-   * @memberOf _
-   * @since 2.4.0
-   * @category Util
-   * @param {Array|string} path The path of the property to get.
-   * @returns {Function} Returns the new accessor function.
-   * @example
-   *
-   * var objects = [
-   *   { 'a': { 'b': 2 } },
-   *   { 'a': { 'b': 1 } }
-   * ];
-   *
-   * _.map(objects, _.property('a.b'));
-   * // => [2, 1]
-   *
-   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
-   * // => [1, 2]
-   */
-  function property(path) {
-    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
-  }
-
-  /**
-   * A method that returns a new empty array.
-   *
-   * @static
-   * @memberOf _
-   * @since 4.13.0
-   * @category Util
-   * @returns {Array} Returns the new empty array.
-   * @example
-   *
-   * var arrays = _.times(2, _.stubArray);
-   *
-   * console.log(arrays);
-   * // => [[], []]
-   *
-   * console.log(arrays[0] === arrays[1]);
-   * // => false
-   */
-  function stubArray() {
-    return [];
-  }
-
-  /**
-   * A method that returns `false`.
-   *
-   * @static
-   * @memberOf _
-   * @since 4.13.0
-   * @category Util
-   * @returns {boolean} Returns `false`.
-   * @example
-   *
-   * _.times(2, _.stubFalse);
-   * // => [false, false]
-   */
-  function stubFalse() {
-    return false;
-  }
-
-  /*------------------------------------------------------------------------*/
-
-  // Add methods that return wrapped values in chain sequences.
-  lodash.iteratee = iteratee;
-  lodash.keys = keys;
-  lodash.keysIn = keysIn;
-  lodash.memoize = memoize;
-  lodash.merge = merge;
-  lodash.property = property;
-  lodash.rest = rest;
-  lodash.set = set;
-  lodash.toArray = toArray;
-  lodash.toPlainObject = toPlainObject;
-  lodash.union = union;
-  lodash.values = values;
-
-  /*------------------------------------------------------------------------*/
-
-  // Add methods that return unwrapped values in chain sequences.
-  lodash.eq = eq;
-  lodash.forEach = forEach;
-  lodash.get = get;
-  lodash.hasIn = hasIn;
-  lodash.identity = identity;
-  lodash.includes = includes;
-  lodash.isArguments = isArguments;
-  lodash.isArray = isArray;
-  lodash.isArrayLike = isArrayLike;
-  lodash.isArrayLikeObject = isArrayLikeObject;
-  lodash.isBuffer = isBuffer;
-  lodash.isFunction = isFunction;
-  lodash.isLength = isLength;
-  lodash.isObject = isObject;
-  lodash.isObjectLike = isObjectLike;
-  lodash.isPlainObject = isPlainObject;
-  lodash.isString = isString;
-  lodash.isSymbol = isSymbol;
-  lodash.isTypedArray = isTypedArray;
-  lodash.isUndefined = isUndefined;
-  lodash.stubArray = stubArray;
-  lodash.stubFalse = stubFalse;
-  lodash.noop = noop;
-  lodash.toFinite = toFinite;
-  lodash.toInteger = toInteger;
-  lodash.toNumber = toNumber;
-  lodash.toString = toString;
-
-  // Add aliases.
-  lodash.each = forEach;
-
-  /*------------------------------------------------------------------------*/
-
-  /**
-   * The semantic version number.
-   *
-   * @static
-   * @memberOf _
-   * @type {string}
-   */
-  lodash.VERSION = VERSION;
-
-  /*--------------------------------------------------------------------------*/
-
-  if (freeModule) {
-    // Export for Node.js.
-    (freeModule.exports = lodash)._ = lodash;
-    // Export for CommonJS support.
-    freeExports._ = lodash;
-  }
-}.call(this));
